(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[32],{

/***/ "../node_modules/pouchdb-adapter-indexeddb/lib/index.es.js":
/*!*****************************************************************!*\
  !*** ../node_modules/pouchdb-adapter-indexeddb/lib/index.es.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pouchdb-binary-utils */ \"../node_modules/pouchdb-binary-utils/lib/index-browser.es.js\");\n/* harmony import */ var pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pouchdb-adapter-utils */ \"../node_modules/pouchdb-adapter-utils/lib/index.es.js\");\n/* harmony import */ var pouchdb_md5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pouchdb-md5 */ \"../node_modules/pouchdb-md5/lib/index-browser.es.js\");\n/* harmony import */ var pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pouchdb-utils */ \"../node_modules/pouchdb-utils/lib/index-browser.es.js\");\n/* harmony import */ var pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! pouchdb-errors */ \"../node_modules/pouchdb-errors/lib/index.es.js\");\n/* harmony import */ var pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! pouchdb-merge */ \"../node_modules/pouchdb-merge/lib/index.es.js\");\n\n\n\n\n\n\n\nvar IDB_NULL = Number.MIN_SAFE_INTEGER;\nvar IDB_FALSE = Number.MIN_SAFE_INTEGER + 1;\nvar IDB_TRUE = Number.MIN_SAFE_INTEGER + 2;\n\n//\n// IndexedDB only allows valid JS names in its index paths, whereas JSON allows\n// for any string at all. This converts invalid JS names to valid ones, to allow\n// for them to be indexed.\n//\n// For example, \"foo-bar\" is a valid JSON key, but cannot be a valid JS name\n// (because that would be read as foo minus bar).\n//\n// Very high level rules for valid JS names are:\n//  - First character cannot start with a number\n//  - Otherwise all characters must be be a-z, A-Z, 0-9, $ or _.\n//  - We allow . unless the name represents a single field, as that represents\n//    a deep index path.\n//\n// This is more aggressive than it needs to be, but also simpler.\n//\nvar KEY_INVALID = /[^a-zA-Z0-9_$]+|(^[^a-zA-Z_$])/g;\nvar PATH_INVALID = /(\\\\.)|[^a-zA-Z0-9_$.]+|(^[^a-zA-Z_$])/g;\nvar SLASH = '\\\\'.charCodeAt(0);\n\n// These are the same as above but without the global flag\n// we want to use RegExp.test because it's really fast, but the global flag\n// makes the regex const stateful (seriously) as it walked through all instances\nvar TEST_KEY_INVALID = /[^a-zA-Z0-9_$]+|(^[^a-zA-Z_$])/;\nvar TEST_PATH_INVALID = /(\\\\.)|[^a-zA-Z0-9_$.]+|(^[^a-zA-Z_$])/;\nfunction needsSanitise(name, isPath) {\n  if (isPath) {\n    return TEST_PATH_INVALID.test(name);\n  } else {\n    return TEST_KEY_INVALID.test(name);\n  }\n}\n\nfunction sanitise(name, isPath) {\n  var correctCharacters = function (match) {\n    var good = '';\n    for (var i = 0; i < match.length; i++) {\n      var code = match.charCodeAt(i);\n      // If you're sanitising a path, a slash character is there to be interpreted\n      // by whatever parses the path later as \"escape the next thing\".\n      //\n      // e.g., if you want to index THIS string:\n      //   {\"foo\": {\"bar.baz\": \"THIS\"}}\n      // Your index path would be \"foo.bar\\.baz\".\n      if (code === SLASH && isPath) {\n        continue;\n      }\n\n      good += '_c' + code + '_';\n    }\n    return good;\n  };\n\n  if (isPath) {\n    return name.replace(PATH_INVALID, correctCharacters);\n  } else {\n    return name.replace(KEY_INVALID, correctCharacters);\n  }\n}\n\nfunction needsRewrite(data) {\n  for (var key of Object.keys(data)) {\n    if (needsSanitise(key)) {\n      return true;\n    } else if (data[key] === null || typeof data[key] === 'boolean') {\n      return true;\n    } else if (typeof data[key] === 'object') {\n      return needsRewrite(data[key]);\n    }\n  }\n}\n\nfunction rewrite(data) {\n  if (!needsRewrite(data)) {\n    return false;\n  }\n\n  var isArray = Array.isArray(data);\n  var clone = isArray\n    ? []\n    : {};\n\n  Object.keys(data).forEach(function (key) {\n    var safeKey = isArray ? key : sanitise(key);\n\n    if (data[key] === null) {\n      clone[safeKey] = IDB_NULL;\n    } else if (typeof data[key] === 'boolean') {\n      clone[safeKey] = data[key] ? IDB_TRUE : IDB_FALSE;\n    } else if (typeof data[key] === 'object') {\n      clone[safeKey] = rewrite(data[key]);\n    } else {\n      clone[safeKey] = data[key];\n    }\n  });\n\n  return clone;\n}\n\nvar DOC_STORE = 'docs';\nvar META_STORE = 'meta';\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"IDB_ERROR\"], message, evt.type));\n  };\n}\n\nfunction processAttachment(name, src, doc, isBinary) {\n\n  delete doc._attachments[name].stub;\n\n  if (isBinary) {\n    doc._attachments[name].data =\n      src.attachments[doc._attachments[name].digest].data;\n    return Promise.resolve();\n  }\n\n  return new Promise(function (resolve) {\n    var data = src.attachments[doc._attachments[name].digest].data;\n    Object(pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__[\"readAsBinaryString\"])(data, function (binString) {\n      doc._attachments[name].data = Object(pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__[\"btoa\"])(binString);\n      delete doc._attachments[name].length;\n      resolve();\n    });\n  });\n}\n\nfunction rawIndexFields(ddoc, viewName) {\n  // fields are an array of either the string name of the field, or a key value\n  var fields = ddoc.views[viewName].options &&\n               ddoc.views[viewName].options.def &&\n               ddoc.views[viewName].options.def.fields || [];\n\n  // Either ['foo'] or [{'foo': 'desc'}]\n  return fields.map(function (field) {\n    if (typeof field === 'string') {\n      return field;\n    } else {\n      return Object.keys(field)[0];\n    }\n  });\n}\n\nfunction naturalIndexName(fields) {\n  return '_find_idx/' + fields.join('/');\n}\n\n/**\n * Convert the fields the user gave us in the view and convert them to work for\n * indexeddb.\n *\n * fields is an array of field strings. A field string could be one field:\n *   'foo'\n * Or it could be a json path:\n *   'foo.bar'\n */\nfunction correctIndexFields(fields) {\n  // Every index has to have deleted at the front, because when we do a query\n  // we need to filter out deleted documents.\n  return ['deleted'].concat(\n    fields.map(function (field) {\n      if (field in ['_id', '_rev', '_deleted', '_attachments']) {\n        // These properties are stored at the top level without the underscore\n        return field.substr(1);\n      } else {\n        // The custom document fields are inside the `data` property\n        return 'data.' + sanitise(field, true);\n      }\n    })\n  );\n}\n\n//\n// Core PouchDB schema version. Increment this if we, as a library, want to make\n// schema changes in indexeddb. See upgradePouchDbSchema()\n//\nvar POUCHDB_IDB_VERSION = 1;\n\n//\n// Functions that manage a combinate indexeddb version, by combining the current\n// time in millis that represents user migrations with a large multiplier that\n// represents PouchDB system migrations.\n//\n// This lets us use the idb version number to both represent\n// PouchDB-library-level migrations as well as \"user migrations\" required for\n// when design documents trigger the addition or removal of native indexes.\n//\n// Given that Number.MAX_SAFE_INTEGER = 9007199254740991\n//\n// We can easily use the largest 2-3 digits and either allow:\n//  - 900 system migrations up to 2198/02/18\n//  - or 89 system migrations up to 5050/02/14\n//\n// This impl does the former. If this code still exists after 2198 someone send my\n// decendents a Spacebook message congratulating them on their impressive genes.\n//\n// 9007199254740991 <- MAX_SAFE_INTEGER\n//   10000000000000 <- 10^13\n//    7199254740991 <- 2198-02-18T16:59:00.991Z\n//\nvar versionMultiplier = Math.pow(10, 13);\nfunction createIdbVersion() {\n  return (versionMultiplier * POUCHDB_IDB_VERSION) + new Date().getTime();\n}\nfunction getPouchDbVersion(version) {\n  return Math.floor(version / versionMultiplier);\n}\n\nfunction maintainNativeIndexes(openReq, reject) {\n  var docStore = openReq.transaction.objectStore(DOC_STORE);\n  var ddocsReq = docStore.getAll(IDBKeyRange.bound('_design/', '_design/\\uffff'));\n\n  ddocsReq.onsuccess = function (e) {\n    var results = e.target.result;\n    var existingIndexNames = Array.from(docStore.indexNames);\n\n    // NB: the only thing we're supporting here is the declared indexing\n    // fields nothing more.\n    var expectedIndexes = results.filter(function (row) {\n      return row.deleted === 0 && row.revs[row.rev].data.views;\n    }).map(function (row) {\n      return row.revs[row.rev].data;\n    }).reduce(function (indexes, ddoc) {\n      return Object.keys(ddoc.views).reduce(function (acc, viewName) {\n        var fields = rawIndexFields(ddoc, viewName);\n\n        if (fields && fields.length > 0) {\n          acc[naturalIndexName(fields)] = correctIndexFields(fields);\n        }\n\n        return acc;\n      }, indexes);\n    }, {});\n\n    var expectedIndexNames = Object.keys(expectedIndexes);\n\n    // Delete any indexes that aren't system indexes or expected\n    var systemIndexNames = ['seq'];\n    existingIndexNames.forEach(function (index) {\n      if (systemIndexNames.indexOf(index) === -1  && expectedIndexNames.indexOf(index) === -1) {\n        docStore.deleteIndex(index);\n      }\n    });\n\n    // Work out which indexes are missing and create them\n    var newIndexNames = expectedIndexNames.filter(function (ei) {\n      return existingIndexNames.indexOf(ei) === -1;\n    });\n\n    try {\n      newIndexNames.forEach(function (indexName) {\n        docStore.createIndex(indexName, expectedIndexes[indexName]);\n      });\n    } catch (err) {\n      reject(err);\n    }\n  };\n}\n\nfunction upgradePouchDbSchema(db, pouchdbVersion) {\n  if (pouchdbVersion < 1) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    docStore.createIndex('seq', 'seq', {unique: true});\n\n    db.createObjectStore(META_STORE, {keyPath: 'id'});\n  }\n\n  // Declare more PouchDB schema changes here\n  // if (pouchdbVersion < 2) { .. }\n}\n\nfunction openDatabase(openDatabases, api, opts, resolve, reject) {\n  var openReq = opts.versionchanged ?\n    indexedDB.open(opts.name) :\n    indexedDB.open(opts.name, createIdbVersion());\n\n  openReq.onupgradeneeded = function (e) {\n    if (e.oldVersion > 0 && e.oldVersion < versionMultiplier) {\n      // This DB was created with the \"idb\" adapter, **not** this one.\n      // For now we're going to just error out here: users must manually\n      // migrate between the two. In the future, dependent on performance tests,\n      // we might silently migrate\n      throw new Error('Incorrect adapter: you should specify the \"idb\" adapter to open this DB');\n    }\n\n    var db = e.target.result;\n\n    var pouchdbVersion = getPouchDbVersion(e.oldVersion);\n    upgradePouchDbSchema(db, pouchdbVersion);\n    maintainNativeIndexes(openReq, reject);\n  };\n\n  openReq.onblocked = function (e) {\n      // AFAICT this only occurs if, after sending `onversionchange` events to\n      // all other open DBs (ie in different tabs), there are still open\n      // connections to the DB. In this code we should never see this because we\n      // close our DBs on these events, and all DB interactions are wrapped in\n      // safely re-opening the DB.\n      console.error('onblocked, this should never happen', e);\n  };\n\n  openReq.onsuccess = function (e) {\n    var idb = e.target.result;\n\n    idb.onabort = function (e) {\n      console.error('Database has a global failure', e.target.error);\n      delete openDatabases[opts.name];\n      idb.close();\n    };\n\n    idb.onversionchange = function () {\n      console.log('Database was made stale, closing handle');\n      openDatabases[opts.name].versionchanged = true;\n      idb.close();\n    };\n\n    var metadata = {id: META_STORE};\n    var txn = idb.transaction([META_STORE], 'readwrite');\n\n    txn.oncomplete = function () {\n      resolve({idb: idb, metadata: metadata});\n    };\n\n    var metaStore = txn.objectStore(META_STORE);\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metadata = e.target.result || metadata;\n      var changed = false;\n\n      if (!('doc_count' in metadata)) {\n        changed = true;\n        metadata.doc_count = 0;\n      }\n\n      if (!('seq' in metadata)) {\n        changed = true;\n        metadata.seq = 0;\n      }\n\n      if (!('db_uuid' in metadata)) {\n        changed = true;\n        metadata.db_uuid = Object(pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__[\"uuid\"])();\n      }\n\n      if (changed) {\n        metaStore.put(metadata);\n      }\n    };\n  };\n\n  openReq.onerror = function (e) {\n    reject(e.target.error);\n  };\n}\n\nfunction setup (openDatabases, api, opts) {\n  if (!openDatabases[opts.name] || openDatabases[opts.name].versionchanged) {\n    opts.versionchanged = openDatabases[opts.name] &&\n                          openDatabases[opts.name].versionchanged;\n\n    openDatabases[opts.name] = new Promise(function (resolve, reject) {\n      openDatabase(openDatabases, api, opts, resolve, reject);\n    });\n  }\n\n  return openDatabases[opts.name];\n}\n\nfunction info (metadata, callback) {\n  callback(null, {\n    doc_count: metadata.doc_count,\n    update_seq: metadata.seq\n  });\n}\n\nfunction get (txn, id, opts, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  txn.txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n    var doc = e.target.result;\n    var rev;\n    if (!opts.rev) {\n      rev = (doc && doc.rev);\n    } else {\n      rev = opts.latest ? Object(pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__[\"latest\"])(opts.rev, doc) : opts.rev;\n    }\n\n    if (!doc || (doc.deleted && !opts.rev) || !(rev in doc.revs)) {\n      callback(Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"MISSING_DOC\"], 'missing'));\n      return;\n    }\n\n    var result = doc.revs[rev].data;\n    result._id = doc.id;\n    result._rev = rev;\n\n    // WARNING: expecting possible old format\n    // TODO: why are we passing the transaction in the context?\n    //       It's not clear we ever thread these txns usefully\n    callback(null, {\n      doc: result,\n      metadata: doc,\n      ctx: txn\n    });\n  };\n}\n\nfunction parseAttachment(attachment, opts, cb) {\n  if (opts.binary) {\n    return cb(null, attachment);\n  } else {\n    Object(pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__[\"readAsBinaryString\"])(attachment, function (binString) {\n      cb(null, Object(pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__[\"btoa\"])(binString));\n    });\n  }\n}\n\nfunction getAttachment(txn, docId, attachId, _, opts, cb) {\n  if (txn.error) {\n    return cb(txn.error);\n  }\n\n  var attachment;\n\n  txn.txn.objectStore(DOC_STORE).get(docId).onsuccess = function (e) {\n    var doc = e.target.result;\n    var rev = doc.revs[opts.rev || doc.rev].data;\n    var digest = rev._attachments[attachId].digest;\n    attachment = doc.attachments[digest].data;\n  };\n\n  txn.txn.oncomplete = function () {\n    parseAttachment(attachment, opts, cb);\n  };\n\n  txn.txn.onabort = cb;\n}\n\nfunction bulkDocs (api, req, opts, metadata, dbOpts, idbChanges, callback) {\n\n  var txn;\n\n  // TODO: I would prefer to get rid of these globals\n  var error;\n  var results = [];\n  var docs = [];\n  var lastWriteIndex;\n\n  var revsLimit = dbOpts.revs_limit || 1000;\n  var rewriteEnabled = dbOpts.name.indexOf(\"-mrview-\") === -1;\n\n  // We only need to track 1 revision for local documents\n  function docsRevsLimit(doc) {\n    return /^_local/.test(doc.id) ? 1 : revsLimit;\n  }\n\n  function rootIsMissing(doc) {\n    return doc.rev_tree[0].ids[1].status === 'missing';\n  }\n\n  function parseBase64(data) {\n    try {\n      return atob(data);\n    } catch (e) {\n      return {\n        error: Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"BAD_ARG\"], 'Attachment is not a valid base64 string')\n      };\n    }\n  }\n\n  // Reads the original doc from the store if available\n  // As in allDocs with keys option using multiple get calls is the fastest way\n  function fetchExistingDocs(txn, docs) {\n    var fetched = 0;\n    var oldDocs = {};\n\n    function readDone(e) {\n      if (e.target.result) {\n        oldDocs[e.target.result.id] = e.target.result;\n      }\n      if (++fetched === docs.length) {\n        processDocs(txn, docs, oldDocs);\n      }\n    }\n\n    docs.forEach(function (doc) {\n      txn.objectStore(DOC_STORE).get(doc.id).onsuccess = readDone;\n    });\n  }\n\n  function processDocs(txn, docs, oldDocs) {\n\n    docs.forEach(function (doc, i) {\n      var newDoc;\n\n      // The first document write cannot be a deletion\n      if ('was_delete' in opts && !(oldDocs.hasOwnProperty(doc.id))) {\n        newDoc = Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"MISSING_DOC\"], 'deleted');\n\n      // The first write of a document cannot specify a revision\n      } else if (opts.new_edits &&\n                 !oldDocs.hasOwnProperty(doc.id) &&\n                 rootIsMissing(doc)) {\n        newDoc = Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"REV_CONFLICT\"]);\n\n      // Update the existing document\n      } else if (oldDocs.hasOwnProperty(doc.id)) {\n        newDoc = update(txn, doc, oldDocs[doc.id]);\n        // The update can be rejected if it is an update to an existing\n        // revision, if so skip it\n        if (newDoc == false) {\n          return;\n        }\n\n      // New document\n      } else {\n        // Ensure new documents are also stemmed\n        var merged = Object(pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__[\"merge\"])([], doc.rev_tree[0], docsRevsLimit(doc));\n        doc.rev_tree = merged.tree;\n        doc.stemmedRevs = merged.stemmedRevs;\n        newDoc = doc;\n        newDoc.isNewDoc = true;\n        newDoc.wasDeleted = doc.revs[doc.rev].deleted ? 1 : 0;\n      }\n\n      if (newDoc.error) {\n        results[i] = newDoc;\n      } else {\n        oldDocs[newDoc.id] = newDoc;\n        lastWriteIndex = i;\n        write(txn, newDoc, i);\n      }\n    });\n  }\n\n  // Converts from the format returned by parseDoc into the new format\n  // we use to store\n  function convertDocFormat(doc) {\n\n    var newDoc = {\n      id: doc.metadata.id,\n      rev: doc.metadata.rev,\n      rev_tree: doc.metadata.rev_tree,\n      revs: doc.metadata.revs || {}\n    };\n\n    newDoc.revs[newDoc.rev] = {\n      data: doc.data,\n      deleted: doc.metadata.deleted\n    };\n\n    return newDoc;\n  }\n\n  function update(txn, doc, oldDoc) {\n\n    // Ignore updates to existing revisions\n    if ((doc.rev in oldDoc.revs) && !opts.new_edits) {\n      return false;\n    }\n\n    var isRoot = /^1-/.test(doc.rev);\n\n    // Reattach first writes after a deletion to last deleted tree\n    if (oldDoc.deleted && !doc.deleted && opts.new_edits && isRoot) {\n      var tmp = doc.revs[doc.rev].data;\n      tmp._rev = oldDoc.rev;\n      tmp._id = oldDoc.id;\n      doc = convertDocFormat(Object(pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_1__[\"parseDoc\"])(tmp, opts.new_edits, dbOpts));\n    }\n\n    var merged = Object(pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__[\"merge\"])(oldDoc.rev_tree, doc.rev_tree[0], docsRevsLimit(doc));\n    doc.stemmedRevs = merged.stemmedRevs;\n    doc.rev_tree = merged.tree;\n\n    // Merge the old and new rev data\n    var revs = oldDoc.revs;\n    revs[doc.rev] = doc.revs[doc.rev];\n    doc.revs = revs;\n\n    doc.attachments = oldDoc.attachments;\n\n    var inConflict = opts.new_edits && (((oldDoc.deleted && doc.deleted) ||\n       (!oldDoc.deleted && merged.conflicts !== 'new_leaf') ||\n       (oldDoc.deleted && !doc.deleted && merged.conflicts === 'new_branch') ||\n       (oldDoc.rev === doc.rev)));\n\n    if (inConflict) {\n      return Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"REV_CONFLICT\"]);\n    }\n\n    doc.wasDeleted = oldDoc.deleted;\n\n    return doc;\n  }\n\n  function write(txn, doc, i) {\n\n    // We copy the data from the winning revision into the root\n    // of the document so that it can be indexed\n    var winningRev$$1 = Object(pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__[\"winningRev\"])(doc);\n    // rev of new doc for attachments and to return it\n    var writtenRev = doc.rev;\n    var isLocal = /^_local/.test(doc.id);\n\n    var theDoc = doc.revs[winningRev$$1].data;\n\n    if (rewriteEnabled) {\n      // doc.data is what we index, so we need to clone and rewrite it, and clean\n      // it up for indexability\n      var result = rewrite(theDoc);\n      if (result) {\n        doc.data = result;\n        delete doc.data._attachments;\n      } else {\n        doc.data = theDoc;\n      }\n    } else {\n      doc.data = theDoc;\n    }\n\n    doc.rev = winningRev$$1;\n    // .deleted needs to be an int for indexing\n    doc.deleted = doc.revs[winningRev$$1].deleted ? 1 : 0;\n\n    // Bump the seq for every new (non local) revision written\n    // TODO: index expects a unique seq, not sure if ignoring local will\n    // work\n    if (!isLocal) {\n      doc.seq = ++metadata.seq;\n\n      var delta = 0;\n      // If its a new document, we wont decrement if deleted\n      if (doc.isNewDoc) {\n        delta = doc.deleted ? 0 : 1;\n      } else if (doc.wasDeleted !== doc.deleted) {\n        delta = doc.deleted ? -1 : 1;\n      }\n      metadata.doc_count += delta;\n    }\n    delete doc.isNewDoc;\n    delete doc.wasDeleted;\n\n    // If there have been revisions stemmed when merging trees,\n    // delete their data\n    if (doc.stemmedRevs) {\n      doc.stemmedRevs.forEach(function (rev) { delete doc.revs[rev]; });\n    }\n    delete doc.stemmedRevs;\n\n    if (!('attachments' in doc)) {\n      doc.attachments = {};\n    }\n\n    if (theDoc._attachments) {\n      for (var k in theDoc._attachments) {\n        var attachment = theDoc._attachments[k];\n        if (attachment.stub) {\n          if (!(attachment.digest in doc.attachments)) {\n            error = Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"MISSING_STUB\"]);\n            // TODO: Not sure how safe this manual abort is, seeing\n            // console issues\n            txn.abort();\n            return;\n          }\n\n          doc.attachments[attachment.digest].revs[writtenRev] = true;\n\n        } else {\n\n          doc.attachments[attachment.digest] = attachment;\n          doc.attachments[attachment.digest].revs = {};\n          doc.attachments[attachment.digest].revs[writtenRev] = true;\n\n          theDoc._attachments[k] = {\n            stub: true,\n            digest: attachment.digest,\n            content_type: attachment.content_type,\n            length: attachment.length,\n            revpos: parseInt(writtenRev, 10)\n          };\n        }\n      }\n    }\n\n    // Local documents have different revision handling\n    if (isLocal && doc.deleted) {\n      txn.objectStore(DOC_STORE).delete(doc.id).onsuccess = function () {\n        results[i] = {\n          ok: true,\n          id: doc.id,\n          rev: '0-0'\n        };\n      };\n      updateSeq(i);\n      return;\n    }\n\n    txn.objectStore(DOC_STORE).put(doc).onsuccess = function () {\n      results[i] = {\n        ok: true,\n        id: doc.id,\n        rev: writtenRev\n      };\n      updateSeq(i);\n    };\n  }\n\n  function updateSeq(i) {\n    if (i === lastWriteIndex) {\n      txn.objectStore(META_STORE).put(metadata);\n    }\n  }\n\n  function preProcessAttachment(attachment) {\n    if (attachment.stub) {\n      return Promise.resolve(attachment);\n    }\n\n    var binData;\n    if (typeof attachment.data === 'string') {\n      binData = parseBase64(attachment.data);\n      if (binData.error) {\n        return Promise.reject(binData.error);\n      }\n      attachment.data = Object(pouchdb_binary_utils__WEBPACK_IMPORTED_MODULE_0__[\"binaryStringToBlobOrBuffer\"])(binData, attachment.content_type);\n    } else {\n      binData = attachment.data;\n    }\n\n    return new Promise(function (resolve) {\n      Object(pouchdb_md5__WEBPACK_IMPORTED_MODULE_2__[\"binaryMd5\"])(binData, function (result) {\n        attachment.digest = 'md5-' + result;\n        attachment.length = binData.size || binData.length || 0;\n        resolve(attachment);\n      });\n    });\n  }\n\n  function preProcessAttachments() {\n    var promises = docs.map(function (doc) {\n      var data = doc.revs[doc.rev].data;\n      if (!data._attachments) {\n        return Promise.resolve(data);\n      }\n      var attachments = Object.keys(data._attachments).map(function (k) {\n        data._attachments[k].name = k;\n        return preProcessAttachment(data._attachments[k]);\n      });\n\n      return Promise.all(attachments).then(function (newAttachments) {\n        var processed = {};\n        newAttachments.forEach(function (attachment) {\n          processed[attachment.name] = attachment;\n          delete attachment.name;\n        });\n        data._attachments = processed;\n        return data;\n      });\n    });\n    return Promise.all(promises);\n  }\n\n  for (var i = 0, len = req.docs.length; i < len; i++) {\n    var result;\n    // TODO: We should get rid of throwing for invalid docs, also not sure\n    // why this is needed in idb-next and not idb\n    try {\n      result = Object(pouchdb_adapter_utils__WEBPACK_IMPORTED_MODULE_1__[\"parseDoc\"])(req.docs[i], opts.new_edits, dbOpts);\n    } catch (err) {\n      result = err;\n    }\n    if (result.error) {\n      return callback(result);\n    }\n\n    // Ideally parseDoc would return data in this format, but it is currently\n    // shared so we need to convert\n    docs.push(convertDocFormat(result));\n  }\n\n  preProcessAttachments().then(function () {\n    api._openTransactionSafely([DOC_STORE, META_STORE], 'readwrite', function (err, _txn) {\n      if (err) {\n        return callback(err);\n      }\n\n      txn = _txn;\n\n      txn.onabort = function () {\n        callback(error);\n      };\n      txn.ontimeout = idbError(callback);\n\n      txn.oncomplete = function () {\n        idbChanges.notify(dbOpts.name);\n        callback(null, results);\n      };\n\n      // We would like to use promises here, but idb sucks\n      fetchExistingDocs(txn, docs);\n    });\n  }).catch(function (err) {\n    callback(err);\n  });\n}\n\nfunction allDocsKeys(keys, docStore, allDocsInner) {\n  // It's not guaranted to be returned in right order\n  var valuesBatch = new Array(keys.length);\n  var count = 0;\n  keys.forEach(function (key, index) {\n    docStore.get(key).onsuccess = function (event) {\n      if (event.target.result) {\n      valuesBatch[index] = event.target.result;\n      } else {\n        valuesBatch[index] = {key: key, error: 'not_found'};\n      }\n      count++;\n      if (count === keys.length) {\n        valuesBatch.forEach(function (doc) {\n            allDocsInner(doc);\n        });\n      }\n    };\n  });\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction handleKeyRangeError(opts, metadata, err, callback) {\n  if (err.name === \"DataError\" && err.code === 0) {\n    // data error, start is less than end\n    var returnVal = {\n      total_rows: metadata.doc_count,\n      offset: opts.skip,\n      rows: []\n    };\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      returnVal.update_seq = metadata.seq;\n    }\n    return callback(null, returnVal);\n  }\n  callback(Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"IDB_ERROR\"], err.name, err.message));\n}\n\nfunction allDocs (txn, metadata, opts, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  // TODO: Weird hack, I dont like it\n  if (opts.limit === 0) {\n    var returnVal = {\n      total_rows: metadata.doc_count,\n      offset: opts.skip,\n      rows: []\n    };\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      returnVal.update_seq = metadata.seq;\n    }\n    return callback(null, returnVal);\n  }\n\n  var results = [];\n  var processing = [];\n\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var keys = 'keys' in opts ? opts.keys : false;\n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n  var descending = 'descending' in opts && opts.descending ? 'prev' : null;\n\n  var keyRange;\n  if (!keys) {\n    keyRange = createKeyRange(start, end, inclusiveEnd, key, descending);\n    if (keyRange && keyRange.error) {\n      return handleKeyRangeError(opts, metadata, keyRange.error, callback);\n    }\n  }\n\n  var docStore = txn.txn.objectStore(DOC_STORE);\n\n  txn.txn.oncomplete = onTxnComplete;\n\n  if (keys) {\n    return allDocsKeys(opts.keys, docStore, allDocsInner);\n  }\n\n  function include_doc(row, doc) {\n    var docData = doc.revs[doc.rev].data;\n\n    row.doc = docData;\n    row.doc._id = doc.id;\n    row.doc._rev = doc.rev;\n    if (opts.conflicts) {\n      var conflicts = Object(pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__[\"collectConflicts\"])(doc);\n      if (conflicts.length) {\n        row.doc._conflicts = conflicts;\n      }\n    }\n    if (opts.attachments && docData._attachments) {\n      for (var name in docData._attachments) {\n        processing.push(processAttachment(name, doc, row.doc, opts.binary));\n      }\n    }\n  }\n\n  function allDocsInner(doc) {\n    if (doc.error && keys) {\n      // key was not found with \"keys\" requests\n      results.push(doc);\n      return true;\n    }\n\n    var row = {\n      id: doc.id,\n      key: doc.id,\n      value: {\n        rev: doc.rev\n      }\n    };\n\n    var deleted = doc.deleted;\n    if (deleted) {\n      if (keys) {\n        results.push(row);\n        row.value.deleted = true;\n        row.doc = null;\n      }\n    } else if (skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        include_doc(row, doc);\n      }\n      if (--limit === 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function onTxnComplete() {\n    Promise.all(processing).then(function () {\n      var returnVal = {\n        total_rows: metadata.doc_count,\n        offset: 0,\n        rows: results\n      };\n\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        returnVal.update_seq = metadata.seq;\n      }\n      callback(null, returnVal);\n    });\n  }\n\n  var cursor = descending ?\n    docStore.openCursor(keyRange, descending) :\n    docStore.openCursor(keyRange);\n\n  cursor.onsuccess = function (e) {\n\n    var doc = e.target.result && e.target.result.value;\n\n    // Happens if opts does not have limit,\n    // because cursor will end normally then,\n    // when all docs are retrieved.\n    // Would not be needed, if getAll() optimization was used like in #6059\n    if (!doc) { return; }\n\n    // Skip local docs\n    if (/^_local/.test(doc.id)) {\n      return e.target.result.continue();\n    }\n\n    var continueCursor = allDocsInner(doc);\n    if (continueCursor) {\n      e.target.result.continue();\n    }\n  };\n\n}\n\nfunction changes (txn, idbChanges, api, dbOpts, opts) {\n  if (txn.error) {\n    return opts.complete(txn.error);\n  }\n\n  if (opts.continuous) {\n    var id = dbOpts.name + ':' + Object(pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__[\"uuid\"])();\n    idbChanges.addListener(dbOpts.name, id, api, opts);\n    idbChanges.notify(dbOpts.name);\n    return {\n      cancel: function () {\n        idbChanges.removeListener(dbOpts.name, id);\n      }\n    };\n  }\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1;\n  }\n\n  var store = txn.txn.objectStore(DOC_STORE).index('seq');\n\n  var filter = Object(pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__[\"filterChange\"])(opts);\n  var received = 0;\n\n  var lastSeq = opts.since || 0;\n  var results = [];\n\n  var processing = [];\n\n  function onReqSuccess(e) {\n    if (!e.target.result) { return; }\n    var cursor = e.target.result;\n    var doc = cursor.value;\n    // Overwrite doc.data, which may have been rewritten (see rewrite.js) with\n    // the clean version for that rev\n    doc.data = doc.revs[doc.rev].data;\n    doc.data._id = doc.id;\n    doc.data._rev = doc.rev;\n    if (doc.deleted) {\n      doc.data._deleted = true;\n    }\n\n    if (opts.doc_ids && opts.doc_ids.indexOf(doc.id) === -1) {\n      return cursor.continue();\n    }\n\n    // WARNING: expecting possible old format\n    var change = opts.processChange(doc.data, doc, opts);\n    change.seq = doc.seq;\n    lastSeq = doc.seq;\n    var filtered = filter(change);\n\n    // If its an error\n    if (typeof filtered === 'object') {\n      return opts.complete(filtered);\n    }\n\n    if (filtered) {\n      received++;\n      if (opts.return_docs) {\n        results.push(change);\n      }\n\n      if (opts.include_docs && opts.attachments && doc.data._attachments) {\n        var promises = [];\n        for (var name in doc.data._attachments) {\n          var p = processAttachment(name, doc, change.doc, opts.binary);\n          // We add the processing promise to 2 arrays, one tracks all\n          // the promises needed before we fire onChange, the other\n          // ensure we process all attachments before onComplete\n          promises.push(p);\n          processing.push(p);\n        }\n\n        Promise.all(promises).then(function () {\n          opts.onChange(change);\n        });\n      } else {\n        opts.onChange(change);\n      }\n    }\n    if (received !== limit) {\n      cursor.continue();\n    }\n  }\n\n  function onTxnComplete() {\n    Promise.all(processing).then(function () {\n      opts.complete(null, {\n        results: results,\n        last_seq: lastSeq\n      });\n    });\n  }\n\n  var req;\n  if (opts.descending) {\n    req = store.openCursor(null, 'prev');\n  } else {\n    req = store.openCursor(IDBKeyRange.lowerBound(opts.since, true));\n  }\n\n  txn.txn.oncomplete = onTxnComplete;\n  req.onsuccess = onReqSuccess;\n}\n\nfunction getRevisionTree (txn, id, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  var req = txn.txn.objectStore(DOC_STORE).get(id);\n  req.onsuccess = function (e) {\n    if (!e.target.result) {\n      callback(Object(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"createError\"])(pouchdb_errors__WEBPACK_IMPORTED_MODULE_4__[\"MISSING_DOC\"]));\n    } else {\n      callback(null, e.target.result.rev_tree);\n    }\n  };\n}\n\nfunction doCompaction (txn, id, revs, callback) {\n  if (txn.error) {\n    return callback(txn.error);\n  }\n\n  var docStore = txn.txn.objectStore(DOC_STORE);\n\n  docStore.get(id).onsuccess = function (e) {\n    var doc = e.target.result;\n\n    Object(pouchdb_merge__WEBPACK_IMPORTED_MODULE_5__[\"traverseRevTree\"])(doc.rev_tree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev = pos + '-' + revHash;\n      if (revs.indexOf(rev) !== -1) {\n        opts.status = 'missing';\n      }\n    });\n\n    var attachments = [];\n\n    revs.forEach(function (rev) {\n      if (rev in doc.revs) {\n        // Make a list of attachments that are used by the revisions being\n        // deleted\n        if (doc.revs[rev].data._attachments) {\n          for (var k in doc.revs[rev].data._attachments) {\n            attachments.push(doc.revs[rev].data._attachments[k].digest);\n          }\n        }\n        delete doc.revs[rev];\n      }\n    });\n\n    // Attachments have a list of revisions that are using them, when\n    // that list becomes empty we can delete the attachment.\n    attachments.forEach(function (digest) {\n      revs.forEach(function (rev) {\n        delete doc.attachments[digest].revs[rev];\n      });\n      if (!Object.keys(doc.attachments[digest].revs).length) {\n        delete doc.attachments[digest];\n      }\n    });\n\n    docStore.put(doc);\n  };\n\n  txn.txn.oncomplete = function () {\n    callback();\n  };\n}\n\nfunction destroy (dbOpts, openDatabases, idbChanges, callback) {\n\n  idbChanges.removeAllListeners(dbOpts.name);\n\n  function doDestroy() {\n    var req = indexedDB.deleteDatabase(dbOpts.name);\n    req.onsuccess = function () {\n      delete openDatabases[dbOpts.name];\n      callback(null, {ok: true});\n    };\n  }\n\n  // If the database is open we need to close it\n  if (dbOpts.name in openDatabases) {\n    openDatabases[dbOpts.name].then(function (res) {\n      res.idb.close();\n      doDestroy();\n    });\n  } else {\n    doDestroy();\n  }\n\n}\n\n// Adapted from\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-find/src/adapters/local/find/query-planner.js#L20-L24\n// This could change / improve in the future?\nvar COUCH_COLLATE_LO = null;\nvar COUCH_COLLATE_HI = '\\uffff'; // actually used as {\"\\uffff\": {}}\n\n// Adapted from: https://www.w3.org/TR/IndexedDB/#compare-two-keys\n// Importantly, *there is no upper bound possible* in idb. The ideal data\n// structure an infintely deep array:\n//   var IDB_COLLATE_HI = []; IDB_COLLATE_HI.push(IDB_COLLATE_HI)\n// But IDBKeyRange is not a fan of shenanigans, so I've just gone with 12 layers\n// because it looks nice and surely that's enough!\nvar IDB_COLLATE_LO = Number.NEGATIVE_INFINITY;\nvar IDB_COLLATE_HI = [[[[[[[[[[[[]]]]]]]]]]]];\n\n//\n// TODO: this should be made offical somewhere and used by AllDocs / get /\n// changes etc as well.\n//\nfunction externaliseRecord(idbDoc) {\n  var doc = idbDoc.revs[idbDoc.rev].data;\n  doc._id = idbDoc.id;\n  doc._rev = idbDoc.rev;\n  if (idbDoc.deleted) {\n    doc._deleted = true;\n  }\n\n  return doc;\n}\n\n/**\n * Generates a keyrange based on the opts passed to query\n *\n * The first key is always 0, as that's how we're filtering out deleted entries.\n */\nfunction generateKeyRange(opts) {\n  function defined(obj, k) {\n    return obj[k] !== void 0;\n  }\n\n  // Converts a valid CouchDB key into a valid IndexedDB one\n  function convert(key, exact) {\n    // The first item in every native index is doc.deleted, and we always want\n    // to only search documents that are not deleted.\n    // \"foo\" -> [0, \"foo\"]\n    var filterDeleted = [0].concat(key);\n\n    return filterDeleted.map(function (k) {\n      // null, true and false are not indexable by indexeddb. When we write\n      // these values we convert them to these constants, and so when we\n      // query for them we need to convert the query also.\n      if (k === null && exact) {\n        // for non-exact queries we treat null as a collate property\n        // see `if (!exact)` block below\n        return IDB_NULL;\n      } else if (k === true) {\n        return IDB_TRUE;\n      } else if (k === false) {\n        return IDB_FALSE;\n      }\n\n      if (!exact) {\n        // We get passed CouchDB's collate low and high values, so for non-exact\n        // ranged queries we're going to convert them to our IDB equivalents\n        if (k === COUCH_COLLATE_LO) {\n          return IDB_COLLATE_LO;\n        } else if (k.hasOwnProperty(COUCH_COLLATE_HI)) {\n          return IDB_COLLATE_HI;\n        }\n      }\n\n      return k;\n    });\n  }\n\n  // CouchDB and so PouchdB defaults to true. We need to make this explicit as\n  // we invert these later for IndexedDB.\n  if (!defined(opts, 'inclusive_end')) {\n    opts.inclusive_end = true;\n  }\n  if (!defined(opts, 'inclusive_start')) {\n    opts.inclusive_start = true;\n  }\n\n  if (opts.descending) {\n    // Flip before generating. We'll check descending again later when performing\n    // an index request\n    var realEndkey = opts.startkey,\n        realInclusiveEnd = opts.inclusive_start;\n\n    opts.startkey = opts.endkey;\n    opts.endkey = realEndkey;\n    opts.inclusive_start = opts.inclusive_end;\n    opts.inclusive_end = realInclusiveEnd;\n  }\n\n  try {\n    if (defined(opts, 'key')) {\n      return IDBKeyRange.only(convert(opts.key, true));\n    }\n\n    if (defined(opts, 'startkey') && !defined(opts, 'endkey')) {\n      return IDBKeyRange.lowerBound(convert(opts.startkey), !opts.inclusive_start);\n    }\n\n    if (!defined(opts, 'startkey') && defined(opts, 'endkey')) {\n      return IDBKeyRange.upperBound(convert(opts.endkey), !opts.inclusive_end);\n    }\n\n    if (defined(opts, 'startkey') && defined(opts, 'endkey')) {\n      return IDBKeyRange.bound(\n        convert(opts.startkey),    convert(opts.endkey),\n        !opts.inclusive_start, !opts.inclusive_end\n      );\n    }\n\n    return IDBKeyRange.only([0]);\n  } catch (err) {\n    console.error('Could not generate keyRange', err, opts);\n    throw Error('Could not generate key range with ' + JSON.stringify(opts));\n  }\n}\n\nfunction getIndexHandle(pdb, fields, reject) {\n  var indexName = naturalIndexName(fields);\n\n  return new Promise(function (resolve) {\n    pdb._openTransactionSafely([DOC_STORE], 'readonly', function (err, txn) {\n      if (err) {\n        return idbError(reject)(err);\n      }\n\n      txn.onabort = idbError(reject);\n      txn.ontimeout = idbError(reject);\n\n      var existingIndexNames = Array.from(txn.objectStore(DOC_STORE).indexNames);\n\n      if (existingIndexNames.indexOf(indexName) === -1) {\n        // The index is missing, force a db restart and try again\n        pdb._freshen()\n          .then(function () { return getIndexHandle(pdb, fields, reject); })\n          .then(resolve);\n      } else {\n        resolve(txn.objectStore(DOC_STORE).index(indexName));\n      }\n    });\n  });\n}\n\n// In theory we should return something like the doc example below, but find\n// only needs rows: [{doc: {...}}], so I think we can just not bother for now\n// {\n//   \"offset\" : 0,\n//   \"rows\": [{\n//     \"id\": \"doc3\",\n//     \"key\": \"Lisa Says\",\n//     \"value\": null,\n//     \"doc\": {\n//       \"_id\": \"doc3\",\n//       \"_rev\": \"1-z\",\n//       \"title\": \"Lisa Says\"\n//     }\n//   }],\n//   \"total_rows\" : 4\n// }\nfunction query(idb, signature, opts) {\n  // At this stage, in the current implementation, find has already gone through\n  // and determined if the index already exists from PouchDB's perspective (eg\n  // there is a design doc for it).\n  //\n  // If we find that the index doesn't exist this means we have to close and\n  // re-open the DB to correct indexes before proceeding, at which point the\n  // index should exist.\n\n  var pdb = this;\n\n  // Assumption, there will be only one /, between the design document name\n  // and the view name.\n  var parts = signature.split('/');\n\n  return new Promise(function (resolve, reject) {\n    pdb.get('_design/' + parts[0]).then(function (ddoc) {\n      var fields = rawIndexFields(ddoc, parts[1]);\n      if (!fields) {\n        throw new Error('ddoc ' + ddoc._id +' with view ' + parts[1] +\n          ' does not have map.options.def.fields defined.');\n      }\n\n      var skip = opts.skip;\n      var limit = Number.isInteger(opts.limit) && opts.limit;\n\n      return getIndexHandle(pdb, fields, reject)\n        .then(function (indexHandle) {\n          var keyRange = generateKeyRange(opts);\n          var req = indexHandle.openCursor(keyRange, opts.descending ? 'prev' : 'next');\n\n          var rows = [];\n          req.onerror = idbError(reject);\n          req.onsuccess = function (e) {\n            var cursor = e.target.result;\n\n            if (!cursor || limit === 0) {\n              return resolve({\n                rows: rows\n              });\n            }\n\n            if (skip) {\n              cursor.advance(skip);\n              skip = false;\n              return;\n            }\n\n            if (limit) {\n              limit = limit - 1;\n            }\n\n            rows.push({doc: externaliseRecord(cursor.value)});\n            cursor.continue();\n          };\n        });\n      })\n      .catch(reject);\n  });\n\n}\n\nfunction viewCleanup() {\n  // I'm not sure we have to do anything here.\n  //\n  // One option is to just close and re-open the DB, which performs the same\n  // action. The only reason you'd want to call this is if you deleted a bunch\n  // of indexes and wanted the space back immediately.\n  //\n  // Otherwise index cleanup happens when:\n  //  - A DB is opened\n  //  - A find query is performed against an index that doesn't exist but should\n\n  return Promise.resolve();\n}\n\nvar ADAPTER_NAME = 'indexeddb';\n\n// TODO: Constructor should be capitalised\nvar idbChanges = new pouchdb_utils__WEBPACK_IMPORTED_MODULE_3__[\"changesHandler\"]();\n\n// A shared list of database handles\nvar openDatabases = {};\n\nfunction IdbPouch(dbOpts, callback) {\n\n  var api = this;\n  var metadata = {};\n\n  // Wrapper that gives you an active DB handle. You probably want $t.\n  var $ = function (fun) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      setup(openDatabases, api, dbOpts).then(function (res) {\n        metadata = res.metadata;\n        args.unshift(res.idb);\n        fun.apply(api, args);\n      }).catch(function (err) {\n        var last = args.unshift();\n        if (typeof last === 'function') {\n          last(err);\n        } else {\n          console.error(err);\n        }\n      });\n    };\n  };\n  // the promise version of $\n  var $p = function (fun) {\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n\n      return new Promise(function (resolve, reject) {\n        setup(openDatabases, api, dbOpts).then(function (res) {\n          metadata = res.metadata;\n          args.unshift(res.idb);\n\n          return fun.apply(api, args);\n        }).then(resolve)\n          .catch(reject);\n      });\n    };\n  };\n  // Wrapper that gives you a safe transaction handle. It's important to use\n  // this instead of opening your own transaction from a db handle got from $,\n  // because in the time between getting the db handle and opening the\n  // transaction it may have been invalidated by index changes.\n  var $t = function (fun, stores, mode) {\n    stores = stores || [DOC_STORE];\n    mode = mode || 'readonly';\n\n    return function () {\n      var args = Array.prototype.slice.call(arguments);\n      var txn = {};\n      setup(openDatabases, api, dbOpts).then(function (res) {\n        metadata = res.metadata;\n        txn.txn = res.idb.transaction(stores, mode);\n        args.unshift(txn);\n        fun.apply(api, args);\n      }).catch(function (err) {\n        console.error('Failed to establish transaction safely');\n        console.error(err);\n        txn.error = err;\n      });\n    };\n  };\n\n  api._openTransactionSafely = function (stores, mode, callback) {\n    $t(function (txn, callback) {\n      callback(txn.error, txn.txn);\n    }, stores, mode)(callback);\n  };\n\n  api._remote = false;\n  api.type = function () { return ADAPTER_NAME; };\n\n  api._id = $(function (_, cb) {\n    cb(null, metadata.db_uuid);\n  });\n\n  api._info = $(function (_, cb) {\n    return info(metadata, cb);\n  });\n\n  api._get = $t(get);\n\n  api._bulkDocs = $(function (_, req, opts, callback) {\n    bulkDocs(api, req, opts, metadata, dbOpts, idbChanges, callback);\n  });\n\n  api._allDocs = $t(function (txn, opts, cb) {\n    allDocs(txn, metadata, opts, cb);\n  });\n\n  api._getAttachment = $t(getAttachment);\n\n  api._changes = $t(function (txn, opts) {\n    changes(txn, idbChanges, api, dbOpts, opts);\n  });\n\n  api._getRevisionTree = $t(getRevisionTree);\n  api._doCompaction = $t(doCompaction, [DOC_STORE], 'readwrite');\n\n  api._customFindAbstractMapper = {\n    query: $p(query),\n    viewCleanup: $p(viewCleanup)\n  };\n\n  api._destroy = function (opts, callback) {\n    return destroy(dbOpts, openDatabases, idbChanges, callback);\n  };\n\n  api._close = $(function (db, cb) {\n    delete openDatabases[dbOpts.name];\n    db.close();\n    cb();\n  });\n\n  // Closing and re-opening the DB re-generates native indexes\n  api._freshen = function () {\n    return new Promise(function (resolve) {\n      api._close(function () {\n        $(resolve)();\n      });\n    });\n  };\n\n  // TODO: this setTimeout seems nasty, if its needed lets\n  // figure out / explain why\n  setTimeout(function () {\n    callback(null, api);\n  });\n}\n\n// TODO: this isnt really valid permanently, just being lazy to start\nIdbPouch.valid = function () {\n  return true;\n};\n\nfunction index (PouchDB) {\n  PouchDB.adapter(ADAPTER_NAME, IdbPouch, true);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2stdnVlOi8vLy4uL25vZGVfbW9kdWxlcy9wb3VjaGRiLWFkYXB0ZXItaW5kZXhlZGRiL2xpYi9pbmRleC5lcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUE0RjtBQUMzQztBQUNUO0FBQzJCO0FBQ3VDO0FBQ2I7O0FBRTdGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtFQUFXLENBQUMsd0RBQVM7QUFDbEM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLCtFQUFrQjtBQUN0QixvQ0FBb0MsaUVBQUk7QUFDeEM7QUFD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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNCQUFzQjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNENBQTRDLEVBQUU7QUFDM0U7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxzQkFBc0IsTUFBTSxLQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixxQ0FBcUM7QUFDNUQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsNERBQWM7O0FBRW5DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSwwQkFBMEIscUJBQXFCOztBQUUvQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVlLG9FQUFLLEVBQUMiLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3BvdWNoZGItYWRhcHRlci1pbmRleGVkZGIvbGliL2luZGV4LmVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnRvYSwgcmVhZEFzQmluYXJ5U3RyaW5nLCBiaW5hcnlTdHJpbmdUb0Jsb2JPckJ1ZmZlciB9IGZyb20gJ3BvdWNoZGItYmluYXJ5LXV0aWxzJztcbmltcG9ydCB7IHBhcnNlRG9jIH0gZnJvbSAncG91Y2hkYi1hZGFwdGVyLXV0aWxzJztcbmltcG9ydCB7IGJpbmFyeU1kNSB9IGZyb20gJ3BvdWNoZGItbWQ1JztcbmltcG9ydCB7IHV1aWQsIGZpbHRlckNoYW5nZSwgY2hhbmdlc0hhbmRsZXIgfSBmcm9tICdwb3VjaGRiLXV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUVycm9yLCBJREJfRVJST1IsIE1JU1NJTkdfRE9DLCBSRVZfQ09ORkxJQ1QsIE1JU1NJTkdfU1RVQiwgQkFEX0FSRyB9IGZyb20gJ3BvdWNoZGItZXJyb3JzJztcbmltcG9ydCB7IGxhdGVzdCwgd2lubmluZ1JldiwgbWVyZ2UsIGNvbGxlY3RDb25mbGljdHMsIHRyYXZlcnNlUmV2VHJlZSB9IGZyb20gJ3BvdWNoZGItbWVyZ2UnO1xuXG52YXIgSURCX05VTEwgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbnZhciBJREJfRkFMU0UgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiArIDE7XG52YXIgSURCX1RSVUUgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiArIDI7XG5cbi8vXG4vLyBJbmRleGVkREIgb25seSBhbGxvd3MgdmFsaWQgSlMgbmFtZXMgaW4gaXRzIGluZGV4IHBhdGhzLCB3aGVyZWFzIEpTT04gYWxsb3dzXG4vLyBmb3IgYW55IHN0cmluZyBhdCBhbGwuIFRoaXMgY29udmVydHMgaW52YWxpZCBKUyBuYW1lcyB0byB2YWxpZCBvbmVzLCB0byBhbGxvd1xuLy8gZm9yIHRoZW0gdG8gYmUgaW5kZXhlZC5cbi8vXG4vLyBGb3IgZXhhbXBsZSwgXCJmb28tYmFyXCIgaXMgYSB2YWxpZCBKU09OIGtleSwgYnV0IGNhbm5vdCBiZSBhIHZhbGlkIEpTIG5hbWVcbi8vIChiZWNhdXNlIHRoYXQgd291bGQgYmUgcmVhZCBhcyBmb28gbWludXMgYmFyKS5cbi8vXG4vLyBWZXJ5IGhpZ2ggbGV2ZWwgcnVsZXMgZm9yIHZhbGlkIEpTIG5hbWVzIGFyZTpcbi8vICAtIEZpcnN0IGNoYXJhY3RlciBjYW5ub3Qgc3RhcnQgd2l0aCBhIG51bWJlclxuLy8gIC0gT3RoZXJ3aXNlIGFsbCBjaGFyYWN0ZXJzIG11c3QgYmUgYmUgYS16LCBBLVosIDAtOSwgJCBvciBfLlxuLy8gIC0gV2UgYWxsb3cgLiB1bmxlc3MgdGhlIG5hbWUgcmVwcmVzZW50cyBhIHNpbmdsZSBmaWVsZCwgYXMgdGhhdCByZXByZXNlbnRzXG4vLyAgICBhIGRlZXAgaW5kZXggcGF0aC5cbi8vXG4vLyBUaGlzIGlzIG1vcmUgYWdncmVzc2l2ZSB0aGFuIGl0IG5lZWRzIHRvIGJlLCBidXQgYWxzbyBzaW1wbGVyLlxuLy9cbnZhciBLRVlfSU5WQUxJRCA9IC9bXmEtekEtWjAtOV8kXSt8KF5bXmEtekEtWl8kXSkvZztcbnZhciBQQVRIX0lOVkFMSUQgPSAvKFxcXFwuKXxbXmEtekEtWjAtOV8kLl0rfCheW15hLXpBLVpfJF0pL2c7XG52YXIgU0xBU0ggPSAnXFxcXCcuY2hhckNvZGVBdCgwKTtcblxuLy8gVGhlc2UgYXJlIHRoZSBzYW1lIGFzIGFib3ZlIGJ1dCB3aXRob3V0IHRoZSBnbG9iYWwgZmxhZ1xuLy8gd2Ugd2FudCB0byB1c2UgUmVnRXhwLnRlc3QgYmVjYXVzZSBpdCdzIHJlYWxseSBmYXN0LCBidXQgdGhlIGdsb2JhbCBmbGFnXG4vLyBtYWtlcyB0aGUgcmVnZXggY29uc3Qgc3RhdGVmdWwgKHNlcmlvdXNseSkgYXMgaXQgd2Fsa2VkIHRocm91Z2ggYWxsIGluc3RhbmNlc1xudmFyIFRFU1RfS0VZX0lOVkFMSUQgPSAvW15hLXpBLVowLTlfJF0rfCheW15hLXpBLVpfJF0pLztcbnZhciBURVNUX1BBVEhfSU5WQUxJRCA9IC8oXFxcXC4pfFteYS16QS1aMC05XyQuXSt8KF5bXmEtekEtWl8kXSkvO1xuZnVuY3Rpb24gbmVlZHNTYW5pdGlzZShuYW1lLCBpc1BhdGgpIHtcbiAgaWYgKGlzUGF0aCkge1xuICAgIHJldHVybiBURVNUX1BBVEhfSU5WQUxJRC50ZXN0KG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBURVNUX0tFWV9JTlZBTElELnRlc3QobmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FuaXRpc2UobmFtZSwgaXNQYXRoKSB7XG4gIHZhciBjb3JyZWN0Q2hhcmFjdGVycyA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHZhciBnb29kID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvZGUgPSBtYXRjaC5jaGFyQ29kZUF0KGkpO1xuICAgICAgLy8gSWYgeW91J3JlIHNhbml0aXNpbmcgYSBwYXRoLCBhIHNsYXNoIGNoYXJhY3RlciBpcyB0aGVyZSB0byBiZSBpbnRlcnByZXRlZFxuICAgICAgLy8gYnkgd2hhdGV2ZXIgcGFyc2VzIHRoZSBwYXRoIGxhdGVyIGFzIFwiZXNjYXBlIHRoZSBuZXh0IHRoaW5nXCIuXG4gICAgICAvL1xuICAgICAgLy8gZS5nLiwgaWYgeW91IHdhbnQgdG8gaW5kZXggVEhJUyBzdHJpbmc6XG4gICAgICAvLyAgIHtcImZvb1wiOiB7XCJiYXIuYmF6XCI6IFwiVEhJU1wifX1cbiAgICAgIC8vIFlvdXIgaW5kZXggcGF0aCB3b3VsZCBiZSBcImZvby5iYXJcXC5iYXpcIi5cbiAgICAgIGlmIChjb2RlID09PSBTTEFTSCAmJiBpc1BhdGgpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGdvb2QgKz0gJ19jJyArIGNvZGUgKyAnXyc7XG4gICAgfVxuICAgIHJldHVybiBnb29kO1xuICB9O1xuXG4gIGlmIChpc1BhdGgpIHtcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKFBBVEhfSU5WQUxJRCwgY29ycmVjdENoYXJhY3RlcnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuYW1lLnJlcGxhY2UoS0VZX0lOVkFMSUQsIGNvcnJlY3RDaGFyYWN0ZXJzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZWVkc1Jld3JpdGUoZGF0YSkge1xuICBmb3IgKHZhciBrZXkgb2YgT2JqZWN0LmtleXMoZGF0YSkpIHtcbiAgICBpZiAobmVlZHNTYW5pdGlzZShrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGFba2V5XSA9PT0gbnVsbCB8fCB0eXBlb2YgZGF0YVtrZXldID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGFba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBuZWVkc1Jld3JpdGUoZGF0YVtrZXldKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV3cml0ZShkYXRhKSB7XG4gIGlmICghbmVlZHNSZXdyaXRlKGRhdGEpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGRhdGEpO1xuICB2YXIgY2xvbmUgPSBpc0FycmF5XG4gICAgPyBbXVxuICAgIDoge307XG5cbiAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHNhZmVLZXkgPSBpc0FycmF5ID8ga2V5IDogc2FuaXRpc2Uoa2V5KTtcblxuICAgIGlmIChkYXRhW2tleV0gPT09IG51bGwpIHtcbiAgICAgIGNsb25lW3NhZmVLZXldID0gSURCX05VTEw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YVtrZXldID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGNsb25lW3NhZmVLZXldID0gZGF0YVtrZXldID8gSURCX1RSVUUgOiBJREJfRkFMU0U7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YVtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgY2xvbmVbc2FmZUtleV0gPSByZXdyaXRlKGRhdGFba2V5XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb25lW3NhZmVLZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNsb25lO1xufVxuXG52YXIgRE9DX1NUT1JFID0gJ2RvY3MnO1xudmFyIE1FVEFfU1RPUkUgPSAnbWV0YSc7XG5cbmZ1bmN0aW9uIGlkYkVycm9yKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAndW5rbm93bl9lcnJvcic7XG4gICAgaWYgKGV2dC50YXJnZXQgJiYgZXZ0LnRhcmdldC5lcnJvcikge1xuICAgICAgbWVzc2FnZSA9IGV2dC50YXJnZXQuZXJyb3IubmFtZSB8fCBldnQudGFyZ2V0LmVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGNhbGxiYWNrKGNyZWF0ZUVycm9yKElEQl9FUlJPUiwgbWVzc2FnZSwgZXZ0LnR5cGUpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dGFjaG1lbnQobmFtZSwgc3JjLCBkb2MsIGlzQmluYXJ5KSB7XG5cbiAgZGVsZXRlIGRvYy5fYXR0YWNobWVudHNbbmFtZV0uc3R1YjtcblxuICBpZiAoaXNCaW5hcnkpIHtcbiAgICBkb2MuX2F0dGFjaG1lbnRzW25hbWVdLmRhdGEgPVxuICAgICAgc3JjLmF0dGFjaG1lbnRzW2RvYy5fYXR0YWNobWVudHNbbmFtZV0uZGlnZXN0XS5kYXRhO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgIHZhciBkYXRhID0gc3JjLmF0dGFjaG1lbnRzW2RvYy5fYXR0YWNobWVudHNbbmFtZV0uZGlnZXN0XS5kYXRhO1xuICAgIHJlYWRBc0JpbmFyeVN0cmluZyhkYXRhLCBmdW5jdGlvbiAoYmluU3RyaW5nKSB7XG4gICAgICBkb2MuX2F0dGFjaG1lbnRzW25hbWVdLmRhdGEgPSBidG9hKGJpblN0cmluZyk7XG4gICAgICBkZWxldGUgZG9jLl9hdHRhY2htZW50c1tuYW1lXS5sZW5ndGg7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByYXdJbmRleEZpZWxkcyhkZG9jLCB2aWV3TmFtZSkge1xuICAvLyBmaWVsZHMgYXJlIGFuIGFycmF5IG9mIGVpdGhlciB0aGUgc3RyaW5nIG5hbWUgb2YgdGhlIGZpZWxkLCBvciBhIGtleSB2YWx1ZVxuICB2YXIgZmllbGRzID0gZGRvYy52aWV3c1t2aWV3TmFtZV0ub3B0aW9ucyAmJlxuICAgICAgICAgICAgICAgZGRvYy52aWV3c1t2aWV3TmFtZV0ub3B0aW9ucy5kZWYgJiZcbiAgICAgICAgICAgICAgIGRkb2Mudmlld3Nbdmlld05hbWVdLm9wdGlvbnMuZGVmLmZpZWxkcyB8fCBbXTtcblxuICAvLyBFaXRoZXIgWydmb28nXSBvciBbeydmb28nOiAnZGVzYyd9XVxuICByZXR1cm4gZmllbGRzLm1hcChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZmllbGQpWzBdO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG5hdHVyYWxJbmRleE5hbWUoZmllbGRzKSB7XG4gIHJldHVybiAnX2ZpbmRfaWR4LycgKyBmaWVsZHMuam9pbignLycpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGZpZWxkcyB0aGUgdXNlciBnYXZlIHVzIGluIHRoZSB2aWV3IGFuZCBjb252ZXJ0IHRoZW0gdG8gd29yayBmb3JcbiAqIGluZGV4ZWRkYi5cbiAqXG4gKiBmaWVsZHMgaXMgYW4gYXJyYXkgb2YgZmllbGQgc3RyaW5ncy4gQSBmaWVsZCBzdHJpbmcgY291bGQgYmUgb25lIGZpZWxkOlxuICogICAnZm9vJ1xuICogT3IgaXQgY291bGQgYmUgYSBqc29uIHBhdGg6XG4gKiAgICdmb28uYmFyJ1xuICovXG5mdW5jdGlvbiBjb3JyZWN0SW5kZXhGaWVsZHMoZmllbGRzKSB7XG4gIC8vIEV2ZXJ5IGluZGV4IGhhcyB0byBoYXZlIGRlbGV0ZWQgYXQgdGhlIGZyb250LCBiZWNhdXNlIHdoZW4gd2UgZG8gYSBxdWVyeVxuICAvLyB3ZSBuZWVkIHRvIGZpbHRlciBvdXQgZGVsZXRlZCBkb2N1bWVudHMuXG4gIHJldHVybiBbJ2RlbGV0ZWQnXS5jb25jYXQoXG4gICAgZmllbGRzLm1hcChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIGlmIChmaWVsZCBpbiBbJ19pZCcsICdfcmV2JywgJ19kZWxldGVkJywgJ19hdHRhY2htZW50cyddKSB7XG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgYXJlIHN0b3JlZCBhdCB0aGUgdG9wIGxldmVsIHdpdGhvdXQgdGhlIHVuZGVyc2NvcmVcbiAgICAgICAgcmV0dXJuIGZpZWxkLnN1YnN0cigxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBjdXN0b20gZG9jdW1lbnQgZmllbGRzIGFyZSBpbnNpZGUgdGhlIGBkYXRhYCBwcm9wZXJ0eVxuICAgICAgICByZXR1cm4gJ2RhdGEuJyArIHNhbml0aXNlKGZpZWxkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuXG4vL1xuLy8gQ29yZSBQb3VjaERCIHNjaGVtYSB2ZXJzaW9uLiBJbmNyZW1lbnQgdGhpcyBpZiB3ZSwgYXMgYSBsaWJyYXJ5LCB3YW50IHRvIG1ha2Vcbi8vIHNjaGVtYSBjaGFuZ2VzIGluIGluZGV4ZWRkYi4gU2VlIHVwZ3JhZGVQb3VjaERiU2NoZW1hKClcbi8vXG52YXIgUE9VQ0hEQl9JREJfVkVSU0lPTiA9IDE7XG5cbi8vXG4vLyBGdW5jdGlvbnMgdGhhdCBtYW5hZ2UgYSBjb21iaW5hdGUgaW5kZXhlZGRiIHZlcnNpb24sIGJ5IGNvbWJpbmluZyB0aGUgY3VycmVudFxuLy8gdGltZSBpbiBtaWxsaXMgdGhhdCByZXByZXNlbnRzIHVzZXIgbWlncmF0aW9ucyB3aXRoIGEgbGFyZ2UgbXVsdGlwbGllciB0aGF0XG4vLyByZXByZXNlbnRzIFBvdWNoREIgc3lzdGVtIG1pZ3JhdGlvbnMuXG4vL1xuLy8gVGhpcyBsZXRzIHVzIHVzZSB0aGUgaWRiIHZlcnNpb24gbnVtYmVyIHRvIGJvdGggcmVwcmVzZW50XG4vLyBQb3VjaERCLWxpYnJhcnktbGV2ZWwgbWlncmF0aW9ucyBhcyB3ZWxsIGFzIFwidXNlciBtaWdyYXRpb25zXCIgcmVxdWlyZWQgZm9yXG4vLyB3aGVuIGRlc2lnbiBkb2N1bWVudHMgdHJpZ2dlciB0aGUgYWRkaXRpb24gb3IgcmVtb3ZhbCBvZiBuYXRpdmUgaW5kZXhlcy5cbi8vXG4vLyBHaXZlbiB0aGF0IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MVxuLy9cbi8vIFdlIGNhbiBlYXNpbHkgdXNlIHRoZSBsYXJnZXN0IDItMyBkaWdpdHMgYW5kIGVpdGhlciBhbGxvdzpcbi8vICAtIDkwMCBzeXN0ZW0gbWlncmF0aW9ucyB1cCB0byAyMTk4LzAyLzE4XG4vLyAgLSBvciA4OSBzeXN0ZW0gbWlncmF0aW9ucyB1cCB0byA1MDUwLzAyLzE0XG4vL1xuLy8gVGhpcyBpbXBsIGRvZXMgdGhlIGZvcm1lci4gSWYgdGhpcyBjb2RlIHN0aWxsIGV4aXN0cyBhZnRlciAyMTk4IHNvbWVvbmUgc2VuZCBteVxuLy8gZGVjZW5kZW50cyBhIFNwYWNlYm9vayBtZXNzYWdlIGNvbmdyYXR1bGF0aW5nIHRoZW0gb24gdGhlaXIgaW1wcmVzc2l2ZSBnZW5lcy5cbi8vXG4vLyA5MDA3MTk5MjU0NzQwOTkxIDwtIE1BWF9TQUZFX0lOVEVHRVJcbi8vICAgMTAwMDAwMDAwMDAwMDAgPC0gMTBeMTNcbi8vICAgIDcxOTkyNTQ3NDA5OTEgPC0gMjE5OC0wMi0xOFQxNjo1OTowMC45OTFaXG4vL1xudmFyIHZlcnNpb25NdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIDEzKTtcbmZ1bmN0aW9uIGNyZWF0ZUlkYlZlcnNpb24oKSB7XG4gIHJldHVybiAodmVyc2lvbk11bHRpcGxpZXIgKiBQT1VDSERCX0lEQl9WRVJTSU9OKSArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuZnVuY3Rpb24gZ2V0UG91Y2hEYlZlcnNpb24odmVyc2lvbikge1xuICByZXR1cm4gTWF0aC5mbG9vcih2ZXJzaW9uIC8gdmVyc2lvbk11bHRpcGxpZXIpO1xufVxuXG5mdW5jdGlvbiBtYWludGFpbk5hdGl2ZUluZGV4ZXMob3BlblJlcSwgcmVqZWN0KSB7XG4gIHZhciBkb2NTdG9yZSA9IG9wZW5SZXEudHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKTtcbiAgdmFyIGRkb2NzUmVxID0gZG9jU3RvcmUuZ2V0QWxsKElEQktleVJhbmdlLmJvdW5kKCdfZGVzaWduLycsICdfZGVzaWduL1xcdWZmZmYnKSk7XG5cbiAgZGRvY3NSZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgcmVzdWx0cyA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICB2YXIgZXhpc3RpbmdJbmRleE5hbWVzID0gQXJyYXkuZnJvbShkb2NTdG9yZS5pbmRleE5hbWVzKTtcblxuICAgIC8vIE5COiB0aGUgb25seSB0aGluZyB3ZSdyZSBzdXBwb3J0aW5nIGhlcmUgaXMgdGhlIGRlY2xhcmVkIGluZGV4aW5nXG4gICAgLy8gZmllbGRzIG5vdGhpbmcgbW9yZS5cbiAgICB2YXIgZXhwZWN0ZWRJbmRleGVzID0gcmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykge1xuICAgICAgcmV0dXJuIHJvdy5kZWxldGVkID09PSAwICYmIHJvdy5yZXZzW3Jvdy5yZXZdLmRhdGEudmlld3M7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHJldHVybiByb3cucmV2c1tyb3cucmV2XS5kYXRhO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoaW5kZXhlcywgZGRvYykge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGRkb2Mudmlld3MpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2aWV3TmFtZSkge1xuICAgICAgICB2YXIgZmllbGRzID0gcmF3SW5kZXhGaWVsZHMoZGRvYywgdmlld05hbWUpO1xuXG4gICAgICAgIGlmIChmaWVsZHMgJiYgZmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhY2NbbmF0dXJhbEluZGV4TmFtZShmaWVsZHMpXSA9IGNvcnJlY3RJbmRleEZpZWxkcyhmaWVsZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIGluZGV4ZXMpO1xuICAgIH0sIHt9KTtcblxuICAgIHZhciBleHBlY3RlZEluZGV4TmFtZXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZEluZGV4ZXMpO1xuXG4gICAgLy8gRGVsZXRlIGFueSBpbmRleGVzIHRoYXQgYXJlbid0IHN5c3RlbSBpbmRleGVzIG9yIGV4cGVjdGVkXG4gICAgdmFyIHN5c3RlbUluZGV4TmFtZXMgPSBbJ3NlcSddO1xuICAgIGV4aXN0aW5nSW5kZXhOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgaWYgKHN5c3RlbUluZGV4TmFtZXMuaW5kZXhPZihpbmRleCkgPT09IC0xICAmJiBleHBlY3RlZEluZGV4TmFtZXMuaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICAgIGRvY1N0b3JlLmRlbGV0ZUluZGV4KGluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFdvcmsgb3V0IHdoaWNoIGluZGV4ZXMgYXJlIG1pc3NpbmcgYW5kIGNyZWF0ZSB0aGVtXG4gICAgdmFyIG5ld0luZGV4TmFtZXMgPSBleHBlY3RlZEluZGV4TmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChlaSkge1xuICAgICAgcmV0dXJuIGV4aXN0aW5nSW5kZXhOYW1lcy5pbmRleE9mKGVpKSA9PT0gLTE7XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgbmV3SW5kZXhOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleE5hbWUpIHtcbiAgICAgICAgZG9jU3RvcmUuY3JlYXRlSW5kZXgoaW5kZXhOYW1lLCBleHBlY3RlZEluZGV4ZXNbaW5kZXhOYW1lXSk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBncmFkZVBvdWNoRGJTY2hlbWEoZGIsIHBvdWNoZGJWZXJzaW9uKSB7XG4gIGlmIChwb3VjaGRiVmVyc2lvbiA8IDEpIHtcbiAgICB2YXIgZG9jU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShET0NfU1RPUkUsIHtrZXlQYXRoIDogJ2lkJ30pO1xuICAgIGRvY1N0b3JlLmNyZWF0ZUluZGV4KCdzZXEnLCAnc2VxJywge3VuaXF1ZTogdHJ1ZX0pO1xuXG4gICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoTUVUQV9TVE9SRSwge2tleVBhdGg6ICdpZCd9KTtcbiAgfVxuXG4gIC8vIERlY2xhcmUgbW9yZSBQb3VjaERCIHNjaGVtYSBjaGFuZ2VzIGhlcmVcbiAgLy8gaWYgKHBvdWNoZGJWZXJzaW9uIDwgMikgeyAuLiB9XG59XG5cbmZ1bmN0aW9uIG9wZW5EYXRhYmFzZShvcGVuRGF0YWJhc2VzLCBhcGksIG9wdHMsIHJlc29sdmUsIHJlamVjdCkge1xuICB2YXIgb3BlblJlcSA9IG9wdHMudmVyc2lvbmNoYW5nZWQgP1xuICAgIGluZGV4ZWREQi5vcGVuKG9wdHMubmFtZSkgOlxuICAgIGluZGV4ZWREQi5vcGVuKG9wdHMubmFtZSwgY3JlYXRlSWRiVmVyc2lvbigpKTtcblxuICBvcGVuUmVxLm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUub2xkVmVyc2lvbiA+IDAgJiYgZS5vbGRWZXJzaW9uIDwgdmVyc2lvbk11bHRpcGxpZXIpIHtcbiAgICAgIC8vIFRoaXMgREIgd2FzIGNyZWF0ZWQgd2l0aCB0aGUgXCJpZGJcIiBhZGFwdGVyLCAqKm5vdCoqIHRoaXMgb25lLlxuICAgICAgLy8gRm9yIG5vdyB3ZSdyZSBnb2luZyB0byBqdXN0IGVycm9yIG91dCBoZXJlOiB1c2VycyBtdXN0IG1hbnVhbGx5XG4gICAgICAvLyBtaWdyYXRlIGJldHdlZW4gdGhlIHR3by4gSW4gdGhlIGZ1dHVyZSwgZGVwZW5kZW50IG9uIHBlcmZvcm1hbmNlIHRlc3RzLFxuICAgICAgLy8gd2UgbWlnaHQgc2lsZW50bHkgbWlncmF0ZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgYWRhcHRlcjogeW91IHNob3VsZCBzcGVjaWZ5IHRoZSBcImlkYlwiIGFkYXB0ZXIgdG8gb3BlbiB0aGlzIERCJyk7XG4gICAgfVxuXG4gICAgdmFyIGRiID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgdmFyIHBvdWNoZGJWZXJzaW9uID0gZ2V0UG91Y2hEYlZlcnNpb24oZS5vbGRWZXJzaW9uKTtcbiAgICB1cGdyYWRlUG91Y2hEYlNjaGVtYShkYiwgcG91Y2hkYlZlcnNpb24pO1xuICAgIG1haW50YWluTmF0aXZlSW5kZXhlcyhvcGVuUmVxLCByZWplY3QpO1xuICB9O1xuXG4gIG9wZW5SZXEub25ibG9ja2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIEFGQUlDVCB0aGlzIG9ubHkgb2NjdXJzIGlmLCBhZnRlciBzZW5kaW5nIGBvbnZlcnNpb25jaGFuZ2VgIGV2ZW50cyB0b1xuICAgICAgLy8gYWxsIG90aGVyIG9wZW4gREJzIChpZSBpbiBkaWZmZXJlbnQgdGFicyksIHRoZXJlIGFyZSBzdGlsbCBvcGVuXG4gICAgICAvLyBjb25uZWN0aW9ucyB0byB0aGUgREIuIEluIHRoaXMgY29kZSB3ZSBzaG91bGQgbmV2ZXIgc2VlIHRoaXMgYmVjYXVzZSB3ZVxuICAgICAgLy8gY2xvc2Ugb3VyIERCcyBvbiB0aGVzZSBldmVudHMsIGFuZCBhbGwgREIgaW50ZXJhY3Rpb25zIGFyZSB3cmFwcGVkIGluXG4gICAgICAvLyBzYWZlbHkgcmUtb3BlbmluZyB0aGUgREIuXG4gICAgICBjb25zb2xlLmVycm9yKCdvbmJsb2NrZWQsIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbicsIGUpO1xuICB9O1xuXG4gIG9wZW5SZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaWRiID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgaWRiLm9uYWJvcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRGF0YWJhc2UgaGFzIGEgZ2xvYmFsIGZhaWx1cmUnLCBlLnRhcmdldC5lcnJvcik7XG4gICAgICBkZWxldGUgb3BlbkRhdGFiYXNlc1tvcHRzLm5hbWVdO1xuICAgICAgaWRiLmNsb3NlKCk7XG4gICAgfTtcblxuICAgIGlkYi5vbnZlcnNpb25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zb2xlLmxvZygnRGF0YWJhc2Ugd2FzIG1hZGUgc3RhbGUsIGNsb3NpbmcgaGFuZGxlJyk7XG4gICAgICBvcGVuRGF0YWJhc2VzW29wdHMubmFtZV0udmVyc2lvbmNoYW5nZWQgPSB0cnVlO1xuICAgICAgaWRiLmNsb3NlKCk7XG4gICAgfTtcblxuICAgIHZhciBtZXRhZGF0YSA9IHtpZDogTUVUQV9TVE9SRX07XG4gICAgdmFyIHR4biA9IGlkYi50cmFuc2FjdGlvbihbTUVUQV9TVE9SRV0sICdyZWFkd3JpdGUnKTtcblxuICAgIHR4bi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVzb2x2ZSh7aWRiOiBpZGIsIG1ldGFkYXRhOiBtZXRhZGF0YX0pO1xuICAgIH07XG5cbiAgICB2YXIgbWV0YVN0b3JlID0gdHhuLm9iamVjdFN0b3JlKE1FVEFfU1RPUkUpO1xuICAgIG1ldGFTdG9yZS5nZXQoTUVUQV9TVE9SRSkub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIG1ldGFkYXRhID0gZS50YXJnZXQucmVzdWx0IHx8IG1ldGFkYXRhO1xuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKCEoJ2RvY19jb3VudCcgaW4gbWV0YWRhdGEpKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICBtZXRhZGF0YS5kb2NfY291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoISgnc2VxJyBpbiBtZXRhZGF0YSkpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIG1ldGFkYXRhLnNlcSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghKCdkYl91dWlkJyBpbiBtZXRhZGF0YSkpIHtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIG1ldGFkYXRhLmRiX3V1aWQgPSB1dWlkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIG1ldGFTdG9yZS5wdXQobWV0YWRhdGEpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgb3BlblJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICByZWplY3QoZS50YXJnZXQuZXJyb3IpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZXR1cCAob3BlbkRhdGFiYXNlcywgYXBpLCBvcHRzKSB7XG4gIGlmICghb3BlbkRhdGFiYXNlc1tvcHRzLm5hbWVdIHx8IG9wZW5EYXRhYmFzZXNbb3B0cy5uYW1lXS52ZXJzaW9uY2hhbmdlZCkge1xuICAgIG9wdHMudmVyc2lvbmNoYW5nZWQgPSBvcGVuRGF0YWJhc2VzW29wdHMubmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlbkRhdGFiYXNlc1tvcHRzLm5hbWVdLnZlcnNpb25jaGFuZ2VkO1xuXG4gICAgb3BlbkRhdGFiYXNlc1tvcHRzLm5hbWVdID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgb3BlbkRhdGFiYXNlKG9wZW5EYXRhYmFzZXMsIGFwaSwgb3B0cywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvcGVuRGF0YWJhc2VzW29wdHMubmFtZV07XG59XG5cbmZ1bmN0aW9uIGluZm8gKG1ldGFkYXRhLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhudWxsLCB7XG4gICAgZG9jX2NvdW50OiBtZXRhZGF0YS5kb2NfY291bnQsXG4gICAgdXBkYXRlX3NlcTogbWV0YWRhdGEuc2VxXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXQgKHR4biwgaWQsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eG4uZXJyb3IpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sodHhuLmVycm9yKTtcbiAgfVxuXG4gIHR4bi50eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5nZXQoaWQpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRvYyA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICB2YXIgcmV2O1xuICAgIGlmICghb3B0cy5yZXYpIHtcbiAgICAgIHJldiA9IChkb2MgJiYgZG9jLnJldik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldiA9IG9wdHMubGF0ZXN0ID8gbGF0ZXN0KG9wdHMucmV2LCBkb2MpIDogb3B0cy5yZXY7XG4gICAgfVxuXG4gICAgaWYgKCFkb2MgfHwgKGRvYy5kZWxldGVkICYmICFvcHRzLnJldikgfHwgIShyZXYgaW4gZG9jLnJldnMpKSB7XG4gICAgICBjYWxsYmFjayhjcmVhdGVFcnJvcihNSVNTSU5HX0RPQywgJ21pc3NpbmcnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IGRvYy5yZXZzW3Jldl0uZGF0YTtcbiAgICByZXN1bHQuX2lkID0gZG9jLmlkO1xuICAgIHJlc3VsdC5fcmV2ID0gcmV2O1xuXG4gICAgLy8gV0FSTklORzogZXhwZWN0aW5nIHBvc3NpYmxlIG9sZCBmb3JtYXRcbiAgICAvLyBUT0RPOiB3aHkgYXJlIHdlIHBhc3NpbmcgdGhlIHRyYW5zYWN0aW9uIGluIHRoZSBjb250ZXh0P1xuICAgIC8vICAgICAgIEl0J3Mgbm90IGNsZWFyIHdlIGV2ZXIgdGhyZWFkIHRoZXNlIHR4bnMgdXNlZnVsbHlcbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICBkb2M6IHJlc3VsdCxcbiAgICAgIG1ldGFkYXRhOiBkb2MsXG4gICAgICBjdHg6IHR4blxuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUF0dGFjaG1lbnQoYXR0YWNobWVudCwgb3B0cywgY2IpIHtcbiAgaWYgKG9wdHMuYmluYXJ5KSB7XG4gICAgcmV0dXJuIGNiKG51bGwsIGF0dGFjaG1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHJlYWRBc0JpbmFyeVN0cmluZyhhdHRhY2htZW50LCBmdW5jdGlvbiAoYmluU3RyaW5nKSB7XG4gICAgICBjYihudWxsLCBidG9hKGJpblN0cmluZykpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEF0dGFjaG1lbnQodHhuLCBkb2NJZCwgYXR0YWNoSWQsIF8sIG9wdHMsIGNiKSB7XG4gIGlmICh0eG4uZXJyb3IpIHtcbiAgICByZXR1cm4gY2IodHhuLmVycm9yKTtcbiAgfVxuXG4gIHZhciBhdHRhY2htZW50O1xuXG4gIHR4bi50eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5nZXQoZG9jSWQpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRvYyA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICB2YXIgcmV2ID0gZG9jLnJldnNbb3B0cy5yZXYgfHwgZG9jLnJldl0uZGF0YTtcbiAgICB2YXIgZGlnZXN0ID0gcmV2Ll9hdHRhY2htZW50c1thdHRhY2hJZF0uZGlnZXN0O1xuICAgIGF0dGFjaG1lbnQgPSBkb2MuYXR0YWNobWVudHNbZGlnZXN0XS5kYXRhO1xuICB9O1xuXG4gIHR4bi50eG4ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwYXJzZUF0dGFjaG1lbnQoYXR0YWNobWVudCwgb3B0cywgY2IpO1xuICB9O1xuXG4gIHR4bi50eG4ub25hYm9ydCA9IGNiO1xufVxuXG5mdW5jdGlvbiBidWxrRG9jcyAoYXBpLCByZXEsIG9wdHMsIG1ldGFkYXRhLCBkYk9wdHMsIGlkYkNoYW5nZXMsIGNhbGxiYWNrKSB7XG5cbiAgdmFyIHR4bjtcblxuICAvLyBUT0RPOiBJIHdvdWxkIHByZWZlciB0byBnZXQgcmlkIG9mIHRoZXNlIGdsb2JhbHNcbiAgdmFyIGVycm9yO1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgZG9jcyA9IFtdO1xuICB2YXIgbGFzdFdyaXRlSW5kZXg7XG5cbiAgdmFyIHJldnNMaW1pdCA9IGRiT3B0cy5yZXZzX2xpbWl0IHx8IDEwMDA7XG4gIHZhciByZXdyaXRlRW5hYmxlZCA9IGRiT3B0cy5uYW1lLmluZGV4T2YoXCItbXJ2aWV3LVwiKSA9PT0gLTE7XG5cbiAgLy8gV2Ugb25seSBuZWVkIHRvIHRyYWNrIDEgcmV2aXNpb24gZm9yIGxvY2FsIGRvY3VtZW50c1xuICBmdW5jdGlvbiBkb2NzUmV2c0xpbWl0KGRvYykge1xuICAgIHJldHVybiAvXl9sb2NhbC8udGVzdChkb2MuaWQpID8gMSA6IHJldnNMaW1pdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJvb3RJc01pc3NpbmcoZG9jKSB7XG4gICAgcmV0dXJuIGRvYy5yZXZfdHJlZVswXS5pZHNbMV0uc3RhdHVzID09PSAnbWlzc2luZyc7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUJhc2U2NChkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhdG9iKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcihCQURfQVJHLCAnQXR0YWNobWVudCBpcyBub3QgYSB2YWxpZCBiYXNlNjQgc3RyaW5nJylcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhZHMgdGhlIG9yaWdpbmFsIGRvYyBmcm9tIHRoZSBzdG9yZSBpZiBhdmFpbGFibGVcbiAgLy8gQXMgaW4gYWxsRG9jcyB3aXRoIGtleXMgb3B0aW9uIHVzaW5nIG11bHRpcGxlIGdldCBjYWxscyBpcyB0aGUgZmFzdGVzdCB3YXlcbiAgZnVuY3Rpb24gZmV0Y2hFeGlzdGluZ0RvY3ModHhuLCBkb2NzKSB7XG4gICAgdmFyIGZldGNoZWQgPSAwO1xuICAgIHZhciBvbGREb2NzID0ge307XG5cbiAgICBmdW5jdGlvbiByZWFkRG9uZShlKSB7XG4gICAgICBpZiAoZS50YXJnZXQucmVzdWx0KSB7XG4gICAgICAgIG9sZERvY3NbZS50YXJnZXQucmVzdWx0LmlkXSA9IGUudGFyZ2V0LnJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmICgrK2ZldGNoZWQgPT09IGRvY3MubGVuZ3RoKSB7XG4gICAgICAgIHByb2Nlc3NEb2NzKHR4biwgZG9jcywgb2xkRG9jcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZG9jcy5mb3JFYWNoKGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgIHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLmdldChkb2MuaWQpLm9uc3VjY2VzcyA9IHJlYWREb25lO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0RvY3ModHhuLCBkb2NzLCBvbGREb2NzKSB7XG5cbiAgICBkb2NzLmZvckVhY2goZnVuY3Rpb24gKGRvYywgaSkge1xuICAgICAgdmFyIG5ld0RvYztcblxuICAgICAgLy8gVGhlIGZpcnN0IGRvY3VtZW50IHdyaXRlIGNhbm5vdCBiZSBhIGRlbGV0aW9uXG4gICAgICBpZiAoJ3dhc19kZWxldGUnIGluIG9wdHMgJiYgIShvbGREb2NzLmhhc093blByb3BlcnR5KGRvYy5pZCkpKSB7XG4gICAgICAgIG5ld0RvYyA9IGNyZWF0ZUVycm9yKE1JU1NJTkdfRE9DLCAnZGVsZXRlZCcpO1xuXG4gICAgICAvLyBUaGUgZmlyc3Qgd3JpdGUgb2YgYSBkb2N1bWVudCBjYW5ub3Qgc3BlY2lmeSBhIHJldmlzaW9uXG4gICAgICB9IGVsc2UgaWYgKG9wdHMubmV3X2VkaXRzICYmXG4gICAgICAgICAgICAgICAgICFvbGREb2NzLmhhc093blByb3BlcnR5KGRvYy5pZCkgJiZcbiAgICAgICAgICAgICAgICAgcm9vdElzTWlzc2luZyhkb2MpKSB7XG4gICAgICAgIG5ld0RvYyA9IGNyZWF0ZUVycm9yKFJFVl9DT05GTElDVCk7XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgZG9jdW1lbnRcbiAgICAgIH0gZWxzZSBpZiAob2xkRG9jcy5oYXNPd25Qcm9wZXJ0eShkb2MuaWQpKSB7XG4gICAgICAgIG5ld0RvYyA9IHVwZGF0ZSh0eG4sIGRvYywgb2xkRG9jc1tkb2MuaWRdKTtcbiAgICAgICAgLy8gVGhlIHVwZGF0ZSBjYW4gYmUgcmVqZWN0ZWQgaWYgaXQgaXMgYW4gdXBkYXRlIHRvIGFuIGV4aXN0aW5nXG4gICAgICAgIC8vIHJldmlzaW9uLCBpZiBzbyBza2lwIGl0XG4gICAgICAgIGlmIChuZXdEb2MgPT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgLy8gTmV3IGRvY3VtZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbnN1cmUgbmV3IGRvY3VtZW50cyBhcmUgYWxzbyBzdGVtbWVkXG4gICAgICAgIHZhciBtZXJnZWQgPSBtZXJnZShbXSwgZG9jLnJldl90cmVlWzBdLCBkb2NzUmV2c0xpbWl0KGRvYykpO1xuICAgICAgICBkb2MucmV2X3RyZWUgPSBtZXJnZWQudHJlZTtcbiAgICAgICAgZG9jLnN0ZW1tZWRSZXZzID0gbWVyZ2VkLnN0ZW1tZWRSZXZzO1xuICAgICAgICBuZXdEb2MgPSBkb2M7XG4gICAgICAgIG5ld0RvYy5pc05ld0RvYyA9IHRydWU7XG4gICAgICAgIG5ld0RvYy53YXNEZWxldGVkID0gZG9jLnJldnNbZG9jLnJldl0uZGVsZXRlZCA/IDEgOiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3RG9jLmVycm9yKSB7XG4gICAgICAgIHJlc3VsdHNbaV0gPSBuZXdEb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGREb2NzW25ld0RvYy5pZF0gPSBuZXdEb2M7XG4gICAgICAgIGxhc3RXcml0ZUluZGV4ID0gaTtcbiAgICAgICAgd3JpdGUodHhuLCBuZXdEb2MsIGkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gQ29udmVydHMgZnJvbSB0aGUgZm9ybWF0IHJldHVybmVkIGJ5IHBhcnNlRG9jIGludG8gdGhlIG5ldyBmb3JtYXRcbiAgLy8gd2UgdXNlIHRvIHN0b3JlXG4gIGZ1bmN0aW9uIGNvbnZlcnREb2NGb3JtYXQoZG9jKSB7XG5cbiAgICB2YXIgbmV3RG9jID0ge1xuICAgICAgaWQ6IGRvYy5tZXRhZGF0YS5pZCxcbiAgICAgIHJldjogZG9jLm1ldGFkYXRhLnJldixcbiAgICAgIHJldl90cmVlOiBkb2MubWV0YWRhdGEucmV2X3RyZWUsXG4gICAgICByZXZzOiBkb2MubWV0YWRhdGEucmV2cyB8fCB7fVxuICAgIH07XG5cbiAgICBuZXdEb2MucmV2c1tuZXdEb2MucmV2XSA9IHtcbiAgICAgIGRhdGE6IGRvYy5kYXRhLFxuICAgICAgZGVsZXRlZDogZG9jLm1ldGFkYXRhLmRlbGV0ZWRcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ld0RvYztcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZSh0eG4sIGRvYywgb2xkRG9jKSB7XG5cbiAgICAvLyBJZ25vcmUgdXBkYXRlcyB0byBleGlzdGluZyByZXZpc2lvbnNcbiAgICBpZiAoKGRvYy5yZXYgaW4gb2xkRG9jLnJldnMpICYmICFvcHRzLm5ld19lZGl0cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpc1Jvb3QgPSAvXjEtLy50ZXN0KGRvYy5yZXYpO1xuXG4gICAgLy8gUmVhdHRhY2ggZmlyc3Qgd3JpdGVzIGFmdGVyIGEgZGVsZXRpb24gdG8gbGFzdCBkZWxldGVkIHRyZWVcbiAgICBpZiAob2xkRG9jLmRlbGV0ZWQgJiYgIWRvYy5kZWxldGVkICYmIG9wdHMubmV3X2VkaXRzICYmIGlzUm9vdCkge1xuICAgICAgdmFyIHRtcCA9IGRvYy5yZXZzW2RvYy5yZXZdLmRhdGE7XG4gICAgICB0bXAuX3JldiA9IG9sZERvYy5yZXY7XG4gICAgICB0bXAuX2lkID0gb2xkRG9jLmlkO1xuICAgICAgZG9jID0gY29udmVydERvY0Zvcm1hdChwYXJzZURvYyh0bXAsIG9wdHMubmV3X2VkaXRzLCBkYk9wdHMpKTtcbiAgICB9XG5cbiAgICB2YXIgbWVyZ2VkID0gbWVyZ2Uob2xkRG9jLnJldl90cmVlLCBkb2MucmV2X3RyZWVbMF0sIGRvY3NSZXZzTGltaXQoZG9jKSk7XG4gICAgZG9jLnN0ZW1tZWRSZXZzID0gbWVyZ2VkLnN0ZW1tZWRSZXZzO1xuICAgIGRvYy5yZXZfdHJlZSA9IG1lcmdlZC50cmVlO1xuXG4gICAgLy8gTWVyZ2UgdGhlIG9sZCBhbmQgbmV3IHJldiBkYXRhXG4gICAgdmFyIHJldnMgPSBvbGREb2MucmV2cztcbiAgICByZXZzW2RvYy5yZXZdID0gZG9jLnJldnNbZG9jLnJldl07XG4gICAgZG9jLnJldnMgPSByZXZzO1xuXG4gICAgZG9jLmF0dGFjaG1lbnRzID0gb2xkRG9jLmF0dGFjaG1lbnRzO1xuXG4gICAgdmFyIGluQ29uZmxpY3QgPSBvcHRzLm5ld19lZGl0cyAmJiAoKChvbGREb2MuZGVsZXRlZCAmJiBkb2MuZGVsZXRlZCkgfHxcbiAgICAgICAoIW9sZERvYy5kZWxldGVkICYmIG1lcmdlZC5jb25mbGljdHMgIT09ICduZXdfbGVhZicpIHx8XG4gICAgICAgKG9sZERvYy5kZWxldGVkICYmICFkb2MuZGVsZXRlZCAmJiBtZXJnZWQuY29uZmxpY3RzID09PSAnbmV3X2JyYW5jaCcpIHx8XG4gICAgICAgKG9sZERvYy5yZXYgPT09IGRvYy5yZXYpKSk7XG5cbiAgICBpZiAoaW5Db25mbGljdCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVycm9yKFJFVl9DT05GTElDVCk7XG4gICAgfVxuXG4gICAgZG9jLndhc0RlbGV0ZWQgPSBvbGREb2MuZGVsZXRlZDtcblxuICAgIHJldHVybiBkb2M7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZSh0eG4sIGRvYywgaSkge1xuXG4gICAgLy8gV2UgY29weSB0aGUgZGF0YSBmcm9tIHRoZSB3aW5uaW5nIHJldmlzaW9uIGludG8gdGhlIHJvb3RcbiAgICAvLyBvZiB0aGUgZG9jdW1lbnQgc28gdGhhdCBpdCBjYW4gYmUgaW5kZXhlZFxuICAgIHZhciB3aW5uaW5nUmV2JCQxID0gd2lubmluZ1Jldihkb2MpO1xuICAgIC8vIHJldiBvZiBuZXcgZG9jIGZvciBhdHRhY2htZW50cyBhbmQgdG8gcmV0dXJuIGl0XG4gICAgdmFyIHdyaXR0ZW5SZXYgPSBkb2MucmV2O1xuICAgIHZhciBpc0xvY2FsID0gL15fbG9jYWwvLnRlc3QoZG9jLmlkKTtcblxuICAgIHZhciB0aGVEb2MgPSBkb2MucmV2c1t3aW5uaW5nUmV2JCQxXS5kYXRhO1xuXG4gICAgaWYgKHJld3JpdGVFbmFibGVkKSB7XG4gICAgICAvLyBkb2MuZGF0YSBpcyB3aGF0IHdlIGluZGV4LCBzbyB3ZSBuZWVkIHRvIGNsb25lIGFuZCByZXdyaXRlIGl0LCBhbmQgY2xlYW5cbiAgICAgIC8vIGl0IHVwIGZvciBpbmRleGFiaWxpdHlcbiAgICAgIHZhciByZXN1bHQgPSByZXdyaXRlKHRoZURvYyk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGRvYy5kYXRhID0gcmVzdWx0O1xuICAgICAgICBkZWxldGUgZG9jLmRhdGEuX2F0dGFjaG1lbnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jLmRhdGEgPSB0aGVEb2M7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvYy5kYXRhID0gdGhlRG9jO1xuICAgIH1cblxuICAgIGRvYy5yZXYgPSB3aW5uaW5nUmV2JCQxO1xuICAgIC8vIC5kZWxldGVkIG5lZWRzIHRvIGJlIGFuIGludCBmb3IgaW5kZXhpbmdcbiAgICBkb2MuZGVsZXRlZCA9IGRvYy5yZXZzW3dpbm5pbmdSZXYkJDFdLmRlbGV0ZWQgPyAxIDogMDtcblxuICAgIC8vIEJ1bXAgdGhlIHNlcSBmb3IgZXZlcnkgbmV3IChub24gbG9jYWwpIHJldmlzaW9uIHdyaXR0ZW5cbiAgICAvLyBUT0RPOiBpbmRleCBleHBlY3RzIGEgdW5pcXVlIHNlcSwgbm90IHN1cmUgaWYgaWdub3JpbmcgbG9jYWwgd2lsbFxuICAgIC8vIHdvcmtcbiAgICBpZiAoIWlzTG9jYWwpIHtcbiAgICAgIGRvYy5zZXEgPSArK21ldGFkYXRhLnNlcTtcblxuICAgICAgdmFyIGRlbHRhID0gMDtcbiAgICAgIC8vIElmIGl0cyBhIG5ldyBkb2N1bWVudCwgd2Ugd29udCBkZWNyZW1lbnQgaWYgZGVsZXRlZFxuICAgICAgaWYgKGRvYy5pc05ld0RvYykge1xuICAgICAgICBkZWx0YSA9IGRvYy5kZWxldGVkID8gMCA6IDE7XG4gICAgICB9IGVsc2UgaWYgKGRvYy53YXNEZWxldGVkICE9PSBkb2MuZGVsZXRlZCkge1xuICAgICAgICBkZWx0YSA9IGRvYy5kZWxldGVkID8gLTEgOiAxO1xuICAgICAgfVxuICAgICAgbWV0YWRhdGEuZG9jX2NvdW50ICs9IGRlbHRhO1xuICAgIH1cbiAgICBkZWxldGUgZG9jLmlzTmV3RG9jO1xuICAgIGRlbGV0ZSBkb2Mud2FzRGVsZXRlZDtcblxuICAgIC8vIElmIHRoZXJlIGhhdmUgYmVlbiByZXZpc2lvbnMgc3RlbW1lZCB3aGVuIG1lcmdpbmcgdHJlZXMsXG4gICAgLy8gZGVsZXRlIHRoZWlyIGRhdGFcbiAgICBpZiAoZG9jLnN0ZW1tZWRSZXZzKSB7XG4gICAgICBkb2Muc3RlbW1lZFJldnMuZm9yRWFjaChmdW5jdGlvbiAocmV2KSB7IGRlbGV0ZSBkb2MucmV2c1tyZXZdOyB9KTtcbiAgICB9XG4gICAgZGVsZXRlIGRvYy5zdGVtbWVkUmV2cztcblxuICAgIGlmICghKCdhdHRhY2htZW50cycgaW4gZG9jKSkge1xuICAgICAgZG9jLmF0dGFjaG1lbnRzID0ge307XG4gICAgfVxuXG4gICAgaWYgKHRoZURvYy5fYXR0YWNobWVudHMpIHtcbiAgICAgIGZvciAodmFyIGsgaW4gdGhlRG9jLl9hdHRhY2htZW50cykge1xuICAgICAgICB2YXIgYXR0YWNobWVudCA9IHRoZURvYy5fYXR0YWNobWVudHNba107XG4gICAgICAgIGlmIChhdHRhY2htZW50LnN0dWIpIHtcbiAgICAgICAgICBpZiAoIShhdHRhY2htZW50LmRpZ2VzdCBpbiBkb2MuYXR0YWNobWVudHMpKSB7XG4gICAgICAgICAgICBlcnJvciA9IGNyZWF0ZUVycm9yKE1JU1NJTkdfU1RVQik7XG4gICAgICAgICAgICAvLyBUT0RPOiBOb3Qgc3VyZSBob3cgc2FmZSB0aGlzIG1hbnVhbCBhYm9ydCBpcywgc2VlaW5nXG4gICAgICAgICAgICAvLyBjb25zb2xlIGlzc3Vlc1xuICAgICAgICAgICAgdHhuLmFib3J0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jLmF0dGFjaG1lbnRzW2F0dGFjaG1lbnQuZGlnZXN0XS5yZXZzW3dyaXR0ZW5SZXZdID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgZG9jLmF0dGFjaG1lbnRzW2F0dGFjaG1lbnQuZGlnZXN0XSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgICAgZG9jLmF0dGFjaG1lbnRzW2F0dGFjaG1lbnQuZGlnZXN0XS5yZXZzID0ge307XG4gICAgICAgICAgZG9jLmF0dGFjaG1lbnRzW2F0dGFjaG1lbnQuZGlnZXN0XS5yZXZzW3dyaXR0ZW5SZXZdID0gdHJ1ZTtcblxuICAgICAgICAgIHRoZURvYy5fYXR0YWNobWVudHNba10gPSB7XG4gICAgICAgICAgICBzdHViOiB0cnVlLFxuICAgICAgICAgICAgZGlnZXN0OiBhdHRhY2htZW50LmRpZ2VzdCxcbiAgICAgICAgICAgIGNvbnRlbnRfdHlwZTogYXR0YWNobWVudC5jb250ZW50X3R5cGUsXG4gICAgICAgICAgICBsZW5ndGg6IGF0dGFjaG1lbnQubGVuZ3RoLFxuICAgICAgICAgICAgcmV2cG9zOiBwYXJzZUludCh3cml0dGVuUmV2LCAxMClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTG9jYWwgZG9jdW1lbnRzIGhhdmUgZGlmZmVyZW50IHJldmlzaW9uIGhhbmRsaW5nXG4gICAgaWYgKGlzTG9jYWwgJiYgZG9jLmRlbGV0ZWQpIHtcbiAgICAgIHR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLmRlbGV0ZShkb2MuaWQpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICBvazogdHJ1ZSxcbiAgICAgICAgICBpZDogZG9jLmlkLFxuICAgICAgICAgIHJldjogJzAtMCdcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICB1cGRhdGVTZXEoaSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHhuLm9iamVjdFN0b3JlKERPQ19TVE9SRSkucHV0KGRvYykub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgb2s6IHRydWUsXG4gICAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAgIHJldjogd3JpdHRlblJldlxuICAgICAgfTtcbiAgICAgIHVwZGF0ZVNlcShpKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2VxKGkpIHtcbiAgICBpZiAoaSA9PT0gbGFzdFdyaXRlSW5kZXgpIHtcbiAgICAgIHR4bi5vYmplY3RTdG9yZShNRVRBX1NUT1JFKS5wdXQobWV0YWRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZVByb2Nlc3NBdHRhY2htZW50KGF0dGFjaG1lbnQpIHtcbiAgICBpZiAoYXR0YWNobWVudC5zdHViKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGF0dGFjaG1lbnQpO1xuICAgIH1cblxuICAgIHZhciBiaW5EYXRhO1xuICAgIGlmICh0eXBlb2YgYXR0YWNobWVudC5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYmluRGF0YSA9IHBhcnNlQmFzZTY0KGF0dGFjaG1lbnQuZGF0YSk7XG4gICAgICBpZiAoYmluRGF0YS5lcnJvcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoYmluRGF0YS5lcnJvcik7XG4gICAgICB9XG4gICAgICBhdHRhY2htZW50LmRhdGEgPSBiaW5hcnlTdHJpbmdUb0Jsb2JPckJ1ZmZlcihiaW5EYXRhLCBhdHRhY2htZW50LmNvbnRlbnRfdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpbkRhdGEgPSBhdHRhY2htZW50LmRhdGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBiaW5hcnlNZDUoYmluRGF0YSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBhdHRhY2htZW50LmRpZ2VzdCA9ICdtZDUtJyArIHJlc3VsdDtcbiAgICAgICAgYXR0YWNobWVudC5sZW5ndGggPSBiaW5EYXRhLnNpemUgfHwgYmluRGF0YS5sZW5ndGggfHwgMDtcbiAgICAgICAgcmVzb2x2ZShhdHRhY2htZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlUHJvY2Vzc0F0dGFjaG1lbnRzKCkge1xuICAgIHZhciBwcm9taXNlcyA9IGRvY3MubWFwKGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgIHZhciBkYXRhID0gZG9jLnJldnNbZG9jLnJldl0uZGF0YTtcbiAgICAgIGlmICghZGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBhdHRhY2htZW50cyA9IE9iamVjdC5rZXlzKGRhdGEuX2F0dGFjaG1lbnRzKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgZGF0YS5fYXR0YWNobWVudHNba10ubmFtZSA9IGs7XG4gICAgICAgIHJldHVybiBwcmVQcm9jZXNzQXR0YWNobWVudChkYXRhLl9hdHRhY2htZW50c1trXSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGF0dGFjaG1lbnRzKS50aGVuKGZ1bmN0aW9uIChuZXdBdHRhY2htZW50cykge1xuICAgICAgICB2YXIgcHJvY2Vzc2VkID0ge307XG4gICAgICAgIG5ld0F0dGFjaG1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGF0dGFjaG1lbnQpIHtcbiAgICAgICAgICBwcm9jZXNzZWRbYXR0YWNobWVudC5uYW1lXSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgICAgZGVsZXRlIGF0dGFjaG1lbnQubmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGEuX2F0dGFjaG1lbnRzID0gcHJvY2Vzc2VkO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVxLmRvY3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIC8vIFRPRE86IFdlIHNob3VsZCBnZXQgcmlkIG9mIHRocm93aW5nIGZvciBpbnZhbGlkIGRvY3MsIGFsc28gbm90IHN1cmVcbiAgICAvLyB3aHkgdGhpcyBpcyBuZWVkZWQgaW4gaWRiLW5leHQgYW5kIG5vdCBpZGJcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gcGFyc2VEb2MocmVxLmRvY3NbaV0sIG9wdHMubmV3X2VkaXRzLCBkYk9wdHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVzdWx0ID0gZXJyO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0KTtcbiAgICB9XG5cbiAgICAvLyBJZGVhbGx5IHBhcnNlRG9jIHdvdWxkIHJldHVybiBkYXRhIGluIHRoaXMgZm9ybWF0LCBidXQgaXQgaXMgY3VycmVudGx5XG4gICAgLy8gc2hhcmVkIHNvIHdlIG5lZWQgdG8gY29udmVydFxuICAgIGRvY3MucHVzaChjb252ZXJ0RG9jRm9ybWF0KHJlc3VsdCkpO1xuICB9XG5cbiAgcHJlUHJvY2Vzc0F0dGFjaG1lbnRzKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgYXBpLl9vcGVuVHJhbnNhY3Rpb25TYWZlbHkoW0RPQ19TVE9SRSwgTUVUQV9TVE9SRV0sICdyZWFkd3JpdGUnLCBmdW5jdGlvbiAoZXJyLCBfdHhuKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICB0eG4gPSBfdHhuO1xuXG4gICAgICB0eG4ub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgfTtcbiAgICAgIHR4bi5vbnRpbWVvdXQgPSBpZGJFcnJvcihjYWxsYmFjayk7XG5cbiAgICAgIHR4bi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZGJDaGFuZ2VzLm5vdGlmeShkYk9wdHMubmFtZSk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgfTtcblxuICAgICAgLy8gV2Ugd291bGQgbGlrZSB0byB1c2UgcHJvbWlzZXMgaGVyZSwgYnV0IGlkYiBzdWNrc1xuICAgICAgZmV0Y2hFeGlzdGluZ0RvY3ModHhuLCBkb2NzKTtcbiAgICB9KTtcbiAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhbGxEb2NzS2V5cyhrZXlzLCBkb2NTdG9yZSwgYWxsRG9jc0lubmVyKSB7XG4gIC8vIEl0J3Mgbm90IGd1YXJhbnRlZCB0byBiZSByZXR1cm5lZCBpbiByaWdodCBvcmRlclxuICB2YXIgdmFsdWVzQmF0Y2ggPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICB2YXIgY291bnQgPSAwO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICBkb2NTdG9yZS5nZXQoa2V5KS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50YXJnZXQucmVzdWx0KSB7XG4gICAgICB2YWx1ZXNCYXRjaFtpbmRleF0gPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzQmF0Y2hbaW5kZXhdID0ge2tleToga2V5LCBlcnJvcjogJ25vdF9mb3VuZCd9O1xuICAgICAgfVxuICAgICAgY291bnQrKztcbiAgICAgIGlmIChjb3VudCA9PT0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWVzQmF0Y2guZm9yRWFjaChmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgICAgICBhbGxEb2NzSW5uZXIoZG9jKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVJhbmdlKHN0YXJ0LCBlbmQsIGluY2x1c2l2ZUVuZCwga2V5LCBkZXNjZW5kaW5nKSB7XG4gIHRyeSB7XG4gICAgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgICAgaWYgKGRlc2NlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLmJvdW5kKGVuZCwgc3RhcnQsICFpbmNsdXNpdmVFbmQsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBJREJLZXlSYW5nZS5ib3VuZChzdGFydCwgZW5kLCBmYWxzZSwgIWluY2x1c2l2ZUVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgaWYgKGRlc2NlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLnVwcGVyQm91bmQoc3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLmxvd2VyQm91bmQoc3RhcnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kKSB7XG4gICAgICBpZiAoZGVzY2VuZGluZykge1xuICAgICAgICByZXR1cm4gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChlbmQsICFpbmNsdXNpdmVFbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIElEQktleVJhbmdlLnVwcGVyQm91bmQoZW5kLCAhaW5jbHVzaXZlRW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSkge1xuICAgICAgcmV0dXJuIElEQktleVJhbmdlLm9ubHkoa2V5KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge2Vycm9yOiBlfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaGFuZGxlS2V5UmFuZ2VFcnJvcihvcHRzLCBtZXRhZGF0YSwgZXJyLCBjYWxsYmFjaykge1xuICBpZiAoZXJyLm5hbWUgPT09IFwiRGF0YUVycm9yXCIgJiYgZXJyLmNvZGUgPT09IDApIHtcbiAgICAvLyBkYXRhIGVycm9yLCBzdGFydCBpcyBsZXNzIHRoYW4gZW5kXG4gICAgdmFyIHJldHVyblZhbCA9IHtcbiAgICAgIHRvdGFsX3Jvd3M6IG1ldGFkYXRhLmRvY19jb3VudCxcbiAgICAgIG9mZnNldDogb3B0cy5za2lwLFxuICAgICAgcm93czogW11cbiAgICB9O1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChvcHRzLnVwZGF0ZV9zZXEpIHtcbiAgICAgIHJldHVyblZhbC51cGRhdGVfc2VxID0gbWV0YWRhdGEuc2VxO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmV0dXJuVmFsKTtcbiAgfVxuICBjYWxsYmFjayhjcmVhdGVFcnJvcihJREJfRVJST1IsIGVyci5uYW1lLCBlcnIubWVzc2FnZSkpO1xufVxuXG5mdW5jdGlvbiBhbGxEb2NzICh0eG4sIG1ldGFkYXRhLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHhuLmVycm9yKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHR4bi5lcnJvcik7XG4gIH1cblxuICAvLyBUT0RPOiBXZWlyZCBoYWNrLCBJIGRvbnQgbGlrZSBpdFxuICBpZiAob3B0cy5saW1pdCA9PT0gMCkge1xuICAgIHZhciByZXR1cm5WYWwgPSB7XG4gICAgICB0b3RhbF9yb3dzOiBtZXRhZGF0YS5kb2NfY291bnQsXG4gICAgICBvZmZzZXQ6IG9wdHMuc2tpcCxcbiAgICAgIHJvd3M6IFtdXG4gICAgfTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChvcHRzLnVwZGF0ZV9zZXEpIHtcbiAgICAgIHJldHVyblZhbC51cGRhdGVfc2VxID0gbWV0YWRhdGEuc2VxO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmV0dXJuVmFsKTtcbiAgfVxuXG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciBwcm9jZXNzaW5nID0gW107XG5cbiAgdmFyIHN0YXJ0ID0gJ3N0YXJ0a2V5JyBpbiBvcHRzID8gb3B0cy5zdGFydGtleSA6IGZhbHNlO1xuICB2YXIgZW5kID0gJ2VuZGtleScgaW4gb3B0cyA/IG9wdHMuZW5ka2V5IDogZmFsc2U7XG4gIHZhciBrZXkgPSAna2V5JyBpbiBvcHRzID8gb3B0cy5rZXkgOiBmYWxzZTtcbiAgdmFyIGtleXMgPSAna2V5cycgaW4gb3B0cyA/IG9wdHMua2V5cyA6IGZhbHNlO1xuICB2YXIgc2tpcCA9IG9wdHMuc2tpcCB8fCAwO1xuICB2YXIgbGltaXQgPSB0eXBlb2Ygb3B0cy5saW1pdCA9PT0gJ251bWJlcicgPyBvcHRzLmxpbWl0IDogLTE7XG4gIHZhciBpbmNsdXNpdmVFbmQgPSBvcHRzLmluY2x1c2l2ZV9lbmQgIT09IGZhbHNlO1xuICB2YXIgZGVzY2VuZGluZyA9ICdkZXNjZW5kaW5nJyBpbiBvcHRzICYmIG9wdHMuZGVzY2VuZGluZyA/ICdwcmV2JyA6IG51bGw7XG5cbiAgdmFyIGtleVJhbmdlO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlSYW5nZSA9IGNyZWF0ZUtleVJhbmdlKHN0YXJ0LCBlbmQsIGluY2x1c2l2ZUVuZCwga2V5LCBkZXNjZW5kaW5nKTtcbiAgICBpZiAoa2V5UmFuZ2UgJiYga2V5UmFuZ2UuZXJyb3IpIHtcbiAgICAgIHJldHVybiBoYW5kbGVLZXlSYW5nZUVycm9yKG9wdHMsIG1ldGFkYXRhLCBrZXlSYW5nZS5lcnJvciwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkb2NTdG9yZSA9IHR4bi50eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKTtcblxuICB0eG4udHhuLm9uY29tcGxldGUgPSBvblR4bkNvbXBsZXRlO1xuXG4gIGlmIChrZXlzKSB7XG4gICAgcmV0dXJuIGFsbERvY3NLZXlzKG9wdHMua2V5cywgZG9jU3RvcmUsIGFsbERvY3NJbm5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBpbmNsdWRlX2RvYyhyb3csIGRvYykge1xuICAgIHZhciBkb2NEYXRhID0gZG9jLnJldnNbZG9jLnJldl0uZGF0YTtcblxuICAgIHJvdy5kb2MgPSBkb2NEYXRhO1xuICAgIHJvdy5kb2MuX2lkID0gZG9jLmlkO1xuICAgIHJvdy5kb2MuX3JldiA9IGRvYy5yZXY7XG4gICAgaWYgKG9wdHMuY29uZmxpY3RzKSB7XG4gICAgICB2YXIgY29uZmxpY3RzID0gY29sbGVjdENvbmZsaWN0cyhkb2MpO1xuICAgICAgaWYgKGNvbmZsaWN0cy5sZW5ndGgpIHtcbiAgICAgICAgcm93LmRvYy5fY29uZmxpY3RzID0gY29uZmxpY3RzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0cy5hdHRhY2htZW50cyAmJiBkb2NEYXRhLl9hdHRhY2htZW50cykge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBkb2NEYXRhLl9hdHRhY2htZW50cykge1xuICAgICAgICBwcm9jZXNzaW5nLnB1c2gocHJvY2Vzc0F0dGFjaG1lbnQobmFtZSwgZG9jLCByb3cuZG9jLCBvcHRzLmJpbmFyeSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbERvY3NJbm5lcihkb2MpIHtcbiAgICBpZiAoZG9jLmVycm9yICYmIGtleXMpIHtcbiAgICAgIC8vIGtleSB3YXMgbm90IGZvdW5kIHdpdGggXCJrZXlzXCIgcmVxdWVzdHNcbiAgICAgIHJlc3VsdHMucHVzaChkb2MpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHJvdyA9IHtcbiAgICAgIGlkOiBkb2MuaWQsXG4gICAgICBrZXk6IGRvYy5pZCxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHJldjogZG9jLnJldlxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGVsZXRlZCA9IGRvYy5kZWxldGVkO1xuICAgIGlmIChkZWxldGVkKSB7XG4gICAgICBpZiAoa2V5cykge1xuICAgICAgICByZXN1bHRzLnB1c2gocm93KTtcbiAgICAgICAgcm93LnZhbHVlLmRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICByb3cuZG9jID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNraXAtLSA8PSAwKSB7XG4gICAgICByZXN1bHRzLnB1c2gocm93KTtcbiAgICAgIGlmIChvcHRzLmluY2x1ZGVfZG9jcykge1xuICAgICAgICBpbmNsdWRlX2RvYyhyb3csIGRvYyk7XG4gICAgICB9XG4gICAgICBpZiAoLS1saW1pdCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UeG5Db21wbGV0ZSgpIHtcbiAgICBQcm9taXNlLmFsbChwcm9jZXNzaW5nKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXR1cm5WYWwgPSB7XG4gICAgICAgIHRvdGFsX3Jvd3M6IG1ldGFkYXRhLmRvY19jb3VudCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICByb3dzOiByZXN1bHRzXG4gICAgICB9O1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChvcHRzLnVwZGF0ZV9zZXEpIHtcbiAgICAgICAgcmV0dXJuVmFsLnVwZGF0ZV9zZXEgPSBtZXRhZGF0YS5zZXE7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCByZXR1cm5WYWwpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGN1cnNvciA9IGRlc2NlbmRpbmcgP1xuICAgIGRvY1N0b3JlLm9wZW5DdXJzb3Ioa2V5UmFuZ2UsIGRlc2NlbmRpbmcpIDpcbiAgICBkb2NTdG9yZS5vcGVuQ3Vyc29yKGtleVJhbmdlKTtcblxuICBjdXJzb3Iub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcblxuICAgIHZhciBkb2MgPSBlLnRhcmdldC5yZXN1bHQgJiYgZS50YXJnZXQucmVzdWx0LnZhbHVlO1xuXG4gICAgLy8gSGFwcGVucyBpZiBvcHRzIGRvZXMgbm90IGhhdmUgbGltaXQsXG4gICAgLy8gYmVjYXVzZSBjdXJzb3Igd2lsbCBlbmQgbm9ybWFsbHkgdGhlbixcbiAgICAvLyB3aGVuIGFsbCBkb2NzIGFyZSByZXRyaWV2ZWQuXG4gICAgLy8gV291bGQgbm90IGJlIG5lZWRlZCwgaWYgZ2V0QWxsKCkgb3B0aW1pemF0aW9uIHdhcyB1c2VkIGxpa2UgaW4gIzYwNTlcbiAgICBpZiAoIWRvYykgeyByZXR1cm47IH1cblxuICAgIC8vIFNraXAgbG9jYWwgZG9jc1xuICAgIGlmICgvXl9sb2NhbC8udGVzdChkb2MuaWQpKSB7XG4gICAgICByZXR1cm4gZS50YXJnZXQucmVzdWx0LmNvbnRpbnVlKCk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRpbnVlQ3Vyc29yID0gYWxsRG9jc0lubmVyKGRvYyk7XG4gICAgaWYgKGNvbnRpbnVlQ3Vyc29yKSB7XG4gICAgICBlLnRhcmdldC5yZXN1bHQuY29udGludWUoKTtcbiAgICB9XG4gIH07XG5cbn1cblxuZnVuY3Rpb24gY2hhbmdlcyAodHhuLCBpZGJDaGFuZ2VzLCBhcGksIGRiT3B0cywgb3B0cykge1xuICBpZiAodHhuLmVycm9yKSB7XG4gICAgcmV0dXJuIG9wdHMuY29tcGxldGUodHhuLmVycm9yKTtcbiAgfVxuXG4gIGlmIChvcHRzLmNvbnRpbnVvdXMpIHtcbiAgICB2YXIgaWQgPSBkYk9wdHMubmFtZSArICc6JyArIHV1aWQoKTtcbiAgICBpZGJDaGFuZ2VzLmFkZExpc3RlbmVyKGRiT3B0cy5uYW1lLCBpZCwgYXBpLCBvcHRzKTtcbiAgICBpZGJDaGFuZ2VzLm5vdGlmeShkYk9wdHMubmFtZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZGJDaGFuZ2VzLnJlbW92ZUxpc3RlbmVyKGRiT3B0cy5uYW1lLCBpZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBsaW1pdCA9ICdsaW1pdCcgaW4gb3B0cyA/IG9wdHMubGltaXQgOiAtMTtcbiAgaWYgKGxpbWl0ID09PSAwKSB7XG4gICAgbGltaXQgPSAxO1xuICB9XG5cbiAgdmFyIHN0b3JlID0gdHhuLnR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpLmluZGV4KCdzZXEnKTtcblxuICB2YXIgZmlsdGVyID0gZmlsdGVyQ2hhbmdlKG9wdHMpO1xuICB2YXIgcmVjZWl2ZWQgPSAwO1xuXG4gIHZhciBsYXN0U2VxID0gb3B0cy5zaW5jZSB8fCAwO1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gIHZhciBwcm9jZXNzaW5nID0gW107XG5cbiAgZnVuY3Rpb24gb25SZXFTdWNjZXNzKGUpIHtcbiAgICBpZiAoIWUudGFyZ2V0LnJlc3VsdCkgeyByZXR1cm47IH1cbiAgICB2YXIgY3Vyc29yID0gZS50YXJnZXQucmVzdWx0O1xuICAgIHZhciBkb2MgPSBjdXJzb3IudmFsdWU7XG4gICAgLy8gT3ZlcndyaXRlIGRvYy5kYXRhLCB3aGljaCBtYXkgaGF2ZSBiZWVuIHJld3JpdHRlbiAoc2VlIHJld3JpdGUuanMpIHdpdGhcbiAgICAvLyB0aGUgY2xlYW4gdmVyc2lvbiBmb3IgdGhhdCByZXZcbiAgICBkb2MuZGF0YSA9IGRvYy5yZXZzW2RvYy5yZXZdLmRhdGE7XG4gICAgZG9jLmRhdGEuX2lkID0gZG9jLmlkO1xuICAgIGRvYy5kYXRhLl9yZXYgPSBkb2MucmV2O1xuICAgIGlmIChkb2MuZGVsZXRlZCkge1xuICAgICAgZG9jLmRhdGEuX2RlbGV0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRzLmRvY19pZHMgJiYgb3B0cy5kb2NfaWRzLmluZGV4T2YoZG9jLmlkKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBjdXJzb3IuY29udGludWUoKTtcbiAgICB9XG5cbiAgICAvLyBXQVJOSU5HOiBleHBlY3RpbmcgcG9zc2libGUgb2xkIGZvcm1hdFxuICAgIHZhciBjaGFuZ2UgPSBvcHRzLnByb2Nlc3NDaGFuZ2UoZG9jLmRhdGEsIGRvYywgb3B0cyk7XG4gICAgY2hhbmdlLnNlcSA9IGRvYy5zZXE7XG4gICAgbGFzdFNlcSA9IGRvYy5zZXE7XG4gICAgdmFyIGZpbHRlcmVkID0gZmlsdGVyKGNoYW5nZSk7XG5cbiAgICAvLyBJZiBpdHMgYW4gZXJyb3JcbiAgICBpZiAodHlwZW9mIGZpbHRlcmVkID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG9wdHMuY29tcGxldGUoZmlsdGVyZWQpO1xuICAgIH1cblxuICAgIGlmIChmaWx0ZXJlZCkge1xuICAgICAgcmVjZWl2ZWQrKztcbiAgICAgIGlmIChvcHRzLnJldHVybl9kb2NzKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChjaGFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5pbmNsdWRlX2RvY3MgJiYgb3B0cy5hdHRhY2htZW50cyAmJiBkb2MuZGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gZG9jLmRhdGEuX2F0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgdmFyIHAgPSBwcm9jZXNzQXR0YWNobWVudChuYW1lLCBkb2MsIGNoYW5nZS5kb2MsIG9wdHMuYmluYXJ5KTtcbiAgICAgICAgICAvLyBXZSBhZGQgdGhlIHByb2Nlc3NpbmcgcHJvbWlzZSB0byAyIGFycmF5cywgb25lIHRyYWNrcyBhbGxcbiAgICAgICAgICAvLyB0aGUgcHJvbWlzZXMgbmVlZGVkIGJlZm9yZSB3ZSBmaXJlIG9uQ2hhbmdlLCB0aGUgb3RoZXJcbiAgICAgICAgICAvLyBlbnN1cmUgd2UgcHJvY2VzcyBhbGwgYXR0YWNobWVudHMgYmVmb3JlIG9uQ29tcGxldGVcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHApO1xuICAgICAgICAgIHByb2Nlc3NpbmcucHVzaChwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvcHRzLm9uQ2hhbmdlKGNoYW5nZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0cy5vbkNoYW5nZShjaGFuZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVjZWl2ZWQgIT09IGxpbWl0KSB7XG4gICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblR4bkNvbXBsZXRlKCkge1xuICAgIFByb21pc2UuYWxsKHByb2Nlc3NpbmcpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgb3B0cy5jb21wbGV0ZShudWxsLCB7XG4gICAgICAgIHJlc3VsdHM6IHJlc3VsdHMsXG4gICAgICAgIGxhc3Rfc2VxOiBsYXN0U2VxXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciByZXE7XG4gIGlmIChvcHRzLmRlc2NlbmRpbmcpIHtcbiAgICByZXEgPSBzdG9yZS5vcGVuQ3Vyc29yKG51bGwsICdwcmV2Jyk7XG4gIH0gZWxzZSB7XG4gICAgcmVxID0gc3RvcmUub3BlbkN1cnNvcihJREJLZXlSYW5nZS5sb3dlckJvdW5kKG9wdHMuc2luY2UsIHRydWUpKTtcbiAgfVxuXG4gIHR4bi50eG4ub25jb21wbGV0ZSA9IG9uVHhuQ29tcGxldGU7XG4gIHJlcS5vbnN1Y2Nlc3MgPSBvblJlcVN1Y2Nlc3M7XG59XG5cbmZ1bmN0aW9uIGdldFJldmlzaW9uVHJlZSAodHhuLCBpZCwgY2FsbGJhY2spIHtcbiAgaWYgKHR4bi5lcnJvcikge1xuICAgIHJldHVybiBjYWxsYmFjayh0eG4uZXJyb3IpO1xuICB9XG5cbiAgdmFyIHJlcSA9IHR4bi50eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5nZXQoaWQpO1xuICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIWUudGFyZ2V0LnJlc3VsdCkge1xuICAgICAgY2FsbGJhY2soY3JlYXRlRXJyb3IoTUlTU0lOR19ET0MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sobnVsbCwgZS50YXJnZXQucmVzdWx0LnJldl90cmVlKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRvQ29tcGFjdGlvbiAodHhuLCBpZCwgcmV2cywgY2FsbGJhY2spIHtcbiAgaWYgKHR4bi5lcnJvcikge1xuICAgIHJldHVybiBjYWxsYmFjayh0eG4uZXJyb3IpO1xuICB9XG5cbiAgdmFyIGRvY1N0b3JlID0gdHhuLnR4bi5vYmplY3RTdG9yZShET0NfU1RPUkUpO1xuXG4gIGRvY1N0b3JlLmdldChpZCkub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZG9jID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgdHJhdmVyc2VSZXZUcmVlKGRvYy5yZXZfdHJlZSwgZnVuY3Rpb24gKGlzTGVhZiwgcG9zLCByZXZIYXNoLCBjdHgsIG9wdHMpIHtcbiAgICAgIHZhciByZXYgPSBwb3MgKyAnLScgKyByZXZIYXNoO1xuICAgICAgaWYgKHJldnMuaW5kZXhPZihyZXYpICE9PSAtMSkge1xuICAgICAgICBvcHRzLnN0YXR1cyA9ICdtaXNzaW5nJztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBhdHRhY2htZW50cyA9IFtdO1xuXG4gICAgcmV2cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXYpIHtcbiAgICAgIGlmIChyZXYgaW4gZG9jLnJldnMpIHtcbiAgICAgICAgLy8gTWFrZSBhIGxpc3Qgb2YgYXR0YWNobWVudHMgdGhhdCBhcmUgdXNlZCBieSB0aGUgcmV2aXNpb25zIGJlaW5nXG4gICAgICAgIC8vIGRlbGV0ZWRcbiAgICAgICAgaWYgKGRvYy5yZXZzW3Jldl0uZGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBrIGluIGRvYy5yZXZzW3Jldl0uZGF0YS5fYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgIGF0dGFjaG1lbnRzLnB1c2goZG9jLnJldnNbcmV2XS5kYXRhLl9hdHRhY2htZW50c1trXS5kaWdlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgZG9jLnJldnNbcmV2XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEF0dGFjaG1lbnRzIGhhdmUgYSBsaXN0IG9mIHJldmlzaW9ucyB0aGF0IGFyZSB1c2luZyB0aGVtLCB3aGVuXG4gICAgLy8gdGhhdCBsaXN0IGJlY29tZXMgZW1wdHkgd2UgY2FuIGRlbGV0ZSB0aGUgYXR0YWNobWVudC5cbiAgICBhdHRhY2htZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkaWdlc3QpIHtcbiAgICAgIHJldnMuZm9yRWFjaChmdW5jdGlvbiAocmV2KSB7XG4gICAgICAgIGRlbGV0ZSBkb2MuYXR0YWNobWVudHNbZGlnZXN0XS5yZXZzW3Jldl07XG4gICAgICB9KTtcbiAgICAgIGlmICghT2JqZWN0LmtleXMoZG9jLmF0dGFjaG1lbnRzW2RpZ2VzdF0ucmV2cykubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSBkb2MuYXR0YWNobWVudHNbZGlnZXN0XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRvY1N0b3JlLnB1dChkb2MpO1xuICB9O1xuXG4gIHR4bi50eG4ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZXN0cm95IChkYk9wdHMsIG9wZW5EYXRhYmFzZXMsIGlkYkNoYW5nZXMsIGNhbGxiYWNrKSB7XG5cbiAgaWRiQ2hhbmdlcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZGJPcHRzLm5hbWUpO1xuXG4gIGZ1bmN0aW9uIGRvRGVzdHJveSgpIHtcbiAgICB2YXIgcmVxID0gaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKGRiT3B0cy5uYW1lKTtcbiAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgZGVsZXRlIG9wZW5EYXRhYmFzZXNbZGJPcHRzLm5hbWVdO1xuICAgICAgY2FsbGJhY2sobnVsbCwge29rOiB0cnVlfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElmIHRoZSBkYXRhYmFzZSBpcyBvcGVuIHdlIG5lZWQgdG8gY2xvc2UgaXRcbiAgaWYgKGRiT3B0cy5uYW1lIGluIG9wZW5EYXRhYmFzZXMpIHtcbiAgICBvcGVuRGF0YWJhc2VzW2RiT3B0cy5uYW1lXS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHJlcy5pZGIuY2xvc2UoKTtcbiAgICAgIGRvRGVzdHJveSgpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvRGVzdHJveSgpO1xuICB9XG5cbn1cblxuLy8gQWRhcHRlZCBmcm9tXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcG91Y2hkYi9wb3VjaGRiL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL25vZGVfbW9kdWxlcy9wb3VjaGRiLWZpbmQvc3JjL2FkYXB0ZXJzL2xvY2FsL2ZpbmQvcXVlcnktcGxhbm5lci5qcyNMMjAtTDI0XG4vLyBUaGlzIGNvdWxkIGNoYW5nZSAvIGltcHJvdmUgaW4gdGhlIGZ1dHVyZT9cbnZhciBDT1VDSF9DT0xMQVRFX0xPID0gbnVsbDtcbnZhciBDT1VDSF9DT0xMQVRFX0hJID0gJ1xcdWZmZmYnOyAvLyBhY3R1YWxseSB1c2VkIGFzIHtcIlxcdWZmZmZcIjoge319XG5cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly93d3cudzMub3JnL1RSL0luZGV4ZWREQi8jY29tcGFyZS10d28ta2V5c1xuLy8gSW1wb3J0YW50bHksICp0aGVyZSBpcyBubyB1cHBlciBib3VuZCBwb3NzaWJsZSogaW4gaWRiLiBUaGUgaWRlYWwgZGF0YVxuLy8gc3RydWN0dXJlIGFuIGluZmludGVseSBkZWVwIGFycmF5OlxuLy8gICB2YXIgSURCX0NPTExBVEVfSEkgPSBbXTsgSURCX0NPTExBVEVfSEkucHVzaChJREJfQ09MTEFURV9ISSlcbi8vIEJ1dCBJREJLZXlSYW5nZSBpcyBub3QgYSBmYW4gb2Ygc2hlbmFuaWdhbnMsIHNvIEkndmUganVzdCBnb25lIHdpdGggMTIgbGF5ZXJzXG4vLyBiZWNhdXNlIGl0IGxvb2tzIG5pY2UgYW5kIHN1cmVseSB0aGF0J3MgZW5vdWdoIVxudmFyIElEQl9DT0xMQVRFX0xPID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xudmFyIElEQl9DT0xMQVRFX0hJID0gW1tbW1tbW1tbW1tbXV1dXV1dXV1dXV1dO1xuXG4vL1xuLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgbWFkZSBvZmZpY2FsIHNvbWV3aGVyZSBhbmQgdXNlZCBieSBBbGxEb2NzIC8gZ2V0IC9cbi8vIGNoYW5nZXMgZXRjIGFzIHdlbGwuXG4vL1xuZnVuY3Rpb24gZXh0ZXJuYWxpc2VSZWNvcmQoaWRiRG9jKSB7XG4gIHZhciBkb2MgPSBpZGJEb2MucmV2c1tpZGJEb2MucmV2XS5kYXRhO1xuICBkb2MuX2lkID0gaWRiRG9jLmlkO1xuICBkb2MuX3JldiA9IGlkYkRvYy5yZXY7XG4gIGlmIChpZGJEb2MuZGVsZXRlZCkge1xuICAgIGRvYy5fZGVsZXRlZCA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZG9jO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGtleXJhbmdlIGJhc2VkIG9uIHRoZSBvcHRzIHBhc3NlZCB0byBxdWVyeVxuICpcbiAqIFRoZSBmaXJzdCBrZXkgaXMgYWx3YXlzIDAsIGFzIHRoYXQncyBob3cgd2UncmUgZmlsdGVyaW5nIG91dCBkZWxldGVkIGVudHJpZXMuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5UmFuZ2Uob3B0cykge1xuICBmdW5jdGlvbiBkZWZpbmVkKG9iaiwgaykge1xuICAgIHJldHVybiBvYmpba10gIT09IHZvaWQgMDtcbiAgfVxuXG4gIC8vIENvbnZlcnRzIGEgdmFsaWQgQ291Y2hEQiBrZXkgaW50byBhIHZhbGlkIEluZGV4ZWREQiBvbmVcbiAgZnVuY3Rpb24gY29udmVydChrZXksIGV4YWN0KSB7XG4gICAgLy8gVGhlIGZpcnN0IGl0ZW0gaW4gZXZlcnkgbmF0aXZlIGluZGV4IGlzIGRvYy5kZWxldGVkLCBhbmQgd2UgYWx3YXlzIHdhbnRcbiAgICAvLyB0byBvbmx5IHNlYXJjaCBkb2N1bWVudHMgdGhhdCBhcmUgbm90IGRlbGV0ZWQuXG4gICAgLy8gXCJmb29cIiAtPiBbMCwgXCJmb29cIl1cbiAgICB2YXIgZmlsdGVyRGVsZXRlZCA9IFswXS5jb25jYXQoa2V5KTtcblxuICAgIHJldHVybiBmaWx0ZXJEZWxldGVkLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgLy8gbnVsbCwgdHJ1ZSBhbmQgZmFsc2UgYXJlIG5vdCBpbmRleGFibGUgYnkgaW5kZXhlZGRiLiBXaGVuIHdlIHdyaXRlXG4gICAgICAvLyB0aGVzZSB2YWx1ZXMgd2UgY29udmVydCB0aGVtIHRvIHRoZXNlIGNvbnN0YW50cywgYW5kIHNvIHdoZW4gd2VcbiAgICAgIC8vIHF1ZXJ5IGZvciB0aGVtIHdlIG5lZWQgdG8gY29udmVydCB0aGUgcXVlcnkgYWxzby5cbiAgICAgIGlmIChrID09PSBudWxsICYmIGV4YWN0KSB7XG4gICAgICAgIC8vIGZvciBub24tZXhhY3QgcXVlcmllcyB3ZSB0cmVhdCBudWxsIGFzIGEgY29sbGF0ZSBwcm9wZXJ0eVxuICAgICAgICAvLyBzZWUgYGlmICghZXhhY3QpYCBibG9jayBiZWxvd1xuICAgICAgICByZXR1cm4gSURCX05VTEw7XG4gICAgICB9IGVsc2UgaWYgKGsgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIElEQl9UUlVFO1xuICAgICAgfSBlbHNlIGlmIChrID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gSURCX0ZBTFNFO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWV4YWN0KSB7XG4gICAgICAgIC8vIFdlIGdldCBwYXNzZWQgQ291Y2hEQidzIGNvbGxhdGUgbG93IGFuZCBoaWdoIHZhbHVlcywgc28gZm9yIG5vbi1leGFjdFxuICAgICAgICAvLyByYW5nZWQgcXVlcmllcyB3ZSdyZSBnb2luZyB0byBjb252ZXJ0IHRoZW0gdG8gb3VyIElEQiBlcXVpdmFsZW50c1xuICAgICAgICBpZiAoayA9PT0gQ09VQ0hfQ09MTEFURV9MTykge1xuICAgICAgICAgIHJldHVybiBJREJfQ09MTEFURV9MTztcbiAgICAgICAgfSBlbHNlIGlmIChrLmhhc093blByb3BlcnR5KENPVUNIX0NPTExBVEVfSEkpKSB7XG4gICAgICAgICAgcmV0dXJuIElEQl9DT0xMQVRFX0hJO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ291Y2hEQiBhbmQgc28gUG91Y2hkQiBkZWZhdWx0cyB0byB0cnVlLiBXZSBuZWVkIHRvIG1ha2UgdGhpcyBleHBsaWNpdCBhc1xuICAvLyB3ZSBpbnZlcnQgdGhlc2UgbGF0ZXIgZm9yIEluZGV4ZWREQi5cbiAgaWYgKCFkZWZpbmVkKG9wdHMsICdpbmNsdXNpdmVfZW5kJykpIHtcbiAgICBvcHRzLmluY2x1c2l2ZV9lbmQgPSB0cnVlO1xuICB9XG4gIGlmICghZGVmaW5lZChvcHRzLCAnaW5jbHVzaXZlX3N0YXJ0JykpIHtcbiAgICBvcHRzLmluY2x1c2l2ZV9zdGFydCA9IHRydWU7XG4gIH1cblxuICBpZiAob3B0cy5kZXNjZW5kaW5nKSB7XG4gICAgLy8gRmxpcCBiZWZvcmUgZ2VuZXJhdGluZy4gV2UnbGwgY2hlY2sgZGVzY2VuZGluZyBhZ2FpbiBsYXRlciB3aGVuIHBlcmZvcm1pbmdcbiAgICAvLyBhbiBpbmRleCByZXF1ZXN0XG4gICAgdmFyIHJlYWxFbmRrZXkgPSBvcHRzLnN0YXJ0a2V5LFxuICAgICAgICByZWFsSW5jbHVzaXZlRW5kID0gb3B0cy5pbmNsdXNpdmVfc3RhcnQ7XG5cbiAgICBvcHRzLnN0YXJ0a2V5ID0gb3B0cy5lbmRrZXk7XG4gICAgb3B0cy5lbmRrZXkgPSByZWFsRW5ka2V5O1xuICAgIG9wdHMuaW5jbHVzaXZlX3N0YXJ0ID0gb3B0cy5pbmNsdXNpdmVfZW5kO1xuICAgIG9wdHMuaW5jbHVzaXZlX2VuZCA9IHJlYWxJbmNsdXNpdmVFbmQ7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChkZWZpbmVkKG9wdHMsICdrZXknKSkge1xuICAgICAgcmV0dXJuIElEQktleVJhbmdlLm9ubHkoY29udmVydChvcHRzLmtleSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGlmIChkZWZpbmVkKG9wdHMsICdzdGFydGtleScpICYmICFkZWZpbmVkKG9wdHMsICdlbmRrZXknKSkge1xuICAgICAgcmV0dXJuIElEQktleVJhbmdlLmxvd2VyQm91bmQoY29udmVydChvcHRzLnN0YXJ0a2V5KSwgIW9wdHMuaW5jbHVzaXZlX3N0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoIWRlZmluZWQob3B0cywgJ3N0YXJ0a2V5JykgJiYgZGVmaW5lZChvcHRzLCAnZW5ka2V5JykpIHtcbiAgICAgIHJldHVybiBJREJLZXlSYW5nZS51cHBlckJvdW5kKGNvbnZlcnQob3B0cy5lbmRrZXkpLCAhb3B0cy5pbmNsdXNpdmVfZW5kKTtcbiAgICB9XG5cbiAgICBpZiAoZGVmaW5lZChvcHRzLCAnc3RhcnRrZXknKSAmJiBkZWZpbmVkKG9wdHMsICdlbmRrZXknKSkge1xuICAgICAgcmV0dXJuIElEQktleVJhbmdlLmJvdW5kKFxuICAgICAgICBjb252ZXJ0KG9wdHMuc3RhcnRrZXkpLCAgICBjb252ZXJ0KG9wdHMuZW5ka2V5KSxcbiAgICAgICAgIW9wdHMuaW5jbHVzaXZlX3N0YXJ0LCAhb3B0cy5pbmNsdXNpdmVfZW5kXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBJREJLZXlSYW5nZS5vbmx5KFswXSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0NvdWxkIG5vdCBnZW5lcmF0ZSBrZXlSYW5nZScsIGVyciwgb3B0cyk7XG4gICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBnZW5lcmF0ZSBrZXkgcmFuZ2Ugd2l0aCAnICsgSlNPTi5zdHJpbmdpZnkob3B0cykpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4SGFuZGxlKHBkYiwgZmllbGRzLCByZWplY3QpIHtcbiAgdmFyIGluZGV4TmFtZSA9IG5hdHVyYWxJbmRleE5hbWUoZmllbGRzKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICBwZGIuX29wZW5UcmFuc2FjdGlvblNhZmVseShbRE9DX1NUT1JFXSwgJ3JlYWRvbmx5JywgZnVuY3Rpb24gKGVyciwgdHhuKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBpZGJFcnJvcihyZWplY3QpKGVycik7XG4gICAgICB9XG5cbiAgICAgIHR4bi5vbmFib3J0ID0gaWRiRXJyb3IocmVqZWN0KTtcbiAgICAgIHR4bi5vbnRpbWVvdXQgPSBpZGJFcnJvcihyZWplY3QpO1xuXG4gICAgICB2YXIgZXhpc3RpbmdJbmRleE5hbWVzID0gQXJyYXkuZnJvbSh0eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5pbmRleE5hbWVzKTtcblxuICAgICAgaWYgKGV4aXN0aW5nSW5kZXhOYW1lcy5pbmRleE9mKGluZGV4TmFtZSkgPT09IC0xKSB7XG4gICAgICAgIC8vIFRoZSBpbmRleCBpcyBtaXNzaW5nLCBmb3JjZSBhIGRiIHJlc3RhcnQgYW5kIHRyeSBhZ2FpblxuICAgICAgICBwZGIuX2ZyZXNoZW4oKVxuICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldEluZGV4SGFuZGxlKHBkYiwgZmllbGRzLCByZWplY3QpOyB9KVxuICAgICAgICAgIC50aGVuKHJlc29sdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSh0eG4ub2JqZWN0U3RvcmUoRE9DX1NUT1JFKS5pbmRleChpbmRleE5hbWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIEluIHRoZW9yeSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBsaWtlIHRoZSBkb2MgZXhhbXBsZSBiZWxvdywgYnV0IGZpbmRcbi8vIG9ubHkgbmVlZHMgcm93czogW3tkb2M6IHsuLi59fV0sIHNvIEkgdGhpbmsgd2UgY2FuIGp1c3Qgbm90IGJvdGhlciBmb3Igbm93XG4vLyB7XG4vLyAgIFwib2Zmc2V0XCIgOiAwLFxuLy8gICBcInJvd3NcIjogW3tcbi8vICAgICBcImlkXCI6IFwiZG9jM1wiLFxuLy8gICAgIFwia2V5XCI6IFwiTGlzYSBTYXlzXCIsXG4vLyAgICAgXCJ2YWx1ZVwiOiBudWxsLFxuLy8gICAgIFwiZG9jXCI6IHtcbi8vICAgICAgIFwiX2lkXCI6IFwiZG9jM1wiLFxuLy8gICAgICAgXCJfcmV2XCI6IFwiMS16XCIsXG4vLyAgICAgICBcInRpdGxlXCI6IFwiTGlzYSBTYXlzXCJcbi8vICAgICB9XG4vLyAgIH1dLFxuLy8gICBcInRvdGFsX3Jvd3NcIiA6IDRcbi8vIH1cbmZ1bmN0aW9uIHF1ZXJ5KGlkYiwgc2lnbmF0dXJlLCBvcHRzKSB7XG4gIC8vIEF0IHRoaXMgc3RhZ2UsIGluIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uLCBmaW5kIGhhcyBhbHJlYWR5IGdvbmUgdGhyb3VnaFxuICAvLyBhbmQgZGV0ZXJtaW5lZCBpZiB0aGUgaW5kZXggYWxyZWFkeSBleGlzdHMgZnJvbSBQb3VjaERCJ3MgcGVyc3BlY3RpdmUgKGVnXG4gIC8vIHRoZXJlIGlzIGEgZGVzaWduIGRvYyBmb3IgaXQpLlxuICAvL1xuICAvLyBJZiB3ZSBmaW5kIHRoYXQgdGhlIGluZGV4IGRvZXNuJ3QgZXhpc3QgdGhpcyBtZWFucyB3ZSBoYXZlIHRvIGNsb3NlIGFuZFxuICAvLyByZS1vcGVuIHRoZSBEQiB0byBjb3JyZWN0IGluZGV4ZXMgYmVmb3JlIHByb2NlZWRpbmcsIGF0IHdoaWNoIHBvaW50IHRoZVxuICAvLyBpbmRleCBzaG91bGQgZXhpc3QuXG5cbiAgdmFyIHBkYiA9IHRoaXM7XG5cbiAgLy8gQXNzdW1wdGlvbiwgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSAvLCBiZXR3ZWVuIHRoZSBkZXNpZ24gZG9jdW1lbnQgbmFtZVxuICAvLyBhbmQgdGhlIHZpZXcgbmFtZS5cbiAgdmFyIHBhcnRzID0gc2lnbmF0dXJlLnNwbGl0KCcvJyk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBwZGIuZ2V0KCdfZGVzaWduLycgKyBwYXJ0c1swXSkudGhlbihmdW5jdGlvbiAoZGRvYykge1xuICAgICAgdmFyIGZpZWxkcyA9IHJhd0luZGV4RmllbGRzKGRkb2MsIHBhcnRzWzFdKTtcbiAgICAgIGlmICghZmllbGRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGRvYyAnICsgZGRvYy5faWQgKycgd2l0aCB2aWV3ICcgKyBwYXJ0c1sxXSArXG4gICAgICAgICAgJyBkb2VzIG5vdCBoYXZlIG1hcC5vcHRpb25zLmRlZi5maWVsZHMgZGVmaW5lZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNraXAgPSBvcHRzLnNraXA7XG4gICAgICB2YXIgbGltaXQgPSBOdW1iZXIuaXNJbnRlZ2VyKG9wdHMubGltaXQpICYmIG9wdHMubGltaXQ7XG5cbiAgICAgIHJldHVybiBnZXRJbmRleEhhbmRsZShwZGIsIGZpZWxkcywgcmVqZWN0KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoaW5kZXhIYW5kbGUpIHtcbiAgICAgICAgICB2YXIga2V5UmFuZ2UgPSBnZW5lcmF0ZUtleVJhbmdlKG9wdHMpO1xuICAgICAgICAgIHZhciByZXEgPSBpbmRleEhhbmRsZS5vcGVuQ3Vyc29yKGtleVJhbmdlLCBvcHRzLmRlc2NlbmRpbmcgPyAncHJldicgOiAnbmV4dCcpO1xuXG4gICAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgICByZXEub25lcnJvciA9IGlkYkVycm9yKHJlamVjdCk7XG4gICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gZS50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAoIWN1cnNvciB8fCBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgcm93czogcm93c1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgICAgY3Vyc29yLmFkdmFuY2Uoc2tpcCk7XG4gICAgICAgICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGltaXQpIHtcbiAgICAgICAgICAgICAgbGltaXQgPSBsaW1pdCAtIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJvd3MucHVzaCh7ZG9jOiBleHRlcm5hbGlzZVJlY29yZChjdXJzb3IudmFsdWUpfSk7XG4gICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgfSk7XG5cbn1cblxuZnVuY3Rpb24gdmlld0NsZWFudXAoKSB7XG4gIC8vIEknbSBub3Qgc3VyZSB3ZSBoYXZlIHRvIGRvIGFueXRoaW5nIGhlcmUuXG4gIC8vXG4gIC8vIE9uZSBvcHRpb24gaXMgdG8ganVzdCBjbG9zZSBhbmQgcmUtb3BlbiB0aGUgREIsIHdoaWNoIHBlcmZvcm1zIHRoZSBzYW1lXG4gIC8vIGFjdGlvbi4gVGhlIG9ubHkgcmVhc29uIHlvdSdkIHdhbnQgdG8gY2FsbCB0aGlzIGlzIGlmIHlvdSBkZWxldGVkIGEgYnVuY2hcbiAgLy8gb2YgaW5kZXhlcyBhbmQgd2FudGVkIHRoZSBzcGFjZSBiYWNrIGltbWVkaWF0ZWx5LlxuICAvL1xuICAvLyBPdGhlcndpc2UgaW5kZXggY2xlYW51cCBoYXBwZW5zIHdoZW46XG4gIC8vICAtIEEgREIgaXMgb3BlbmVkXG4gIC8vICAtIEEgZmluZCBxdWVyeSBpcyBwZXJmb3JtZWQgYWdhaW5zdCBhbiBpbmRleCB0aGF0IGRvZXNuJ3QgZXhpc3QgYnV0IHNob3VsZFxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn1cblxudmFyIEFEQVBURVJfTkFNRSA9ICdpbmRleGVkZGInO1xuXG4vLyBUT0RPOiBDb25zdHJ1Y3RvciBzaG91bGQgYmUgY2FwaXRhbGlzZWRcbnZhciBpZGJDaGFuZ2VzID0gbmV3IGNoYW5nZXNIYW5kbGVyKCk7XG5cbi8vIEEgc2hhcmVkIGxpc3Qgb2YgZGF0YWJhc2UgaGFuZGxlc1xudmFyIG9wZW5EYXRhYmFzZXMgPSB7fTtcblxuZnVuY3Rpb24gSWRiUG91Y2goZGJPcHRzLCBjYWxsYmFjaykge1xuXG4gIHZhciBhcGkgPSB0aGlzO1xuICB2YXIgbWV0YWRhdGEgPSB7fTtcblxuICAvLyBXcmFwcGVyIHRoYXQgZ2l2ZXMgeW91IGFuIGFjdGl2ZSBEQiBoYW5kbGUuIFlvdSBwcm9iYWJseSB3YW50ICR0LlxuICB2YXIgJCA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgc2V0dXAob3BlbkRhdGFiYXNlcywgYXBpLCBkYk9wdHMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBtZXRhZGF0YSA9IHJlcy5tZXRhZGF0YTtcbiAgICAgICAgYXJncy51bnNoaWZ0KHJlcy5pZGIpO1xuICAgICAgICBmdW4uYXBwbHkoYXBpLCBhcmdzKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGxhc3QgPSBhcmdzLnVuc2hpZnQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsYXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbGFzdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbiAgLy8gdGhlIHByb21pc2UgdmVyc2lvbiBvZiAkXG4gIHZhciAkcCA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZXR1cChvcGVuRGF0YWJhc2VzLCBhcGksIGRiT3B0cykudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgbWV0YWRhdGEgPSByZXMubWV0YWRhdGE7XG4gICAgICAgICAgYXJncy51bnNoaWZ0KHJlcy5pZGIpO1xuXG4gICAgICAgICAgcmV0dXJuIGZ1bi5hcHBseShhcGksIGFyZ3MpO1xuICAgICAgICB9KS50aGVuKHJlc29sdmUpXG4gICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICAvLyBXcmFwcGVyIHRoYXQgZ2l2ZXMgeW91IGEgc2FmZSB0cmFuc2FjdGlvbiBoYW5kbGUuIEl0J3MgaW1wb3J0YW50IHRvIHVzZVxuICAvLyB0aGlzIGluc3RlYWQgb2Ygb3BlbmluZyB5b3VyIG93biB0cmFuc2FjdGlvbiBmcm9tIGEgZGIgaGFuZGxlIGdvdCBmcm9tICQsXG4gIC8vIGJlY2F1c2UgaW4gdGhlIHRpbWUgYmV0d2VlbiBnZXR0aW5nIHRoZSBkYiBoYW5kbGUgYW5kIG9wZW5pbmcgdGhlXG4gIC8vIHRyYW5zYWN0aW9uIGl0IG1heSBoYXZlIGJlZW4gaW52YWxpZGF0ZWQgYnkgaW5kZXggY2hhbmdlcy5cbiAgdmFyICR0ID0gZnVuY3Rpb24gKGZ1biwgc3RvcmVzLCBtb2RlKSB7XG4gICAgc3RvcmVzID0gc3RvcmVzIHx8IFtET0NfU1RPUkVdO1xuICAgIG1vZGUgPSBtb2RlIHx8ICdyZWFkb25seSc7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgdmFyIHR4biA9IHt9O1xuICAgICAgc2V0dXAob3BlbkRhdGFiYXNlcywgYXBpLCBkYk9wdHMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBtZXRhZGF0YSA9IHJlcy5tZXRhZGF0YTtcbiAgICAgICAgdHhuLnR4biA9IHJlcy5pZGIudHJhbnNhY3Rpb24oc3RvcmVzLCBtb2RlKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KHR4bik7XG4gICAgICAgIGZ1bi5hcHBseShhcGksIGFyZ3MpO1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZXN0YWJsaXNoIHRyYW5zYWN0aW9uIHNhZmVseScpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIHR4bi5lcnJvciA9IGVycjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgYXBpLl9vcGVuVHJhbnNhY3Rpb25TYWZlbHkgPSBmdW5jdGlvbiAoc3RvcmVzLCBtb2RlLCBjYWxsYmFjaykge1xuICAgICR0KGZ1bmN0aW9uICh0eG4sIGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjayh0eG4uZXJyb3IsIHR4bi50eG4pO1xuICAgIH0sIHN0b3JlcywgbW9kZSkoY2FsbGJhY2spO1xuICB9O1xuXG4gIGFwaS5fcmVtb3RlID0gZmFsc2U7XG4gIGFwaS50eXBlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQURBUFRFUl9OQU1FOyB9O1xuXG4gIGFwaS5faWQgPSAkKGZ1bmN0aW9uIChfLCBjYikge1xuICAgIGNiKG51bGwsIG1ldGFkYXRhLmRiX3V1aWQpO1xuICB9KTtcblxuICBhcGkuX2luZm8gPSAkKGZ1bmN0aW9uIChfLCBjYikge1xuICAgIHJldHVybiBpbmZvKG1ldGFkYXRhLCBjYik7XG4gIH0pO1xuXG4gIGFwaS5fZ2V0ID0gJHQoZ2V0KTtcblxuICBhcGkuX2J1bGtEb2NzID0gJChmdW5jdGlvbiAoXywgcmVxLCBvcHRzLCBjYWxsYmFjaykge1xuICAgIGJ1bGtEb2NzKGFwaSwgcmVxLCBvcHRzLCBtZXRhZGF0YSwgZGJPcHRzLCBpZGJDaGFuZ2VzLCBjYWxsYmFjayk7XG4gIH0pO1xuXG4gIGFwaS5fYWxsRG9jcyA9ICR0KGZ1bmN0aW9uICh0eG4sIG9wdHMsIGNiKSB7XG4gICAgYWxsRG9jcyh0eG4sIG1ldGFkYXRhLCBvcHRzLCBjYik7XG4gIH0pO1xuXG4gIGFwaS5fZ2V0QXR0YWNobWVudCA9ICR0KGdldEF0dGFjaG1lbnQpO1xuXG4gIGFwaS5fY2hhbmdlcyA9ICR0KGZ1bmN0aW9uICh0eG4sIG9wdHMpIHtcbiAgICBjaGFuZ2VzKHR4biwgaWRiQ2hhbmdlcywgYXBpLCBkYk9wdHMsIG9wdHMpO1xuICB9KTtcblxuICBhcGkuX2dldFJldmlzaW9uVHJlZSA9ICR0KGdldFJldmlzaW9uVHJlZSk7XG4gIGFwaS5fZG9Db21wYWN0aW9uID0gJHQoZG9Db21wYWN0aW9uLCBbRE9DX1NUT1JFXSwgJ3JlYWR3cml0ZScpO1xuXG4gIGFwaS5fY3VzdG9tRmluZEFic3RyYWN0TWFwcGVyID0ge1xuICAgIHF1ZXJ5OiAkcChxdWVyeSksXG4gICAgdmlld0NsZWFudXA6ICRwKHZpZXdDbGVhbnVwKVxuICB9O1xuXG4gIGFwaS5fZGVzdHJveSA9IGZ1bmN0aW9uIChvcHRzLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBkZXN0cm95KGRiT3B0cywgb3BlbkRhdGFiYXNlcywgaWRiQ2hhbmdlcywgY2FsbGJhY2spO1xuICB9O1xuXG4gIGFwaS5fY2xvc2UgPSAkKGZ1bmN0aW9uIChkYiwgY2IpIHtcbiAgICBkZWxldGUgb3BlbkRhdGFiYXNlc1tkYk9wdHMubmFtZV07XG4gICAgZGIuY2xvc2UoKTtcbiAgICBjYigpO1xuICB9KTtcblxuICAvLyBDbG9zaW5nIGFuZCByZS1vcGVuaW5nIHRoZSBEQiByZS1nZW5lcmF0ZXMgbmF0aXZlIGluZGV4ZXNcbiAgYXBpLl9mcmVzaGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgYXBpLl9jbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICQocmVzb2x2ZSkoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRPRE86IHRoaXMgc2V0VGltZW91dCBzZWVtcyBuYXN0eSwgaWYgaXRzIG5lZWRlZCBsZXRzXG4gIC8vIGZpZ3VyZSBvdXQgLyBleHBsYWluIHdoeVxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhudWxsLCBhcGkpO1xuICB9KTtcbn1cblxuLy8gVE9ETzogdGhpcyBpc250IHJlYWxseSB2YWxpZCBwZXJtYW5lbnRseSwganVzdCBiZWluZyBsYXp5IHRvIHN0YXJ0XG5JZGJQb3VjaC52YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBpbmRleCAoUG91Y2hEQikge1xuICBQb3VjaERCLmFkYXB0ZXIoQURBUFRFUl9OQU1FLCBJZGJQb3VjaCwgdHJ1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/pouchdb-adapter-indexeddb/lib/index.es.js\n");

/***/ })

}]);