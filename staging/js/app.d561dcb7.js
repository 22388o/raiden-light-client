(function(e){function n(n){for(var Q,s,U=n[0],c=n[1],a=n[2],i=0,r=[];i<U.length;i++)s=U[i],Object.prototype.hasOwnProperty.call(F,s)&&F[s]&&r.push(F[s][0]),F[s]=0;for(Q in c)Object.prototype.hasOwnProperty.call(c,Q)&&(e[Q]=c[Q]);l&&l(n);while(r.length)r.shift()();return B.push.apply(B,a||[]),t()}function t(){for(var e,n=0;n<B.length;n++){for(var t=B[n],Q=!0,s=1;s<t.length;s++){var U=t[s];0!==F[U]&&(Q=!1)}Q&&(B.splice(n--,1),e=c(c.s=t[0]))}return e}var Q={},s={app:0},F={app:0},B=[];function U(e){return c.p+"js/"+({}[e]||e)+"."+{"chunk-08151fa2":"248f1e1e","chunk-4c34ba5c":"f3ae5db4","chunk-5e7189c2":"17e35c26","chunk-488fc1f2":"6548e12e","chunk-b14359ce":"efc1fe7c","chunk-15f0b7af":"cc04dab4","chunk-7bc2c414":"6642ea59","chunk-552b1730":"de88027e","chunk-d3b2fbc4":"55975ca2","chunk-27f3174b":"5fca6fb2","chunk-43b69ccc":"f8d9e6d4","chunk-7e432e88":"7cc83e6e","chunk-e17a21de":"6fe8044e"}[e]+".js"}function c(n){if(Q[n])return Q[n].exports;var t=Q[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,c),t.l=!0,t.exports}c.e=function(e){var n=[],t={"chunk-08151fa2":1,"chunk-4c34ba5c":1,"chunk-5e7189c2":1,"chunk-488fc1f2":1,"chunk-b14359ce":1,"chunk-15f0b7af":1,"chunk-7bc2c414":1,"chunk-552b1730":1,"chunk-d3b2fbc4":1,"chunk-27f3174b":1,"chunk-43b69ccc":1,"chunk-7e432e88":1,"chunk-e17a21de":1};s[e]?n.push(s[e]):0!==s[e]&&t[e]&&n.push(s[e]=new Promise((function(n,t){for(var Q="css/"+({}[e]||e)+"."+{"chunk-08151fa2":"b6ac451a","chunk-4c34ba5c":"39ba85ce","chunk-5e7189c2":"295d09cf","chunk-488fc1f2":"6d6e40eb","chunk-b14359ce":"59b8ab97","chunk-15f0b7af":"1d5a726d","chunk-7bc2c414":"4ec49789","chunk-552b1730":"b6b89419","chunk-d3b2fbc4":"8da4d130","chunk-27f3174b":"4454c863","chunk-43b69ccc":"c60dbc20","chunk-7e432e88":"f27e0b35","chunk-e17a21de":"1740c2a4"}[e]+".css",F=c.p+Q,B=document.getElementsByTagName("link"),U=0;U<B.length;U++){var a=B[U],i=a.getAttribute("data-href")||a.getAttribute("href");if("stylesheet"===a.rel&&(i===Q||i===F))return n()}var r=document.getElementsByTagName("style");for(U=0;U<r.length;U++){a=r[U],i=a.getAttribute("data-href");if(i===Q||i===F)return n()}var l=document.createElement("link");l.rel="stylesheet",l.type="text/css",l.onload=n,l.onerror=function(n){var Q=n&&n.target&&n.target.src||F,B=new Error("Loading CSS chunk "+e+" failed.\n("+Q+")");B.code="CSS_CHUNK_LOAD_FAILED",B.request=Q,delete s[e],l.parentNode.removeChild(l),t(B)},l.href=F;var I=document.getElementsByTagName("head")[0];I.appendChild(l)})).then((function(){s[e]=0})));var Q=F[e];if(0!==Q)if(Q)n.push(Q[2]);else{var B=new Promise((function(n,t){Q=F[e]=[n,t]}));n.push(Q[2]=B);var a,i=document.createElement("script");i.charset="utf-8",i.timeout=120,c.nc&&i.setAttribute("nonce",c.nc),i.src=U(e);var r=new Error;a=function(n){i.onerror=i.onload=null,clearTimeout(l);var t=F[e];if(0!==t){if(t){var Q=n&&("load"===n.type?"missing":n.type),s=n&&n.target&&n.target.src;r.message="Loading chunk "+e+" failed.\n("+Q+": "+s+")",r.name="ChunkLoadError",r.type=Q,r.request=s,t[1](r)}F[e]=void 0}};var l=setTimeout((function(){a({type:"timeout",target:i})}),12e4);i.onerror=i.onload=a,document.head.appendChild(i)}return Promise.all(n)},c.m=e,c.c=Q,c.d=function(e,n,t){c.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},c.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},c.t=function(e,n){if(1&n&&(e=c(e)),8&n)return e;if(4&n&&"object"===typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(c.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var Q in e)c.d(t,Q,function(n){return e[n]}.bind(null,Q));return t},c.n=function(e){var n=e&&e.__esModule?function(){return e["default"]}:function(){return e};return c.d(n,"a",n),n},c.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},c.p="/staging/",c.oe=function(e){throw console.error(e),e};var a=window["webpackJsonp"]=window["webpackJsonp"]||[],i=a.push.bind(a);a.push=n,a=a.slice();for(var r=0;r<a.length;r++)n(a[r]);var l=i;B.push([0,"chunk-vendors"]),t()})({0:function(e,n,t){e.exports=t("cd49")},"09b0":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9IZWFkZXJJZGVudGljb24udnVlP2E3MWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMDliMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///09b0\n")},"0f75":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Filters; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("2b0e");\n/* harmony import */ var _utils_balance_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("a3d5");\n/* harmony import */ var lodash_split__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("6625");\n/* harmony import */ var lodash_split__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_split__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lodash_capitalize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("e9a71");\n/* harmony import */ var lodash_capitalize__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_capitalize__WEBPACK_IMPORTED_MODULE_3__);\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar Filters = /*#__PURE__*/function () {\n  function Filters() {\n    _classCallCheck(this, Filters);\n  }\n\n  _createClass(Filters, null, [{\n    key: "truncate",\n    value: function truncate(value) {\n      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;\n      var separator = \'...\';\n\n      if (value.length <= width) {\n        return value;\n      } else {\n        var substWidth = Math.floor(width / 2);\n        return value.substr(0, substWidth) + separator + value.substr(value.length - substWidth);\n      }\n    }\n  }, {\n    key: "decimals",\n    value: function decimals(value) {\n      var _decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n\n      return parseFloat(value).toFixed(_decimals);\n    }\n  }, {\n    key: "upper",\n    value: function upper(value) {\n      if (!value) {\n        return \'\';\n      }\n\n      return value.toLocaleUpperCase();\n    }\n  }, {\n    key: "displayFormat",\n    value: function displayFormat(amount, decimals) {\n      var units = _utils_balance_utils__WEBPACK_IMPORTED_MODULE_1__[/* BalanceUtils */ "a"].toUnits(amount, decimals || 18);\n      var deposit = parseFloat(units);\n\n      if (deposit === 0) {\n        return \'0.0\';\n      } else if (deposit < 0.000001) {\n        return \'<0.000001\';\n      } else {\n        var _split = lodash_split__WEBPACK_IMPORTED_MODULE_2___default()(units, \'.\'),\n            _split2 = _slicedToArray(_split, 2),\n            integerPart = _split2[0],\n            decimalPart = _split2[1];\n\n        if (decimalPart && decimalPart.length > 6) {\n          var newDecimal = decimalPart.substring(0, 6);\n          return "\\u2248".concat(integerPart, ".").concat(newDecimal);\n        } else {\n          return units;\n        }\n      }\n    }\n  }, {\n    key: "capitalizeFirst",\n    value: function capitalizeFirst(value) {\n      return lodash_capitalize__WEBPACK_IMPORTED_MODULE_3___default()(value);\n    }\n  }]);\n\n  return Filters;\n}();\n\n\n\nFilters.toUnits = function (wei, decimals) {\n  return _utils_balance_utils__WEBPACK_IMPORTED_MODULE_1__[/* BalanceUtils */ "a"].toUnits(wei, decimals || 18);\n};\n\nvue__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].filter(\'truncate\', Filters.truncate);\nvue__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].filter(\'decimals\', Filters.decimals);\nvue__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].filter(\'upper\', Filters.upper);\nvue__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].filter(\'displayFormat\', Filters.displayFormat);\nvue__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].filter(\'capitalizeFirst\', Filters.capitalizeFirst);\nvue__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].filter(\'toUnits\', Filters.toUnits);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZmlsdGVycy50cz85NzZiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7SUFFcUIsTzs7Ozs7Ozs2QkFDSCxLLEVBQWlDO0FBQUEsVUFBbEIsS0FBa0IsdUVBQUYsRUFBRTtBQUMvQyxVQUFNLFNBQVMsR0FBRyxLQUFsQjs7QUFDQSxVQUFJLEtBQUssQ0FBQyxNQUFOLElBQWdCLEtBQXBCLEVBQTJCO0FBQ3pCLGVBQU8sS0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLFlBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsS0FBSyxHQUFHLENBQW5CLENBQW5CO0FBQ0EsZUFDRSxLQUFLLENBQUMsTUFBTixDQUFhLENBQWIsRUFBZ0IsVUFBaEIsSUFDQSxTQURBLEdBRUEsS0FBSyxDQUFDLE1BQU4sQ0FBYSxLQUFLLENBQUMsTUFBTixHQUFlLFVBQTVCLENBSEY7QUFLRDtBQUNGOzs7NkJBRWUsSyxFQUFtQztBQUFBLFVBQXBCLFNBQW9CLHVFQUFELENBQUM7O0FBQ2pELGFBQU8sVUFBVSxDQUFDLEtBQUQsQ0FBVixDQUFrQixPQUFsQixDQUEwQixTQUExQixDQUFQO0FBQ0Q7OzswQkFFWSxLLEVBQWM7QUFDekIsVUFBSSxDQUFDLEtBQUwsRUFBWTtBQUNWLGVBQU8sRUFBUDtBQUNEOztBQUNELGFBQU8sS0FBSyxDQUFDLGlCQUFOLEVBQVA7QUFDRDs7O2tDQUVvQixNLEVBQW1CLFEsRUFBaUI7QUFDdkQsVUFBTSxLQUFLLEdBQUcseUVBQVksQ0FBQyxPQUFiLENBQXFCLE1BQXJCLEVBQTZCLFFBQVEsSUFBSSxFQUF6QyxDQUFkO0FBQ0EsVUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLEtBQUQsQ0FBMUI7O0FBQ0EsVUFBSSxPQUFPLEtBQUssQ0FBaEIsRUFBbUI7QUFDakIsZUFBTyxLQUFQO0FBQ0QsT0FGRCxNQUVPLElBQUksT0FBTyxHQUFHLFFBQWQsRUFBd0I7QUFDN0IsZUFBTyxXQUFQO0FBQ0QsT0FGTSxNQUVBO0FBQUEscUJBQzhCLG1EQUFLLENBQUMsS0FBRCxFQUFRLEdBQVIsQ0FEbkM7QUFBQTtBQUFBLFlBQ0UsV0FERjtBQUFBLFlBQ2UsV0FEZjs7QUFHTCxZQUFJLFdBQVcsSUFBSSxXQUFXLENBQUMsTUFBWixHQUFxQixDQUF4QyxFQUEyQztBQUN6QyxjQUFJLFVBQVUsR0FBRyxXQUFXLENBQUMsU0FBWixDQUFzQixDQUF0QixFQUF5QixDQUF6QixDQUFqQjtBQUNBLGlDQUFXLFdBQVgsY0FBMEIsVUFBMUI7QUFDRCxTQUhELE1BR087QUFDTCxpQkFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNGOzs7b0NBRXNCLEssRUFBYTtBQUNsQyxhQUFPLHdEQUFVLENBQUMsS0FBRCxDQUFqQjtBQUNEOzs7Ozs7OztBQUVNLGtCQUFVLFVBQUMsR0FBRCxFQUFpQixRQUFqQjtBQUFBLFNBQ2YseUVBQVksQ0FBQyxPQUFiLENBQXFCLEdBQXJCLEVBQTBCLFFBQVEsSUFBSSxFQUF0QyxDQURlO0FBQUEsQ0FBVjs7QUFJVCxtREFBRyxDQUFDLE1BQUosQ0FBVyxVQUFYLEVBQXVCLE9BQU8sQ0FBQyxRQUEvQjtBQUNBLG1EQUFHLENBQUMsTUFBSixDQUFXLFVBQVgsRUFBdUIsT0FBTyxDQUFDLFFBQS9CO0FBQ0EsbURBQUcsQ0FBQyxNQUFKLENBQVcsT0FBWCxFQUFvQixPQUFPLENBQUMsS0FBNUI7QUFDQSxtREFBRyxDQUFDLE1BQUosQ0FBVyxlQUFYLEVBQTRCLE9BQU8sQ0FBQyxhQUFwQztBQUNBLG1EQUFHLENBQUMsTUFBSixDQUFXLGlCQUFYLEVBQThCLE9BQU8sQ0FBQyxlQUF0QztBQUNBLG1EQUFHLENBQUMsTUFBSixDQUFXLFNBQVgsRUFBc0IsT0FBTyxDQUFDLE9BQTlCIiwiZmlsZSI6IjBmNzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdldGhlcnMvdXRpbHMnO1xuaW1wb3J0IHsgQmFsYW5jZVV0aWxzIH0gZnJvbSAnQC91dGlscy9iYWxhbmNlLXV0aWxzJztcbmltcG9ydCBzcGxpdCBmcm9tICdsb2Rhc2gvc3BsaXQnO1xuaW1wb3J0IGNhcGl0YWxpemUgZnJvbSAnbG9kYXNoL2NhcGl0YWxpemUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWx0ZXJzIHtcbiAgc3RhdGljIHRydW5jYXRlKHZhbHVlOiBzdHJpbmcsIHdpZHRoOiBudW1iZXIgPSAxMikge1xuICAgIGNvbnN0IHNlcGFyYXRvciA9ICcuLi4nO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gd2lkdGgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3Vic3RXaWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyAyKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZhbHVlLnN1YnN0cigwLCBzdWJzdFdpZHRoKSArXG4gICAgICAgIHNlcGFyYXRvciArXG4gICAgICAgIHZhbHVlLnN1YnN0cih2YWx1ZS5sZW5ndGggLSBzdWJzdFdpZHRoKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZGVjaW1hbHModmFsdWU6IHN0cmluZywgZGVjaW1hbHM6IG51bWJlciA9IDMpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkudG9GaXhlZChkZWNpbWFscyk7XG4gIH1cblxuICBzdGF0aWMgdXBwZXIodmFsdWU/OiBzdHJpbmcpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS50b0xvY2FsZVVwcGVyQ2FzZSgpO1xuICB9XG5cbiAgc3RhdGljIGRpc3BsYXlGb3JtYXQoYW1vdW50OiBCaWdOdW1iZXIsIGRlY2ltYWxzPzogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCB1bml0cyA9IEJhbGFuY2VVdGlscy50b1VuaXRzKGFtb3VudCwgZGVjaW1hbHMgfHwgMTgpO1xuICAgIGNvbnN0IGRlcG9zaXQgPSBwYXJzZUZsb2F0KHVuaXRzKTtcbiAgICBpZiAoZGVwb3NpdCA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwLjAnO1xuICAgIH0gZWxzZSBpZiAoZGVwb3NpdCA8IDAuMDAwMDAxKSB7XG4gICAgICByZXR1cm4gJzwwLjAwMDAwMSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gc3BsaXQodW5pdHMsICcuJyk7XG5cbiAgICAgIGlmIChkZWNpbWFsUGFydCAmJiBkZWNpbWFsUGFydC5sZW5ndGggPiA2KSB7XG4gICAgICAgIGxldCBuZXdEZWNpbWFsID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIDYpO1xuICAgICAgICByZXR1cm4gYOKJiCR7aW50ZWdlclBhcnR9LiR7bmV3RGVjaW1hbH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBjYXBpdGFsaXplRmlyc3QodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGNhcGl0YWxpemUodmFsdWUpO1xuICB9XG5cbiAgc3RhdGljIHRvVW5pdHMgPSAod2VpOiBCaWdOdW1iZXIsIGRlY2ltYWxzPzogbnVtYmVyKSA9PlxuICAgIEJhbGFuY2VVdGlscy50b1VuaXRzKHdlaSwgZGVjaW1hbHMgfHwgMTgpO1xufVxuXG5WdWUuZmlsdGVyKCd0cnVuY2F0ZScsIEZpbHRlcnMudHJ1bmNhdGUpO1xuVnVlLmZpbHRlcignZGVjaW1hbHMnLCBGaWx0ZXJzLmRlY2ltYWxzKTtcblZ1ZS5maWx0ZXIoJ3VwcGVyJywgRmlsdGVycy51cHBlcik7XG5WdWUuZmlsdGVyKCdkaXNwbGF5Rm9ybWF0JywgRmlsdGVycy5kaXNwbGF5Rm9ybWF0KTtcblZ1ZS5maWx0ZXIoJ2NhcGl0YWxpemVGaXJzdCcsIEZpbHRlcnMuY2FwaXRhbGl6ZUZpcnN0KTtcblZ1ZS5maWx0ZXIoJ3RvVW5pdHMnLCBGaWx0ZXJzLnRvVW5pdHMpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0f75\n')},"0ff6":function(module){eval('module.exports = JSON.parse("{\\"contracts_version\\":null,\\"chain_id\\":4,\\"contracts\\":{\\"ServiceRegistry\\":{\\"address\\":\\"0x6a922ADB133502d9Bf55aa9897580C1be159a8b2\\",\\"transaction_hash\\":\\"0xd206df08ae6d2107efcfae3c666456580f2d9b2a62d8f3fdcaa95c86e66ffbcc\\",\\"block_number\\":5907112,\\"gas_cost\\":1980416,\\"constructor_arguments\\":[\\"0xec3BD5D6CE7c29b434ec77a638c0F4E6441225e8\\",\\"0x0000000000000000000000000000000000000000\\",2e+21,6,5,17280000,1000,17280000]},\\"UserDeposit\\":{\\"address\\":\\"0x7a6afd06Ef28dA0479cfd47CbCF68B9E4fd6fFbe\\",\\"transaction_hash\\":\\"0x3ad7e5b3080fd8ef6018b296a8a87047b1a91536c2247161cd07ea5ff96a1141\\",\\"block_number\\":5907113,\\"gas_cost\\":1530254,\\"constructor_arguments\\":[\\"0xec3BD5D6CE7c29b434ec77a638c0F4E6441225e8\\",1.157920892373162e+77]},\\"MonitoringService\\":{\\"address\\":\\"0x709282aE42C9Df6F156F8A92fC110Fed039DCdB3\\",\\"transaction_hash\\":\\"0x7809b24fa2f04603dab3cc9f7a2a2c310f244dcbbb93960542b4f7eb15475142\\",\\"block_number\\":5907114,\\"gas_cost\\":1949685,\\"constructor_arguments\\":[\\"0xec3BD5D6CE7c29b434ec77a638c0F4E6441225e8\\",\\"0x6a922ADB133502d9Bf55aa9897580C1be159a8b2\\",\\"0x7a6afd06Ef28dA0479cfd47CbCF68B9E4fd6fFbe\\",\\"0x9B5ef38daA6Cb7f9914cd4635504B63BB410e0F1\\"]},\\"OneToN\\":{\\"address\\":\\"0x083a0411483b3Fb9eb9ccfb1F07003BF8f27D094\\",\\"transaction_hash\\":\\"0x63d88efd315657d9b8e370a04f77b290d06909d5211248f5c05695539438c2e3\\",\\"block_number\\":5907115,\\"gas_cost\\":1097569,\\"constructor_arguments\\":[\\"0x7a6afd06Ef28dA0479cfd47CbCF68B9E4fd6fFbe\\",4,\\"0x6a922ADB133502d9Bf55aa9897580C1be159a8b2\\"]}}}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIwZmY2LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0ff6\n')},1:function(module,exports){eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYnVmZmVyIChpZ25vcmVkKT9mNmZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")},"152b":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9ab4");\n/* harmony import */ var vue_property_decorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("60a3");\n/* harmony import */ var _router_route_names__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("80bf");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\nvar NavigationMixin = /*#__PURE__*/function (_Vue) {\n  _inherits(NavigationMixin, _Vue);\n\n  var _super = _createSuper(NavigationMixin);\n\n  function NavigationMixin() {\n    _classCallCheck(this, NavigationMixin);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(NavigationMixin, [{\n    key: "navigateToSelectHub",\n    value: function navigateToSelectHub(token) {\n      this.$router.push({\n        name: _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].SELECT_HUB,\n        params: {\n          token: token\n        }\n      });\n    }\n  }, {\n    key: "navigateToHome",\n    value: function navigateToHome() {\n      this.$router.push({\n        name: _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].HOME\n      }).catch(function () {});\n    }\n  }, {\n    key: "navigateToOpenChannel",\n    value: function navigateToOpenChannel(token, partner) {\n      this.$router.push({\n        name: _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].OPEN_CHANNEL,\n        params: {\n          token: token,\n          partner: partner\n        }\n      });\n    }\n  }, {\n    key: "navigateToChannels",\n    value: function navigateToChannels(token) {\n      this.$router.push({\n        name: _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].CHANNELS,\n        params: {\n          token: token\n        }\n      });\n    }\n  }, {\n    key: "navigateToSelectTransferTarget",\n    value: function navigateToSelectTransferTarget(token, target, amount) {\n      var route = {\n        name: _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].TRANSFER,\n        params: {\n          token: token\n        },\n        query: {}\n      };\n\n      if (target && amount) {\n        route.query = {\n          target: target,\n          amount: amount\n        };\n      }\n\n      this.$router.push(route);\n    }\n  }, {\n    key: "navigateToTokenSelect",\n    value: function navigateToTokenSelect() {\n      this.$router.push({\n        name: _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].SELECT_TOKEN\n      });\n    }\n  }, {\n    key: "navigateToTransferSteps",\n    value: function navigateToTransferSteps(target, amount) {\n      this.$router.push({\n        name: _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].TRANSFER_STEPS,\n        params: {\n          target: target\n        },\n        query: {\n          amount: amount\n        }\n      });\n    }\n  }, {\n    key: "navigateToGeneralHome",\n    value: function navigateToGeneralHome() {\n      this.$router.push({\n        name: _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].GENERAL_HOME\n      });\n    }\n  }, {\n    key: "navigateToBackupState",\n    value: function navigateToBackupState() {\n      this.$router.push({\n        name: _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].BACKUP_STATE\n      });\n    }\n  }, {\n    key: "onGeneralBackClicked",\n    value: function onGeneralBackClicked() {\n      this.$router.go(-1);\n    }\n  }, {\n    key: "onBackClicked",\n    value: function onBackClicked() {\n      switch (this.$route.name) {\n        case _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].TRANSFER_STEPS:\n          this.navigateToSelectTransferTarget(this.$route.params.token, this.$route.params.target, this.$route.params.amount);\n          break;\n\n        case _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].TRANSFER:\n        case _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].CHANNELS:\n        case _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].SELECT_TOKEN:\n          this.navigateToHome();\n          break;\n\n        case _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].SELECT_HUB:\n          this.navigateToTokenSelect();\n          break;\n\n        case _router_route_names__WEBPACK_IMPORTED_MODULE_2__[/* RouteNames */ "a"].OPEN_CHANNEL:\n          this.navigateToSelectHub(this.$route.params.token);\n          break;\n      }\n    }\n  }]);\n\n  return NavigationMixin;\n}(vue_property_decorator__WEBPACK_IMPORTED_MODULE_1__[/* Vue */ "e"]);\n\nNavigationMixin = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ "b"])([vue_property_decorator__WEBPACK_IMPORTED_MODULE_1__[/* Component */ "a"]], NavigationMixin);\n/* harmony default export */ __webpack_exports__["a"] = (NavigationMixin);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWl4aW5zL25hdmlnYXRpb24tbWl4aW4udHM/MDk1YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBR0EsSUFBcUIsZUFBckI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLHdDQUNzQixLQUR0QixFQUNtQztBQUMvQixXQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCO0FBQ2hCLFlBQUksRUFBRSxzRUFBVSxDQUFDLFVBREQ7QUFFaEIsY0FBTSxFQUFFO0FBQ04sZUFBSyxFQUFFO0FBREQ7QUFGUSxPQUFsQjtBQU1EO0FBUkg7QUFBQTtBQUFBLHFDQVVnQjtBQUNaLFdBQUssT0FBTCxDQUNHLElBREgsQ0FDUTtBQUNKLFlBQUksRUFBRSxzRUFBVSxDQUFDO0FBRGIsT0FEUixFQUlHLEtBSkgsQ0FJUyxZQUFLLENBQUcsQ0FKakI7QUFLRDtBQWhCSDtBQUFBO0FBQUEsMENBa0J3QixLQWxCeEIsRUFrQnVDLE9BbEJ2QyxFQWtCc0Q7QUFDbEQsV0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQjtBQUNoQixZQUFJLEVBQUUsc0VBQVUsQ0FBQyxZQUREO0FBRWhCLGNBQU0sRUFBRTtBQUNOLGVBQUssRUFBRSxLQUREO0FBRU4saUJBQU8sRUFBRTtBQUZIO0FBRlEsT0FBbEI7QUFPRDtBQTFCSDtBQUFBO0FBQUEsdUNBNEJxQixLQTVCckIsRUE0QmtDO0FBQzlCLFdBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0I7QUFDaEIsWUFBSSxFQUFFLHNFQUFVLENBQUMsUUFERDtBQUVoQixjQUFNLEVBQUU7QUFDTixlQUFLLEVBQUU7QUFERDtBQUZRLE9BQWxCO0FBTUQ7QUFuQ0g7QUFBQTtBQUFBLG1EQXNDSSxLQXRDSixFQXVDSSxNQXZDSixFQXdDSSxNQXhDSixFQXdDbUI7QUFFZixVQUFNLEtBQUssR0FBRztBQUNaLFlBQUksRUFBRSxzRUFBVSxDQUFDLFFBREw7QUFFWixjQUFNLEVBQUU7QUFBRSxlQUFLLEVBQUU7QUFBVCxTQUZJO0FBR1osYUFBSyxFQUFFO0FBSEssT0FBZDs7QUFLQSxVQUFJLE1BQU0sSUFBSSxNQUFkLEVBQXNCO0FBQ3BCLGFBQUssQ0FBQyxLQUFOLEdBQWM7QUFBRSxnQkFBTSxFQUFOLE1BQUY7QUFBVSxnQkFBTSxFQUFOO0FBQVYsU0FBZDtBQUNEOztBQUNELFdBQUssT0FBTCxDQUFhLElBQWIsQ0FBa0IsS0FBbEI7QUFDRDtBQW5ESDtBQUFBO0FBQUEsNENBcUR1QjtBQUNuQixXQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCO0FBQ2hCLFlBQUksRUFBRSxzRUFBVSxDQUFDO0FBREQsT0FBbEI7QUFHRDtBQXpESDtBQUFBO0FBQUEsNENBMkQwQixNQTNEMUIsRUEyRDBDLE1BM0QxQyxFQTJEd0Q7QUFDcEQsV0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQjtBQUNoQixZQUFJLEVBQUUsc0VBQVUsQ0FBQyxjQUREO0FBRWhCLGNBQU0sRUFBRTtBQUFFLGdCQUFNLEVBQU47QUFBRixTQUZRO0FBR2hCLGFBQUssRUFBRTtBQUFFLGdCQUFNLEVBQU47QUFBRjtBQUhTLE9BQWxCO0FBS0Q7QUFqRUg7QUFBQTtBQUFBLDRDQW1FdUI7QUFDbkIsV0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQjtBQUNoQixZQUFJLEVBQUUsc0VBQVUsQ0FBQztBQURELE9BQWxCO0FBR0Q7QUF2RUg7QUFBQTtBQUFBLDRDQXlFdUI7QUFDbkIsV0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQjtBQUNoQixZQUFJLEVBQUUsc0VBQVUsQ0FBQztBQURELE9BQWxCO0FBR0Q7QUE3RUg7QUFBQTtBQUFBLDJDQStFc0I7QUFDbEIsV0FBSyxPQUFMLENBQWEsRUFBYixDQUFnQixDQUFDLENBQWpCO0FBQ0Q7QUFqRkg7QUFBQTtBQUFBLG9DQW1GZTtBQUNYLGNBQVEsS0FBSyxNQUFMLENBQVksSUFBcEI7QUFDRSxhQUFLLHNFQUFVLENBQUMsY0FBaEI7QUFDRSxlQUFLLDhCQUFMLENBQ0UsS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixLQURyQixFQUVFLEtBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUIsTUFGckIsRUFHRSxLQUFLLE1BQUwsQ0FBWSxNQUFaLENBQW1CLE1BSHJCO0FBS0E7O0FBQ0YsYUFBSyxzRUFBVSxDQUFDLFFBQWhCO0FBQ0EsYUFBSyxzRUFBVSxDQUFDLFFBQWhCO0FBQ0EsYUFBSyxzRUFBVSxDQUFDLFlBQWhCO0FBQ0UsZUFBSyxjQUFMO0FBQ0E7O0FBQ0YsYUFBSyxzRUFBVSxDQUFDLFVBQWhCO0FBQ0UsZUFBSyxxQkFBTDtBQUNBOztBQUNGLGFBQUssc0VBQVUsQ0FBQyxZQUFoQjtBQUNFLGVBQUssbUJBQUwsQ0FBeUIsS0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixLQUE1QztBQUNBO0FBbEJKO0FBb0JEO0FBeEdIOztBQUFBO0FBQUEsRUFBNkMsa0VBQTdDOztBQUFxQixlQUFlLHFFQURuQyx3RUFDbUMsR0FBZixlQUFlLENBQWY7QUFBQSx3RSIsImZpbGUiOiIxNTJiLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBWdWUgfSBmcm9tICd2dWUtcHJvcGVydHktZGVjb3JhdG9yJztcbmltcG9ydCB7IFJvdXRlTmFtZXMgfSBmcm9tICdAL3JvdXRlci9yb3V0ZS1uYW1lcyc7XG5cbkBDb21wb25lbnRcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRpb25NaXhpbiBleHRlbmRzIFZ1ZSB7XG4gIG5hdmlnYXRlVG9TZWxlY3RIdWIodG9rZW46IHN0cmluZykge1xuICAgIHRoaXMuJHJvdXRlci5wdXNoKHtcbiAgICAgIG5hbWU6IFJvdXRlTmFtZXMuU0VMRUNUX0hVQixcbiAgICAgIHBhcmFtczoge1xuICAgICAgICB0b2tlbjogdG9rZW5cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG5hdmlnYXRlVG9Ib21lKCkge1xuICAgIHRoaXMuJHJvdXRlclxuICAgICAgLnB1c2goe1xuICAgICAgICBuYW1lOiBSb3V0ZU5hbWVzLkhPTUVcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKCkgPT4ge30pO1xuICB9XG5cbiAgbmF2aWdhdGVUb09wZW5DaGFubmVsKHRva2VuOiBzdHJpbmcsIHBhcnRuZXI6IHN0cmluZykge1xuICAgIHRoaXMuJHJvdXRlci5wdXNoKHtcbiAgICAgIG5hbWU6IFJvdXRlTmFtZXMuT1BFTl9DSEFOTkVMLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHRva2VuOiB0b2tlbixcbiAgICAgICAgcGFydG5lcjogcGFydG5lclxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbmF2aWdhdGVUb0NoYW5uZWxzKHRva2VuOiBzdHJpbmcpIHtcbiAgICB0aGlzLiRyb3V0ZXIucHVzaCh7XG4gICAgICBuYW1lOiBSb3V0ZU5hbWVzLkNIQU5ORUxTLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHRva2VuOiB0b2tlblxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbmF2aWdhdGVUb1NlbGVjdFRyYW5zZmVyVGFyZ2V0KFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgdGFyZ2V0Pzogc3RyaW5nLFxuICAgIGFtb3VudD86IHN0cmluZ1xuICApIHtcbiAgICBjb25zdCByb3V0ZSA9IHtcbiAgICAgIG5hbWU6IFJvdXRlTmFtZXMuVFJBTlNGRVIsXG4gICAgICBwYXJhbXM6IHsgdG9rZW46IHRva2VuIH0sXG4gICAgICBxdWVyeToge31cbiAgICB9O1xuICAgIGlmICh0YXJnZXQgJiYgYW1vdW50KSB7XG4gICAgICByb3V0ZS5xdWVyeSA9IHsgdGFyZ2V0LCBhbW91bnQgfTtcbiAgICB9XG4gICAgdGhpcy4kcm91dGVyLnB1c2gocm91dGUpO1xuICB9XG5cbiAgbmF2aWdhdGVUb1Rva2VuU2VsZWN0KCkge1xuICAgIHRoaXMuJHJvdXRlci5wdXNoKHtcbiAgICAgIG5hbWU6IFJvdXRlTmFtZXMuU0VMRUNUX1RPS0VOXG4gICAgfSk7XG4gIH1cblxuICBuYXZpZ2F0ZVRvVHJhbnNmZXJTdGVwcyh0YXJnZXQ6IHN0cmluZywgYW1vdW50OiBzdHJpbmcpIHtcbiAgICB0aGlzLiRyb3V0ZXIucHVzaCh7XG4gICAgICBuYW1lOiBSb3V0ZU5hbWVzLlRSQU5TRkVSX1NURVBTLFxuICAgICAgcGFyYW1zOiB7IHRhcmdldCB9LFxuICAgICAgcXVlcnk6IHsgYW1vdW50IH1cbiAgICB9KTtcbiAgfVxuXG4gIG5hdmlnYXRlVG9HZW5lcmFsSG9tZSgpIHtcbiAgICB0aGlzLiRyb3V0ZXIucHVzaCh7XG4gICAgICBuYW1lOiBSb3V0ZU5hbWVzLkdFTkVSQUxfSE9NRVxuICAgIH0pO1xuICB9XG5cbiAgbmF2aWdhdGVUb0JhY2t1cFN0YXRlKCkge1xuICAgIHRoaXMuJHJvdXRlci5wdXNoKHtcbiAgICAgIG5hbWU6IFJvdXRlTmFtZXMuQkFDS1VQX1NUQVRFXG4gICAgfSk7XG4gIH1cblxuICBvbkdlbmVyYWxCYWNrQ2xpY2tlZCgpIHtcbiAgICB0aGlzLiRyb3V0ZXIuZ28oLTEpO1xuICB9XG5cbiAgb25CYWNrQ2xpY2tlZCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuJHJvdXRlLm5hbWUpIHtcbiAgICAgIGNhc2UgUm91dGVOYW1lcy5UUkFOU0ZFUl9TVEVQUzpcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZVRvU2VsZWN0VHJhbnNmZXJUYXJnZXQoXG4gICAgICAgICAgdGhpcy4kcm91dGUucGFyYW1zLnRva2VuLFxuICAgICAgICAgIHRoaXMuJHJvdXRlLnBhcmFtcy50YXJnZXQsXG4gICAgICAgICAgdGhpcy4kcm91dGUucGFyYW1zLmFtb3VudFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUm91dGVOYW1lcy5UUkFOU0ZFUjpcbiAgICAgIGNhc2UgUm91dGVOYW1lcy5DSEFOTkVMUzpcbiAgICAgIGNhc2UgUm91dGVOYW1lcy5TRUxFQ1RfVE9LRU46XG4gICAgICAgIHRoaXMubmF2aWdhdGVUb0hvbWUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJvdXRlTmFtZXMuU0VMRUNUX0hVQjpcbiAgICAgICAgdGhpcy5uYXZpZ2F0ZVRvVG9rZW5TZWxlY3QoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJvdXRlTmFtZXMuT1BFTl9DSEFOTkVMOlxuICAgICAgICB0aGlzLm5hdmlnYXRlVG9TZWxlY3RIdWIodGhpcy4kcm91dGUucGFyYW1zLnRva2VuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///152b\n')},1922:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9SYWlkZW5EaWFsb2cudnVlPzMyNjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTkyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1922\n")},"1a2b":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_NoTokens_vue_vue_type_style_index_0_id_4f16408a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("f45e");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_NoTokens_vue_vue_type_style_index_0_id_4f16408a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_NoTokens_vue_vue_type_style_index_0_id_4f16408a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_NoTokens_vue_vue_type_style_index_0_id_4f16408a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ob1Rva2Vucy52dWU/M2NmNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBZ2xCLENBQWdCLDhtQkFBRyxFQUFDIiwiZmlsZSI6IjFhMmIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS04LW9uZU9mLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS04LW9uZU9mLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS04LW9uZU9mLTEtMiEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL05vVG9rZW5zLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTRmMTY0MDhhJmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tOC1vbmVPZi0xLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tOC1vbmVPZi0xLTIhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTgtb25lT2YtMS0zIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Ob1Rva2Vucy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD00ZjE2NDA4YSZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1a2b\n')},2:function(module,exports){eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCk/MjZiNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogKGlnbm9yZWQpICovIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n")},"233e":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e349156a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/HeaderIdenticon.vue?vue&type=template&id=b740b99e&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"header-identicon"},[(_vm.pendingTransferAmount)?_c(\'v-tooltip\',{attrs:{"bottom":""},scopedSlots:_vm._u([{key:"activator",fn:function(ref){\nvar on = ref.on;\nreturn [_c(\'v-badge\',{attrs:{"color":"primary","bordered":"","content":_vm.pendingTransferAmount,"overlap":""}},[_c(\'v-img\',_vm._g({staticClass:"header-identicon__blockie",attrs:{"src":_vm.$blockie(_vm.defaultAccount),"contain":"","aspect-ratio":"1"}},on))],1)]}}],null,false,1705622633)},[_c(\'span\',[_vm._v(" "+_vm._s(_vm.$tc(\'app-header.pending-transfers\', _vm.pendingTransferAmount, { amount: _vm.pendingTransferAmount }))+" ")])]):_c(\'v-img\',{class:{\n      \'header-identicon__blockie\': _vm.defaultAccount,\n      \'header-identicon__blockie header-identicon__blockie__grayscale\': !_vm.defaultAccount\n    },attrs:{"src":_vm.$blockie(_vm.defaultAccount),"contain":"","aspect-ratio":"1"}})],1)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/HeaderIdenticon.vue?vue&type=template&id=b740b99e&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__("9ab4");\n\n// EXTERNAL MODULE: ./node_modules/vue-property-decorator/lib/vue-property-decorator.js\nvar vue_property_decorator = __webpack_require__("60a3");\n\n// EXTERNAL MODULE: ./node_modules/vuex/dist/vuex.esm.js\nvar vuex_esm = __webpack_require__("2f62");\n\n// EXTERNAL MODULE: ./src/mixins/blockie-mixin.ts\nvar blockie_mixin = __webpack_require__("77fd");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/HeaderIdenticon.vue?vue&type=script&lang=ts&\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\nvar HeaderIdenticon = /*#__PURE__*/function (_Mixins) {\n  _inherits(HeaderIdenticon, _Mixins);\n\n  var _super = _createSuper(HeaderIdenticon);\n\n  function HeaderIdenticon() {\n    _classCallCheck(this, HeaderIdenticon);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(HeaderIdenticon, [{\n    key: "pendingTransferAmount",\n    get: function get() {\n      return Object.keys(this.pendingTransfers).length;\n    }\n  }]);\n\n  return HeaderIdenticon;\n}(Object(vue_property_decorator["c" /* Mixins */])(blockie_mixin["a" /* default */]));\n\nHeaderIdenticon = Object(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["a" /* Component */])({\n  computed: _objectSpread({}, Object(vuex_esm["c" /* mapState */])([\'defaultAccount\']), {}, Object(vuex_esm["b" /* mapGetters */])([\'pendingTransfers\']))\n})], HeaderIdenticon);\n/* harmony default export */ var HeaderIdenticonvue_type_script_lang_ts_ = (HeaderIdenticon);\n// CONCATENATED MODULE: ./src/components/HeaderIdenticon.vue?vue&type=script&lang=ts&\n /* harmony default export */ var components_HeaderIdenticonvue_type_script_lang_ts_ = (HeaderIdenticonvue_type_script_lang_ts_); \n// EXTERNAL MODULE: ./src/components/HeaderIdenticon.vue?vue&type=style&index=0&id=b740b99e&scoped=true&lang=scss&\nvar HeaderIdenticonvue_type_style_index_0_id_b740b99e_scoped_true_lang_scss_ = __webpack_require__("be88");\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__("2877");\n\n// EXTERNAL MODULE: ./node_modules/vuetify-loader/lib/runtime/installComponents.js\nvar installComponents = __webpack_require__("6544");\nvar installComponents_default = /*#__PURE__*/__webpack_require__.n(installComponents);\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VBadge/VBadge.js\nvar VBadge = __webpack_require__("4ca6");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VImg/VImg.js + 2 modules\nvar VImg = __webpack_require__("adda");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTooltip/VTooltip.js\nvar VTooltip = __webpack_require__("3a2f");\n\n// CONCATENATED MODULE: ./src/components/HeaderIdenticon.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  components_HeaderIdenticonvue_type_script_lang_ts_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "b740b99e",\n  null\n  \n)\n\n/* harmony default export */ var components_HeaderIdenticon = __webpack_exports__["a"] = (component.exports);\n\n/* vuetify-loader */\n\n\n\n\ninstallComponents_default()(component, {VBadge: VBadge["a" /* default */],VImg: VImg["a" /* default */],VTooltip: VTooltip["a" /* default */]})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9IZWFkZXJJZGVudGljb24udnVlP2ZjNDUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvSGVhZGVySWRlbnRpY29uLnZ1ZT8wYmU1Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0hlYWRlcklkZW50aWNvbi52dWU/Y2Y5YiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9IZWFkZXJJZGVudGljb24udnVlPzZhYTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwwQkFBMEIsYUFBYSwwQkFBMEIsd0JBQXdCLGlCQUFpQiwrQkFBK0IsOENBQThDLE9BQU8sWUFBWSxzQkFBc0I7QUFDaE87QUFDQSxzQkFBc0IsT0FBTyxrRkFBa0YscUJBQXFCLCtDQUErQyx3RUFBd0UsWUFBWSx5QkFBeUIsbUdBQW1HLG9DQUFvQyx3QkFBd0I7QUFDL2I7QUFDQTtBQUNBLEtBQUssUUFBUSx3RUFBd0U7QUFDckY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbUNBO0FBQ0E7QUFDQTs7QUFTQSxJQUFxQixlQUFyQjtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsd0JBSTJCO0FBQ3ZCLGFBQU8sTUFBTSxDQUFDLElBQVAsQ0FBWSxLQUFLLGdCQUFqQixFQUFtQyxNQUExQztBQUNEO0FBTkg7O0FBQUE7QUFBQSxFQUE2QyxnREFBTSxDQUFDLGdDQUFELENBQW5EOztBQUFxQixlQUFlLDRDQU5uQyxtREFBUyxDQUFDO0FBQ1QsVUFBUSxvQkFDSCxvQ0FBUSxDQUFDLENBQUMsZ0JBQUQsQ0FBRCxDQURMLE1BRUgsc0NBQVUsQ0FBQyxDQUFDLGtCQUFELENBQUQsQ0FGUDtBQURDLENBQUQsQ0FNMEIsR0FBZixlQUFlLENBQWY7QUFBQSwyRjs7QUNwRGdhLENBQWdCLDhIQUFHLEVBQUMsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQS9WO0FBQ3ZDO0FBQ0w7QUFDc0M7OztBQUdwRztBQUMwRjtBQUMxRixnQkFBZ0IsOENBQVU7QUFDMUIsRUFBRSxrREFBTTtBQUNSLEVBQUUsTUFBTTtBQUNSLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZSwyR0FBaUI7O0FBRWhDO0FBQ21HO0FBQzVDO0FBQ0o7QUFDUTtBQUMzRCwyQkFBaUIsYUFBYSxpQ0FBTSxDQUFDLDZCQUFJLENBQUMscUNBQVEsQ0FBQyIsImZpbGUiOiIyMzNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiaGVhZGVyLWlkZW50aWNvblwifSxbKF92bS5wZW5kaW5nVHJhbnNmZXJBbW91bnQpP19jKCd2LXRvb2x0aXAnLHthdHRyczp7XCJib3R0b21cIjpcIlwifSxzY29wZWRTbG90czpfdm0uX3UoW3trZXk6XCJhY3RpdmF0b3JcIixmbjpmdW5jdGlvbihyZWYpe1xudmFyIG9uID0gcmVmLm9uO1xucmV0dXJuIFtfYygndi1iYWRnZScse2F0dHJzOntcImNvbG9yXCI6XCJwcmltYXJ5XCIsXCJib3JkZXJlZFwiOlwiXCIsXCJjb250ZW50XCI6X3ZtLnBlbmRpbmdUcmFuc2ZlckFtb3VudCxcIm92ZXJsYXBcIjpcIlwifX0sW19jKCd2LWltZycsX3ZtLl9nKHtzdGF0aWNDbGFzczpcImhlYWRlci1pZGVudGljb25fX2Jsb2NraWVcIixhdHRyczp7XCJzcmNcIjpfdm0uJGJsb2NraWUoX3ZtLmRlZmF1bHRBY2NvdW50KSxcImNvbnRhaW5cIjpcIlwiLFwiYXNwZWN0LXJhdGlvXCI6XCIxXCJ9fSxvbikpXSwxKV19fV0sbnVsbCxmYWxzZSwxNzA1NjIyNjMzKX0sW19jKCdzcGFuJyxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0uJHRjKCdhcHAtaGVhZGVyLnBlbmRpbmctdHJhbnNmZXJzJywgX3ZtLnBlbmRpbmdUcmFuc2ZlckFtb3VudCwgeyBhbW91bnQ6IF92bS5wZW5kaW5nVHJhbnNmZXJBbW91bnQgfSkpK1wiIFwiKV0pXSk6X2MoJ3YtaW1nJyx7Y2xhc3M6e1xuICAgICAgJ2hlYWRlci1pZGVudGljb25fX2Jsb2NraWUnOiBfdm0uZGVmYXVsdEFjY291bnQsXG4gICAgICAnaGVhZGVyLWlkZW50aWNvbl9fYmxvY2tpZSBoZWFkZXItaWRlbnRpY29uX19ibG9ja2llX19ncmF5c2NhbGUnOiAhX3ZtLmRlZmF1bHRBY2NvdW50XG4gICAgfSxhdHRyczp7XCJzcmNcIjpfdm0uJGJsb2NraWUoX3ZtLmRlZmF1bHRBY2NvdW50KSxcImNvbnRhaW5cIjpcIlwiLFwiYXNwZWN0LXJhdGlvXCI6XCIxXCJ9fSldLDEpfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBNaXhpbnMgfSBmcm9tICd2dWUtcHJvcGVydHktZGVjb3JhdG9yJztcbmltcG9ydCB7IG1hcEdldHRlcnMsIG1hcFN0YXRlIH0gZnJvbSAndnVleCc7XG5pbXBvcnQgQmxvY2tpZU1peGluIGZyb20gJ0AvbWl4aW5zL2Jsb2NraWUtbWl4aW4nO1xuaW1wb3J0IHsgVHJhbnNmZXJzIH0gZnJvbSAnQC90eXBlcyc7XG5cbkBDb21wb25lbnQoe1xuICBjb21wdXRlZDoge1xuICAgIC4uLm1hcFN0YXRlKFsnZGVmYXVsdEFjY291bnQnXSksXG4gICAgLi4ubWFwR2V0dGVycyhbJ3BlbmRpbmdUcmFuc2ZlcnMnXSlcbiAgfVxufSlcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYWRlcklkZW50aWNvbiBleHRlbmRzIE1peGlucyhCbG9ja2llTWl4aW4pIHtcbiAgZGVmYXVsdEFjY291bnQhOiBzdHJpbmc7XG4gIHBlbmRpbmdUcmFuc2ZlcnMhOiBUcmFuc2ZlcnM7XG5cbiAgZ2V0IHBlbmRpbmdUcmFuc2ZlckFtb3VudCgpOiBudW1iZXIge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBlbmRpbmdUcmFuc2ZlcnMpLmxlbmd0aDtcbiAgfVxufVxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTE0LTAhLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xNC0zIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9IZWFkZXJJZGVudGljb24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTQtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTE0LTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0hlYWRlcklkZW50aWNvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0hlYWRlcklkZW50aWNvbi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9Yjc0MGI5OWUmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vSGVhZGVySWRlbnRpY29uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vSGVhZGVySWRlbnRpY29uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9IZWFkZXJJZGVudGljb24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9Yjc0MGI5OWUmc2NvcGVkPXRydWUmbGFuZz1zY3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCJiNzQwYjk5ZVwiLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0c1xuXG4vKiB2dWV0aWZ5LWxvYWRlciAqL1xuaW1wb3J0IGluc3RhbGxDb21wb25lbnRzIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9ydW50aW1lL2luc3RhbGxDb21wb25lbnRzLmpzXCJcbmltcG9ydCB7IFZCYWRnZSB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkJhZGdlJztcbmltcG9ydCB7IFZJbWcgfSBmcm9tICd2dWV0aWZ5L2xpYi9jb21wb25lbnRzL1ZJbWcnO1xuaW1wb3J0IHsgVlRvb2x0aXAgfSBmcm9tICd2dWV0aWZ5L2xpYi9jb21wb25lbnRzL1ZUb29sdGlwJztcbmluc3RhbGxDb21wb25lbnRzKGNvbXBvbmVudCwge1ZCYWRnZSxWSW1nLFZUb29sdGlwfSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///233e\n')},3:function(module,exports){eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCk/NGQ2MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogKGlnbm9yZWQpICovIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n")},"31a7":function(module){eval('module.exports = JSON.parse("{\\"contracts_version\\":null,\\"chain_id\\":4,\\"contracts\\":{\\"SecretRegistry\\":{\\"address\\":\\"0x7714DA9D9c577F0b89FE4774193d646F07b880c5\\",\\"transaction_hash\\":\\"0x3377ccdc9624bd432a89b6e3d068fe8dd01949f2f52b4e0538843b88b9fbcdab\\",\\"block_number\\":5907003,\\"gas_cost\\":247082,\\"constructor_arguments\\":[]},\\"TokenNetworkRegistry\\":{\\"address\\":\\"0x9B5ef38daA6Cb7f9914cd4635504B63BB410e0F1\\",\\"transaction_hash\\":\\"0x84fcd1320182f5255b93609e17056fb84a0edf4752ca6841a8a271bea7981ce4\\",\\"block_number\\":5907005,\\"gas_cost\\":4001114,\\"constructor_arguments\\":[\\"0x7714DA9D9c577F0b89FE4774193d646F07b880c5\\",4,20,555428,1.157920892373162e+77]}}}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIzMWE3LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31a7\n')},"3c58":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ConnectDialog_vue_vue_type_style_index_0_id_3604c23c_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("f33c");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ConnectDialog_vue_vue_type_style_index_0_id_3604c23c_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ConnectDialog_vue_vue_type_style_index_0_id_3604c23c_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ConnectDialog_vue_vue_type_style_index_0_id_3604c23c_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Db25uZWN0RGlhbG9nLnZ1ZT83MGEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFxbEIsQ0FBZ0IsbW5CQUFHLEVBQUMiLCJmaWxlIjoiM2M1OC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzPz9yZWYtLTgtb25lT2YtMS0wIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTgtb25lT2YtMS0xIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTgtb25lT2YtMS0yIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS04LW9uZU9mLTEtMyEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0yMS0wIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ29ubmVjdERpYWxvZy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0zNjA0YzIzYyZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzPz9yZWYtLTgtb25lT2YtMS0wIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTgtb25lT2YtMS0xIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTgtb25lT2YtMS0yIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS04LW9uZU9mLTEtMyEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0yMS0wIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ29ubmVjdERpYWxvZy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0zNjA0YzIzYyZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3c58\n')},4:function(module,exports){eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vY3J5cHRvIChpZ25vcmVkKT9iNWU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n")},"49f8":function(module,exports,__webpack_require__){eval('var map = {\n\t"./en.json": "edd4"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error("Cannot find module \'" + req + "\'");\n\t\te.code = \'MODULE_NOT_FOUND\';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = "49f8";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbG9jYWxlcyBzeW5jIFtBLVphLXowLTktXyxcXHNdK1xcLmpzb24kLz80ZGE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQ5ZjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWFwID0ge1xuXHRcIi4vZW4uanNvblwiOiBcImVkZDRcIlxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIG1hcFtyZXFdO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IFwiNDlmOFwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///49f8\n')},"4e0b2":function(module){eval('module.exports = JSON.parse("{\\"contracts_version\\":null,\\"chain_id\\":5,\\"contracts\\":{\\"ServiceRegistry\\":{\\"address\\":\\"0x1d238cdacA8fFFD56F722B587aA010d6B438B077\\",\\"transaction_hash\\":\\"0x3bdd7711721781ba977cf436d8cc77312e27b1467102927169e8aa6c3a3abdf0\\",\\"block_number\\":2114518,\\"gas_cost\\":1980416,\\"constructor_arguments\\":[\\"0x4074fD4d460d0c31cbEdC3f59B2D98626D063952\\",\\"0x0000000000000000000000000000000000000000\\",2e+21,6,5,17280000,1000,17280000]},\\"UserDeposit\\":{\\"address\\":\\"0xDd9282Ad0A36052af41c85863F8C51eEbDC68E0A\\",\\"transaction_hash\\":\\"0xabb4bf75eb1946f6342c21959d6443140ab7378f33d9a5bdb1f3a039083b1214\\",\\"block_number\\":2114520,\\"gas_cost\\":1530254,\\"constructor_arguments\\":[\\"0x4074fD4d460d0c31cbEdC3f59B2D98626D063952\\",1.157920892373162e+77]},\\"MonitoringService\\":{\\"address\\":\\"0x850C3E4914417eC41230177c2821B9514c2e2bC9\\",\\"transaction_hash\\":\\"0x2cf29dea37d02049295ffa5ea9f744cff82995c0c547f79f6bdd7f27abeae0b4\\",\\"block_number\\":2114521,\\"gas_cost\\":1949685,\\"constructor_arguments\\":[\\"0x4074fD4d460d0c31cbEdC3f59B2D98626D063952\\",\\"0x1d238cdacA8fFFD56F722B587aA010d6B438B077\\",\\"0xDd9282Ad0A36052af41c85863F8C51eEbDC68E0A\\",\\"0x9b0c8C8C75904CEf5B7a8dbF59c3459Ea85c6526\\"]},\\"OneToN\\":{\\"address\\":\\"0xe4C2C47F070152c03a564C2c681C3FbD78234156\\",\\"transaction_hash\\":\\"0xe5d1fa41d7b72feeaed494c42bd98860c49c396fe1961f9f2f5567a392018816\\",\\"block_number\\":2114523,\\"gas_cost\\":1097569,\\"constructor_arguments\\":[\\"0xDd9282Ad0A36052af41c85863F8C51eEbDC68E0A\\",5,\\"0x1d238cdacA8fFFD56F722B587aA010d6B438B077\\"]}}}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI0ZTBiMi5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4e0b2\n')},"4e0d":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Home_vue_vue_type_style_index_0_id_02ef831a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9a9c");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Home_vue_vue_type_style_index_0_id_02ef831a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Home_vue_vue_type_style_index_0_id_02ef831a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Home_vue_vue_type_style_index_0_id_02ef831a_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvSG9tZS52dWU/N2YxMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBNGtCLENBQWdCLDBtQkFBRyxFQUFDIiwiZmlsZSI6IjRlMGQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS04LW9uZU9mLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS04LW9uZU9mLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS04LW9uZU9mLTEtMiEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0hvbWUudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MDJlZjgzMWEmbGFuZz1zY3NzJnNjb3BlZD10cnVlJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS04LW9uZU9mLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS04LW9uZU9mLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS04LW9uZU9mLTEtMiEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0hvbWUudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MDJlZjgzMWEmbGFuZz1zY3NzJnNjb3BlZD10cnVlJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4e0d\n')},"508d":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_RaidenDialog_vue_vue_type_style_index_0_id_23c69e33_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("1922");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_RaidenDialog_vue_vue_type_style_index_0_id_23c69e33_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_RaidenDialog_vue_vue_type_style_index_0_id_23c69e33_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_RaidenDialog_vue_vue_type_style_index_0_id_23c69e33_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9SYWlkZW5EaWFsb2cudnVlPzY3MDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQW9sQixDQUFnQixrbkJBQUcsRUFBQyIsImZpbGUiOiI1MDhkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tOC1vbmVPZi0xLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tOC1vbmVPZi0xLTIhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTgtb25lT2YtMS0zIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9SYWlkZW5EaWFsb2cudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MjNjNjllMzMmc2NvcGVkPXRydWUmbGFuZz1zY3NzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS04LW9uZU9mLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS04LW9uZU9mLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS04LW9uZU9mLTEtMiEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1JhaWRlbkRpYWxvZy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0yM2M2OWUzMyZzY29wZWQ9dHJ1ZSZsYW5nPXNjc3MmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///508d\n')},"51ce":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BY3Rpb25CdXR0b24udnVlPzZhMTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNTFjZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///51ce\n")},"51ea":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BcHBIZWFkZXIudnVlP2U2Y2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNTFlYS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///51ea\n")},"73da":function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/back_arrow.268247fb.svg";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2JhY2tfYXJyb3cuc3ZnP2MzN2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiI3M2RhLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1nL2JhY2tfYXJyb3cuMjY4MjQ3ZmIuc3ZnXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///73da\n')},"750b":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e349156a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/ActionButton.vue?vue&type=template&id=de9d7fe4&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'v-row\',{staticClass:"action-button",class:{ sticky: _vm.sticky },attrs:{"no-gutters":"","align-content":"center","justify":"center"}},[_c(\'v-col\',{staticClass:"text-center",attrs:{"cols":_vm.sticky ? 12 : 10}},[_c(\'v-btn\',{staticClass:"text-capitalize action-button__button",class:{\n        sticky: _vm.sticky,\n        \'action-button__button--ghost\': _vm.ghost,\n        \'action-button__button--full-width\': _vm.fullWidth\n      },attrs:{"type":"submit","disabled":!_vm.enabled,"loading":_vm.loading,"depressed":"","large":""},on:{"click":function($event){return _vm.click()}}},[_vm._v(" "+_vm._s(_vm.text)+" "),(_vm.arrow)?_c(\'v-icon\',{attrs:{"right":""}},[_vm._v("keyboard_arrow_right")]):_vm._e()],1)],1)],1)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/ActionButton.vue?vue&type=template&id=de9d7fe4&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__("9ab4");\n\n// EXTERNAL MODULE: ./node_modules/vue-property-decorator/lib/vue-property-decorator.js\nvar vue_property_decorator = __webpack_require__("60a3");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/ActionButton.vue?vue&type=script&lang=ts&\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\nvar ActionButton = /*#__PURE__*/function (_Vue) {\n  _inherits(ActionButton, _Vue);\n\n  var _super = _createSuper(ActionButton);\n\n  function ActionButton() {\n    _classCallCheck(this, ActionButton);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ActionButton, [{\n    key: "click",\n    value: function click() {}\n  }]);\n\n  return ActionButton;\n}(vue_property_decorator["e" /* Vue */]);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  required: true,\n  type: Boolean\n})], ActionButton.prototype, "enabled", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  required: true\n})], ActionButton.prototype, "text", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  type: Boolean,\n  default: false\n})], ActionButton.prototype, "loading", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  type: Boolean,\n  default: false\n})], ActionButton.prototype, "sticky", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  type: Boolean,\n  default: false\n})], ActionButton.prototype, "arrow", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  type: Boolean,\n  default: false\n})], ActionButton.prototype, "ghost", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  type: Boolean,\n  default: false\n})], ActionButton.prototype, "fullWidth", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["b" /* Emit */])()], ActionButton.prototype, "click", null);\n\nActionButton = Object(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["a" /* Component */])({})], ActionButton);\n/* harmony default export */ var ActionButtonvue_type_script_lang_ts_ = (ActionButton);\n// CONCATENATED MODULE: ./src/components/ActionButton.vue?vue&type=script&lang=ts&\n /* harmony default export */ var components_ActionButtonvue_type_script_lang_ts_ = (ActionButtonvue_type_script_lang_ts_); \n// EXTERNAL MODULE: ./src/components/ActionButton.vue?vue&type=style&index=0&id=de9d7fe4&lang=scss&scoped=true&\nvar ActionButtonvue_type_style_index_0_id_de9d7fe4_lang_scss_scoped_true_ = __webpack_require__("c6c9");\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__("2877");\n\n// EXTERNAL MODULE: ./node_modules/vuetify-loader/lib/runtime/installComponents.js\nvar installComponents = __webpack_require__("6544");\nvar installComponents_default = /*#__PURE__*/__webpack_require__.n(installComponents);\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VBtn/VBtn.js\nvar VBtn = __webpack_require__("8336");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/VCol.js\nvar VCol = __webpack_require__("62ad");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VIcon/VIcon.js\nvar VIcon = __webpack_require__("132d");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/VRow.js\nvar VRow = __webpack_require__("0fd9");\n\n// CONCATENATED MODULE: ./src/components/ActionButton.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  components_ActionButtonvue_type_script_lang_ts_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "de9d7fe4",\n  null\n  \n)\n\n/* harmony default export */ var components_ActionButton = __webpack_exports__["a"] = (component.exports);\n\n/* vuetify-loader */\n\n\n\n\n\ninstallComponents_default()(component, {VBtn: VBtn["a" /* default */],VCol: VCol["a" /* default */],VIcon: VIcon["a" /* default */],VRow: VRow["a" /* default */]})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BY3Rpb25CdXR0b24udnVlP2MzZGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQWN0aW9uQnV0dG9uLnZ1ZT8xMmQwIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0FjdGlvbkJ1dHRvbi52dWU/YTFkZCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BY3Rpb25CdXR0b24udnVlPzlkYzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwwQkFBMEIsYUFBYSwwQkFBMEIsd0JBQXdCLG1CQUFtQixtQ0FBbUMscUJBQXFCLFFBQVEsNkRBQTZELGNBQWMsaUNBQWlDLDZCQUE2QixjQUFjO0FBQ25VO0FBQ0E7QUFDQTtBQUNBLE9BQU8sUUFBUSx3RkFBd0YsS0FBSyx5QkFBeUIscUJBQXFCLDREQUE0RCxPQUFPLFlBQVk7QUFDek87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeUJBOztBQUdBLElBQXFCLFlBQXJCO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSw0QkF1Qk8sQ0FBSztBQXZCWjs7QUFBQTtBQUFBLEVBQTBDLHFDQUExQzs7QUFFRSx5Q0FEQyw4Q0FBSSxDQUFDO0FBQUUsVUFBUSxFQUFFLElBQVo7QUFBa0IsTUFBSSxFQUFFO0FBQXhCLENBQUQsQ0FDTCxHLHNCQUFBLEUsU0FBQSxFLEtBQWtCLENBQWxCOztBQUdBLHlDQURDLDhDQUFJLENBQUM7QUFBRSxVQUFRLEVBQUU7QUFBWixDQUFELENBQ0wsRyxzQkFBQSxFLE1BQUEsRSxLQUFjLENBQWQ7O0FBR0EseUNBREMsOENBQUksQ0FBQztBQUFFLE1BQUksRUFBRSxPQUFSO0FBQWlCLFNBQU8sRUFBRTtBQUExQixDQUFELENBQ0wsRyxzQkFBQSxFLFNBQUEsRSxLQUFrQixDQUFsQjs7QUFHQSx5Q0FEQyw4Q0FBSSxDQUFDO0FBQUUsTUFBSSxFQUFFLE9BQVI7QUFBaUIsU0FBTyxFQUFFO0FBQTFCLENBQUQsQ0FDTCxHLHNCQUFBLEUsUUFBQSxFLEtBQWlCLENBQWpCOztBQUdBLHlDQURDLDhDQUFJLENBQUM7QUFBRSxNQUFJLEVBQUUsT0FBUjtBQUFpQixTQUFPLEVBQUU7QUFBMUIsQ0FBRCxDQUNMLEcsc0JBQUEsRSxPQUFBLEUsS0FBZ0IsQ0FBaEI7O0FBR0EseUNBREMsOENBQUksQ0FBQztBQUFFLE1BQUksRUFBRSxPQUFSO0FBQWlCLFNBQU8sRUFBRTtBQUExQixDQUFELENBQ0wsRyxzQkFBQSxFLE9BQUEsRSxLQUFnQixDQUFoQjs7QUFHQSx5Q0FEQyw4Q0FBSSxDQUFDO0FBQUUsTUFBSSxFQUFFLE9BQVI7QUFBaUIsU0FBTyxFQUFFO0FBQTFCLENBQUQsQ0FDTCxHLHNCQUFBLEUsV0FBQSxFLEtBQW9CLENBQXBCOztBQUdBLHlDQURDLDhDQUFJLEVBQ0wsRyxzQkFBQSxFLE9BQUEsRUFBVSxJQUFWOztBQXZCbUIsWUFBWSw0Q0FEaEMsbURBQVMsQ0FBQyxFQUFELENBQ3VCLEdBQVosWUFBWSxDQUFaO0FBQUEscUY7O0FDakM2WixDQUFnQix3SEFBRyxFQUFDLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0EvVjtBQUN2QztBQUNMO0FBQ3NDOzs7QUFHakc7QUFDMEY7QUFDMUYsZ0JBQWdCLDhDQUFVO0FBQzFCLEVBQUUsK0NBQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsd0dBQWlCOztBQUVoQztBQUNtRztBQUNoRDtBQUNDO0FBQ0M7QUFDRDtBQUNwRCwyQkFBaUIsYUFBYSw2QkFBSSxDQUFDLDZCQUFJLENBQUMsK0JBQUssQ0FBQyw2QkFBSSxDQUFDIiwiZmlsZSI6Ijc1MGIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygndi1yb3cnLHtzdGF0aWNDbGFzczpcImFjdGlvbi1idXR0b25cIixjbGFzczp7IHN0aWNreTogX3ZtLnN0aWNreSB9LGF0dHJzOntcIm5vLWd1dHRlcnNcIjpcIlwiLFwiYWxpZ24tY29udGVudFwiOlwiY2VudGVyXCIsXCJqdXN0aWZ5XCI6XCJjZW50ZXJcIn19LFtfYygndi1jb2wnLHtzdGF0aWNDbGFzczpcInRleHQtY2VudGVyXCIsYXR0cnM6e1wiY29sc1wiOl92bS5zdGlja3kgPyAxMiA6IDEwfX0sW19jKCd2LWJ0bicse3N0YXRpY0NsYXNzOlwidGV4dC1jYXBpdGFsaXplIGFjdGlvbi1idXR0b25fX2J1dHRvblwiLGNsYXNzOntcbiAgICAgICAgc3RpY2t5OiBfdm0uc3RpY2t5LFxuICAgICAgICAnYWN0aW9uLWJ1dHRvbl9fYnV0dG9uLS1naG9zdCc6IF92bS5naG9zdCxcbiAgICAgICAgJ2FjdGlvbi1idXR0b25fX2J1dHRvbi0tZnVsbC13aWR0aCc6IF92bS5mdWxsV2lkdGhcbiAgICAgIH0sYXR0cnM6e1widHlwZVwiOlwic3VibWl0XCIsXCJkaXNhYmxlZFwiOiFfdm0uZW5hYmxlZCxcImxvYWRpbmdcIjpfdm0ubG9hZGluZyxcImRlcHJlc3NlZFwiOlwiXCIsXCJsYXJnZVwiOlwiXCJ9LG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLmNsaWNrKCl9fX0sW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLnRleHQpK1wiIFwiKSwoX3ZtLmFycm93KT9fYygndi1pY29uJyx7YXR0cnM6e1wicmlnaHRcIjpcIlwifX0sW192bS5fdihcImtleWJvYXJkX2Fycm93X3JpZ2h0XCIpXSk6X3ZtLl9lKCldLDEpXSwxKV0sMSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmltcG9ydCB7IENvbXBvbmVudCwgRW1pdCwgUHJvcCwgVnVlIH0gZnJvbSAndnVlLXByb3BlcnR5LWRlY29yYXRvcic7XG5cbkBDb21wb25lbnQoe30pXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY3Rpb25CdXR0b24gZXh0ZW5kcyBWdWUge1xuICBAUHJvcCh7IHJlcXVpcmVkOiB0cnVlLCB0eXBlOiBCb29sZWFuIH0pXG4gIGVuYWJsZWQhOiBib29sZWFuO1xuXG4gIEBQcm9wKHsgcmVxdWlyZWQ6IHRydWUgfSlcbiAgdGV4dCE6IHN0cmluZztcblxuICBAUHJvcCh7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0pXG4gIGxvYWRpbmchOiBib29sZWFuO1xuXG4gIEBQcm9wKHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSlcbiAgc3RpY2t5PzogYm9vbGVhbjtcblxuICBAUHJvcCh7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0pXG4gIGFycm93PzogYm9vbGVhbjtcblxuICBAUHJvcCh7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0pXG4gIGdob3N0PzogYm9vbGVhbjtcblxuICBAUHJvcCh7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0pXG4gIGZ1bGxXaWR0aD86IGJvb2xlYW47XG5cbiAgQEVtaXQoKVxuICBjbGljaygpIHt9XG59XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTQtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTE0LTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FjdGlvbkJ1dHRvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xNC0wIS4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMTQtMyEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0yMS0wIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQWN0aW9uQnV0dG9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vQWN0aW9uQnV0dG9uLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1kZTlkN2ZlNCZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9BY3Rpb25CdXR0b24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9BY3Rpb25CdXR0b24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL0FjdGlvbkJ1dHRvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1kZTlkN2ZlNCZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcImRlOWQ3ZmU0XCIsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzXG5cbi8qIHZ1ZXRpZnktbG9hZGVyICovXG5pbXBvcnQgaW5zdGFsbENvbXBvbmVudHMgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL3J1bnRpbWUvaW5zdGFsbENvbXBvbmVudHMuanNcIlxuaW1wb3J0IHsgVkJ0biB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkJ0bic7XG5pbXBvcnQgeyBWQ29sIH0gZnJvbSAndnVldGlmeS9saWIvY29tcG9uZW50cy9WR3JpZCc7XG5pbXBvcnQgeyBWSWNvbiB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkljb24nO1xuaW1wb3J0IHsgVlJvdyB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkdyaWQnO1xuaW5zdGFsbENvbXBvbmVudHMoY29tcG9uZW50LCB7VkJ0bixWQ29sLFZJY29uLFZSb3d9KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///750b\n')},"753f":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_NoAccessMessage_vue_vue_type_style_index_0_id_7b92b083_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("94e9");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_NoAccessMessage_vue_vue_type_style_index_0_id_7b92b083_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_NoAccessMessage_vue_vue_type_style_index_0_id_7b92b083_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_NoAccessMessage_vue_vue_type_style_index_0_id_7b92b083_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ob0FjY2Vzc01lc3NhZ2UudnVlPzk2MzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQXVsQixDQUFnQixxbkJBQUcsRUFBQyIsImZpbGUiOiI3NTNmLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tOC1vbmVPZi0xLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tOC1vbmVPZi0xLTIhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTgtb25lT2YtMS0zIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Ob0FjY2Vzc01lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9N2I5MmIwODMmc2NvcGVkPXRydWUmbGFuZz1zY3NzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS04LW9uZU9mLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS04LW9uZU9mLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS04LW9uZU9mLTEtMiEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL05vQWNjZXNzTWVzc2FnZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD03YjkyYjA4MyZzY29wZWQ9dHJ1ZSZsYW5nPXNjc3MmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///753f\n')},"77fd":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9ab4");\n/* harmony import */ var vue_property_decorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("60a3");\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\nvar BlockieMixin = /*#__PURE__*/function (_Vue) {\n  _inherits(BlockieMixin, _Vue);\n\n  var _super = _createSuper(BlockieMixin);\n\n  function BlockieMixin() {\n    _classCallCheck(this, BlockieMixin);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(BlockieMixin, [{\n    key: "$blockie",\n    value: function $blockie(address) {\n      if (address) {\n        return this.$identicon.getIdenticon(address);\n      } else {\n        return this.$identicon.getIdenticon(\'0x000\');\n      }\n    }\n  }]);\n\n  return BlockieMixin;\n}(vue_property_decorator__WEBPACK_IMPORTED_MODULE_1__[/* Vue */ "e"]);\n\nBlockieMixin = Object(tslib__WEBPACK_IMPORTED_MODULE_0__[/* __decorate */ "b"])([vue_property_decorator__WEBPACK_IMPORTED_MODULE_1__[/* Component */ "a"]], BlockieMixin);\n/* harmony default export */ __webpack_exports__["a"] = (BlockieMixin);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWl4aW5zL2Jsb2NraWUtbWl4aW4udHM/NzE3MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBR0EsSUFBcUIsWUFBckI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLDZCQUNXLE9BRFgsRUFDMkI7QUFDdkIsVUFBSSxPQUFKLEVBQWE7QUFDWCxlQUFPLEtBQUssVUFBTCxDQUFnQixZQUFoQixDQUE2QixPQUE3QixDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBTyxLQUFLLFVBQUwsQ0FBZ0IsWUFBaEIsQ0FBNkIsT0FBN0IsQ0FBUDtBQUNEO0FBQ0Y7QUFQSDs7QUFBQTtBQUFBLEVBQTBDLGtFQUExQzs7QUFBcUIsWUFBWSxxRUFEaEMsd0VBQ2dDLEdBQVosWUFBWSxDQUFaO0FBQUEscUUiLCJmaWxlIjoiNzdmZC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgVnVlIH0gZnJvbSAndnVlLXByb3BlcnR5LWRlY29yYXRvcic7XG5cbkBDb21wb25lbnRcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsb2NraWVNaXhpbiBleHRlbmRzIFZ1ZSB7XG4gICRibG9ja2llKGFkZHJlc3M/OiBzdHJpbmcpIHtcbiAgICBpZiAoYWRkcmVzcykge1xuICAgICAgcmV0dXJuIHRoaXMuJGlkZW50aWNvbi5nZXRJZGVudGljb24oYWRkcmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLiRpZGVudGljb24uZ2V0SWRlbnRpY29uKCcweDAwMCcpO1xuICAgIH1cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///77fd\n')},"80bf":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RouteNames; });\nvar RouteNames;\n\n(function (RouteNames) {\n  RouteNames["TRANSFER"] = "transfer";\n  RouteNames["TRANSFER_STEPS"] = "transfer-steps";\n  RouteNames["SELECT_TOKEN"] = "select-token";\n  RouteNames["SELECT_HUB"] = "select-hub";\n  RouteNames["HOME"] = "home";\n  RouteNames["CHANNELS"] = "channels";\n  RouteNames["OPEN_CHANNEL"] = "open-channel";\n  RouteNames["GENERAL"] = "general";\n  RouteNames["GENERAL_HOME"] = "general-home";\n  RouteNames["BACKUP_STATE"] = "backup-state";\n})(RouteNames || (RouteNames = {}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcm91dGVyL3JvdXRlLW5hbWVzLnRzPzk4MDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQSxJQUFZLFVBQVo7O0FBQUEsV0FBWSxVQUFaLEVBQXNCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0QsQ0FYRCxFQUFZLFVBQVUsS0FBVixVQUFVLE1BQXRCIiwiZmlsZSI6IjgwYmYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZW51bSBSb3V0ZU5hbWVzIHtcbiAgVFJBTlNGRVIgPSAndHJhbnNmZXInLFxuICBUUkFOU0ZFUl9TVEVQUyA9ICd0cmFuc2Zlci1zdGVwcycsXG4gIFNFTEVDVF9UT0tFTiA9ICdzZWxlY3QtdG9rZW4nLFxuICBTRUxFQ1RfSFVCID0gJ3NlbGVjdC1odWInLFxuICBIT01FID0gJ2hvbWUnLFxuICBDSEFOTkVMUyA9ICdjaGFubmVscycsXG4gIE9QRU5fQ0hBTk5FTCA9ICdvcGVuLWNoYW5uZWwnLFxuICBHRU5FUkFMID0gJ2dlbmVyYWwnLFxuICBHRU5FUkFMX0hPTUUgPSAnZ2VuZXJhbC1ob21lJyxcbiAgQkFDS1VQX1NUQVRFID0gJ2JhY2t1cC1zdGF0ZSdcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///80bf\n')},"87a2":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return emptyDescription; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return emptyTokenModel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return PlaceHolderNetwork; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DeniedReason; });\nvar emptyDescription = function emptyDescription() {\n  return {\n    label: \'\',\n    title: \'\',\n    description: \'\'\n  };\n};\nvar emptyTokenModel = function emptyTokenModel() {\n  return {\n    name: \'\',\n    symbol: \'\',\n    address: \'\',\n    opening: 0,\n    open: 0,\n    closing: 0,\n    closed: 0,\n    settling: 0,\n    settled: 0\n  };\n};\nvar PlaceHolderNetwork = {\n  name: \'\',\n  chainId: -1\n};\nvar DeniedReason;\n\n(function (DeniedReason) {\n  DeniedReason[DeniedReason["UNDEFINED"] = 0] = "UNDEFINED";\n  DeniedReason[DeniedReason["NO_ACCOUNT"] = 1] = "NO_ACCOUNT";\n  DeniedReason[DeniedReason["UNSUPPORTED_NETWORK"] = 2] = "UNSUPPORTED_NETWORK";\n  DeniedReason[DeniedReason["INITIALIZATION_FAILED"] = 3] = "INITIALIZATION_FAILED";\n  DeniedReason[DeniedReason["RDN_STATE_MIGRATION"] = 4] = "RDN_STATE_MIGRATION";\n})(DeniedReason || (DeniedReason = {}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWwvdHlwZXMudHM/MDNmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUF1RUE7QUFBQTtBQUFBO0FBQUE7QUFBTyxJQUFNLGdCQUFnQixHQUFHLFNBQW5CLGdCQUFtQjtBQUFBLFNBQXdCO0FBQ3RELFNBQUssRUFBRSxFQUQrQztBQUV0RCxTQUFLLEVBQUUsRUFGK0M7QUFHdEQsZUFBVyxFQUFFO0FBSHlDLEdBQXhCO0FBQUEsQ0FBekI7QUFNQSxJQUFNLGVBQWUsR0FBRyxTQUFsQixlQUFrQjtBQUFBLFNBQXNCO0FBQ25ELFFBQUksRUFBRSxFQUQ2QztBQUVuRCxVQUFNLEVBQUUsRUFGMkM7QUFHbkQsV0FBTyxFQUFFLEVBSDBDO0FBSW5ELFdBQU8sRUFBRSxDQUowQztBQUtuRCxRQUFJLEVBQUUsQ0FMNkM7QUFNbkQsV0FBTyxFQUFFLENBTjBDO0FBT25ELFVBQU0sRUFBRSxDQVAyQztBQVFuRCxZQUFRLEVBQUUsQ0FSeUM7QUFTbkQsV0FBTyxFQUFFO0FBVDBDLEdBQXRCO0FBQUEsQ0FBeEI7QUFZQSxJQUFNLGtCQUFrQixHQUFZO0FBQ3pDLE1BQUksRUFBRSxFQURtQztBQUV6QyxTQUFPLEVBQUUsQ0FBQztBQUYrQixDQUFwQztBQUtQLElBQVksWUFBWjs7QUFBQSxXQUFZLFlBQVosRUFBd0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNELENBTkQsRUFBWSxZQUFZLEtBQVosWUFBWSxNQUF4QiIsImZpbGUiOiI4N2EyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmlnTnVtYmVyLCBCaWdOdW1iZXJpc2gsIE5ldHdvcmsgfSBmcm9tICdldGhlcnMvdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRva2VuIHtcbiAgcmVhZG9ubHkgYWRkcmVzczogc3RyaW5nO1xuICByZWFkb25seSBkZWNpbWFscz86IG51bWJlcjtcbiAgcmVhZG9ubHkgYmFsYW5jZT86IEJpZ051bWJlcmlzaDtcbiAgcmVhZG9ubHkgc3ltYm9sPzogc3RyaW5nO1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByZXNlbmNlcyB7XG4gIFthZGRyZXNzOiBzdHJpbmddOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFjY1Rva2VuTW9kZWwge1xuICBuYW1lOiBzdHJpbmc7XG4gIHN5bWJvbDogc3RyaW5nO1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIG9wZW5pbmc6IG51bWJlcjtcbiAgb3BlbjogbnVtYmVyO1xuICBjbG9zaW5nOiBudW1iZXI7XG4gIGNsb3NlZDogbnVtYmVyO1xuICBzZXR0bGluZzogbnVtYmVyO1xuICBzZXR0bGVkOiBudW1iZXI7XG5cbiAgW2luZGV4OiBzdHJpbmddOiBudW1iZXIgfCBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW5Nb2RlbCBleHRlbmRzIEFjY1Rva2VuTW9kZWwge1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHN5bWJvbDogc3RyaW5nO1xuICByZWFkb25seSBhZGRyZXNzOiBzdHJpbmc7XG4gIHJlYWRvbmx5IG9wZW5pbmc6IG51bWJlcjtcbiAgcmVhZG9ubHkgb3BlbjogbnVtYmVyO1xuICByZWFkb25seSBjbG9zaW5nOiBudW1iZXI7XG4gIHJlYWRvbmx5IGNsb3NlZDogbnVtYmVyO1xuICByZWFkb25seSBzZXR0bGluZzogbnVtYmVyO1xuICByZWFkb25seSBzZXR0bGVkOiBudW1iZXI7XG59XG5leHBvcnQgaW50ZXJmYWNlIFByb2dyZXNzIHtcbiAgcmVhZG9ubHkgY3VycmVudDogbnVtYmVyO1xuICByZWFkb25seSB0b3RhbDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0ZXBEZXNjcmlwdGlvbiB7XG4gIHJlYWRvbmx5IGxhYmVsOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHRpdGxlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGUge1xuICByZWFkb25seSBrZXk6IG51bWJlcjtcbiAgcmVhZG9ubHkgaG9wczogbnVtYmVyO1xuICByZWFkb25seSBwYXRoOiBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgZmVlOiBCaWdOdW1iZXI7XG4gIHJlYWRvbmx5IGRpc3BsYXlGZWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2ZlciB7XG4gIHBmc0FkZHJlc3M/OiBzdHJpbmc7XG4gIHNlcnZpY2VGZWU/OiBCaWdOdW1iZXI7XG4gIHNlcnZpY2VUb2tlbj86IFRva2VuO1xuICBtZWRpYXRpb25GZWU/OiBCaWdOdW1iZXI7XG4gIHRhcmdldDogc3RyaW5nO1xuICBob3BzOiBudW1iZXI7XG4gIHBheW1lbnRJZDogQmlnTnVtYmVyaXNoO1xuICB0cmFuc2ZlckFtb3VudDogQmlnTnVtYmVyO1xuICB0cmFuc2ZlclRva2VuOiBUb2tlbjtcbiAgdHJhbnNmZXJUb3RhbDogQmlnTnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgZW1wdHlEZXNjcmlwdGlvbiA9ICgpOiBTdGVwRGVzY3JpcHRpb24gPT4gKHtcbiAgbGFiZWw6ICcnLFxuICB0aXRsZTogJycsXG4gIGRlc2NyaXB0aW9uOiAnJ1xufSk7XG5cbmV4cG9ydCBjb25zdCBlbXB0eVRva2VuTW9kZWwgPSAoKTogQWNjVG9rZW5Nb2RlbCA9PiAoe1xuICBuYW1lOiAnJyxcbiAgc3ltYm9sOiAnJyxcbiAgYWRkcmVzczogJycsXG4gIG9wZW5pbmc6IDAsXG4gIG9wZW46IDAsXG4gIGNsb3Npbmc6IDAsXG4gIGNsb3NlZDogMCxcbiAgc2V0dGxpbmc6IDAsXG4gIHNldHRsZWQ6IDBcbn0pO1xuXG5leHBvcnQgY29uc3QgUGxhY2VIb2xkZXJOZXR3b3JrOiBOZXR3b3JrID0ge1xuICBuYW1lOiAnJyxcbiAgY2hhaW5JZDogLTFcbn07XG5cbmV4cG9ydCBlbnVtIERlbmllZFJlYXNvbiB7XG4gIFVOREVGSU5FRCxcbiAgTk9fQUNDT1VOVCxcbiAgVU5TVVBQT1JURURfTkVUV09SSyxcbiAgSU5JVElBTElaQVRJT05fRkFJTEVELFxuICBSRE5fU1RBVEVfTUlHUkFUSU9OXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///87a2\n')},"8aa9":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return setupLogStore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getLogsFromStore; });\n/* harmony import */ var _home_circleci_src_raiden_dapp_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a34a");\n/* harmony import */ var _home_circleci_src_raiden_dapp_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_home_circleci_src_raiden_dapp_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("5c7d");\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("3f4f");\n\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar collectionName = \'logs\';\nvar db;\n/* istanbul ignore next */\n\nfunction serializeError(e) {\n  // special handling of Errors, since firefox doesn\'t like to structure-clone it\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1556604\n  var strError = e.toString();\n\n  if (!e.stack) {\n    return strError;\n  } else if (e.stack.startsWith(strError)) {\n    return e.stack; // chrome includes error str repr on top of stack\n  } else {\n    return "".concat(strError, "\\n").concat(e.stack);\n  }\n}\n/* istanbul ignore next */\n\n\nfunction filterMessage(message) {\n  if (message[0] === \'%c prev state\') return;\n  if (message[0] === \'—— log end ——\') return;\n  message = message.map(function (e) {\n    return e instanceof Error ? serializeError(e) : (e === null || e === void 0 ? void 0 : e.payload) instanceof Error // error action\n    ? _objectSpread({}, e, {\n      payload: serializeError(e.payload)\n    }) : e;\n  });\n  if (typeof message[1] === \'string\' && message[1].startsWith(\'color:\')) message.splice(1, 1);\n  return message;\n}\n/* istanbul ignore next */\n\n\nfunction serialize(e) {\n  if (typeof e === \'string\') return e;\n\n  try {\n    return JSON.stringify(e);\n  } catch (err) {\n    try {\n      return e.toString();\n    } catch (err) {\n      return \'<unserializable>\';\n    }\n  }\n}\n/* istanbul ignore next */\n\n\nfunction setupLogStore() {\n  return _setupLogStore.apply(this, arguments);\n}\n\nfunction _setupLogStore() {\n  _setupLogStore = _asyncToGenerator( /*#__PURE__*/_home_circleci_src_raiden_dapp_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {\n    var dbName,\n        additionalLoggers,\n        _loop,\n        _i,\n        _arr,\n        _args = arguments;\n\n    return _home_circleci_src_raiden_dapp_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            dbName = _args.length > 0 && _args[0] !== undefined ? _args[0] : \'raiden\';\n            additionalLoggers = _args.length > 1 && _args[1] !== undefined ? _args[1] : [\'matrix\'];\n\n            if (!(typeof db !== \'undefined\')) {\n              _context.next = 4;\n              break;\n            }\n\n            return _context.abrupt("return");\n\n          case 4:\n            _context.next = 6;\n            return Object(idb__WEBPACK_IMPORTED_MODULE_2__[/* openDB */ "a"])(dbName, 1, {\n              upgrade: function upgrade(db) {\n                var logsStore = db.createObjectStore(collectionName);\n                logsStore.createIndex(\'by-logger\', \'logger\');\n                logsStore.createIndex(\'by-level\', \'level\');\n              }\n            });\n\n          case 6:\n            db = _context.sent;\n\n            _loop = function _loop() {\n              var log = _arr[_i];\n              var origFactory = log.methodFactory;\n\n              log.methodFactory = function (methodName, level, loggerName) {\n                var rawMethod = origFactory(methodName, level, loggerName);\n                return function () {\n                  for (var _len = arguments.length, message = new Array(_len), _key = 0; _key < _len; _key++) {\n                    message[_key] = arguments[_key];\n                  }\n\n                  rawMethod.apply(void 0, message);\n                  var filtered = filterMessage(message);\n                  if (!filtered) return;\n                  db.put(collectionName, {\n                    logger: loggerName,\n                    level: methodName,\n                    message: message\n                  }, Date.now()).catch(function () {\n                    return db.put(collectionName, {\n                      logger: loggerName,\n                      level: methodName,\n                      message: message.map(serialize)\n                    }, Date.now());\n                  });\n                };\n              };\n            };\n\n            for (_i = 0, _arr = [loglevel__WEBPACK_IMPORTED_MODULE_1___default.a].concat(_toConsumableArray(additionalLoggers.map(loglevel__WEBPACK_IMPORTED_MODULE_1___default.a.getLogger))); _i < _arr.length; _i++) {\n              _loop();\n            }\n\n          case 9:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _setupLogStore.apply(this, arguments);\n}\n\nfunction getLogsFromStore() {\n  return _getLogsFromStore.apply(this, arguments);\n}\n\nfunction _getLogsFromStore() {\n  _getLogsFromStore = _asyncToGenerator( /*#__PURE__*/_home_circleci_src_raiden_dapp_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2() {\n    var content, cursor, lastTime, _cursor$value, logger, level, message, line, time;\n\n    return _home_circleci_src_raiden_dapp_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            content = \'\';\n            _context2.next = 3;\n            return db.transaction(collectionName).store.openCursor();\n\n          case 3:\n            cursor = _context2.sent;\n            lastTime = Date.now();\n\n          case 5:\n            if (!cursor) {\n              _context2.next = 16;\n              break;\n            }\n\n            _cursor$value = cursor.value, logger = _cursor$value.logger, level = _cursor$value.level, message = _cursor$value.message;\n            line = message.map(function (m) {\n              return typeof m === \'string\' ? m : JSON.stringify(m);\n            }).join(\' \');\n            lastTime = +cursor.key;\n            time = new Date(cursor.key).toISOString();\n            content += "".concat(time, " @ ").concat(logger, " [").concat(level, "] \\t=> ").concat(line, "\\n");\n            _context2.next = 13;\n            return cursor.continue();\n\n          case 13:\n            cursor = _context2.sent;\n            _context2.next = 5;\n            break;\n\n          case 16:\n            return _context2.abrupt("return", [lastTime, content]);\n\n          case 17:\n          case "end":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getLogsFromStore.apply(this, arguments);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvbG9nc3RvcmUudHM/ODBhMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUVBLElBQU0sY0FBYyxHQUFHLE1BQXZCO0FBaUJBLElBQUksRUFBSjtBQUVBOztBQUNBLFNBQVMsY0FBVCxDQUF3QixDQUF4QixFQUFnQztBQUM5QjtBQUNBO0FBQ0EsTUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFDLFFBQUYsRUFBakI7O0FBQ0EsTUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFQLEVBQWM7QUFDWixXQUFPLFFBQVA7QUFDRCxHQUZELE1BRU8sSUFBSSxDQUFDLENBQUMsS0FBRixDQUFRLFVBQVIsQ0FBbUIsUUFBbkIsQ0FBSixFQUFrQztBQUN2QyxXQUFPLENBQUMsQ0FBQyxLQUFULENBRHVDLENBQ3ZCO0FBQ2pCLEdBRk0sTUFFQTtBQUNMLHFCQUFVLFFBQVYsZUFBdUIsQ0FBQyxDQUFDLEtBQXpCO0FBQ0Q7QUFDRjtBQUVEOzs7QUFDQSxTQUFTLGFBQVQsQ0FBdUIsT0FBdkIsRUFBcUM7QUFDbkMsTUFBSSxPQUFPLENBQUMsQ0FBRCxDQUFQLEtBQWUsZUFBbkIsRUFBb0M7QUFDcEMsTUFBSSxPQUFPLENBQUMsQ0FBRCxDQUFQLEtBQWUsZUFBbkIsRUFBb0M7QUFDcEMsU0FBTyxHQUFHLE9BQU8sQ0FBQyxHQUFSLENBQVksV0FBQztBQUFBLFdBQ3JCLENBQUMsWUFBWSxLQUFiLEdBQ0ksY0FBYyxDQUFDLENBQUQsQ0FEbEIsR0FFSSxFQUFDLFNBQUQsS0FBQyxXQUFELGFBQUMsQ0FBRSxPQUFILGFBQXNCLEtBQXRCLENBQTRCO0FBQTVCLHdCQUNLLENBREw7QUFDUSxhQUFPLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQyxPQUFIO0FBRC9CLFNBRUEsQ0FMaUI7QUFBQSxHQUFiLENBQVY7QUFPQSxNQUFJLE9BQU8sT0FBTyxDQUFDLENBQUQsQ0FBZCxLQUFz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YyxFQUFFLENBQUMsV0FBSCxDQUFlLGNBQWYsRUFBK0IsS0FBL0IsQ0FBcUMsVUFBckMsRUFGZDs7QUFBQTtBQUVELGtCQUZDO0FBR0Qsb0JBSEMsR0FHVSxJQUFJLENBQUMsR0FBTCxFQUhWOztBQUFBO0FBQUEsaUJBSUUsTUFKRjtBQUFBO0FBQUE7QUFBQTs7QUFBQSw0QkFLZ0MsTUFBTSxDQUFDLEtBTHZDLEVBS0ssTUFMTCxpQkFLSyxNQUxMLEVBS2EsS0FMYixpQkFLYSxLQUxiLEVBS29CLE9BTHBCLGlCQUtvQixPQUxwQjtBQU1HLGdCQU5ILEdBTVUsT0FBTyxDQUNqQixHQURVLENBQ04sV0FBQztBQUFBLHFCQUFLLE9BQU8sQ0FBUCxLQUFhLFFBQWIsR0FBd0IsQ0FBeEIsR0FBNEIsSUFBSSxDQUFDLFNBQUwsQ0FBZSxDQUFmLENBQWpDO0FBQUEsYUFESyxFQUVWLElBRlUsQ0FFTCxHQUZLLENBTlY7QUFTSCxvQkFBUSxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQW5CO0FBQ00sZ0JBVkgsR0FVVSxJQUFJLElBQUosQ0FBUyxNQUFNLENBQUMsR0FBaEIsRUFBcUIsV0FBckIsRUFWVjtBQVdILG1CQUFPLGNBQU8sSUFBUCxnQkFBaUIsTUFBakIsZUFBNEIsS0FBNUIsb0JBQTJDLElBQTNDLE9BQVA7QUFYRztBQUFBLG1CQVlZLE1BQU0sQ0FBQyxRQUFQLEVBWlo7O0FBQUE7QUFZSCxrQkFaRztBQUFBO0FBQUE7O0FBQUE7QUFBQSw4Q0FjRSxDQUFDLFFBQUQsRUFBVyxPQUFYLENBZEY7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRyIsImZpbGUiOiI4YWE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvZ2dpbmcgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgb3BlbkRCLCBEQlNjaGVtYSwgSURCUERhdGFiYXNlIH0gZnJvbSAnaWRiJztcblxuY29uc3QgY29sbGVjdGlvbk5hbWUgPSAnbG9ncyc7XG5cbmludGVyZmFjZSBSYWlkZW5EQiBleHRlbmRzIERCU2NoZW1hIHtcbiAgW2NvbGxlY3Rpb25OYW1lXToge1xuICAgIHZhbHVlOiB7XG4gICAgICBsb2dnZXI6IHN0cmluZztcbiAgICAgIGxldmVsOiBzdHJpbmc7XG4gICAgICBtZXNzYWdlOiBhbnlbXTtcbiAgICB9O1xuICAgIGtleTogbnVtYmVyO1xuICAgIGluZGV4ZXM6IHtcbiAgICAgICdieS1sb2dnZXInOiBzdHJpbmc7XG4gICAgICAnYnktbGV2ZWwnOiBudW1iZXI7XG4gICAgfTtcbiAgfTtcbn1cblxubGV0IGRiOiBJREJQRGF0YWJhc2U8UmFpZGVuREI+O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gc2VyaWFsaXplRXJyb3IoZTogRXJyb3IpOiBzdHJpbmcge1xuICAvLyBzcGVjaWFsIGhhbmRsaW5nIG9mIEVycm9ycywgc2luY2UgZmlyZWZveCBkb2Vzbid0IGxpa2UgdG8gc3RydWN0dXJlLWNsb25lIGl0XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE1NTY2MDRcbiAgY29uc3Qgc3RyRXJyb3IgPSBlLnRvU3RyaW5nKCk7XG4gIGlmICghZS5zdGFjaykge1xuICAgIHJldHVybiBzdHJFcnJvcjtcbiAgfSBlbHNlIGlmIChlLnN0YWNrLnN0YXJ0c1dpdGgoc3RyRXJyb3IpKSB7XG4gICAgcmV0dXJuIGUuc3RhY2s7IC8vIGNocm9tZSBpbmNsdWRlcyBlcnJvciBzdHIgcmVwciBvbiB0b3Agb2Ygc3RhY2tcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYCR7c3RyRXJyb3J9XFxuJHtlLnN0YWNrfWA7XG4gIH1cbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGZpbHRlck1lc3NhZ2UobWVzc2FnZTogYW55W10pIHtcbiAgaWYgKG1lc3NhZ2VbMF0gPT09ICclYyBwcmV2IHN0YXRlJykgcmV0dXJuO1xuICBpZiAobWVzc2FnZVswXSA9PT0gJ+KAlOKAlCBsb2cgZW5kIOKAlOKAlCcpIHJldHVybjtcbiAgbWVzc2FnZSA9IG1lc3NhZ2UubWFwKGUgPT5cbiAgICBlIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgID8gc2VyaWFsaXplRXJyb3IoZSlcbiAgICAgIDogZT8ucGF5bG9hZCBpbnN0YW5jZW9mIEVycm9yIC8vIGVycm9yIGFjdGlvblxuICAgICAgPyB7IC4uLmUsIHBheWxvYWQ6IHNlcmlhbGl6ZUVycm9yKGUucGF5bG9hZCkgfVxuICAgICAgOiBlXG4gICk7XG4gIGlmICh0eXBlb2YgbWVzc2FnZVsxXSA9PT0gJ3N0cmluZycgJiYgbWVzc2FnZVsxXS5zdGFydHNXaXRoKCdjb2xvcjonKSlcbiAgICBtZXNzYWdlLnNwbGljZSgxLCAxKTtcbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBzZXJpYWxpemUoZTogYW55KTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBlID09PSAnc3RyaW5nJykgcmV0dXJuIGU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGUudG9TdHJpbmcoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiAnPHVuc2VyaWFsaXphYmxlPic7XG4gICAgfVxuICB9XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0dXBMb2dTdG9yZShcbiAgZGJOYW1lID0gJ3JhaWRlbicsXG4gIGFkZGl0aW9uYWxMb2dnZXJzOiBzdHJpbmdbXSA9IFsnbWF0cml4J11cbik6IFByb21pc2U8dm9pZD4ge1xuICBpZiAodHlwZW9mIGRiICE9PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICBkYiA9IGF3YWl0IG9wZW5EQjxSYWlkZW5EQj4oZGJOYW1lLCAxLCB7XG4gICAgdXBncmFkZShkYikge1xuICAgICAgY29uc3QgbG9nc1N0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoY29sbGVjdGlvbk5hbWUpO1xuICAgICAgbG9nc1N0b3JlLmNyZWF0ZUluZGV4KCdieS1sb2dnZXInLCAnbG9nZ2VyJyk7XG4gICAgICBsb2dzU3RvcmUuY3JlYXRlSW5kZXgoJ2J5LWxldmVsJywgJ2xldmVsJyk7XG4gICAgfVxuICB9KTtcblxuICBmb3IgKGNvbnN0IGxvZyBvZiBbbG9nZ2luZywgLi4uYWRkaXRpb25hbExvZ2dlcnMubWFwKGxvZ2dpbmcuZ2V0TG9nZ2VyKV0pIHtcbiAgICBjb25zdCBvcmlnRmFjdG9yeSA9IGxvZy5tZXRob2RGYWN0b3J5O1xuICAgIGxvZy5tZXRob2RGYWN0b3J5ID0gKFxuICAgICAgbWV0aG9kTmFtZTogc3RyaW5nLFxuICAgICAgbGV2ZWw6IDAgfCAxIHwgMiB8IDMgfCA0IHwgNSxcbiAgICAgIGxvZ2dlck5hbWU6IHN0cmluZ1xuICAgICk6IGxvZ2dpbmcuTG9nZ2luZ01ldGhvZCA9PiB7XG4gICAgICBjb25zdCByYXdNZXRob2QgPSBvcmlnRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICByZXR1cm4gKC4uLm1lc3NhZ2U6IGFueVtdKTogdm9pZCA9PiB7XG4gICAgICAgIHJhd01ldGhvZCguLi5tZXNzYWdlKTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBmaWx0ZXJNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICBpZiAoIWZpbHRlcmVkKSByZXR1cm47XG4gICAgICAgIGRiLnB1dChcbiAgICAgICAgICBjb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICB7IGxvZ2dlcjogbG9nZ2VyTmFtZSwgbGV2ZWw6IG1ldGhvZE5hbWUsIG1lc3NhZ2UgfSxcbiAgICAgICAgICBEYXRlLm5vdygpXG4gICAgICAgICkuY2F0Y2goKCkgPT5cbiAgICAgICAgICBkYi5wdXQoXG4gICAgICAgICAgICBjb2xsZWN0aW9uTmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbG9nZ2VyOiBsb2dnZXJOYW1lLFxuICAgICAgICAgICAgICBsZXZlbDogbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZS5tYXAoc2VyaWFsaXplKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIERhdGUubm93KClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldExvZ3NGcm9tU3RvcmUoKTogUHJvbWlzZTxbbnVtYmVyLCBzdHJpbmddPiB7XG4gIGxldCBjb250ZW50ID0gJyc7XG4gIGxldCBjdXJzb3IgPSBhd2FpdCBkYi50cmFuc2FjdGlvbihjb2xsZWN0aW9uTmFtZSkuc3RvcmUub3BlbkN1cnNvcigpO1xuICBsZXQgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xuICB3aGlsZSAoY3Vyc29yKSB7XG4gICAgY29uc3QgeyBsb2dnZXIsIGxldmVsLCBtZXNzYWdlIH0gPSBjdXJzb3IudmFsdWU7XG4gICAgY29uc3QgbGluZSA9IG1lc3NhZ2VcbiAgICAgIC5tYXAobSA9PiAodHlwZW9mIG0gPT09ICdzdHJpbmcnID8gbSA6IEpTT04uc3RyaW5naWZ5KG0pKSlcbiAgICAgIC5qb2luKCcgJyk7XG4gICAgbGFzdFRpbWUgPSArY3Vyc29yLmtleTtcbiAgICBjb25zdCB0aW1lID0gbmV3IERhdGUoY3Vyc29yLmtleSkudG9JU09TdHJpbmcoKTtcbiAgICBjb250ZW50ICs9IGAke3RpbWV9IEAgJHtsb2dnZXJ9IFske2xldmVsfV0gXFx0PT4gJHtsaW5lfVxcbmA7XG4gICAgY3Vyc29yID0gYXdhaXQgY3Vyc29yLmNvbnRpbnVlKCk7XG4gIH1cbiAgcmV0dXJuIFtsYXN0VGltZSwgY29udGVudF07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8aa9\n')},"8e33":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e349156a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/BlurredOverlay.vue?vue&type=template&id=1d51571c&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.show)?_c(\'div\',{staticClass:"blurred-overlay",class:{ fullscreen: _vm.fullscreen }},[_vm._t("default")],2):_vm._e()}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/BlurredOverlay.vue?vue&type=template&id=1d51571c&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__("9ab4");\n\n// EXTERNAL MODULE: ./node_modules/vue-property-decorator/lib/vue-property-decorator.js\nvar vue_property_decorator = __webpack_require__("60a3");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/BlurredOverlay.vue?vue&type=script&lang=ts&\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\nvar BlurredOverlay = /*#__PURE__*/function (_Vue) {\n  _inherits(BlurredOverlay, _Vue);\n\n  var _super = _createSuper(BlurredOverlay);\n\n  function BlurredOverlay() {\n    _classCallCheck(this, BlurredOverlay);\n\n    return _super.apply(this, arguments);\n  }\n\n  return BlurredOverlay;\n}(vue_property_decorator["e" /* Vue */]);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  type: Boolean,\n  required: true\n})], BlurredOverlay.prototype, "show", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  required: false,\n  default: false,\n  type: Boolean\n})], BlurredOverlay.prototype, "fullscreen", void 0);\n\nBlurredOverlay = Object(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["a" /* Component */])({})], BlurredOverlay);\n/* harmony default export */ var BlurredOverlayvue_type_script_lang_ts_ = (BlurredOverlay);\n// CONCATENATED MODULE: ./src/components/BlurredOverlay.vue?vue&type=script&lang=ts&\n /* harmony default export */ var components_BlurredOverlayvue_type_script_lang_ts_ = (BlurredOverlayvue_type_script_lang_ts_); \n// EXTERNAL MODULE: ./src/components/BlurredOverlay.vue?vue&type=style&index=0&id=1d51571c&scoped=true&lang=scss&\nvar BlurredOverlayvue_type_style_index_0_id_1d51571c_scoped_true_lang_scss_ = __webpack_require__("cb0b");\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__("2877");\n\n// CONCATENATED MODULE: ./src/components/BlurredOverlay.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  components_BlurredOverlayvue_type_script_lang_ts_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "1d51571c",\n  null\n  \n)\n\n/* harmony default export */ var components_BlurredOverlay = __webpack_exports__["a"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CbHVycmVkT3ZlcmxheS52dWU/ZjI3OSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CbHVycmVkT3ZlcmxheS52dWU/ZWRjMSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CbHVycmVkT3ZlcmxheS52dWU/MzZmNyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CbHVycmVkT3ZlcmxheS52dWU/ZjM0MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDBCQUEwQixhQUFhLDBCQUEwQix3QkFBd0IsNEJBQTRCLHFDQUFxQyw4QkFBOEI7QUFDeEw7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNNQTs7QUFHQSxJQUFxQixjQUFyQjtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBLEVBQTRDLHFDQUE1Qzs7QUFFRSx5Q0FEQyw4Q0FBSSxDQUFDO0FBQUUsTUFBSSxFQUFFLE9BQVI7QUFBaUIsVUFBUSxFQUFFO0FBQTNCLENBQUQsQ0FDTCxHLHdCQUFBLEUsTUFBQSxFLEtBQWUsQ0FBZjs7QUFFQSx5Q0FEQyw4Q0FBSSxDQUFDO0FBQUUsVUFBUSxFQUFFLEtBQVo7QUFBbUIsU0FBTyxFQUFFLEtBQTVCO0FBQW1DLE1BQUksRUFBRTtBQUF6QyxDQUFELENBQ0wsRyx3QkFBQSxFLFlBQUEsRSxLQUFxQixDQUFyQjs7QUFKbUIsY0FBYyw0Q0FEbEMsbURBQVMsQ0FBQyxFQUFELENBQ3lCLEdBQWQsY0FBYyxDQUFkO0FBQUEseUY7O0FDVitaLENBQWdCLDRIQUFHLEVBQUMsQzs7Ozs7Ozs7QUNBL1Y7QUFDdkM7QUFDTDtBQUNzQzs7O0FBR25HO0FBQzBGO0FBQzFGLGdCQUFnQiw4Q0FBVTtBQUMxQixFQUFFLGlEQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVlLDBHIiwiZmlsZSI6IjhlMzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiAoX3ZtLnNob3cpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImJsdXJyZWQtb3ZlcmxheVwiLGNsYXNzOnsgZnVsbHNjcmVlbjogX3ZtLmZ1bGxzY3JlZW4gfX0sW192bS5fdChcImRlZmF1bHRcIildLDIpOl92bS5fZSgpfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJcblxuXG5cblxuXG5cbmltcG9ydCB7IENvbXBvbmVudCwgVnVlLCBQcm9wIH0gZnJvbSAndnVlLXByb3BlcnR5LWRlY29yYXRvcic7XG5cbkBDb21wb25lbnQoe30pXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCbHVycmVkT3ZlcmxheSBleHRlbmRzIFZ1ZSB7XG4gIEBQcm9wKHsgdHlwZTogQm9vbGVhbiwgcmVxdWlyZWQ6IHRydWUgfSlcbiAgc2hvdyE6IGJvb2xlYW47XG4gIEBQcm9wKHsgcmVxdWlyZWQ6IGZhbHNlLCBkZWZhdWx0OiBmYWxzZSwgdHlwZTogQm9vbGVhbiB9KVxuICBmdWxsc2NyZWVuITogYm9vbGVhbjtcbn1cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xNC0wIS4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMTQtMyEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0yMS0wIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQmx1cnJlZE92ZXJsYXkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTQtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTE0LTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0JsdXJyZWRPdmVybGF5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vQmx1cnJlZE92ZXJsYXkudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTFkNTE1NzFjJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0JsdXJyZWRPdmVybGF5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vQmx1cnJlZE92ZXJsYXkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL0JsdXJyZWRPdmVybGF5LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFkNTE1NzFjJnNjb3BlZD10cnVlJmxhbmc9c2NzcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiMWQ1MTU3MWNcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8e33\n')},9302:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e349156a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/AddressDisplay.vue?vue&type=template&id=dda182e6&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"address__container"},[_c(\'v-tooltip\',{attrs:{"bottom":"","close-delay":"1400"},scopedSlots:_vm._u([{key:"activator",fn:function(ref){\nvar on = ref.on;\nreturn [_c(\'p\',_vm._g({staticClass:"address__label",on:{"click":_vm.copy}},on),[_vm._v(" "+_vm._s(_vm.addressOutput)+" ")])]}}])},[_c(\'div\',{staticClass:"address__tooltip"},[_c(\'input\',{ref:"copy",staticClass:"address__input",domProps:{"value":_vm.address}}),_c(\'div\',[_vm._v(" "+_vm._s(_vm.copied ? _vm.$t(\'address-display.copied\') : _vm.$t(\'address-display.copy\'))+" ")])])])],1)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/AddressDisplay.vue?vue&type=template&id=dda182e6&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__("9ab4");\n\n// EXTERNAL MODULE: ./node_modules/vue-property-decorator/lib/vue-property-decorator.js\nvar vue_property_decorator = __webpack_require__("60a3");\n\n// EXTERNAL MODULE: ./src/filters.ts\nvar filters = __webpack_require__("0f75");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/AddressDisplay.vue?vue&type=script&lang=ts&\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\nvar AddressDisplayvue_type_script_lang_ts_AddressDisplay = /*#__PURE__*/function (_Vue) {\n  _inherits(AddressDisplay, _Vue);\n\n  var _super = _createSuper(AddressDisplay);\n\n  function AddressDisplay() {\n    var _this;\n\n    _classCallCheck(this, AddressDisplay);\n\n    _this = _super.apply(this, arguments);\n    _this.copied = false;\n    _this.timeout = 0;\n    return _this;\n  }\n\n  _createClass(AddressDisplay, [{\n    key: "selectAddress",\n    value: function selectAddress(input) {\n      if (input) {\n        input.focus();\n        input.select();\n      }\n    }\n  }, {\n    key: "deselectAddress",\n    value: function deselectAddress(input) {\n      if (input) {\n        input.blur();\n      }\n    }\n  }, {\n    key: "copy",\n    value: function copy(event) {\n      var _this2 = this;\n\n      event.stopPropagation(); // Select address\n\n      this.selectAddress(this.$refs.copy);\n      this.copied = document.execCommand(\'copy\'); // Deselect text\n\n      this.deselectAddress(this.$refs.copy);\n\n      if (this.timeout) {\n        clearTimeout(this.timeout);\n      }\n\n      this.timeout = setTimeout(function () {\n        _this2.copied = false;\n      }, 2000);\n    }\n  }, {\n    key: "addressOutput",\n    get: function get() {\n      return this.fullAddress ? this.address : filters["a" /* default */].truncate(this.address, 8);\n    }\n  }]);\n\n  return AddressDisplay;\n}(vue_property_decorator["e" /* Vue */]);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  required: true\n})], AddressDisplayvue_type_script_lang_ts_AddressDisplay.prototype, "address", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  required: false,\n  default: false,\n  type: Boolean\n})], AddressDisplayvue_type_script_lang_ts_AddressDisplay.prototype, "fullAddress", void 0);\n\nAddressDisplayvue_type_script_lang_ts_AddressDisplay = Object(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["a" /* Component */])({})], AddressDisplayvue_type_script_lang_ts_AddressDisplay);\n/* harmony default export */ var AddressDisplayvue_type_script_lang_ts_ = (AddressDisplayvue_type_script_lang_ts_AddressDisplay);\n// CONCATENATED MODULE: ./src/components/AddressDisplay.vue?vue&type=script&lang=ts&\n /* harmony default export */ var components_AddressDisplayvue_type_script_lang_ts_ = (AddressDisplayvue_type_script_lang_ts_); \n// EXTERNAL MODULE: ./src/components/AddressDisplay.vue?vue&type=style&index=0&id=dda182e6&lang=scss&scoped=true&\nvar AddressDisplayvue_type_style_index_0_id_dda182e6_lang_scss_scoped_true_ = __webpack_require__("a130");\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__("2877");\n\n// EXTERNAL MODULE: ./node_modules/vuetify-loader/lib/runtime/installComponents.js\nvar installComponents = __webpack_require__("6544");\nvar installComponents_default = /*#__PURE__*/__webpack_require__.n(installComponents);\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VTooltip/VTooltip.js\nvar VTooltip = __webpack_require__("3a2f");\n\n// CONCATENATED MODULE: ./src/components/AddressDisplay.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  components_AddressDisplayvue_type_script_lang_ts_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "dda182e6",\n  null\n  \n)\n\n/* harmony default export */ var components_AddressDisplay = __webpack_exports__["a"] = (component.exports);\n\n/* vuetify-loader */\n\n\ninstallComponents_default()(component, {VTooltip: VTooltip["a" /* default */]})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BZGRyZXNzRGlzcGxheS52dWU/YzI4NiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BZGRyZXNzRGlzcGxheS52dWU/NDczMiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BZGRyZXNzRGlzcGxheS52dWU/YjY1ZCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BZGRyZXNzRGlzcGxheS52dWU/NTQ2NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDBCQUEwQixhQUFhLDBCQUEwQix3QkFBd0IsaUJBQWlCLGlDQUFpQyxrQkFBa0IsT0FBTyxpQ0FBaUMsc0JBQXNCO0FBQzNOO0FBQ0EsdUJBQXVCLGlDQUFpQyxrQkFBa0Isb0RBQW9ELEdBQUcsWUFBWSwrQkFBK0IsY0FBYyxrREFBa0QscUJBQXFCO0FBQ2pROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2tCQTtBQUNBOztBQUdBLElBQXFCLG9EQUFyQjtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7OztBQU9FLG1CQUFrQixLQUFsQjtBQUNRLG9CQUFrQixDQUFsQjtBQVJWO0FBNkNDOztBQTdDRDtBQUFBO0FBQUEsa0NBY2dCLEtBZGhCLEVBY3dDO0FBQ3BDLFVBQUksS0FBSixFQUFXO0FBQ1QsYUFBSyxDQUFDLEtBQU47QUFDQSxhQUFLLENBQUMsTUFBTjtBQUNEO0FBQ0Y7QUFuQkg7QUFBQTtBQUFBLG9DQXFCa0IsS0FyQmxCLEVBcUIwQztBQUN0QyxVQUFJLEtBQUosRUFBVztBQUNULGFBQUssQ0FBQyxJQUFOO0FBQ0Q7QUFDRjtBQXpCSDtBQUFBO0FBQUEseUJBMkJPLEtBM0JQLEVBMkJ3QjtBQUFBOztBQUNwQixXQUFLLENBQUMsZUFBTixHQURvQixDQUdwQjs7QUFDQSxXQUFLLGFBQUwsQ0FBbUIsS0FBSyxLQUFMLENBQVcsSUFBOUI7QUFDQSxXQUFLLE1BQUwsR0FBYyxRQUFRLENBQUMsV0FBVCxDQUFxQixNQUFyQixDQUFkLENBTG9CLENBT3BCOztBQUNBLFdBQUssZUFBTCxDQUFxQixLQUFLLEtBQUwsQ0FBVyxJQUFoQzs7QUFFQSxVQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNoQixvQkFBWSxDQUFDLEtBQUssT0FBTixDQUFaO0FBQ0Q7O0FBRUQsV0FBSyxPQUFMLEdBQWdCLFVBQVUsQ0FBQyxZQUFLO0FBQzlCLGNBQUksQ0FBQyxNQUFMLEdBQWMsS0FBZDtBQUNELE9BRnlCLEVBRXZCLElBRnVCLENBQTFCO0FBR0Q7QUE1Q0g7QUFBQTtBQUFBLHdCQVVtQjtBQUNmLGFBQU8sS0FBSyxXQUFMLEdBQW1CLEtBQUssT0FBeEIsR0FBa0MsMEJBQU8sQ0FBQyxRQUFSLENBQWlCLEtBQUssT0FBdEIsRUFBK0IsQ0FBL0IsQ0FBekM7QUFDRDtBQVpIOztBQUFBO0FBQUEsRUFBNEMscUNBQTVDOztBQUVFLHlDQURDLDhDQUFJLENBQUM7QUFBRSxVQUFRLEVBQUU7QUFBWixDQUFELENBQ0wsRyw4REFBQSxFLFNBQUEsRSxLQUFpQixDQUFqQjs7QUFHQSx5Q0FEQyw4Q0FBSSxDQUFDO0FBQUUsVUFBUSxFQUFFLEtBQVo7QUFBbUIsU0FBTyxFQUFFLEtBQTVCO0FBQW1DLE1BQUksRUFBRTtBQUF6QyxDQUFELENBQ0wsRyw4REFBQSxFLGFBQUEsRSxLQUFzQixDQUF0Qjs7QUFMbUIsb0RBQWMsNENBRGxDLG1EQUFTLENBQUMsRUFBRCxDQUN5QixHQUFkLG9EQUFjLENBQWQ7QUFBQSwrSDs7QUN6QitaLENBQWdCLDRIQUFHLEVBQUMsQzs7Ozs7Ozs7Ozs7Ozs7O0FDQS9WO0FBQ3ZDO0FBQ0w7QUFDc0M7OztBQUduRztBQUMwRjtBQUMxRixnQkFBZ0IsOENBQVU7QUFDMUIsRUFBRSxpREFBTTtBQUNSLEVBQUUsTUFBTTtBQUNSLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZSwwR0FBaUI7O0FBRWhDO0FBQ21HO0FBQ3hDO0FBQzNELDJCQUFpQixhQUFhLHFDQUFRLENBQUMiLCJmaWxlIjoiOTMwMi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImFkZHJlc3NfX2NvbnRhaW5lclwifSxbX2MoJ3YtdG9vbHRpcCcse2F0dHJzOntcImJvdHRvbVwiOlwiXCIsXCJjbG9zZS1kZWxheVwiOlwiMTQwMFwifSxzY29wZWRTbG90czpfdm0uX3UoW3trZXk6XCJhY3RpdmF0b3JcIixmbjpmdW5jdGlvbihyZWYpe1xudmFyIG9uID0gcmVmLm9uO1xucmV0dXJuIFtfYygncCcsX3ZtLl9nKHtzdGF0aWNDbGFzczpcImFkZHJlc3NfX2xhYmVsXCIsb246e1wiY2xpY2tcIjpfdm0uY29weX19LG9uKSxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0uYWRkcmVzc091dHB1dCkrXCIgXCIpXSldfX1dKX0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImFkZHJlc3NfX3Rvb2x0aXBcIn0sW19jKCdpbnB1dCcse3JlZjpcImNvcHlcIixzdGF0aWNDbGFzczpcImFkZHJlc3NfX2lucHV0XCIsZG9tUHJvcHM6e1widmFsdWVcIjpfdm0uYWRkcmVzc319KSxfYygnZGl2JyxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0uY29waWVkID8gX3ZtLiR0KCdhZGRyZXNzLWRpc3BsYXkuY29waWVkJykgOiBfdm0uJHQoJ2FkZHJlc3MtZGlzcGxheS5jb3B5JykpK1wiIFwiKV0pXSldKV0sMSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmltcG9ydCB7IENvbXBvbmVudCwgUHJvcCwgVnVlIH0gZnJvbSAndnVlLXByb3BlcnR5LWRlY29yYXRvcic7XG5pbXBvcnQgRmlsdGVycyBmcm9tICcuLi9maWx0ZXJzJztcblxuQENvbXBvbmVudCh7fSlcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFkZHJlc3NEaXNwbGF5IGV4dGVuZHMgVnVlIHtcbiAgQFByb3AoeyByZXF1aXJlZDogdHJ1ZSB9KVxuICBhZGRyZXNzITogc3RyaW5nO1xuXG4gIEBQcm9wKHsgcmVxdWlyZWQ6IGZhbHNlLCBkZWZhdWx0OiBmYWxzZSwgdHlwZTogQm9vbGVhbiB9KVxuICBmdWxsQWRkcmVzcyE6IGJvb2xlYW47XG5cbiAgY29waWVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgdGltZW91dDogbnVtYmVyID0gMDtcblxuICBnZXQgYWRkcmVzc091dHB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsQWRkcmVzcyA/IHRoaXMuYWRkcmVzcyA6IEZpbHRlcnMudHJ1bmNhdGUodGhpcy5hZGRyZXNzLCA4KTtcbiAgfVxuXG4gIHNlbGVjdEFkZHJlc3MoaW5wdXQ/OiBIVE1MSW5wdXRFbGVtZW50KTogdm9pZCB7XG4gICAgaWYgKGlucHV0KSB7XG4gICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgaW5wdXQuc2VsZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgZGVzZWxlY3RBZGRyZXNzKGlucHV0PzogSFRNTElucHV0RWxlbWVudCk6IHZvaWQge1xuICAgIGlmIChpbnB1dCkge1xuICAgICAgaW5wdXQuYmx1cigpO1xuICAgIH1cbiAgfVxuXG4gIGNvcHkoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIC8vIFNlbGVjdCBhZGRyZXNzXG4gICAgdGhpcy5zZWxlY3RBZGRyZXNzKHRoaXMuJHJlZnMuY29weSBhcyBIVE1MSW5wdXRFbGVtZW50KTtcbiAgICB0aGlzLmNvcGllZCA9IGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG5cbiAgICAvLyBEZXNlbGVjdCB0ZXh0XG4gICAgdGhpcy5kZXNlbGVjdEFkZHJlc3ModGhpcy4kcmVmcy5jb3B5IGFzIEhUTUxJbnB1dEVsZW1lbnQpO1xuXG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgfVxuXG4gICAgdGhpcy50aW1lb3V0ID0gKHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jb3BpZWQgPSBmYWxzZTtcbiAgICB9LCAyMDAwKSBhcyB1bmtub3duKSBhcyBudW1iZXI7XG4gIH1cbn1cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xNC0wIS4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMTQtMyEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0yMS0wIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQWRkcmVzc0Rpc3BsYXkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTQtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTE0LTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FkZHJlc3NEaXNwbGF5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vQWRkcmVzc0Rpc3BsYXkudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWRkYTE4MmU2JnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0FkZHJlc3NEaXNwbGF5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vQWRkcmVzc0Rpc3BsYXkudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL0FkZHJlc3NEaXNwbGF5LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWRkYTE4MmU2Jmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiZGRhMTgyZTZcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHNcblxuLyogdnVldGlmeS1sb2FkZXIgKi9cbmltcG9ydCBpbnN0YWxsQ29tcG9uZW50cyBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvcnVudGltZS9pbnN0YWxsQ29tcG9uZW50cy5qc1wiXG5pbXBvcnQgeyBWVG9vbHRpcCB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVlRvb2x0aXAnO1xuaW5zdGFsbENvbXBvbmVudHMoY29tcG9uZW50LCB7VlRvb2x0aXB9KVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9302\n')},"94e9":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ob0FjY2Vzc01lc3NhZ2UudnVlP2EyNzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiOTRlOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///94e9\n")},"9a9c":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvSG9tZS52dWU/MGNlYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI5YTljLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9a9c\n")},"9b19":function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "img/logo.5c4b022d.svg";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL2xvZ28uc3ZnPzExMTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLHFCQUF1QiIsImZpbGUiOiI5YjE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiaW1nL2xvZ28uNWM0YjAyMmQuc3ZnXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9b19\n')},"9e24":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AppHeader_vue_vue_type_style_index_0_id_6ccf2084_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("51ea");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AppHeader_vue_vue_type_style_index_0_id_6ccf2084_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AppHeader_vue_vue_type_style_index_0_id_6ccf2084_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AppHeader_vue_vue_type_style_index_0_id_6ccf2084_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BcHBIZWFkZXIudnVlP2E0MGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQWlsQixDQUFnQiwrbUJBQUcsRUFBQyIsImZpbGUiOiI5ZTI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tOC1vbmVPZi0xLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tOC1vbmVPZi0xLTIhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTgtb25lT2YtMS0zIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BcHBIZWFkZXIudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NmNjZjIwODQmbGFuZz1zY3NzJnNjb3BlZD10cnVlJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS04LW9uZU9mLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS04LW9uZU9mLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS04LW9uZU9mLTEtMiEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FwcEhlYWRlci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD02Y2NmMjA4NCZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9e24\n')},a0df:function(module){eval('module.exports = JSON.parse("{\\"contracts_version\\":null,\\"chain_id\\":3,\\"contracts\\":{\\"SecretRegistry\\":{\\"address\\":\\"0xC1b67a7e53511e59B96B35472c3eB1c1f84C2baf\\",\\"transaction_hash\\":\\"0x59a02287485ff7ac0153022959f0bbe4a044242ba94bb53f7dedbafd4d35fb4e\\",\\"block_number\\":7255736,\\"gas_cost\\":247082,\\"constructor_arguments\\":[]},\\"TokenNetworkRegistry\\":{\\"address\\":\\"0x3DE1B1E10Ae71C3E3b793e545A047d1B4FAB587a\\",\\"transaction_hash\\":\\"0x20ae67f204baca19726e040399ab2fc45fd3e8abdd16eb3d67abeca2eab31d45\\",\\"block_number\\":7255738,\\"gas_cost\\":4001114,\\"constructor_arguments\\":[\\"0xC1b67a7e53511e59B96B35472c3eB1c1f84C2baf\\",3,20,555428,1.157920892373162e+77]}}}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJhMGRmLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///a0df\n')},a130:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AddressDisplay_vue_vue_type_style_index_0_id_dda182e6_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("e1fc");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AddressDisplay_vue_vue_type_style_index_0_id_dda182e6_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AddressDisplay_vue_vue_type_style_index_0_id_dda182e6_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_AddressDisplay_vue_vue_type_style_index_0_id_dda182e6_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BZGRyZXNzRGlzcGxheS52dWU/NjQwNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBc2xCLENBQWdCLG9uQkFBRyxFQUFDIiwiZmlsZSI6ImExMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS04LW9uZU9mLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS04LW9uZU9mLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS04LW9uZU9mLTEtMiEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FkZHJlc3NEaXNwbGF5LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWRkYTE4MmU2Jmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tOC1vbmVPZi0xLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tOC1vbmVPZi0xLTIhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTgtb25lT2YtMS0zIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BZGRyZXNzRGlzcGxheS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1kZGExODJlNiZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///a130\n')},a3d5:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BalanceUtils; });\n/* harmony import */ var ethers_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("6934");\n/* harmony import */ var ethers_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ethers_utils__WEBPACK_IMPORTED_MODULE_0__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar BalanceUtils = /*#__PURE__*/function () {\n  function BalanceUtils() {\n    _classCallCheck(this, BalanceUtils);\n  }\n\n  _createClass(BalanceUtils, null, [{\n    key: "toEth",\n    value: function toEth(wei) {\n      return Object(ethers_utils__WEBPACK_IMPORTED_MODULE_0__["formatEther"])(wei);\n    }\n  }, {\n    key: "toUnits",\n    value: function toUnits(wei, decimals) {\n      return Object(ethers_utils__WEBPACK_IMPORTED_MODULE_0__["formatUnits"])(wei, decimals);\n    }\n  }, {\n    key: "decimalsOverflow",\n    value: function decimalsOverflow(depositTokens, decimals) {\n      var decimalPart;\n\n      if (depositTokens.indexOf(\'.\') > 0) {\n        decimalPart = depositTokens.split(\'.\')[1];\n      } else {\n        decimalPart = \'\';\n      }\n\n      return decimalPart.length > decimals;\n    }\n  }, {\n    key: "parse",\n    value: function parse(deposit, decimals) {\n      return Object(ethers_utils__WEBPACK_IMPORTED_MODULE_0__["parseUnits"])(deposit, decimals);\n    }\n  }]);\n\n  return BalanceUtils;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvYmFsYW5jZS11dGlscy50cz9kOWUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBRU8sSUFBTSxZQUFiO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSwwQkFDZSxHQURmLEVBQzZCO0FBQ3pCLGFBQU8sZ0VBQVcsQ0FBQyxHQUFELENBQWxCO0FBQ0Q7QUFISDtBQUFBO0FBQUEsNEJBS2lCLEdBTGpCLEVBS2lDLFFBTGpDLEVBS2lEO0FBQzdDLGFBQU8sZ0VBQVcsQ0FBQyxHQUFELEVBQU0sUUFBTixDQUFsQjtBQUNEO0FBUEg7QUFBQTtBQUFBLHFDQVMwQixhQVQxQixFQVNpRCxRQVRqRCxFQVNpRTtBQUM3RCxVQUFJLFdBQUo7O0FBQ0EsVUFBSSxhQUFhLENBQUMsT0FBZCxDQUFzQixHQUF0QixJQUE2QixDQUFqQyxFQUFvQztBQUNsQyxtQkFBVyxHQUFHLGFBQWEsQ0FBQyxLQUFkLENBQW9CLEdBQXBCLEVBQXlCLENBQXpCLENBQWQ7QUFDRCxPQUZELE1BRU87QUFDTCxtQkFBVyxHQUFHLEVBQWQ7QUFDRDs7QUFDRCxhQUFPLFdBQVcsQ0FBQyxNQUFaLEdBQXFCLFFBQTVCO0FBQ0Q7QUFqQkg7QUFBQTtBQUFBLDBCQW1CZSxPQW5CZixFQW1CZ0MsUUFuQmhDLEVBbUJnRDtBQUM1QyxhQUFPLCtEQUFVLENBQUMsT0FBRCxFQUFVLFFBQVYsQ0FBakI7QUFDRDtBQXJCSDs7QUFBQTtBQUFBIiwiZmlsZSI6ImEzZDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCaWdOdW1iZXIsIHBhcnNlVW5pdHMsIGZvcm1hdFVuaXRzLCBmb3JtYXRFdGhlciB9IGZyb20gJ2V0aGVycy91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBCYWxhbmNlVXRpbHMge1xuICBzdGF0aWMgdG9FdGgod2VpOiBCaWdOdW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBmb3JtYXRFdGhlcih3ZWkpO1xuICB9XG5cbiAgc3RhdGljIHRvVW5pdHMod2VpOiBCaWdOdW1iZXIsIGRlY2ltYWxzOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBmb3JtYXRVbml0cyh3ZWksIGRlY2ltYWxzKTtcbiAgfVxuXG4gIHN0YXRpYyBkZWNpbWFsc092ZXJmbG93KGRlcG9zaXRUb2tlbnM6IHN0cmluZywgZGVjaW1hbHM6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGxldCBkZWNpbWFsUGFydDogc3RyaW5nO1xuICAgIGlmIChkZXBvc2l0VG9rZW5zLmluZGV4T2YoJy4nKSA+IDApIHtcbiAgICAgIGRlY2ltYWxQYXJ0ID0gZGVwb3NpdFRva2Vucy5zcGxpdCgnLicpWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWNpbWFsUGFydCA9ICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGVjaW1hbFBhcnQubGVuZ3RoID4gZGVjaW1hbHM7XG4gIH1cblxuICBzdGF0aWMgcGFyc2UoZGVwb3NpdDogc3RyaW5nLCBkZWNpbWFsczogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHBhcnNlVW5pdHMoZGVwb3NpdCwgZGVjaW1hbHMpO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///a3d5\n')},a491:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT9kNmZlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImE0OTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///a491\n")},a53d:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_id_52aa355e_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a491");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_id_52aa355e_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_id_52aa355e_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_id_52aa355e_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT80N2IyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFtakIsQ0FBZ0IseW1CQUFHLEVBQUMiLCJmaWxlIjoiYTUzZC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzPz9yZWYtLTgtb25lT2YtMS0wIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTgtb25lT2YtMS0xIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTgtb25lT2YtMS0yIS4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS04LW9uZU9mLTEtMyEuLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0yMS0wIS4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQXBwLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTUyYWEzNTVlJmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tOC1vbmVPZi0xLTAhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tOC1vbmVPZi0xLTIhLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTgtb25lT2YtMS0zIS4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BcHAudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NTJhYTM1NWUmbGFuZz1zY3NzJnNjb3BlZD10cnVlJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///a53d\n')},a683:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e349156a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/RaidenDialog.vue?vue&type=template&id=23c69e33&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'blurred-overlay\',{attrs:{"show":_vm.visible,"fullscreen":""}},[_c(\'v-dialog\',{attrs:{"value":_vm.visible,"width":"350","hide-overlay":"","dark":"","persistent":_vm.hideClose},on:{"click:outside":function($event){return _vm.close()}}},[_c(\'v-card\',{staticClass:"raiden-dialog"},[(!_vm.hideClose)?_c(\'v-btn\',{staticClass:"raiden-dialog__close",attrs:{"icon":""},on:{"click":function($event){return _vm.close()}}},[_c(\'v-icon\',[_vm._v("mdi-close")])],1):_vm._e(),_vm._t("default")],2)],1)],1)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/RaidenDialog.vue?vue&type=template&id=23c69e33&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__("9ab4");\n\n// EXTERNAL MODULE: ./src/components/BlurredOverlay.vue + 4 modules\nvar BlurredOverlay = __webpack_require__("8e33");\n\n// EXTERNAL MODULE: ./node_modules/vue-property-decorator/lib/vue-property-decorator.js\nvar vue_property_decorator = __webpack_require__("60a3");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/RaidenDialog.vue?vue&type=script&lang=ts&\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\nvar RaidenDialog = /*#__PURE__*/function (_Vue) {\n  _inherits(RaidenDialog, _Vue);\n\n  var _super = _createSuper(RaidenDialog);\n\n  function RaidenDialog() {\n    _classCallCheck(this, RaidenDialog);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(RaidenDialog, [{\n    key: "close",\n    value: function close() {}\n  }]);\n\n  return RaidenDialog;\n}(vue_property_decorator["e" /* Vue */]);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  required: true,\n  default: false,\n  type: Boolean\n})], RaidenDialog.prototype, "visible", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  required: false,\n  default: false,\n  type: Boolean\n})], RaidenDialog.prototype, "hideClose", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["b" /* Emit */])()], RaidenDialog.prototype, "close", null);\n\nRaidenDialog = Object(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["a" /* Component */])({\n  components: {\n    BlurredOverlay: BlurredOverlay["a" /* default */]\n  }\n})], RaidenDialog);\n/* harmony default export */ var RaidenDialogvue_type_script_lang_ts_ = (RaidenDialog);\n// CONCATENATED MODULE: ./src/components/RaidenDialog.vue?vue&type=script&lang=ts&\n /* harmony default export */ var components_RaidenDialogvue_type_script_lang_ts_ = (RaidenDialogvue_type_script_lang_ts_); \n// EXTERNAL MODULE: ./src/components/RaidenDialog.vue?vue&type=style&index=0&id=23c69e33&scoped=true&lang=scss&\nvar RaidenDialogvue_type_style_index_0_id_23c69e33_scoped_true_lang_scss_ = __webpack_require__("508d");\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__("2877");\n\n// EXTERNAL MODULE: ./node_modules/vuetify-loader/lib/runtime/installComponents.js\nvar installComponents = __webpack_require__("6544");\nvar installComponents_default = /*#__PURE__*/__webpack_require__.n(installComponents);\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VBtn/VBtn.js\nvar VBtn = __webpack_require__("8336");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VCard/VCard.js\nvar VCard = __webpack_require__("b0af");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VDialog/VDialog.js + 1 modules\nvar VDialog = __webpack_require__("169a");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VIcon/VIcon.js\nvar VIcon = __webpack_require__("132d");\n\n// CONCATENATED MODULE: ./src/components/RaidenDialog.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  components_RaidenDialogvue_type_script_lang_ts_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "23c69e33",\n  null\n  \n)\n\n/* harmony default export */ var components_RaidenDialog = __webpack_exports__["a"] = (component.exports);\n\n/* vuetify-loader */\n\n\n\n\n\ninstallComponents_default()(component, {VBtn: VBtn["a" /* default */],VCard: VCard["a" /* default */],VDialog: VDialog["a" /* default */],VIcon: VIcon["a" /* default */]})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9SYWlkZW5EaWFsb2cudnVlPzhjODgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmFpZGVuRGlhbG9nLnZ1ZT85NjRhIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1JhaWRlbkRpYWxvZy52dWU/NDJkNiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9SYWlkZW5EaWFsb2cudnVlPzNmMDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwwQkFBMEIsYUFBYSwwQkFBMEIsd0JBQXdCLDZCQUE2QixPQUFPLG9DQUFvQyxpQkFBaUIsT0FBTyx5RkFBeUYsS0FBSyxpQ0FBaUMscUJBQXFCLGVBQWUsNEJBQTRCLCtCQUErQiwwQ0FBMEMsVUFBVSxLQUFLLHlCQUF5QixxQkFBcUI7QUFDOWY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeUJBO0FBQ0E7O0FBR0EsSUFBcUIsWUFBckI7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLDRCQU9PLENBQUs7QUFQWjs7QUFBQTtBQUFBLEVBQTBDLHFDQUExQzs7QUFFRSx5Q0FEQyw4Q0FBSSxDQUFDO0FBQUUsVUFBUSxFQUFFLElBQVo7QUFBa0IsU0FBTyxFQUFFLEtBQTNCO0FBQWtDLE1BQUksRUFBRTtBQUF4QyxDQUFELENBQ0wsRyxzQkFBQSxFLFNBQUEsRSxLQUFrQixDQUFsQjs7QUFFQSx5Q0FEQyw4Q0FBSSxDQUFDO0FBQUUsVUFBUSxFQUFFLEtBQVo7QUFBbUIsU0FBTyxFQUFFLEtBQTVCO0FBQW1DLE1BQUksRUFBRTtBQUF6QyxDQUFELENBQ0wsRyxzQkFBQSxFLFdBQUEsRSxLQUFvQixDQUFwQjs7QUFHQSx5Q0FEQyw4Q0FBSSxFQUNMLEcsc0JBQUEsRSxPQUFBLEVBQVUsSUFBVjs7QUFQbUIsWUFBWSw0Q0FEaEMsbURBQVMsQ0FBQztBQUFFLFlBQVUsRUFBRTtBQUFFLGtCQUFjLEVBQWQsaUNBQWM7QUFBaEI7QUFBZCxDQUFELENBQ3VCLEdBQVosWUFBWSxDQUFaO0FBQUEscUY7O0FDOUI2WixDQUFnQix3SEFBRyxFQUFDLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0EvVjtBQUN2QztBQUNMO0FBQ3NDOzs7QUFHakc7QUFDMEY7QUFDMUYsZ0JBQWdCLDhDQUFVO0FBQzFCLEVBQUUsK0NBQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsd0dBQWlCOztBQUVoQztBQUNtRztBQUNoRDtBQUNFO0FBQ0k7QUFDSjtBQUNyRCwyQkFBaUIsYUFBYSw2QkFBSSxDQUFDLCtCQUFLLENBQUMsbUNBQU8sQ0FBQywrQkFBSyxDQUFDIiwiZmlsZSI6ImE2ODMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnYmx1cnJlZC1vdmVybGF5Jyx7YXR0cnM6e1wic2hvd1wiOl92bS52aXNpYmxlLFwiZnVsbHNjcmVlblwiOlwiXCJ9fSxbX2MoJ3YtZGlhbG9nJyx7YXR0cnM6e1widmFsdWVcIjpfdm0udmlzaWJsZSxcIndpZHRoXCI6XCIzNTBcIixcImhpZGUtb3ZlcmxheVwiOlwiXCIsXCJkYXJrXCI6XCJcIixcInBlcnNpc3RlbnRcIjpfdm0uaGlkZUNsb3NlfSxvbjp7XCJjbGljazpvdXRzaWRlXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLmNsb3NlKCl9fX0sW19jKCd2LWNhcmQnLHtzdGF0aWNDbGFzczpcInJhaWRlbi1kaWFsb2dcIn0sWyghX3ZtLmhpZGVDbG9zZSk/X2MoJ3YtYnRuJyx7c3RhdGljQ2xhc3M6XCJyYWlkZW4tZGlhbG9nX19jbG9zZVwiLGF0dHJzOntcImljb25cIjpcIlwifSxvbjp7XCJjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7cmV0dXJuIF92bS5jbG9zZSgpfX19LFtfYygndi1pY29uJyxbX3ZtLl92KFwibWRpLWNsb3NlXCIpXSldLDEpOl92bS5fZSgpLF92bS5fdChcImRlZmF1bHRcIildLDIpXSwxKV0sMSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5pbXBvcnQgQmx1cnJlZE92ZXJsYXkgZnJvbSAnQC9jb21wb25lbnRzL0JsdXJyZWRPdmVybGF5LnZ1ZSc7XG5pbXBvcnQgeyBDb21wb25lbnQsIEVtaXQsIFZ1ZSwgUHJvcCB9IGZyb20gJ3Z1ZS1wcm9wZXJ0eS1kZWNvcmF0b3InO1xuXG5AQ29tcG9uZW50KHsgY29tcG9uZW50czogeyBCbHVycmVkT3ZlcmxheSB9IH0pXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWlkZW5EaWFsb2cgZXh0ZW5kcyBWdWUge1xuICBAUHJvcCh7IHJlcXVpcmVkOiB0cnVlLCBkZWZhdWx0OiBmYWxzZSwgdHlwZTogQm9vbGVhbiB9KVxuICB2aXNpYmxlITogYm9vbGVhbjtcbiAgQFByb3AoeyByZXF1aXJlZDogZmFsc2UsIGRlZmF1bHQ6IGZhbHNlLCB0eXBlOiBCb29sZWFuIH0pXG4gIGhpZGVDbG9zZSE6IGJvb2xlYW47XG5cbiAgQEVtaXQoKVxuICBjbG9zZSgpIHt9XG59XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTQtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTE0LTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1JhaWRlbkRpYWxvZy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xNC0wIS4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMTQtMyEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0yMS0wIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vUmFpZGVuRGlhbG9nLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vUmFpZGVuRGlhbG9nLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yM2M2OWUzMyZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9SYWlkZW5EaWFsb2cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9SYWlkZW5EaWFsb2cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL1JhaWRlbkRpYWxvZy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0yM2M2OWUzMyZzY29wZWQ9dHJ1ZSZsYW5nPXNjc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjIzYzY5ZTMzXCIsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzXG5cbi8qIHZ1ZXRpZnktbG9hZGVyICovXG5pbXBvcnQgaW5zdGFsbENvbXBvbmVudHMgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL3J1bnRpbWUvaW5zdGFsbENvbXBvbmVudHMuanNcIlxuaW1wb3J0IHsgVkJ0biB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkJ0bic7XG5pbXBvcnQgeyBWQ2FyZCB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkNhcmQnO1xuaW1wb3J0IHsgVkRpYWxvZyB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkRpYWxvZyc7XG5pbXBvcnQgeyBWSWNvbiB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkljb24nO1xuaW5zdGFsbENvbXBvbmVudHMoY29tcG9uZW50LCB7VkJ0bixWQ2FyZCxWRGlhbG9nLFZJY29ufSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///a683\n')},b4cc:function(module){eval('module.exports = JSON.parse("{\\"contracts_version\\":null,\\"chain_id\\":3,\\"contracts\\":{\\"ServiceRegistry\\":{\\"address\\":\\"0x8b6358D7bD07dF6a0454383249975C5575a2C4c0\\",\\"transaction_hash\\":\\"0xc7bb55a286aa1dba66dc08a8197be50e8b4dc2658ff1867a998e292c30e5cc2c\\",\\"block_number\\":7255768,\\"gas_cost\\":1980416,\\"constructor_arguments\\":[\\"0x83e827B34e85F6f9019296299d0c13d9BE2B9D70\\",\\"0x0000000000000000000000000000000000000000\\",2e+21,6,5,17280000,1000,17280000]},\\"UserDeposit\\":{\\"address\\":\\"0x87Dd0D812161Dc6D210254c7e7B81E3aD3FfD4EF\\",\\"transaction_hash\\":\\"0x9f6a524f5ce39584637d2d60a9726e1f4137de10cd892b46852f1b903680f008\\",\\"block_number\\":7255770,\\"gas_cost\\":1530254,\\"constructor_arguments\\":[\\"0x83e827B34e85F6f9019296299d0c13d9BE2B9D70\\",1.157920892373162e+77]},\\"MonitoringService\\":{\\"address\\":\\"0xFE94CfD16926af2EfD31C3F7F7d60D40180cA552\\",\\"transaction_hash\\":\\"0xd3bcc2d4d6b7cf9c0d899cc6bdde3f9ebc88769c925d0c77fa736138e5d4e4f3\\",\\"block_number\\":7255775,\\"gas_cost\\":1949685,\\"constructor_arguments\\":[\\"0x83e827B34e85F6f9019296299d0c13d9BE2B9D70\\",\\"0x8b6358D7bD07dF6a0454383249975C5575a2C4c0\\",\\"0x87Dd0D812161Dc6D210254c7e7B81E3aD3FfD4EF\\",\\"0x3DE1B1E10Ae71C3E3b793e545A047d1B4FAB587a\\"]},\\"OneToN\\":{\\"address\\":\\"0x69A69251f281eEf1926fdF7744BcE48163493E9f\\",\\"transaction_hash\\":\\"0x70e3b1d71a77a85357c14f8e1e1b9ed73696f59025e93358a540a9bfbe9c8d7f\\",\\"block_number\\":7255778,\\"gas_cost\\":1097569,\\"constructor_arguments\\":[\\"0x87Dd0D812161Dc6D210254c7e7B81E3aD3FfD4EF\\",3,\\"0x8b6358D7bD07dF6a0454383249975C5575a2C4c0\\"]}}}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJiNGNjLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///b4cc\n')},be88:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_HeaderIdenticon_vue_vue_type_style_index_0_id_b740b99e_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("09b0");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_HeaderIdenticon_vue_vue_type_style_index_0_id_b740b99e_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_HeaderIdenticon_vue_vue_type_style_index_0_id_b740b99e_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_HeaderIdenticon_vue_vue_type_style_index_0_id_b740b99e_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9IZWFkZXJJZGVudGljb24udnVlPzgwZjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQXVsQixDQUFnQixxbkJBQUcsRUFBQyIsImZpbGUiOiJiZTg4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tOC1vbmVPZi0xLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tOC1vbmVPZi0xLTIhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTgtb25lT2YtMS0zIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9IZWFkZXJJZGVudGljb24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9Yjc0MGI5OWUmc2NvcGVkPXRydWUmbGFuZz1zY3NzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS04LW9uZU9mLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS04LW9uZU9mLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS04LW9uZU9mLTEtMiEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0hlYWRlcklkZW50aWNvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1iNzQwYjk5ZSZzY29wZWQ9dHJ1ZSZsYW5nPXNjc3MmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///be88\n')},bf6c:function(module){eval('module.exports = JSON.parse("{\\"sdk\\":\\"0.6.0\\",\\"contracts\\":\\"0.36.2\\"}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJiZjZjLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///bf6c\n')},c6c9:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ActionButton_vue_vue_type_style_index_0_id_de9d7fe4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("51ce");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ActionButton_vue_vue_type_style_index_0_id_de9d7fe4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ActionButton_vue_vue_type_style_index_0_id_de9d7fe4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ActionButton_vue_vue_type_style_index_0_id_de9d7fe4_lang_scss_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BY3Rpb25CdXR0b24udnVlP2EwYmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQW9sQixDQUFnQixrbkJBQUcsRUFBQyIsImZpbGUiOiJjNmM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tOC1vbmVPZi0xLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tOC1vbmVPZi0xLTIhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTgtb25lT2YtMS0zIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BY3Rpb25CdXR0b24udnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9ZGU5ZDdmZTQmbGFuZz1zY3NzJnNjb3BlZD10cnVlJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS04LW9uZU9mLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS04LW9uZU9mLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS04LW9uZU9mLTEtMiEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FjdGlvbkJ1dHRvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1kZTlkN2ZlNCZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///c6c9\n')},c998:function(module){eval('module.exports = JSON.parse("{\\"contracts_version\\":null,\\"chain_id\\":5,\\"contracts\\":{\\"SecretRegistry\\":{\\"address\\":\\"0xfe26Dc87Fd7Ed01AC3429d7913738e2fae018BB6\\",\\"transaction_hash\\":\\"0xf015b6c93951e645c45d4632dcd25de2869bd6613b5b59c53e2453c168c36447\\",\\"block_number\\":2114499,\\"gas_cost\\":247082,\\"constructor_arguments\\":[]},\\"TokenNetworkRegistry\\":{\\"address\\":\\"0x9b0c8C8C75904CEf5B7a8dbF59c3459Ea85c6526\\",\\"transaction_hash\\":\\"0xa77a53156131d50af579a3ab22e80af01eb3e40405292d78e80c8c4d238d4886\\",\\"block_number\\":2114501,\\"gas_cost\\":4001114,\\"constructor_arguments\\":[\\"0xfe26Dc87Fd7Ed01AC3429d7913738e2fae018BB6\\",5,20,555428,1.157920892373162e+77]}}}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJjOTk4LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///c998\n')},cb0b:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_BlurredOverlay_vue_vue_type_style_index_0_id_1d51571c_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("df2d");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_BlurredOverlay_vue_vue_type_style_index_0_id_1d51571c_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_BlurredOverlay_vue_vue_type_style_index_0_id_1d51571c_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_dist_cjs_js_ref_8_oneOf_1_3_node_modules_vuetify_loader_lib_loader_js_ref_21_0_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_BlurredOverlay_vue_vue_type_style_index_0_id_1d51571c_scoped_true_lang_scss___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CbHVycmVkT3ZlcmxheS52dWU/ZmM0MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBc2xCLENBQWdCLG9uQkFBRyxFQUFDIiwiZmlsZSI6ImNiMGIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS04LW9uZU9mLTEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS04LW9uZU9mLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS04LW9uZU9mLTEtMiEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0JsdXJyZWRPdmVybGF5LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFkNTE1NzFjJnNjb3BlZD10cnVlJmxhbmc9c2NzcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tOC1vbmVPZi0xLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tOC1vbmVPZi0xLTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tOC1vbmVPZi0xLTIhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTgtb25lT2YtMS0zIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9CbHVycmVkT3ZlcmxheS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xZDUxNTcxYyZzY29wZWQ9dHJ1ZSZsYW5nPXNjc3MmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///cb0b\n')},cd49:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.runtime.esm.js\nvar vue_runtime_esm = __webpack_require__("2b0e");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e349156a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/App.vue?vue&type=template&id=52aa355e&scoped=true&\nvar Appvue_type_template_id_52aa355e_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'v-app\',{attrs:{"dark":""}},[_c(\'div\',{attrs:{"id":"application-wrapper"}},[_c(\'router-view\',{attrs:{"name":"modal"}}),_c(\'div\',{attrs:{"id":"application-content"}},[_c(\'app-header\'),_c(\'v-content\',[_c(\'v-container\',{staticClass:"application__container fill-height",attrs:{"fluid":""}},[_c(\'router-view\')],1)],1)],1)],1),_c(\'div\',{staticClass:"policy"},[_c(\'a\',{attrs:{"href":"https://raiden.network/privacy.html","target":"_blank"}},[_vm._v(" "+_vm._s(_vm.$t(\'application.privacy-policy\'))+" ")])]),_c(\'offline-snackbar\'),_c(\'update-snackbar\')],1)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/App.vue?vue&type=template&id=52aa355e&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__("9ab4");\n\n// EXTERNAL MODULE: ./node_modules/vue-property-decorator/lib/vue-property-decorator.js\nvar vue_property_decorator = __webpack_require__("60a3");\n\n// EXTERNAL MODULE: ./node_modules/vuex/dist/vuex.esm.js\nvar vuex_esm = __webpack_require__("2f62");\n\n// EXTERNAL MODULE: ./src/mixins/navigation-mixin.ts\nvar navigation_mixin = __webpack_require__("152b");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e349156a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/AppHeader.vue?vue&type=template&id=6ccf2084&scoped=true&\nvar AppHeadervue_type_template_id_6ccf2084_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"app-header"},[_c(\'v-row\',{staticClass:"app-header__top",attrs:{"justify":"center","align":"center","no-gutters":""}},[_c(\'v-col\',{attrs:{"cols":"12"}},[_c(\'div\',{staticClass:"app-header__top__content"},[_c(\'div\',{staticClass:"app-header__top__content__back"},[(_vm.canGoBack)?_c(\'v-btn\',{attrs:{"height":"40px","width":"40px","text":"","icon":""},on:{"click":function($event){return _vm.onBackClicked()}}},[_c(\'v-img\',{attrs:{"src":__webpack_require__("73da"),"max-width":"34px"}})],1):_vm._e()],1),_c(\'v-spacer\'),_c(\'v-col\',[_c(\'div\',{staticClass:"app-header__top__content__title"},[_vm._v(" "+_vm._s(_vm.$route.meta.title)+" ")]),(!_vm.loading && _vm.defaultAccount)?_c(\'div\',{staticClass:"app-header__top__content__network"},[_vm._v(" "+_vm._s(_vm.network)+" ")]):_vm._e()]),_c(\'v-spacer\'),_c(\'span\',{staticClass:"app-header__account-wrapper"},[_c(\'header-identicon\',{nativeOn:{"click":function($event){return _vm.navigateToGeneralHome()}}})],1)],1)])],1),_c(\'v-row\',{staticClass:"app-header__bottom",attrs:{"align":"center","no-gutters":""}},[(!_vm.loading && _vm.defaultAccount)?_c(\'v-col\',{attrs:{"cols":"12"}},[_c(\'div\',{staticClass:"app-header__bottom__address text-left"},[_c(\'address-display\',{attrs:{"address":_vm.defaultAccount}})],1)]):_vm._e()],1)],1)}\nvar AppHeadervue_type_template_id_6ccf2084_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/AppHeader.vue?vue&type=template&id=6ccf2084&scoped=true&\n\n// EXTERNAL MODULE: ./src/router/route-names.ts\nvar route_names = __webpack_require__("80bf");\n\n// EXTERNAL MODULE: ./src/components/HeaderIdenticon.vue + 4 modules\nvar HeaderIdenticon = __webpack_require__("233e");\n\n// EXTERNAL MODULE: ./src/components/AddressDisplay.vue + 4 modules\nvar AddressDisplay = __webpack_require__("9302");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/AppHeader.vue?vue&type=script&lang=ts&\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\nvar AppHeadervue_type_script_lang_ts_AppHeader = /*#__PURE__*/function (_Mixins) {\n  _inherits(AppHeader, _Mixins);\n\n  var _super = _createSuper(AppHeader);\n\n  function AppHeader() {\n    _classCallCheck(this, AppHeader);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AppHeader, [{\n    key: "canGoBack",\n    get: function get() {\n      var routesWithoutBackBtn = [route_names["a" /* RouteNames */].HOME, route_names["a" /* RouteNames */].TRANSFER];\n      return !routesWithoutBackBtn.includes(this.$route.name);\n    }\n  }]);\n\n  return AppHeader;\n}(Object(vue_property_decorator["c" /* Mixins */])(navigation_mixin["a" /* default */]));\n\nAppHeadervue_type_script_lang_ts_AppHeader = Object(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["a" /* Component */])({\n  components: {\n    HeaderIdenticon: HeaderIdenticon["a" /* default */],\n    AddressDisplay: AddressDisplay["a" /* default */]\n  },\n  computed: _objectSpread({}, Object(vuex_esm["c" /* mapState */])([\'loading\', \'defaultAccount\']), {}, Object(vuex_esm["b" /* mapGetters */])([\'network\']))\n})], AppHeadervue_type_script_lang_ts_AppHeader);\n/* harmony default export */ var AppHeadervue_type_script_lang_ts_ = (AppHeadervue_type_script_lang_ts_AppHeader);\n// CONCATENATED MODULE: ./src/components/AppHeader.vue?vue&type=script&lang=ts&\n /* harmony default export */ var components_AppHeadervue_type_script_lang_ts_ = (AppHeadervue_type_script_lang_ts_); \n// EXTERNAL MODULE: ./src/components/AppHeader.vue?vue&type=style&index=0&id=6ccf2084&lang=scss&scoped=true&\nvar AppHeadervue_type_style_index_0_id_6ccf2084_lang_scss_scoped_true_ = __webpack_require__("9e24");\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__("2877");\n\n// EXTERNAL MODULE: ./node_modules/vuetify-loader/lib/runtime/installComponents.js\nvar installComponents = __webpack_require__("6544");\nvar installComponents_default = /*#__PURE__*/__webpack_require__.n(installComponents);\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VBtn/VBtn.js\nvar VBtn = __webpack_require__("8336");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/VCol.js\nvar VCol = __webpack_require__("62ad");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VImg/VImg.js + 2 modules\nvar VImg = __webpack_require__("adda");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/VRow.js\nvar VRow = __webpack_require__("0fd9");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/VSpacer.js\nvar VSpacer = __webpack_require__("2fa4");\n\n// CONCATENATED MODULE: ./src/components/AppHeader.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  components_AppHeadervue_type_script_lang_ts_,\n  AppHeadervue_type_template_id_6ccf2084_scoped_true_render,\n  AppHeadervue_type_template_id_6ccf2084_scoped_true_staticRenderFns,\n  false,\n  null,\n  "6ccf2084",\n  null\n  \n)\n\n/* harmony default export */ var components_AppHeader = (component.exports);\n\n/* vuetify-loader */\n\n\n\n\n\n\ninstallComponents_default()(component, {VBtn: VBtn["a" /* default */],VCol: VCol["a" /* default */],VImg: VImg["a" /* default */],VRow: VRow["a" /* default */],VSpacer: VSpacer["a" /* default */]})\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e349156a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/OfflineSnackbar.vue?vue&type=template&id=11200242&\nvar OfflineSnackbarvue_type_template_id_11200242_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.offline)?_c(\'span\',[_c(\'blurred-overlay\',{attrs:{"show":_vm.offline,"fullscreen":true}}),_c(\'v-snackbar\',{attrs:{"timeout":0,"color":"error"},model:{value:(_vm.offline),callback:function ($$v) {_vm.offline=$$v},expression:"offline"}},[_vm._v(" "+_vm._s(_vm.$t(\'general.offline\'))+" "),_c(\'v-icon\',[_vm._v("mdi-alert")])],1)],1):_vm._e()}\nvar OfflineSnackbarvue_type_template_id_11200242_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/OfflineSnackbar.vue?vue&type=template&id=11200242&\n\n// EXTERNAL MODULE: ./src/components/BlurredOverlay.vue + 4 modules\nvar BlurredOverlay = __webpack_require__("8e33");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/OfflineSnackbar.vue?vue&type=script&lang=ts&\nfunction OfflineSnackbarvue_type_script_lang_ts_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { OfflineSnackbarvue_type_script_lang_ts_typeof = function _typeof(obj) { return typeof obj; }; } else { OfflineSnackbarvue_type_script_lang_ts_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return OfflineSnackbarvue_type_script_lang_ts_typeof(obj); }\n\nfunction OfflineSnackbarvue_type_script_lang_ts_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction OfflineSnackbarvue_type_script_lang_ts_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction OfflineSnackbarvue_type_script_lang_ts_createClass(Constructor, protoProps, staticProps) { if (protoProps) OfflineSnackbarvue_type_script_lang_ts_defineProperties(Constructor.prototype, protoProps); if (staticProps) OfflineSnackbarvue_type_script_lang_ts_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction OfflineSnackbarvue_type_script_lang_ts_createSuper(Derived) { return function () { var Super = OfflineSnackbarvue_type_script_lang_ts_getPrototypeOf(Derived), result; if (OfflineSnackbarvue_type_script_lang_ts_isNativeReflectConstruct()) { var NewTarget = OfflineSnackbarvue_type_script_lang_ts_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return OfflineSnackbarvue_type_script_lang_ts_possibleConstructorReturn(this, result); }; }\n\nfunction OfflineSnackbarvue_type_script_lang_ts_possibleConstructorReturn(self, call) { if (call && (OfflineSnackbarvue_type_script_lang_ts_typeof(call) === "object" || typeof call === "function")) { return call; } return OfflineSnackbarvue_type_script_lang_ts_assertThisInitialized(self); }\n\nfunction OfflineSnackbarvue_type_script_lang_ts_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction OfflineSnackbarvue_type_script_lang_ts_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction OfflineSnackbarvue_type_script_lang_ts_getPrototypeOf(o) { OfflineSnackbarvue_type_script_lang_ts_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return OfflineSnackbarvue_type_script_lang_ts_getPrototypeOf(o); }\n\nfunction OfflineSnackbarvue_type_script_lang_ts_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) OfflineSnackbarvue_type_script_lang_ts_setPrototypeOf(subClass, superClass); }\n\nfunction OfflineSnackbarvue_type_script_lang_ts_setPrototypeOf(o, p) { OfflineSnackbarvue_type_script_lang_ts_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return OfflineSnackbarvue_type_script_lang_ts_setPrototypeOf(o, p); }\n\n\n\n\n\nvar OfflineSnackbar = /*#__PURE__*/function (_Vue) {\n  OfflineSnackbarvue_type_script_lang_ts_inherits(OfflineSnackbar, _Vue);\n\n  var _super = OfflineSnackbarvue_type_script_lang_ts_createSuper(OfflineSnackbar);\n\n  function OfflineSnackbar() {\n    var _this;\n\n    OfflineSnackbarvue_type_script_lang_ts_classCallCheck(this, OfflineSnackbar);\n\n    _this = _super.apply(this, arguments);\n    _this.offline = false;\n    return _this;\n  }\n\n  OfflineSnackbarvue_type_script_lang_ts_createClass(OfflineSnackbar, [{\n    key: "handleOnline",\n    value: function handleOnline() {\n      this.offline = false;\n    }\n  }, {\n    key: "handleOffline",\n    value: function handleOffline() {\n      this.offline = true;\n    }\n  }, {\n    key: "mounted",\n    value: function mounted() {\n      this.offline = !navigator.onLine;\n      window.addEventListener(\'offline\', this.handleOffline);\n      window.addEventListener(\'online\', this.handleOnline);\n    }\n  }, {\n    key: "beforeDestroy",\n    value: function beforeDestroy() {\n      window.removeEventListener(\'offline\', this.handleOffline);\n      window.removeEventListener(\'online\', this.handleOnline);\n    }\n  }]);\n\n  return OfflineSnackbar;\n}(vue_property_decorator["e" /* Vue */]);\n\nOfflineSnackbar = Object(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["a" /* Component */])({\n  components: {\n    BlurredOverlay: BlurredOverlay["a" /* default */]\n  }\n})], OfflineSnackbar);\n/* harmony default export */ var OfflineSnackbarvue_type_script_lang_ts_ = (OfflineSnackbar);\n// CONCATENATED MODULE: ./src/components/OfflineSnackbar.vue?vue&type=script&lang=ts&\n /* harmony default export */ var components_OfflineSnackbarvue_type_script_lang_ts_ = (OfflineSnackbarvue_type_script_lang_ts_); \n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VIcon/VIcon.js\nvar VIcon = __webpack_require__("132d");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VSnackbar/VSnackbar.js\nvar VSnackbar = __webpack_require__("2db4");\n\n// CONCATENATED MODULE: ./src/components/OfflineSnackbar.vue\n\n\n\n\n\n/* normalize component */\n\nvar OfflineSnackbar_component = Object(componentNormalizer["a" /* default */])(\n  components_OfflineSnackbarvue_type_script_lang_ts_,\n  OfflineSnackbarvue_type_template_id_11200242_render,\n  OfflineSnackbarvue_type_template_id_11200242_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var components_OfflineSnackbar = (OfflineSnackbar_component.exports);\n\n/* vuetify-loader */\n\n\n\ninstallComponents_default()(OfflineSnackbar_component, {VIcon: VIcon["a" /* default */],VSnackbar: VSnackbar["a" /* default */]})\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e349156a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/UpdateSnackbar.vue?vue&type=template&id=1d4ed306&\nvar UpdateSnackbarvue_type_template_id_1d4ed306_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.updateAvailable)?_c(\'span\',[_c(\'blurred-overlay\',{attrs:{"show":_vm.updateAvailable,"fullscreen":true}}),_c(\'v-snackbar\',{attrs:{"timeout":0,"color":"primary"},model:{value:(_vm.updateAvailable),callback:function ($$v) {_vm.updateAvailable=$$v},expression:"updateAvailable"}},[_vm._v(" "+_vm._s(_vm.$t(\'update.available\'))+" "),_c(\'v-btn\',{attrs:{"dark":"","text":"","loading":_vm.isUpdating},on:{"click":_vm.update}},[_vm._v(" "+_vm._s(_vm.$t(\'update.update\'))+" ")])],1)],1):_vm._e()}\nvar UpdateSnackbarvue_type_template_id_1d4ed306_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/UpdateSnackbar.vue?vue&type=template&id=1d4ed306&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/UpdateSnackbar.vue?vue&type=script&lang=ts&\nfunction UpdateSnackbarvue_type_script_lang_ts_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { UpdateSnackbarvue_type_script_lang_ts_typeof = function _typeof(obj) { return typeof obj; }; } else { UpdateSnackbarvue_type_script_lang_ts_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return UpdateSnackbarvue_type_script_lang_ts_typeof(obj); }\n\nfunction UpdateSnackbarvue_type_script_lang_ts_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction UpdateSnackbarvue_type_script_lang_ts_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction UpdateSnackbarvue_type_script_lang_ts_createClass(Constructor, protoProps, staticProps) { if (protoProps) UpdateSnackbarvue_type_script_lang_ts_defineProperties(Constructor.prototype, protoProps); if (staticProps) UpdateSnackbarvue_type_script_lang_ts_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction UpdateSnackbarvue_type_script_lang_ts_createSuper(Derived) { return function () { var Super = UpdateSnackbarvue_type_script_lang_ts_getPrototypeOf(Derived), result; if (UpdateSnackbarvue_type_script_lang_ts_isNativeReflectConstruct()) { var NewTarget = UpdateSnackbarvue_type_script_lang_ts_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return UpdateSnackbarvue_type_script_lang_ts_possibleConstructorReturn(this, result); }; }\n\nfunction UpdateSnackbarvue_type_script_lang_ts_possibleConstructorReturn(self, call) { if (call && (UpdateSnackbarvue_type_script_lang_ts_typeof(call) === "object" || typeof call === "function")) { return call; } return UpdateSnackbarvue_type_script_lang_ts_assertThisInitialized(self); }\n\nfunction UpdateSnackbarvue_type_script_lang_ts_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction UpdateSnackbarvue_type_script_lang_ts_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction UpdateSnackbarvue_type_script_lang_ts_getPrototypeOf(o) { UpdateSnackbarvue_type_script_lang_ts_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return UpdateSnackbarvue_type_script_lang_ts_getPrototypeOf(o); }\n\nfunction UpdateSnackbarvue_type_script_lang_ts_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) UpdateSnackbarvue_type_script_lang_ts_setPrototypeOf(subClass, superClass); }\n\nfunction UpdateSnackbarvue_type_script_lang_ts_setPrototypeOf(o, p) { UpdateSnackbarvue_type_script_lang_ts_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return UpdateSnackbarvue_type_script_lang_ts_setPrototypeOf(o, p); }\n\n\n/* istanbul ignore file */\n\n\n\n\nvar UpdateSnackbar = /*#__PURE__*/function (_Vue) {\n  UpdateSnackbarvue_type_script_lang_ts_inherits(UpdateSnackbar, _Vue);\n\n  var _super = UpdateSnackbarvue_type_script_lang_ts_createSuper(UpdateSnackbar);\n\n  function UpdateSnackbar() {\n    var _this;\n\n    UpdateSnackbarvue_type_script_lang_ts_classCallCheck(this, UpdateSnackbar);\n\n    _this = _super.apply(this, arguments);\n    _this.isUpdating = false;\n    _this.updateAvailable = false;\n    _this.swRegistration = null;\n    return _this;\n  }\n\n  UpdateSnackbarvue_type_script_lang_ts_createClass(UpdateSnackbar, [{\n    key: "created",\n    value: function created() {\n      var _this2 = this;\n\n      document.addEventListener(\'swUpdated\', this.handleSWUpdate, {\n        once: true\n      });\n      navigator.serviceWorker.addEventListener(\'controllerchange\', function () {\n        setTimeout(function () {\n          _this2.updateAvailable = false;\n          window.location.reload();\n        }, 1500);\n      });\n    }\n  }, {\n    key: "beforeDestroy",\n    value: function beforeDestroy() {\n      document.removeEventListener(\'swUpdated\', this.handleSWUpdate);\n    }\n  }, {\n    key: "handleSWUpdate",\n    value: function handleSWUpdate(event) {\n      this.swRegistration = event.detail;\n      this.updateAvailable = true;\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      this.isUpdating = true;\n\n      if (!this.swRegistration || !this.swRegistration.waiting) {\n        return;\n      }\n\n      this.swRegistration.waiting.postMessage(\'skipWaiting\');\n    }\n  }]);\n\n  return UpdateSnackbar;\n}(vue_property_decorator["e" /* Vue */]);\n\nUpdateSnackbar = Object(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["a" /* Component */])({\n  components: {\n    BlurredOverlay: BlurredOverlay["a" /* default */]\n  }\n})], UpdateSnackbar);\n/* harmony default export */ var UpdateSnackbarvue_type_script_lang_ts_ = (UpdateSnackbar);\n// CONCATENATED MODULE: ./src/components/UpdateSnackbar.vue?vue&type=script&lang=ts&\n /* harmony default export */ var components_UpdateSnackbarvue_type_script_lang_ts_ = (UpdateSnackbarvue_type_script_lang_ts_); \n// CONCATENATED MODULE: ./src/components/UpdateSnackbar.vue\n\n\n\n\n\n/* normalize component */\n\nvar UpdateSnackbar_component = Object(componentNormalizer["a" /* default */])(\n  components_UpdateSnackbarvue_type_script_lang_ts_,\n  UpdateSnackbarvue_type_template_id_1d4ed306_render,\n  UpdateSnackbarvue_type_template_id_1d4ed306_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var components_UpdateSnackbar = (UpdateSnackbar_component.exports);\n\n/* vuetify-loader */\n\n\n\ninstallComponents_default()(UpdateSnackbar_component, {VBtn: VBtn["a" /* default */],VSnackbar: VSnackbar["a" /* default */]})\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/App.vue?vue&type=script&lang=ts&\nfunction Appvue_type_script_lang_ts_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Appvue_type_script_lang_ts_typeof = function _typeof(obj) { return typeof obj; }; } else { Appvue_type_script_lang_ts_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Appvue_type_script_lang_ts_typeof(obj); }\n\nfunction Appvue_type_script_lang_ts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction Appvue_type_script_lang_ts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Appvue_type_script_lang_ts_ownKeys(Object(source), true).forEach(function (key) { Appvue_type_script_lang_ts_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Appvue_type_script_lang_ts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Appvue_type_script_lang_ts_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Appvue_type_script_lang_ts_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Appvue_type_script_lang_ts_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Appvue_type_script_lang_ts_createClass(Constructor, protoProps, staticProps) { if (protoProps) Appvue_type_script_lang_ts_defineProperties(Constructor.prototype, protoProps); if (staticProps) Appvue_type_script_lang_ts_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Appvue_type_script_lang_ts_createSuper(Derived) { return function () { var Super = Appvue_type_script_lang_ts_getPrototypeOf(Derived), result; if (Appvue_type_script_lang_ts_isNativeReflectConstruct()) { var NewTarget = Appvue_type_script_lang_ts_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Appvue_type_script_lang_ts_possibleConstructorReturn(this, result); }; }\n\nfunction Appvue_type_script_lang_ts_possibleConstructorReturn(self, call) { if (call && (Appvue_type_script_lang_ts_typeof(call) === "object" || typeof call === "function")) { return call; } return Appvue_type_script_lang_ts_assertThisInitialized(self); }\n\nfunction Appvue_type_script_lang_ts_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Appvue_type_script_lang_ts_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Appvue_type_script_lang_ts_getPrototypeOf(o) { Appvue_type_script_lang_ts_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Appvue_type_script_lang_ts_getPrototypeOf(o); }\n\nfunction Appvue_type_script_lang_ts_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Appvue_type_script_lang_ts_setPrototypeOf(subClass, superClass); }\n\nfunction Appvue_type_script_lang_ts_setPrototypeOf(o, p) { Appvue_type_script_lang_ts_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Appvue_type_script_lang_ts_setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\nvar App = /*#__PURE__*/function (_Mixins) {\n  Appvue_type_script_lang_ts_inherits(App, _Mixins);\n\n  var _super = Appvue_type_script_lang_ts_createSuper(App);\n\n  function App() {\n    Appvue_type_script_lang_ts_classCallCheck(this, App);\n\n    return _super.apply(this, arguments);\n  }\n\n  Appvue_type_script_lang_ts_createClass(App, [{\n    key: "onIsConnectedChange",\n    value: function onIsConnectedChange() {\n      if (!this.isConnected) {\n        this.navigateToHome();\n      }\n    }\n  }, {\n    key: "destroyed",\n    value: function destroyed() {\n      this.$raiden.disconnect();\n    }\n  }]);\n\n  return App;\n}(Object(vue_property_decorator["c" /* Mixins */])(navigation_mixin["a" /* default */]));\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["f" /* Watch */])(\'isConnected\', {\n  immediate: true\n})], App.prototype, "onIsConnectedChange", null);\n\nApp = Object(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["a" /* Component */])({\n  computed: Appvue_type_script_lang_ts_objectSpread({}, Object(vuex_esm["b" /* mapGetters */])([\'isConnected\'])),\n  components: {\n    AppHeader: components_AppHeader,\n    OfflineSnackbar: components_OfflineSnackbar,\n    UpdateSnackbar: components_UpdateSnackbar\n  }\n})], App);\n/* harmony default export */ var Appvue_type_script_lang_ts_ = (App);\n// CONCATENATED MODULE: ./src/App.vue?vue&type=script&lang=ts&\n /* harmony default export */ var src_Appvue_type_script_lang_ts_ = (Appvue_type_script_lang_ts_); \n// EXTERNAL MODULE: ./src/App.vue?vue&type=style&index=0&id=52aa355e&lang=scss&scoped=true&\nvar Appvue_type_style_index_0_id_52aa355e_lang_scss_scoped_true_ = __webpack_require__("a53d");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VApp/VApp.js\nvar VApp = __webpack_require__("7496");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VGrid/VContainer.js + 1 modules\nvar VContainer = __webpack_require__("a523");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VContent/VContent.js + 1 modules\nvar VContent = __webpack_require__("a75b");\n\n// CONCATENATED MODULE: ./src/App.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar App_component = Object(componentNormalizer["a" /* default */])(\n  src_Appvue_type_script_lang_ts_,\n  Appvue_type_template_id_52aa355e_scoped_true_render,\n  staticRenderFns,\n  false,\n  null,\n  "52aa355e",\n  null\n  \n)\n\n/* harmony default export */ var src_App = (App_component.exports);\n\n/* vuetify-loader */\n\n\n\n\ninstallComponents_default()(App_component, {VApp: VApp["a" /* default */],VContainer: VContainer["a" /* default */],VContent: VContent["a" /* default */]})\n\n// EXTERNAL MODULE: ./node_modules/vue-class-component/dist/vue-class-component.esm.js\nvar vue_class_component_esm = __webpack_require__("2fe1");\n\n// CONCATENATED MODULE: ./src/plugins/class-component.hooks.ts\n/* istanbul ignore file */\n // Register the router hooks with their names\n\nvue_class_component_esm["b" /* default */].registerHooks([\'beforeRouteEnter\', \'beforeRouteLeave\', \'beforeRouteUpdate\' // for vue-router 2.2+\n]);\n// EXTERNAL MODULE: ./src/filters.ts\nvar filters = __webpack_require__("0f75");\n\n// EXTERNAL MODULE: ./node_modules/vue-router/dist/vue-router.esm.js\nvar vue_router_esm = __webpack_require__("8c4f");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e349156a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/Home.vue?vue&type=template&id=02ef831a&scoped=true&\nvar Homevue_type_template_id_02ef831a_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'v-container\',{staticClass:"home",attrs:{"fluid":""}},[(!_vm.inaccessible && _vm.isConnected)?_c(\'no-tokens\'):_c(\'div\',[_c(\'v-row\',{attrs:{"no-gutters":""}},[_c(\'v-col\',{attrs:{"cols":"12"}},[_c(\'div\',{staticClass:"home__logo-container"},[_c(\'v-img\',{staticClass:"home__logo-container__logo",attrs:{"src":__webpack_require__("9b19"),"aspect-ratio":"1","contain":""}})],1)])],1),_c(\'v-row\',{attrs:{"no-gutters":""}},[_c(\'v-col\',{attrs:{"cols":"12"}},[_c(\'div\',{staticClass:"home__app-welcome text-center"},[_vm._v(" "+_vm._s(_vm.$t(\'home.welcome\'))+" ")])])],1),_c(\'v-row\',{attrs:{"no-gutters":""}},[_c(\'v-col\',{attrs:{"cols":"12"}},[_c(\'div\',{staticClass:"home__disclaimer text-center font-weight-light"},[_vm._v(" "+_vm._s(_vm.$t(\'home.disclaimer\'))+" ")]),_c(\'i18n\',{staticClass:"home__getting-started text-center font-weight-light",attrs:{"path":"home.getting-started.description","tag":"div"}},[_c(\'a\',{attrs:{"href":"https://github.com/raiden-network/light-client#getting-started","target":"_blank"}},[_vm._v(" "+_vm._s(_vm.$t(\'home.getting-started.link-name\'))+" ")])])],1)],1),_c(\'action-button\',{attrs:{"enabled":"","text":_vm.$t(\'home.connect-button\'),"sticky":""},on:{"click":function($event){_vm.connectDialog = true}}}),_c(\'connect-dialog\',{attrs:{"connecting":_vm.connecting,"connecting-subkey":_vm.connectingSubkey,"visible":_vm.connectDialog},on:{"connect":_vm.connect,"close":function($event){_vm.connectDialog = false}}})],1)],1)}\nvar Homevue_type_template_id_02ef831a_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/views/Home.vue?vue&type=template&id=02ef831a&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\nvar regenerator = __webpack_require__("a34a");\nvar regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);\n\n// EXTERNAL MODULE: ./src/model/types.ts\nvar types = __webpack_require__("87a2");\n\n// EXTERNAL MODULE: ./src/components/ActionButton.vue + 4 modules\nvar ActionButton = __webpack_require__("750b");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e349156a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/ConnectDialog.vue?vue&type=template&id=3604c23c&scoped=true&\nvar ConnectDialogvue_type_template_id_3604c23c_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'raiden-dialog\',{staticClass:"connect",attrs:{"visible":_vm.visible,"hide-close":_vm.hideClose},on:{"close":_vm.close}},[_c(\'v-card-title\',[_vm._v(" "+_vm._s(_vm.$t(\'home.connect-dialog.connect-title\'))+" ")]),(_vm.injectedProvider)?_c(\'div\',[_c(\'div\',{staticClass:"connect__button"},[_c(\'action-button\',{attrs:{"text":_vm.$t(\'home.connect-dialog.web3-provider\'),"enabled":!_vm.connecting && !_vm.connectingSubkey,"loading":_vm.connecting},on:{"click":function($event){return _vm.connect(_vm.stateBackup)}}})],1),_c(\'div\',{staticClass:"text-center font-weight-light"},[_vm._v(" "+_vm._s(_vm.$t(\'home.connect-dialog.divider\'))+" ")]),(!_vm.connectingSubkey)?_c(\'i18n\',{staticClass:"connect__raiden-account text-center font-weight-light",attrs:{"path":"home.connect-dialog.raiden-account.description","tag":"div"}},[(!_vm.connecting)?_c(\'a\',{on:{"click":function($event){return _vm.connect(_vm.stateBackup, true)}}},[_vm._v(" "+_vm._s(_vm.$t(\'home.connect-dialog.raiden-account.link-name\'))+" ")]):_c(\'span\',[_vm._v(" "+_vm._s(_vm.$t(\'home.connect-dialog.raiden-account.link-name\'))+" ")])]):_c(\'div\',{staticClass:"connect__raiden-account-spinner text-center"},[_c(\'v-progress-circular\',{attrs:{"size":30,"width":1,"indeterminate":""}})],1)],1):_vm._e(),(_vm.accessDenied)?_c(\'no-access-message\',{attrs:{"reason":_vm.accessDenied}}):_vm._e(),(!_vm.injectedProvider)?_c(\'v-card-text\',[_c(\'div\',{staticClass:"text-center"},[_vm._v(" "+_vm._s(_vm.$t(\'home.connect-dialog.no-provider\'))+" ")])]):_vm._e()],1)}\nvar ConnectDialogvue_type_template_id_3604c23c_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/ConnectDialog.vue?vue&type=template&id=3604c23c&scoped=true&\n\n// CONCATENATED MODULE: ./src/services/web3-provider.ts\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction web3_provider_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction web3_provider_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction web3_provider_createClass(Constructor, protoProps, staticProps) { if (protoProps) web3_provider_defineProperties(Constructor.prototype, protoProps); if (staticProps) web3_provider_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar web3_provider_Web3Provider = /*#__PURE__*/function () {\n  function Web3Provider() {\n    web3_provider_classCallCheck(this, Web3Provider);\n  }\n\n  web3_provider_createClass(Web3Provider, null, [{\n    key: "provider",\n    value: function () {\n      var _provider = _asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee(config) {\n        var ethereum, provider;\n        return regenerator_default.a.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                ethereum = window.ethereum;\n                provider = null;\n\n                if (!config) {\n                  _context.next = 6;\n                  break;\n                }\n\n                provider = "https://".concat(config.INFURA_ENDPOINT);\n                _context.next = 13;\n                break;\n\n              case 6:\n                if (!(typeof ethereum !== \'undefined\')) {\n                  _context.next = 12;\n                  break;\n                }\n\n                _context.next = 9;\n                return ethereum.enable();\n\n              case 9:\n                provider = ethereum;\n                _context.next = 13;\n                break;\n\n              case 12:\n                if (window.web3) {\n                  provider = window.web3.currentProvider;\n                }\n\n              case 13:\n                /* istanbul ignore next */\n                if (provider && provider.isMetaMask) {\n                  provider.autoRefreshOnNetworkChange = false;\n                  provider.on(\'networkChanged\', function () {\n                    return window.location.replace(window.location.origin);\n                  });\n                }\n\n                return _context.abrupt("return", provider);\n\n              case 15:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function provider(_x) {\n        return _provider.apply(this, arguments);\n      }\n\n      return provider;\n    }()\n  }]);\n\n  return Web3Provider;\n}();\n\nweb3_provider_Web3Provider.injectedWeb3Available = function () {\n  return window.ethereum || window.web3;\n};\n// EXTERNAL MODULE: ./src/components/RaidenDialog.vue + 4 modules\nvar RaidenDialog = __webpack_require__("a683");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e349156a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/NoAccessMessage.vue?vue&type=template&id=7b92b083&scoped=true&\nvar NoAccessMessagevue_type_template_id_7b92b083_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'v-alert\',{staticClass:"no-access-message",attrs:{"value":true,"color":"error","icon":"warning"}},[_c(\'div\',{staticClass:"font-weight-light no-access-message__message"},[(_vm.networkUnsupported)?_c(\'span\',[_vm._v(" "+_vm._s(_vm.$t(\'no-access.unsupported-network\'))+" ")]):_vm._e(),(_vm.initializationFailed)?_c(\'span\',[_vm._v(" "+_vm._s(_vm.$t(\'no-access.sdk-initialization-failure\'))+" ")]):_vm._e(),(_vm.rdnStateMigration)?_c(\'span\',[_vm._v(" "+_vm._s(_vm.$t(\'no-access.rdn-state-migration\'))+" ")]):_c(\'span\',[_vm._v(_vm._s(_vm.$t(\'no-access.generic-error\')))])])])}\nvar NoAccessMessagevue_type_template_id_7b92b083_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/NoAccessMessage.vue?vue&type=template&id=7b92b083&scoped=true&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/NoAccessMessage.vue?vue&type=script&lang=ts&\nfunction NoAccessMessagevue_type_script_lang_ts_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { NoAccessMessagevue_type_script_lang_ts_typeof = function _typeof(obj) { return typeof obj; }; } else { NoAccessMessagevue_type_script_lang_ts_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return NoAccessMessagevue_type_script_lang_ts_typeof(obj); }\n\nfunction NoAccessMessagevue_type_script_lang_ts_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction NoAccessMessagevue_type_script_lang_ts_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction NoAccessMessagevue_type_script_lang_ts_createClass(Constructor, protoProps, staticProps) { if (protoProps) NoAccessMessagevue_type_script_lang_ts_defineProperties(Constructor.prototype, protoProps); if (staticProps) NoAccessMessagevue_type_script_lang_ts_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction NoAccessMessagevue_type_script_lang_ts_createSuper(Derived) { return function () { var Super = NoAccessMessagevue_type_script_lang_ts_getPrototypeOf(Derived), result; if (NoAccessMessagevue_type_script_lang_ts_isNativeReflectConstruct()) { var NewTarget = NoAccessMessagevue_type_script_lang_ts_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return NoAccessMessagevue_type_script_lang_ts_possibleConstructorReturn(this, result); }; }\n\nfunction NoAccessMessagevue_type_script_lang_ts_possibleConstructorReturn(self, call) { if (call && (NoAccessMessagevue_type_script_lang_ts_typeof(call) === "object" || typeof call === "function")) { return call; } return NoAccessMessagevue_type_script_lang_ts_assertThisInitialized(self); }\n\nfunction NoAccessMessagevue_type_script_lang_ts_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction NoAccessMessagevue_type_script_lang_ts_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction NoAccessMessagevue_type_script_lang_ts_getPrototypeOf(o) { NoAccessMessagevue_type_script_lang_ts_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return NoAccessMessagevue_type_script_lang_ts_getPrototypeOf(o); }\n\nfunction NoAccessMessagevue_type_script_lang_ts_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) NoAccessMessagevue_type_script_lang_ts_setPrototypeOf(subClass, superClass); }\n\nfunction NoAccessMessagevue_type_script_lang_ts_setPrototypeOf(o, p) { NoAccessMessagevue_type_script_lang_ts_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return NoAccessMessagevue_type_script_lang_ts_setPrototypeOf(o, p); }\n\n\n\n\n\nvar NoAccessMessagevue_type_script_lang_ts_NoAccessMessage = /*#__PURE__*/function (_Vue) {\n  NoAccessMessagevue_type_script_lang_ts_inherits(NoAccessMessage, _Vue);\n\n  var _super = NoAccessMessagevue_type_script_lang_ts_createSuper(NoAccessMessage);\n\n  function NoAccessMessage() {\n    NoAccessMessagevue_type_script_lang_ts_classCallCheck(this, NoAccessMessage);\n\n    return _super.apply(this, arguments);\n  }\n\n  NoAccessMessagevue_type_script_lang_ts_createClass(NoAccessMessage, [{\n    key: "networkUnsupported",\n    get: function get() {\n      return this.reason === types["a" /* DeniedReason */].UNSUPPORTED_NETWORK;\n    }\n  }, {\n    key: "initializationFailed",\n    get: function get() {\n      return this.reason === types["a" /* DeniedReason */].INITIALIZATION_FAILED;\n    }\n  }, {\n    key: "rdnStateMigration",\n    get: function get() {\n      return this.reason === types["a" /* DeniedReason */].RDN_STATE_MIGRATION;\n    }\n  }]);\n\n  return NoAccessMessage;\n}(vue_property_decorator["e" /* Vue */]);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  required: true\n})], NoAccessMessagevue_type_script_lang_ts_NoAccessMessage.prototype, "reason", void 0);\n\nNoAccessMessagevue_type_script_lang_ts_NoAccessMessage = Object(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["a" /* Component */])({})], NoAccessMessagevue_type_script_lang_ts_NoAccessMessage);\n/* harmony default export */ var NoAccessMessagevue_type_script_lang_ts_ = (NoAccessMessagevue_type_script_lang_ts_NoAccessMessage);\n// CONCATENATED MODULE: ./src/components/NoAccessMessage.vue?vue&type=script&lang=ts&\n /* harmony default export */ var components_NoAccessMessagevue_type_script_lang_ts_ = (NoAccessMessagevue_type_script_lang_ts_); \n// EXTERNAL MODULE: ./src/components/NoAccessMessage.vue?vue&type=style&index=0&id=7b92b083&scoped=true&lang=scss&\nvar NoAccessMessagevue_type_style_index_0_id_7b92b083_scoped_true_lang_scss_ = __webpack_require__("753f");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VAlert/VAlert.js\nvar VAlert = __webpack_require__("0798");\n\n// CONCATENATED MODULE: ./src/components/NoAccessMessage.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar NoAccessMessage_component = Object(componentNormalizer["a" /* default */])(\n  components_NoAccessMessagevue_type_script_lang_ts_,\n  NoAccessMessagevue_type_template_id_7b92b083_scoped_true_render,\n  NoAccessMessagevue_type_template_id_7b92b083_scoped_true_staticRenderFns,\n  false,\n  null,\n  "7b92b083",\n  null\n  \n)\n\n/* harmony default export */ var components_NoAccessMessage = (NoAccessMessage_component.exports);\n\n/* vuetify-loader */\n\n\ninstallComponents_default()(NoAccessMessage_component, {VAlert: VAlert["a" /* default */]})\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/ConnectDialog.vue?vue&type=script&lang=ts&\nfunction ConnectDialogvue_type_script_lang_ts_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { ConnectDialogvue_type_script_lang_ts_typeof = function _typeof(obj) { return typeof obj; }; } else { ConnectDialogvue_type_script_lang_ts_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return ConnectDialogvue_type_script_lang_ts_typeof(obj); }\n\nfunction ConnectDialogvue_type_script_lang_ts_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction ConnectDialogvue_type_script_lang_ts_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction ConnectDialogvue_type_script_lang_ts_createClass(Constructor, protoProps, staticProps) { if (protoProps) ConnectDialogvue_type_script_lang_ts_defineProperties(Constructor.prototype, protoProps); if (staticProps) ConnectDialogvue_type_script_lang_ts_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction ConnectDialogvue_type_script_lang_ts_createSuper(Derived) { return function () { var Super = ConnectDialogvue_type_script_lang_ts_getPrototypeOf(Derived), result; if (ConnectDialogvue_type_script_lang_ts_isNativeReflectConstruct()) { var NewTarget = ConnectDialogvue_type_script_lang_ts_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ConnectDialogvue_type_script_lang_ts_possibleConstructorReturn(this, result); }; }\n\nfunction ConnectDialogvue_type_script_lang_ts_possibleConstructorReturn(self, call) { if (call && (ConnectDialogvue_type_script_lang_ts_typeof(call) === "object" || typeof call === "function")) { return call; } return ConnectDialogvue_type_script_lang_ts_assertThisInitialized(self); }\n\nfunction ConnectDialogvue_type_script_lang_ts_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction ConnectDialogvue_type_script_lang_ts_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ConnectDialogvue_type_script_lang_ts_getPrototypeOf(o) { ConnectDialogvue_type_script_lang_ts_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ConnectDialogvue_type_script_lang_ts_getPrototypeOf(o); }\n\nfunction ConnectDialogvue_type_script_lang_ts_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) ConnectDialogvue_type_script_lang_ts_setPrototypeOf(subClass, superClass); }\n\nfunction ConnectDialogvue_type_script_lang_ts_setPrototypeOf(o, p) { ConnectDialogvue_type_script_lang_ts_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ConnectDialogvue_type_script_lang_ts_setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\nvar ConnectDialogvue_type_script_lang_ts_ConnectDialog = /*#__PURE__*/function (_Vue) {\n  ConnectDialogvue_type_script_lang_ts_inherits(ConnectDialog, _Vue);\n\n  var _super = ConnectDialogvue_type_script_lang_ts_createSuper(ConnectDialog);\n\n  function ConnectDialog() {\n    var _this;\n\n    ConnectDialogvue_type_script_lang_ts_classCallCheck(this, ConnectDialog);\n\n    _this = _super.apply(this, arguments);\n    _this.hideClose = false;\n    return _this;\n  }\n\n  ConnectDialogvue_type_script_lang_ts_createClass(ConnectDialog, [{\n    key: "close",\n    value: function close() {}\n  }, {\n    key: "connect",\n    value: function connect(uploadedState, subkey) {\n      return {\n        uploadedState: uploadedState,\n        subkey: subkey\n      };\n    }\n  }, {\n    key: "injectedProvider",\n    get: function get() {\n      return web3_provider_Web3Provider.injectedWeb3Available();\n    }\n  }]);\n\n  return ConnectDialog;\n}(vue_property_decorator["e" /* Vue */]);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  required: true,\n  type: Boolean,\n  default: false\n})], ConnectDialogvue_type_script_lang_ts_ConnectDialog.prototype, "visible", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  default: false,\n  required: true,\n  type: Boolean\n})], ConnectDialogvue_type_script_lang_ts_ConnectDialog.prototype, "connecting", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["d" /* Prop */])({\n  default: false,\n  required: true,\n  type: Boolean\n})], ConnectDialogvue_type_script_lang_ts_ConnectDialog.prototype, "connectingSubkey", void 0);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["b" /* Emit */])()], ConnectDialogvue_type_script_lang_ts_ConnectDialog.prototype, "close", null);\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["b" /* Emit */])()], ConnectDialogvue_type_script_lang_ts_ConnectDialog.prototype, "connect", null);\n\nConnectDialogvue_type_script_lang_ts_ConnectDialog = Object(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["a" /* Component */])({\n  components: {\n    RaidenDialog: RaidenDialog["a" /* default */],\n    ActionButton: ActionButton["a" /* default */],\n    NoAccessMessage: components_NoAccessMessage\n  },\n  computed: Object(vuex_esm["c" /* mapState */])([\'stateBackup\', \'accessDenied\'])\n})], ConnectDialogvue_type_script_lang_ts_ConnectDialog);\n/* harmony default export */ var ConnectDialogvue_type_script_lang_ts_ = (ConnectDialogvue_type_script_lang_ts_ConnectDialog);\n// CONCATENATED MODULE: ./src/components/ConnectDialog.vue?vue&type=script&lang=ts&\n /* harmony default export */ var components_ConnectDialogvue_type_script_lang_ts_ = (ConnectDialogvue_type_script_lang_ts_); \n// EXTERNAL MODULE: ./src/components/ConnectDialog.vue?vue&type=style&index=0&id=3604c23c&lang=scss&scoped=true&\nvar ConnectDialogvue_type_style_index_0_id_3604c23c_lang_scss_scoped_true_ = __webpack_require__("3c58");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VCard/index.js\nvar VCard = __webpack_require__("99d9");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/components/VProgressCircular/VProgressCircular.js\nvar VProgressCircular = __webpack_require__("490a");\n\n// CONCATENATED MODULE: ./src/components/ConnectDialog.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar ConnectDialog_component = Object(componentNormalizer["a" /* default */])(\n  components_ConnectDialogvue_type_script_lang_ts_,\n  ConnectDialogvue_type_template_id_3604c23c_scoped_true_render,\n  ConnectDialogvue_type_template_id_3604c23c_scoped_true_staticRenderFns,\n  false,\n  null,\n  "3604c23c",\n  null\n  \n)\n\n/* harmony default export */ var components_ConnectDialog = (ConnectDialog_component.exports);\n\n/* vuetify-loader */\n\n\n\n\ninstallComponents_default()(ConnectDialog_component, {VCardText: VCard["b" /* VCardText */],VCardTitle: VCard["c" /* VCardTitle */],VProgressCircular: VProgressCircular["a" /* default */]})\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"e349156a-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/NoTokens.vue?vue&type=template&id=4f16408a&scoped=true&\nvar NoTokensvue_type_template_id_4f16408a_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (!_vm.tokens.length)?_c(\'v-container\',{staticClass:"new-token fill-height",attrs:{"fluid":""}},[_c(\'v-row\',{attrs:{"align":"center","justify":"center","no-gutters":""}},[_c(\'v-col\',{staticClass:"new-token__button",attrs:{"cols":"12"}},[_c(\'v-btn\',{attrs:{"fab":"","color":"primary"},on:{"click":function($event){return _vm.navigateToTokenSelect()}}},[_c(\'v-icon\',{attrs:{"large":""}},[_vm._v("mdi-plus")])],1)],1),_c(\'v-col\',{staticClass:"new-token__header",attrs:{"cols":"12"}},[_vm._v(" "+_vm._s(_vm.$t(\'tokens.connect-new\'))+" ")])],1)],1):_vm._e()}\nvar NoTokensvue_type_template_id_4f16408a_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/NoTokens.vue?vue&type=template&id=4f16408a&scoped=true&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/NoTokens.vue?vue&type=script&lang=ts&\nfunction NoTokensvue_type_script_lang_ts_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { NoTokensvue_type_script_lang_ts_typeof = function _typeof(obj) { return typeof obj; }; } else { NoTokensvue_type_script_lang_ts_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return NoTokensvue_type_script_lang_ts_typeof(obj); }\n\nfunction NoTokensvue_type_script_lang_ts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction NoTokensvue_type_script_lang_ts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { NoTokensvue_type_script_lang_ts_ownKeys(Object(source), true).forEach(function (key) { NoTokensvue_type_script_lang_ts_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { NoTokensvue_type_script_lang_ts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction NoTokensvue_type_script_lang_ts_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction NoTokensvue_type_script_lang_ts_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction NoTokensvue_type_script_lang_ts_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction NoTokensvue_type_script_lang_ts_createClass(Constructor, protoProps, staticProps) { if (protoProps) NoTokensvue_type_script_lang_ts_defineProperties(Constructor.prototype, protoProps); if (staticProps) NoTokensvue_type_script_lang_ts_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction NoTokensvue_type_script_lang_ts_createSuper(Derived) { return function () { var Super = NoTokensvue_type_script_lang_ts_getPrototypeOf(Derived), result; if (NoTokensvue_type_script_lang_ts_isNativeReflectConstruct()) { var NewTarget = NoTokensvue_type_script_lang_ts_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return NoTokensvue_type_script_lang_ts_possibleConstructorReturn(this, result); }; }\n\nfunction NoTokensvue_type_script_lang_ts_possibleConstructorReturn(self, call) { if (call && (NoTokensvue_type_script_lang_ts_typeof(call) === "object" || typeof call === "function")) { return call; } return NoTokensvue_type_script_lang_ts_assertThisInitialized(self); }\n\nfunction NoTokensvue_type_script_lang_ts_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction NoTokensvue_type_script_lang_ts_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction NoTokensvue_type_script_lang_ts_getPrototypeOf(o) { NoTokensvue_type_script_lang_ts_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return NoTokensvue_type_script_lang_ts_getPrototypeOf(o); }\n\nfunction NoTokensvue_type_script_lang_ts_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) NoTokensvue_type_script_lang_ts_setPrototypeOf(subClass, superClass); }\n\nfunction NoTokensvue_type_script_lang_ts_setPrototypeOf(o, p) { NoTokensvue_type_script_lang_ts_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return NoTokensvue_type_script_lang_ts_setPrototypeOf(o, p); }\n\n\n\n\n\n\nvar NoTokens = /*#__PURE__*/function (_Mixins) {\n  NoTokensvue_type_script_lang_ts_inherits(NoTokens, _Mixins);\n\n  var _super = NoTokensvue_type_script_lang_ts_createSuper(NoTokens);\n\n  function NoTokens() {\n    NoTokensvue_type_script_lang_ts_classCallCheck(this, NoTokens);\n\n    return _super.apply(this, arguments);\n  }\n\n  NoTokensvue_type_script_lang_ts_createClass(NoTokens, [{\n    key: "onChange",\n    value: function onChange(tokens) {\n      if (tokens.length) {\n        this.navigateToSelectTransferTarget(tokens[0].address);\n      }\n    }\n  }]);\n\n  return NoTokens;\n}(Object(vue_property_decorator["c" /* Mixins */])(navigation_mixin["a" /* default */]));\n\nObject(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["f" /* Watch */])(\'tokens\', {\n  immediate: true\n})], NoTokens.prototype, "onChange", null);\n\nNoTokens = Object(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["a" /* Component */])({\n  computed: NoTokensvue_type_script_lang_ts_objectSpread({}, Object(vuex_esm["b" /* mapGetters */])([\'tokens\']))\n})], NoTokens);\n/* harmony default export */ var NoTokensvue_type_script_lang_ts_ = (NoTokens);\n// CONCATENATED MODULE: ./src/components/NoTokens.vue?vue&type=script&lang=ts&\n /* harmony default export */ var components_NoTokensvue_type_script_lang_ts_ = (NoTokensvue_type_script_lang_ts_); \n// EXTERNAL MODULE: ./src/components/NoTokens.vue?vue&type=style&index=0&id=4f16408a&lang=scss&scoped=true&\nvar NoTokensvue_type_style_index_0_id_4f16408a_lang_scss_scoped_true_ = __webpack_require__("1a2b");\n\n// CONCATENATED MODULE: ./src/components/NoTokens.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar NoTokens_component = Object(componentNormalizer["a" /* default */])(\n  components_NoTokensvue_type_script_lang_ts_,\n  NoTokensvue_type_template_id_4f16408a_scoped_true_render,\n  NoTokensvue_type_template_id_4f16408a_scoped_true_staticRenderFns,\n  false,\n  null,\n  "4f16408a",\n  null\n  \n)\n\n/* harmony default export */ var components_NoTokens = (NoTokens_component.exports);\n\n/* vuetify-loader */\n\n\n\n\n\n\ninstallComponents_default()(NoTokens_component, {VBtn: VBtn["a" /* default */],VCol: VCol["a" /* default */],VContainer: VContainer["a" /* default */],VIcon: VIcon["a" /* default */],VRow: VRow["a" /* default */]})\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--14-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/ts-loader??ref--14-3!./node_modules/vuetify-loader/lib/loader.js??ref--21-0!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/views/Home.vue?vue&type=script&lang=ts&\n\n\nfunction Homevue_type_script_lang_ts_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Homevue_type_script_lang_ts_typeof = function _typeof(obj) { return typeof obj; }; } else { Homevue_type_script_lang_ts_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Homevue_type_script_lang_ts_typeof(obj); }\n\nfunction Homevue_type_script_lang_ts_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction Homevue_type_script_lang_ts_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Homevue_type_script_lang_ts_ownKeys(Object(source), true).forEach(function (key) { Homevue_type_script_lang_ts_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Homevue_type_script_lang_ts_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction Homevue_type_script_lang_ts_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Homevue_type_script_lang_ts_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction Homevue_type_script_lang_ts_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { Homevue_type_script_lang_ts_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { Homevue_type_script_lang_ts_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction Homevue_type_script_lang_ts_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Homevue_type_script_lang_ts_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Homevue_type_script_lang_ts_createClass(Constructor, protoProps, staticProps) { if (protoProps) Homevue_type_script_lang_ts_defineProperties(Constructor.prototype, protoProps); if (staticProps) Homevue_type_script_lang_ts_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Homevue_type_script_lang_ts_createSuper(Derived) { return function () { var Super = Homevue_type_script_lang_ts_getPrototypeOf(Derived), result; if (Homevue_type_script_lang_ts_isNativeReflectConstruct()) { var NewTarget = Homevue_type_script_lang_ts_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Homevue_type_script_lang_ts_possibleConstructorReturn(this, result); }; }\n\nfunction Homevue_type_script_lang_ts_possibleConstructorReturn(self, call) { if (call && (Homevue_type_script_lang_ts_typeof(call) === "object" || typeof call === "function")) { return call; } return Homevue_type_script_lang_ts_assertThisInitialized(self); }\n\nfunction Homevue_type_script_lang_ts_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Homevue_type_script_lang_ts_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Homevue_type_script_lang_ts_getPrototypeOf(o) { Homevue_type_script_lang_ts_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Homevue_type_script_lang_ts_getPrototypeOf(o); }\n\nfunction Homevue_type_script_lang_ts_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Homevue_type_script_lang_ts_setPrototypeOf(subClass, superClass); }\n\nfunction Homevue_type_script_lang_ts_setPrototypeOf(o, p) { Homevue_type_script_lang_ts_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Homevue_type_script_lang_ts_setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\nvar Homevue_type_script_lang_ts_Home = /*#__PURE__*/function (_Vue) {\n  Homevue_type_script_lang_ts_inherits(Home, _Vue);\n\n  var _super = Homevue_type_script_lang_ts_createSuper(Home);\n\n  function Home() {\n    var _this;\n\n    Homevue_type_script_lang_ts_classCallCheck(this, Home);\n\n    _this = _super.apply(this, arguments);\n    _this.connectDialog = false;\n    _this.connecting = false;\n    _this.connectingSubkey = false;\n    return _this;\n  }\n\n  Homevue_type_script_lang_ts_createClass(Home, [{\n    key: "connect",\n    value: function () {\n      var _connect = Homevue_type_script_lang_ts_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee(connectOptions) {\n        var stateBackup, subkey;\n        return regenerator_default.a.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                stateBackup = connectOptions.uploadedState;\n                subkey = connectOptions.subkey;\n\n                if (subkey) {\n                  this.connectingSubkey = true;\n                } else {\n                  this.connecting = true;\n                }\n\n                this.$store.commit(\'reset\');\n                _context.next = 6;\n                return this.$raiden.connect(stateBackup, subkey);\n\n              case 6:\n                this.connectingSubkey = false;\n                this.connecting = false;\n\n                if (!this.accessDenied) {\n                  this.connectDialog = false;\n                }\n\n              case 9:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function connect(_x) {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: "inaccessible",\n    get: function get() {\n      return this.connecting || this.loading || this.accessDenied !== types["a" /* DeniedReason */].UNDEFINED;\n    }\n  }]);\n\n  return Home;\n}(vue_property_decorator["e" /* Vue */]);\n\nHomevue_type_script_lang_ts_Home = Object(tslib_es6["b" /* __decorate */])([Object(vue_property_decorator["a" /* Component */])({\n  computed: Homevue_type_script_lang_ts_objectSpread({}, Object(vuex_esm["c" /* mapState */])([\'loading\', \'accessDenied\']), {}, Object(vuex_esm["b" /* mapGetters */])([\'isConnected\'])),\n  components: {\n    ActionButton: ActionButton["a" /* default */],\n    ConnectDialog: components_ConnectDialog,\n    NoTokens: components_NoTokens\n  }\n})], Homevue_type_script_lang_ts_Home);\n/* harmony default export */ var Homevue_type_script_lang_ts_ = (Homevue_type_script_lang_ts_Home);\n// CONCATENATED MODULE: ./src/views/Home.vue?vue&type=script&lang=ts&\n /* harmony default export */ var views_Homevue_type_script_lang_ts_ = (Homevue_type_script_lang_ts_); \n// EXTERNAL MODULE: ./src/views/Home.vue?vue&type=style&index=0&id=02ef831a&lang=scss&scoped=true&\nvar Homevue_type_style_index_0_id_02ef831a_lang_scss_scoped_true_ = __webpack_require__("4e0d");\n\n// CONCATENATED MODULE: ./src/views/Home.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar Home_component = Object(componentNormalizer["a" /* default */])(\n  views_Homevue_type_script_lang_ts_,\n  Homevue_type_template_id_02ef831a_scoped_true_render,\n  Homevue_type_template_id_02ef831a_scoped_true_staticRenderFns,\n  false,\n  null,\n  "02ef831a",\n  null\n  \n)\n\n/* harmony default export */ var views_Home = (Home_component.exports);\n\n/* vuetify-loader */\n\n\n\n\n\ninstallComponents_default()(Home_component, {VCol: VCol["a" /* default */],VContainer: VContainer["a" /* default */],VImg: VImg["a" /* default */],VRow: VRow["a" /* default */]})\n\n// CONCATENATED MODULE: ./src/router/index.ts\n\n\n\n\nvue_runtime_esm["a" /* default */].use(vue_router_esm["a" /* default */]);\n/* istanbul ignore next */\n\nvar router = new vue_router_esm["a" /* default */]({\n  mode: \'history\',\n  base: "/staging/",\n  routes: [{\n    path: \'/\',\n    name: route_names["a" /* RouteNames */].HOME,\n    meta: {\n      title: \'Raiden dApp\'\n    },\n    component: views_Home\n  }, {\n    path: \'*\',\n    redirect: \'/\'\n  }, {\n    path: \'/transfer/:token\',\n    name: route_names["a" /* RouteNames */].TRANSFER,\n    meta: {\n      title: \'Transfer\'\n    },\n    component: function component() {\n      return Promise.all(/* import() */[__webpack_require__.e("chunk-15f0b7af"), __webpack_require__.e("chunk-08151fa2"), __webpack_require__.e("chunk-4c34ba5c"), __webpack_require__.e("chunk-5e7189c2"), __webpack_require__.e("chunk-7bc2c414")]).then(__webpack_require__.bind(null, "69aa"));\n    }\n  }, {\n    path: \'/transfer/:token/:target\',\n    name: route_names["a" /* RouteNames */].TRANSFER_STEPS,\n    meta: {\n      title: \'Transfer\'\n    },\n    component: function component() {\n      return Promise.all(/* import() */[__webpack_require__.e("chunk-15f0b7af"), __webpack_require__.e("chunk-08151fa2"), __webpack_require__.e("chunk-d3b2fbc4")]).then(__webpack_require__.bind(null, "feae"));\n    }\n  }, {\n    path: \'/connect\',\n    name: route_names["a" /* RouteNames */].SELECT_TOKEN,\n    meta: {\n      title: \'Select Token\'\n    },\n    component: function component() {\n      return Promise.all(/* import() */[__webpack_require__.e("chunk-15f0b7af"), __webpack_require__.e("chunk-27f3174b")]).then(__webpack_require__.bind(null, "7724"));\n    }\n  }, {\n    path: \'/connect/:token\',\n    name: route_names["a" /* RouteNames */].SELECT_HUB,\n    meta: {\n      title: \'Select Hub\'\n    },\n    component: function component() {\n      return Promise.all(/* import() */[__webpack_require__.e("chunk-08151fa2"), __webpack_require__.e("chunk-4c34ba5c"), __webpack_require__.e("chunk-5e7189c2"), __webpack_require__.e("chunk-488fc1f2")]).then(__webpack_require__.bind(null, "c405"));\n    }\n  }, {\n    path: \'/connect/:token/:partner\',\n    name: route_names["a" /* RouteNames */].OPEN_CHANNEL,\n    meta: {\n      title: \'Open Channel\'\n    },\n    component: function component() {\n      return Promise.all(/* import() */[__webpack_require__.e("chunk-08151fa2"), __webpack_require__.e("chunk-4c34ba5c"), __webpack_require__.e("chunk-b14359ce")]).then(__webpack_require__.bind(null, "7542"));\n    }\n  }, {\n    path: \'/channels/:token\',\n    name: route_names["a" /* RouteNames */].CHANNELS,\n    meta: {\n      title: \'Channels\'\n    },\n    component: function component() {\n      return Promise.all(/* import() */[__webpack_require__.e("chunk-15f0b7af"), __webpack_require__.e("chunk-08151fa2"), __webpack_require__.e("chunk-552b1730")]).then(__webpack_require__.bind(null, "3010"));\n    }\n  }, {\n    path: \'/general\',\n    name: route_names["a" /* RouteNames */].GENERAL,\n    beforeEnter: function beforeEnter(to, from, next) {\n      // Remembers the route that was visited just before the General view is opened and\n      // then loads the General view in a separate <router-view>. The last visited route\n      // is loaded when clicking out of the General view.\n      if (from.name === null) {\n        next({\n          name: route_names["a" /* RouteNames */].HOME\n        });\n      } else if (to.matched.length) {\n        to.matched[0].components.default = from.matched[0].components.default;\n\n        to.matched[0].components.modal = function () {\n          return __webpack_require__.e(/* import() */ "chunk-e17a21de").then(__webpack_require__.bind(null, "18b0"));\n        };\n      }\n\n      next();\n    },\n    children: [{\n      path: \'general-home\',\n      name: route_names["a" /* RouteNames */].GENERAL_HOME,\n      meta: {\n        title: \'General\'\n      },\n      component: function component() {\n        return Promise.all(/* import() */[__webpack_require__.e("chunk-15f0b7af"), __webpack_require__.e("chunk-7e432e88")]).then(__webpack_require__.bind(null, "3a87"));\n      }\n    }, {\n      path: \'backup-state\',\n      name: route_names["a" /* RouteNames */].BACKUP_STATE,\n      meta: {\n        title: \'Backup State\'\n      },\n      component: function component() {\n        return Promise.all(/* import() */[__webpack_require__.e("chunk-15f0b7af"), __webpack_require__.e("chunk-43b69ccc")]).then(__webpack_require__.bind(null, "797d"));\n      }\n    }]\n  }]\n});\n/* harmony default export */ var src_router = (router);\n// EXTERNAL MODULE: ../raiden-ts/dist/index.js + 66 modules\nvar dist = __webpack_require__("f455");\n\n// EXTERNAL MODULE: ./node_modules/lodash/map.js\nvar map = __webpack_require__("dd61");\nvar map_default = /*#__PURE__*/__webpack_require__.n(map);\n\n// EXTERNAL MODULE: ./node_modules/lodash/flatMap.js\nvar flatMap = __webpack_require__("e9a8d");\nvar flatMap_default = /*#__PURE__*/__webpack_require__.n(flatMap);\n\n// EXTERNAL MODULE: ./node_modules/lodash/filter.js\nvar filter = __webpack_require__("9380");\nvar filter_default = /*#__PURE__*/__webpack_require__.n(filter);\n\n// EXTERNAL MODULE: ./node_modules/lodash/clone.js\nvar clone = __webpack_require__("b8ce");\nvar clone_default = /*#__PURE__*/__webpack_require__.n(clone);\n\n// EXTERNAL MODULE: ./node_modules/lodash/reduce.js\nvar reduce = __webpack_require__("c5a2");\nvar reduce_default = /*#__PURE__*/__webpack_require__.n(reduce);\n\n// EXTERNAL MODULE: ./node_modules/lodash/orderBy.js\nvar orderBy = __webpack_require__("93c6");\nvar orderBy_default = /*#__PURE__*/__webpack_require__.n(orderBy);\n\n// EXTERNAL MODULE: ./node_modules/lodash/isEqual.js\nvar isEqual = __webpack_require__("63ea");\nvar isEqual_default = /*#__PURE__*/__webpack_require__.n(isEqual);\n\n// EXTERNAL MODULE: ./node_modules/lodash/isEmpty.js\nvar isEmpty = __webpack_require__("13ea");\nvar isEmpty_default = /*#__PURE__*/__webpack_require__.n(isEmpty);\n\n// CONCATENATED MODULE: ./src/store/index.ts\nfunction store_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction store_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { store_ownKeys(Object(source), true).forEach(function (key) { store_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { store_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction store_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\n\n\n\nvue_runtime_esm["a" /* default */].use(vuex_esm["a" /* default */]);\nvar _defaultState = {\n  loading: true,\n  defaultAccount: \'\',\n  accountBalance: \'0.0\',\n  raidenAccountBalance: \'\',\n  providerDetected: true,\n  accessDenied: types["a" /* DeniedReason */].UNDEFINED,\n  channels: {},\n  tokens: {},\n  transfers: {},\n  presences: {},\n  network: types["b" /* PlaceHolderNetwork */],\n  stateBackup: \'\'\n};\nfunction defaultState() {\n  return clone_default()(_defaultState);\n}\nvar store = {\n  state: defaultState(),\n  mutations: {\n    noProvider: function noProvider(state) {\n      state.providerDetected = false;\n    },\n    accessDenied: function accessDenied(state, reason) {\n      state.accessDenied = reason;\n    },\n    account: function account(state, _account) {\n      state.defaultAccount = _account;\n    },\n    loadComplete: function loadComplete(state) {\n      state.loading = false;\n    },\n    balance: function balance(state, _balance) {\n      state.accountBalance = _balance;\n    },\n    raidenAccountBalance: function raidenAccountBalance(state, balance) {\n      state.raidenAccountBalance = balance;\n    },\n    updateChannels: function updateChannels(state, channels) {\n      state.channels = channels;\n    },\n    updateTokens: function updateTokens(state, tokens) {\n      for (var _i = 0, _Object$entries = Object.entries(tokens); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n            address = _Object$entries$_i[0],\n            token = _Object$entries$_i[1];\n\n        if (address in state.tokens && isEqual_default()(token, state.tokens[address])) continue;else if (address in state.tokens) state.tokens[address] = store_objectSpread({}, state.tokens[address], {}, token);else state.tokens = store_objectSpread({}, state.tokens, store_defineProperty({}, address, token));\n      }\n    },\n    updatePresence: function updatePresence(state, presence) {\n      state.presences = store_objectSpread({}, state.presences, {}, presence);\n    },\n    network: function network(state, _network) {\n      state.network = _network;\n    },\n    reset: function reset(state) {\n      Object.assign(state, defaultState());\n    },\n    updateTransfers: function updateTransfers(state, transfer) {\n      state.transfers = store_objectSpread({}, state.transfers, store_defineProperty({}, transfer.secrethash, transfer));\n    },\n    backupState: function backupState(state, uploadedState) {\n      state.stateBackup = uploadedState;\n    }\n  },\n  actions: {},\n  getters: {\n    tokens: function tokens(state) {\n      var reducer = function reducer(acc, channel) {\n        acc.address = channel.token;\n        acc[channel.state] += 1;\n        return acc;\n      };\n\n      return map_default()(filter_default()(flatMap_default()(state.channels), function (channels) {\n        return !isEmpty_default()(channels);\n      }), function (tokenChannels) {\n        var model = reduce_default()(tokenChannels, reducer, Object(types["d" /* emptyTokenModel */])());\n        var tokenInfo = state.tokens[model.address];\n\n        if (tokenInfo) {\n          model.name = tokenInfo.name || \'\';\n          model.symbol = tokenInfo.symbol || \'\';\n        }\n\n        return model;\n      });\n    },\n    allTokens: function allTokens(state) {\n      return Object.values(state.tokens);\n    },\n    channels: function channels(state) {\n      return function (tokenAddress) {\n        var channels = [];\n        var tokenChannels = state.channels[tokenAddress];\n\n        if (tokenChannels && !isEmpty_default()(tokenChannels)) {\n          channels = flatMap_default()(tokenChannels);\n        }\n\n        return channels;\n      };\n    },\n    token: function token(state) {\n      return function (tokenAddress) {\n        if (tokenAddress in state.tokens) {\n          return state.tokens[tokenAddress];\n        } else {\n          return null;\n        }\n      };\n    },\n    network: function network(state) {\n      return state.network.name || "Chain ".concat(state.network.chainId);\n    },\n    channelWithBiggestCapacity: function channelWithBiggestCapacity(_, getters) {\n      return function (tokenAddress) {\n        var channels = getters.channels(tokenAddress);\n        var openChannels = channels.filter(function (value) {\n          return value.state === dist["a" /* ChannelState */].open;\n        });\n        return orderBy_default()(openChannels, [\'capacity\'], [\'desc\'])[0];\n      };\n    },\n    pendingTransfers: function pendingTransfers(_ref) {\n      var transfers = _ref.transfers;\n      return Object.keys(transfers).filter(function (secretHash) {\n        var completed = transfers[secretHash].completed; // return whether transfer is pending or not\n\n        return !completed;\n      }).reduce(function (pendingTransfers, secretHash) {\n        pendingTransfers[secretHash] = transfers[secretHash];\n        return pendingTransfers;\n      }, {});\n    },\n    transfer: function transfer(state) {\n      return function (paymentId) {\n        var secretHash = Object.keys(state.transfers).find(function (secretHash) {\n          return state.transfers[secretHash].paymentId === paymentId;\n        });\n\n        if (secretHash) {\n          return state.transfers[secretHash];\n        }\n\n        return undefined;\n      };\n    },\n    isConnected: function isConnected(state) {\n      return !!(state.defaultAccount && state.defaultAccount !== \'\');\n    },\n    balance: function balance(state) {\n      return state.raidenAccountBalance ? state.raidenAccountBalance : state.accountBalance;\n    }\n  }\n};\n/* harmony default export */ var src_store = (new vuex_esm["a" /* default */].Store(store));\n// EXTERNAL MODULE: ./src/utils/logstore.ts\nvar logstore = __webpack_require__("8aa9");\n\n// CONCATENATED MODULE: ./src/class-component-hooks.ts\n/* istanbul ignore file */\n // Register the router hooks with their names\n\nvue_class_component_esm["b" /* default */].registerHooks([\'beforeRouteEnter\', \'beforeRouteLeave\', \'beforeRouteUpdate\']);\n// EXTERNAL MODULE: ./src/utils/balance-utils.ts\nvar balance_utils = __webpack_require__("a3d5");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js\nvar operators_filter = __webpack_require__("5670");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/exhaustMap.js\nvar exhaustMap = __webpack_require__("e95d");\n\n// EXTERNAL MODULE: ./node_modules/tiny-async-pool/dist/node.js\nvar node = __webpack_require__("7f4b");\nvar node_default = /*#__PURE__*/__webpack_require__.n(node);\n\n// CONCATENATED MODULE: ./src/services/config-provider.ts\n\n\nfunction config_provider_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction config_provider_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { config_provider_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { config_provider_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction config_provider_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction config_provider_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction config_provider_createClass(Constructor, protoProps, staticProps) { if (protoProps) config_provider_defineProperties(Constructor.prototype, protoProps); if (staticProps) config_provider_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar config_provider_ConfigProvider = /*#__PURE__*/function () {\n  function ConfigProvider() {\n    config_provider_classCallCheck(this, ConfigProvider);\n  }\n\n  config_provider_createClass(ConfigProvider, null, [{\n    key: "fetch",\n    value: function (_fetch) {\n      function fetch(_x) {\n        return _fetch.apply(this, arguments);\n      }\n\n      fetch.toString = function () {\n        return _fetch.toString();\n      };\n\n      return fetch;\n    }( /*#__PURE__*/function () {\n      var _ref = config_provider_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee(url) {\n        return regenerator_default.a.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!url) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 3;\n                return fetch(url);\n\n              case 3:\n                _context.next = 5;\n                return _context.sent.json();\n\n              case 5:\n                return _context.abrupt("return", _context.sent);\n\n              case 6:\n                return _context.abrupt("return", undefined);\n\n              case 7:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x2) {\n        return _ref.apply(this, arguments);\n      };\n    }())\n  }]);\n\n  return ConfigProvider;\n}();\n// CONCATENATED MODULE: ./src/services/raiden-service.ts\n\n\nfunction raiden_service_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { raiden_service_typeof = function _typeof(obj) { return typeof obj; }; } else { raiden_service_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return raiden_service_typeof(obj); }\n\nfunction raiden_service_createSuper(Derived) { return function () { var Super = raiden_service_getPrototypeOf(Derived), result; if (raiden_service_isNativeReflectConstruct()) { var NewTarget = raiden_service_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return raiden_service_possibleConstructorReturn(this, result); }; }\n\nfunction raiden_service_possibleConstructorReturn(self, call) { if (call && (raiden_service_typeof(call) === "object" || typeof call === "function")) { return call; } return raiden_service_assertThisInitialized(self); }\n\nfunction raiden_service_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction raiden_service_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) raiden_service_setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, raiden_service_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return raiden_service_setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (raiden_service_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) raiden_service_setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction raiden_service_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\n\nfunction raiden_service_setPrototypeOf(o, p) { raiden_service_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return raiden_service_setPrototypeOf(o, p); }\n\nfunction raiden_service_getPrototypeOf(o) { raiden_service_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return raiden_service_getPrototypeOf(o); }\n\nfunction raiden_service_slicedToArray(arr, i) { return raiden_service_arrayWithHoles(arr) || raiden_service_iterableToArrayLimit(arr, i) || raiden_service_unsupportedIterableToArray(arr, i) || raiden_service_nonIterableRest(); }\n\nfunction raiden_service_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction raiden_service_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction raiden_service_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction raiden_service_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = raiden_service_unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction raiden_service_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return raiden_service_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return raiden_service_arrayLikeToArray(o, minLen); }\n\nfunction raiden_service_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction raiden_service_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction raiden_service_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { raiden_service_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { raiden_service_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction raiden_service_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction raiden_service_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction raiden_service_createClass(Constructor, protoProps, staticProps) { if (protoProps) raiden_service_defineProperties(Constructor.prototype, protoProps); if (staticProps) raiden_service_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\n\nvar raiden_service_RaidenService = /*#__PURE__*/function () {\n  function RaidenService(store) {\n    raiden_service_classCallCheck(this, RaidenService);\n\n    this._userDepositTokenAddress = \'\';\n    this._raiden = undefined;\n    this.store = store;\n  }\n\n  raiden_service_createClass(RaidenService, [{\n    key: "fetchTokenList",\n    value: function () {\n      var _fetchTokenList = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n        var allTokens, toFetch, placeholders, _iterator, _step, token;\n\n        return regenerator_default.a.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.raiden.getTokenList();\n\n              case 2:\n                allTokens = _context.sent;\n                toFetch = [];\n                placeholders = {};\n                _iterator = _createForOfIteratorHelper(allTokens);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    token = _step.value;\n                    toFetch.push(token);\n                    placeholders[token] = {\n                      address: token\n                    };\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                this.store.commit(\'updateTokens\', placeholders);\n                _context.next = 10;\n                return this.fetchTokenData(toFetch);\n\n              case 10:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function fetchTokenList() {\n        return _fetchTokenList.apply(this, arguments);\n      }\n\n      return fetchTokenList;\n    }()\n  }, {\n    key: "ensResolve",\n    value: function () {\n      var _ensResolve = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee2(name) {\n        return regenerator_default.a.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this.raiden.resolveName(name);\n\n              case 3:\n                return _context2.abrupt("return", _context2.sent);\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2["catch"](0);\n                throw new EnsResolveFailed(_context2.t0);\n\n              case 9:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 6]]);\n      }));\n\n      function ensResolve(_x) {\n        return _ensResolve.apply(this, arguments);\n      }\n\n      return ensResolve;\n    }()\n  }, {\n    key: "connect",\n    value: function () {\n      var _connect = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee3(stateBackup, subkey) {\n        var _this = this;\n\n        var raidenPackageConfigUrl, config, provider, raiden, account, deniedReason;\n        return regenerator_default.a.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                raidenPackageConfigUrl = Object({"NODE_ENV":"production","VUE_APP_PFS":"https://pfs.raidentransport.test001.env.raiden.network","VUE_APP_TRANSPORT":"https://raidentransport.test001.env.raiden.network","VUE_APP_HUB":"hub.raiden.eth","VUE_APP_I18N_LOCALE":"en","VUE_APP_I18N_FALLBACK_LOCALE":"en","BASE_URL":"/staging/"}).VUE_APP_RAIDEN_PACKAGE;\n\n                if (!raidenPackageConfigUrl) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                _context3.next = 5;\n                return config_provider_ConfigProvider.fetch(raidenPackageConfigUrl);\n\n              case 5:\n                config = _context3.sent;\n                _context3.next = 8;\n                return web3_provider_Web3Provider.provider(config);\n\n              case 8:\n                provider = _context3.sent;\n                _context3.next = 14;\n                break;\n\n              case 11:\n                _context3.next = 13;\n                return web3_provider_Web3Provider.provider();\n\n              case 13:\n                provider = _context3.sent;\n\n              case 14:\n                if (provider) {\n                  _context3.next = 18;\n                  break;\n                }\n\n                this.store.commit(\'noProvider\');\n                _context3.next = 54;\n                break;\n\n              case 18:\n                if (!config) {\n                  _context3.next = 24;\n                  break;\n                }\n\n                _context3.next = 21;\n                return RaidenService.createRaiden(provider, config.PRIVATE_KEY, stateBackup, subkey);\n\n              case 21:\n                raiden = _context3.sent;\n                _context3.next = 27;\n                break;\n\n              case 24:\n                _context3.next = 26;\n                return RaidenService.createRaiden(provider, undefined, stateBackup, subkey);\n\n              case 26:\n                raiden = _context3.sent;\n\n              case 27:\n                this._raiden = raiden;\n                _context3.next = 30;\n                return this.getAccount();\n\n              case 30:\n                account = _context3.sent;\n                this.store.commit(\'account\', account);\n                _context3.next = 34;\n                return raiden.userDepositTokenAddress();\n\n              case 34:\n                this._userDepositTokenAddress = _context3.sent;\n                // update connected tokens data on each newBlock\n                raiden.events$.pipe(Object(operators_filter["a" /* filter */])(function (value) {\n                  return value.type === \'newBlock\';\n                }), Object(exhaustMap["a" /* exhaustMap */])(function () {\n                  return _this.fetchTokenData(_this.store.getters.tokens.map(function (m) {\n                    return m.address;\n                  }));\n                })).subscribe();\n                raiden.events$.pipe(Object(operators_filter["a" /* filter */])(function (value) {\n                  return value.type === \'raidenShutdown\';\n                })).subscribe(function () {\n                  return _this.store.commit(\'reset\');\n                });\n                raiden.events$.subscribe(function (value) {\n                  if (value.type === \'tokenMonitored\') {\n                    _this.store.commit(\'updateTokens\', raiden_service_defineProperty({}, value.payload.token, {\n                      address: value.payload.token\n                    }));\n                  } // Update presences on matrix presence updates\n\n\n                  if (value.type === \'matrix/presence/success\') {\n                    _this.store.commit(\'updatePresence\', raiden_service_defineProperty({}, value.meta.address, value.payload.available));\n                  }\n                });\n                raiden.channels$.subscribe(function (value) {\n                  _this.store.commit(\'updateChannels\', value);\n                }); // Subscribe to our pending transfers\n\n                raiden.transfers$.subscribe(function (transfer) {\n                  if (transfer.initiator === account) {\n                    _this.store.commit(\'updateTransfers\', transfer);\n                  }\n                });\n                this.store.commit(\'network\', raiden.network);\n                window.addEventListener(\'beforeunload\', function () {\n                  return _this.raiden.stop();\n                });\n                raiden.start();\n                _context3.t0 = this.store;\n                _context3.next = 46;\n                return this.getBalance();\n\n              case 46:\n                _context3.t1 = _context3.sent;\n\n                _context3.t0.commit.call(_context3.t0, \'balance\', _context3.t1);\n\n                if (!subkey) {\n                  _context3.next = 54;\n                  break;\n                }\n\n                _context3.t2 = this.store;\n                _context3.next = 52;\n                return this.getBalance(raiden.address);\n\n              case 52:\n                _context3.t3 = _context3.sent;\n\n                _context3.t2.commit.call(_context3.t2, \'raidenAccountBalance\', _context3.t3);\n\n              case 54:\n                _context3.next = 60;\n                break;\n\n              case 56:\n                _context3.prev = 56;\n                _context3.t4 = _context3["catch"](0);\n\n                if (_context3.t4.message && _context3.t4.message.indexOf(\'No deploy info provided\') > -1) {\n                  deniedReason = types["a" /* DeniedReason */].UNSUPPORTED_NETWORK;\n                } else if (_context3.t4.message && _context3.t4.message.indexOf(\'Could not replace stored state\') > -1) {\n                  deniedReason = types["a" /* DeniedReason */].RDN_STATE_MIGRATION;\n                } else if (_context3.t4 instanceof RaidenInitializationFailed) {\n                  deniedReason = types["a" /* DeniedReason */].INITIALIZATION_FAILED;\n                } else {\n                  deniedReason = types["a" /* DeniedReason */].NO_ACCOUNT;\n                }\n\n                this.store.commit(\'accessDenied\', deniedReason);\n\n              case 60:\n                this.store.commit(\'loadComplete\');\n\n              case 61:\n              case "end":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 56]]);\n      }));\n\n      function connect(_x2, _x3) {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: "disconnect",\n    value: function disconnect() {\n      this.raiden.stop();\n    }\n  }, {\n    key: "getAccount",\n    value: function () {\n      var _getAccount = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee4() {\n        return regenerator_default.a.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt("return", this.raiden.address);\n\n              case 1:\n              case "end":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getAccount() {\n        return _getAccount.apply(this, arguments);\n      }\n\n      return getAccount;\n    }()\n  }, {\n    key: "getBalance",\n    value: function () {\n      var _getBalance = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee5(address) {\n        var balance;\n        return regenerator_default.a.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.raiden.getBalance(address);\n\n              case 2:\n                balance = _context5.sent;\n                return _context5.abrupt("return", balance_utils["a" /* BalanceUtils */].toEth(balance));\n\n              case 4:\n              case "end":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getBalance(_x4) {\n        return _getBalance.apply(this, arguments);\n      }\n\n      return getBalance;\n    }()\n  }, {\n    key: "getToken",\n    value: function () {\n      var _getToken = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee6(tokenAddress) {\n        var raiden, _yield$Promise$all, _yield$Promise$all2, balance, _yield$Promise$all2$, decimals, symbol, name;\n\n        return regenerator_default.a.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                raiden = this.raiden;\n                _context6.prev = 1;\n                _context6.next = 4;\n                return Promise.all([raiden.getTokenBalance(tokenAddress), raiden.getTokenInfo(tokenAddress)]);\n\n              case 4:\n                _yield$Promise$all = _context6.sent;\n                _yield$Promise$all2 = raiden_service_slicedToArray(_yield$Promise$all, 2);\n                balance = _yield$Promise$all2[0];\n                _yield$Promise$all2$ = _yield$Promise$all2[1];\n                decimals = _yield$Promise$all2$.decimals;\n                symbol = _yield$Promise$all2$.symbol;\n                name = _yield$Promise$all2$.name;\n                return _context6.abrupt("return", {\n                  name: name,\n                  symbol: symbol,\n                  balance: balance,\n                  decimals: decimals,\n                  address: tokenAddress\n                });\n\n              case 14:\n                _context6.prev = 14;\n                _context6.t0 = _context6["catch"](1);\n                return _context6.abrupt("return", null);\n\n              case 17:\n              case "end":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[1, 14]]);\n      }));\n\n      function getToken(_x5) {\n        return _getToken.apply(this, arguments);\n      }\n\n      return getToken;\n    }()\n  }, {\n    key: "openChannel",\n    value: function () {\n      var _openChannel = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee7(token, partner, amount, progress) {\n        var progressUpdater, raiden;\n        return regenerator_default.a.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                progressUpdater = function progressUpdater(current, total) {\n                  if (progress) {\n                    progress({\n                      current: current,\n                      total: total\n                    });\n                  }\n                };\n\n                raiden = this.raiden;\n                progressUpdater(1, 3);\n                _context7.prev = 3;\n                _context7.next = 6;\n                return raiden.openChannel(token, partner, {\n                  deposit: amount\n                }, function (e) {\n                  return e.type === dist["b" /* EventTypes */].OPENED ? progressUpdater(2, 3) : \'\';\n                });\n\n              case 6:\n                _context7.next = 11;\n                break;\n\n              case 8:\n                _context7.prev = 8;\n                _context7.t0 = _context7["catch"](3);\n                throw new ChannelOpenFailed(_context7.t0);\n\n              case 11:\n              case "end":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[3, 8]]);\n      }));\n\n      function openChannel(_x6, _x7, _x8, _x9) {\n        return _openChannel.apply(this, arguments);\n      }\n\n      return openChannel;\n    }()\n  }, {\n    key: "closeChannel",\n    value: function () {\n      var _closeChannel = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee8(token, partner) {\n        return regenerator_default.a.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                _context8.next = 3;\n                return this.raiden.closeChannel(token, partner);\n\n              case 3:\n                _context8.next = 8;\n                break;\n\n              case 5:\n                _context8.prev = 5;\n                _context8.t0 = _context8["catch"](0);\n                throw new ChannelCloseFailed(_context8.t0);\n\n              case 8:\n              case "end":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 5]]);\n      }));\n\n      function closeChannel(_x10, _x11) {\n        return _closeChannel.apply(this, arguments);\n      }\n\n      return closeChannel;\n    }()\n  }, {\n    key: "deposit",\n    value: function () {\n      var _deposit = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee9(token, partner, amount) {\n        return regenerator_default.a.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                _context9.next = 3;\n                return this.raiden.depositChannel(token, partner, amount);\n\n              case 3:\n                _context9.next = 8;\n                break;\n\n              case 5:\n                _context9.prev = 5;\n                _context9.t0 = _context9["catch"](0);\n                throw new ChannelDepositFailed(_context9.t0);\n\n              case 8:\n              case "end":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 5]]);\n      }));\n\n      function deposit(_x12, _x13, _x14) {\n        return _deposit.apply(this, arguments);\n      }\n\n      return deposit;\n    }()\n  }, {\n    key: "settleChannel",\n    value: function () {\n      var _settleChannel = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee10(token, partner) {\n        return regenerator_default.a.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.prev = 0;\n                _context10.next = 3;\n                return this.raiden.settleChannel(token, partner);\n\n              case 3:\n                _context10.next = 8;\n                break;\n\n              case 5:\n                _context10.prev = 5;\n                _context10.t0 = _context10["catch"](0);\n                throw new ChannelSettleFailed(_context10.t0);\n\n              case 8:\n              case "end":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[0, 5]]);\n      }));\n\n      function settleChannel(_x15, _x16) {\n        return _settleChannel.apply(this, arguments);\n      }\n\n      return settleChannel;\n    }()\n  }, {\n    key: "fetchTokenData",\n    value: function () {\n      var _fetchTokenData = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee12(tokens) {\n        var _this2 = this;\n\n        var fetchToken;\n        return regenerator_default.a.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (tokens.length) {\n                  _context12.next = 2;\n                  break;\n                }\n\n                return _context12.abrupt("return");\n\n              case 2:\n                fetchToken = /*#__PURE__*/function () {\n                  var _ref = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee11(address) {\n                    return regenerator_default.a.wrap(function _callee11$(_context11) {\n                      while (1) {\n                        switch (_context11.prev = _context11.next) {\n                          case 0:\n                            return _context11.abrupt("return", _this2.getToken(address).then(function (token) {\n                              if (!token) return;\n\n                              _this2.store.commit(\'updateTokens\', raiden_service_defineProperty({}, token.address, token));\n                            }));\n\n                          case 1:\n                          case "end":\n                            return _context11.stop();\n                        }\n                      }\n                    }, _callee11);\n                  }));\n\n                  return function fetchToken(_x18) {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                _context12.next = 5;\n                return node_default()(6, tokens, fetchToken);\n\n              case 5:\n              case "end":\n                return _context12.stop();\n            }\n          }\n        }, _callee12);\n      }));\n\n      function fetchTokenData(_x17) {\n        return _fetchTokenData.apply(this, arguments);\n      }\n\n      return fetchTokenData;\n    }()\n  }, {\n    key: "transfer",\n    value: function () {\n      var _transfer = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee13(token, target, amount, paths, paymentId) {\n        var secretHash;\n        return regenerator_default.a.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.prev = 0;\n                _context13.next = 3;\n                return this.raiden.transfer(token, target, amount, {\n                  paymentId: paymentId,\n                  paths: paths\n                });\n\n              case 3:\n                secretHash = _context13.sent;\n                _context13.next = 6;\n                return this.raiden.waitTransfer(secretHash);\n\n              case 6:\n                _context13.next = 11;\n                break;\n\n              case 8:\n                _context13.prev = 8;\n                _context13.t0 = _context13["catch"](0);\n                throw new TransferFailed(_context13.t0);\n\n              case 11:\n              case "end":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[0, 8]]);\n      }));\n\n      function transfer(_x19, _x20, _x21, _x22, _x23) {\n        return _transfer.apply(this, arguments);\n      }\n\n      return transfer;\n    }()\n  }, {\n    key: "findRoutes",\n    value: function () {\n      var _findRoutes = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee14(token, target, amount, raidenPFS) {\n        var routes;\n        return regenerator_default.a.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return this.raiden.getAvailability(target);\n\n              case 2:\n                _context14.next = 4;\n                return this.raiden.findRoutes(token, target, amount, {\n                  pfs: raidenPFS\n                });\n\n              case 4:\n                routes = _context14.sent;\n                return _context14.abrupt("return", routes);\n\n              case 6:\n              case "end":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function findRoutes(_x24, _x25, _x26, _x27) {\n        return _findRoutes.apply(this, arguments);\n      }\n\n      return findRoutes;\n    }()\n  }, {\n    key: "fetchServices",\n    value: function () {\n      var _fetchServices = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee15() {\n        var raidenPFS;\n        return regenerator_default.a.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                _context15.next = 2;\n                return this.raiden.findPFS();\n\n              case 2:\n                raidenPFS = _context15.sent;\n                return _context15.abrupt("return", raidenPFS);\n\n              case 4:\n              case "end":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function fetchServices() {\n        return _fetchServices.apply(this, arguments);\n      }\n\n      return fetchServices;\n    }()\n    /* istanbul ignore next */\n\n  }, {\n    key: "directRoute",\n    value: function () {\n      var _directRoute = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee16(token, target, value) {\n        return regenerator_default.a.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                _context16.next = 2;\n                return this.raiden.directRoute(token, target, value);\n\n              case 2:\n                return _context16.abrupt("return", _context16.sent);\n\n              case 3:\n              case "end":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function directRoute(_x28, _x29, _x30) {\n        return _directRoute.apply(this, arguments);\n      }\n\n      return directRoute;\n    }()\n    /* istanbul ignore next */\n\n  }, {\n    key: "mint",\n    value: function () {\n      var _mint = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee17(token, amount) {\n        return regenerator_default.a.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this.raiden.mint(token, amount);\n\n              case 2:\n                return _context17.abrupt("return", _context17.sent);\n\n              case 3:\n              case "end":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function mint(_x31, _x32) {\n        return _mint.apply(this, arguments);\n      }\n\n      return mint;\n    }()\n    /* istanbul ignore next */\n\n  }, {\n    key: "depositToUDC",\n    value: function () {\n      var _depositToUDC = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee18(amount, depositing) {\n        return regenerator_default.a.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.next = 2;\n                return this.raiden.depositToUDC(amount, function (event) {\n                  return event.type === dist["b" /* EventTypes */].APPROVED ? depositing() : null;\n                });\n\n              case 2:\n              case "end":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function depositToUDC(_x33, _x34) {\n        return _depositToUDC.apply(this, arguments);\n      }\n\n      return depositToUDC;\n    }()\n    /* istanbul ignore next */\n\n  }, {\n    key: "getUDCCapacity",\n    value: function () {\n      var _getUDCCapacity = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee19() {\n        return regenerator_default.a.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                return _context19.abrupt("return", this.raiden.getUDCCapacity());\n\n              case 1:\n              case "end":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function getUDCCapacity() {\n        return _getUDCCapacity.apply(this, arguments);\n      }\n\n      return getUDCCapacity;\n    }()\n  }, {\n    key: "getAvailability",\n    value: function () {\n      var _getAvailability = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee20(address) {\n        var _yield$this$raiden$ge, available;\n\n        return regenerator_default.a.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.prev = 0;\n                _context20.next = 3;\n                return this.raiden.getAvailability(address);\n\n              case 3:\n                _yield$this$raiden$ge = _context20.sent;\n                available = _yield$this$raiden$ge.available;\n                return _context20.abrupt("return", available);\n\n              case 8:\n                _context20.prev = 8;\n                _context20.t0 = _context20["catch"](0);\n                this.store.commit(\'updatePresence\', raiden_service_defineProperty({}, address, false));\n\n              case 11:\n                return _context20.abrupt("return", false);\n\n              case 12:\n              case "end":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this, [[0, 8]]);\n      }));\n\n      function getAvailability(_x35) {\n        return _getAvailability.apply(this, arguments);\n      }\n\n      return getAvailability;\n    }()\n    /* istanbul ignore next */\n\n  }, {\n    key: "getState",\n    value: function () {\n      var _getState = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee21() {\n        var _this$_raiden, _this$_raiden2;\n\n        return regenerator_default.a.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                (_this$_raiden = this._raiden) === null || _this$_raiden === void 0 ? void 0 : _this$_raiden.stop();\n                _context21.next = 3;\n                return (_this$_raiden2 = this._raiden) === null || _this$_raiden2 === void 0 ? void 0 : _this$_raiden2.state$.toPromise();\n\n              case 3:\n                return _context21.abrupt("return", _context21.sent);\n\n              case 4:\n              case "end":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function getState() {\n        return _getState.apply(this, arguments);\n      }\n\n      return getState;\n    }()\n  }, {\n    key: "raiden",\n    get: function get() {\n      if (this._raiden === undefined) {\n        throw new Error(\'Raiden instance was not initialized\');\n      } else {\n        return this._raiden;\n      }\n    }\n  }, {\n    key: "userDepositTokenAddress",\n    get: function get() {\n      if (!this._userDepositTokenAddress) throw new Error(\'address empty\');\n      return this._userDepositTokenAddress;\n    }\n  }], [{\n    key: "createRaiden",\n    value: function () {\n      var _createRaiden = raiden_service_asyncToGenerator( /*#__PURE__*/regenerator_default.a.mark(function _callee22(provider) {\n        var account,\n            stateBackup,\n            subkey,\n            _args22 = arguments;\n        return regenerator_default.a.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                account = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : 0;\n                stateBackup = _args22.length > 2 ? _args22[2] : undefined;\n                subkey = _args22.length > 3 ? _args22[3] : undefined;\n                _context22.prev = 3;\n                _context22.next = 6;\n                return dist["c" /* Raiden */].create(provider, account, {\n                  storage: window.localStorage,\n                  state: stateBackup\n                }, undefined, {\n                  pfsSafetyMargin: 1.1,\n                  pfs: "https://pfs.raidentransport.test001.env.raiden.network",\n                  matrixServer: "https://raidentransport.test001.env.raiden.network"\n                }, subkey);\n\n              case 6:\n                return _context22.abrupt("return", _context22.sent);\n\n              case 9:\n                _context22.prev = 9;\n                _context22.t0 = _context22["catch"](3);\n                throw new RaidenInitializationFailed(_context22.t0);\n\n              case 12:\n              case "end":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, null, [[3, 9]]);\n      }));\n\n      function createRaiden(_x36) {\n        return _createRaiden.apply(this, arguments);\n      }\n\n      return createRaiden;\n    }()\n  }]);\n\n  return RaidenService;\n}();\n\n\nvar ChannelSettleFailed = /*#__PURE__*/function (_Error) {\n  raiden_service_inherits(ChannelSettleFailed, _Error);\n\n  var _super = raiden_service_createSuper(ChannelSettleFailed);\n\n  function ChannelSettleFailed() {\n    raiden_service_classCallCheck(this, ChannelSettleFailed);\n\n    return _super.apply(this, arguments);\n  }\n\n  return ChannelSettleFailed;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar ChannelCloseFailed = /*#__PURE__*/function (_Error2) {\n  raiden_service_inherits(ChannelCloseFailed, _Error2);\n\n  var _super2 = raiden_service_createSuper(ChannelCloseFailed);\n\n  function ChannelCloseFailed() {\n    raiden_service_classCallCheck(this, ChannelCloseFailed);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return ChannelCloseFailed;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar ChannelOpenFailed = /*#__PURE__*/function (_Error3) {\n  raiden_service_inherits(ChannelOpenFailed, _Error3);\n\n  var _super3 = raiden_service_createSuper(ChannelOpenFailed);\n\n  function ChannelOpenFailed() {\n    raiden_service_classCallCheck(this, ChannelOpenFailed);\n\n    return _super3.apply(this, arguments);\n  }\n\n  return ChannelOpenFailed;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar ChannelDepositFailed = /*#__PURE__*/function (_Error4) {\n  raiden_service_inherits(ChannelDepositFailed, _Error4);\n\n  var _super4 = raiden_service_createSuper(ChannelDepositFailed);\n\n  function ChannelDepositFailed() {\n    raiden_service_classCallCheck(this, ChannelDepositFailed);\n\n    return _super4.apply(this, arguments);\n  }\n\n  return ChannelDepositFailed;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar EnsResolveFailed = /*#__PURE__*/function (_Error5) {\n  raiden_service_inherits(EnsResolveFailed, _Error5);\n\n  var _super5 = raiden_service_createSuper(EnsResolveFailed);\n\n  function EnsResolveFailed() {\n    raiden_service_classCallCheck(this, EnsResolveFailed);\n\n    return _super5.apply(this, arguments);\n  }\n\n  return EnsResolveFailed;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar TransferFailed = /*#__PURE__*/function (_Error6) {\n  raiden_service_inherits(TransferFailed, _Error6);\n\n  var _super6 = raiden_service_createSuper(TransferFailed);\n\n  function TransferFailed() {\n    raiden_service_classCallCheck(this, TransferFailed);\n\n    return _super6.apply(this, arguments);\n  }\n\n  return TransferFailed;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar RaidenInitializationFailed = /*#__PURE__*/function (_Error7) {\n  raiden_service_inherits(RaidenInitializationFailed, _Error7);\n\n  var _super7 = raiden_service_createSuper(RaidenInitializationFailed);\n\n  function RaidenInitializationFailed() {\n    raiden_service_classCallCheck(this, RaidenInitializationFailed);\n\n    return _super7.apply(this, arguments);\n  }\n\n  return RaidenInitializationFailed;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n// CONCATENATED MODULE: ./src/plugins/raiden.ts\n\n\nfunction RaidenPlugin(Vue, _options) {\n  Vue.prototype.$raiden = new raiden_service_RaidenService(src_store);\n}\n// EXTERNAL MODULE: ./node_modules/ethereum-blockies-base64/dist/main.js\nvar main = __webpack_require__("103a");\nvar main_default = /*#__PURE__*/__webpack_require__.n(main);\n\n// CONCATENATED MODULE: ./src/services/identicon-cache.ts\nfunction identicon_cache_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction identicon_cache_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction identicon_cache_createClass(Constructor, protoProps, staticProps) { if (protoProps) identicon_cache_defineProperties(Constructor.prototype, protoProps); if (staticProps) identicon_cache_defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar identicon_cache_IdenticonCache = /*#__PURE__*/function () {\n  function IdenticonCache() {\n    identicon_cache_classCallCheck(this, IdenticonCache);\n\n    this.cache = {};\n  }\n\n  identicon_cache_createClass(IdenticonCache, [{\n    key: "getIdenticon",\n    value: function getIdenticon(address) {\n      var cached = this.cache[address];\n\n      if (!cached) {\n        var generated = main_default()(address);\n        this.cache[address] = generated;\n        return generated;\n      } else {\n        return cached;\n      }\n    }\n  }]);\n\n  return IdenticonCache;\n}();\n// CONCATENATED MODULE: ./src/plugins/identicon-plugin.ts\n\nfunction IdenticonPlugin(Vue, _options) {\n  Vue.prototype.$identicon = new identicon_cache_IdenticonCache();\n}\n// EXTERNAL MODULE: ./node_modules/vue-i18n/dist/vue-i18n.esm.js\nvar vue_i18n_esm = __webpack_require__("a925");\n\n// CONCATENATED MODULE: ./src/i18n.ts\n/* istanbul ignore file */\n\n\nvue_runtime_esm["a" /* default */].use(vue_i18n_esm["a" /* default */]);\n\nfunction loadLocaleMessages() {\n  var locales = __webpack_require__("49f8");\n\n  var messages = {};\n  locales.keys().forEach(function (key) {\n    var matched = key.match(/([A-Za-z0-9-_]+)\\./i);\n\n    if (matched && matched.length > 1) {\n      var locale = matched[1];\n      messages[locale] = locales(key);\n    }\n  });\n  return messages;\n}\n\n/* harmony default export */ var i18n = (new vue_i18n_esm["a" /* default */]({\n  locale: "en" || false,\n  fallbackLocale: "en" || false,\n  messages: loadLocaleMessages()\n}));\n// EXTERNAL MODULE: ./node_modules/@mdi/font/css/materialdesignicons.css\nvar materialdesignicons = __webpack_require__("5363");\n\n// EXTERNAL MODULE: ./node_modules/vuetify/lib/framework.js + 24 modules\nvar framework = __webpack_require__("f309");\n\n// CONCATENATED MODULE: ./src/plugins/vuetify.ts\n/* istanbul ignore file */\n\n\n\nvue_runtime_esm["a" /* default */].use(framework["a" /* default */]);\n/* harmony default export */ var vuetify = (new framework["a" /* default */]({\n  icons: {\n    iconfont: \'mdi\'\n  },\n  theme: {\n    dark: true,\n    themes: {\n      dark: {\n        primary: \'#28A5C8\',\n        secondary: \'#0A6E87\'\n      }\n    }\n  }\n}));\n// EXTERNAL MODULE: ./node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.esm.js\nvar vue_virtual_scroller_esm = __webpack_require__("e508");\n\n// EXTERNAL MODULE: ./node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.css\nvar vue_virtual_scroller = __webpack_require__("a899");\n\n// EXTERNAL MODULE: ./node_modules/register-service-worker/index.js\nvar register_service_worker = __webpack_require__("9483");\n\n// CONCATENATED MODULE: ./src/registerServiceWorker.ts\n/* eslint-disable no-console */\n\n/* istanbul ignore file */\n\n\nif ( true && !Object({"NODE_ENV":"production","VUE_APP_PFS":"https://pfs.raidentransport.test001.env.raiden.network","VUE_APP_TRANSPORT":"https://raidentransport.test001.env.raiden.network","VUE_APP_HUB":"hub.raiden.eth","VUE_APP_I18N_LOCALE":"en","VUE_APP_I18N_FALLBACK_LOCALE":"en","BASE_URL":"/staging/"}).VUE_APP_RAIDEN_PACKAGE) {\n  Object(register_service_worker["a" /* register */])("".concat("/staging/", "service-worker.js"), {\n    ready: function ready() {\n      console.log(\'App is being served from cache by a service worker.\\n\' + \'For more details, visit https://goo.gl/AFskqB\');\n    },\n    registered: function registered(registration) {\n      // Check periodically for updates every minute\n      setInterval(function () {\n        registration.update();\n      }, 1000 * 60);\n      console.log(\'Service worker has been registered.\');\n    },\n    cached: function cached() {\n      console.log(\'Content has been cached for offline use.\');\n    },\n    updatefound: function updatefound() {\n      console.log(\'New content is downloading.\');\n    },\n    updated: function updated(registration) {\n      document.dispatchEvent(new CustomEvent(\'swUpdated\', {\n        detail: registration\n      }));\n      console.log(\'New content is available; please refresh.\');\n    },\n    offline: function offline() {\n      console.log(\'No internet connection found. App is running in offline mode.\');\n    },\n    error: function error(_error) {\n      console.error(\'Error during service worker registration:\', _error);\n    }\n  });\n}\n// CONCATENATED MODULE: ./src/main.ts\n/* istanbul ignore file */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvue_runtime_esm["a" /* default */].config.productionTip = false;\nObject(logstore["b" /* setupLogStore */])();\nvue_runtime_esm["a" /* default */].use(RaidenPlugin);\nvue_runtime_esm["a" /* default */].use(IdenticonPlugin);\nvue_runtime_esm["a" /* default */].use(vue_virtual_scroller_esm["a" /* default */]);\nnew vue_runtime_esm["a" /* default */]({\n  vuetify: vuetify,\n  router: src_router,\n  store: src_store,\n  i18n: i18n,\n  render: function render(h) {\n    return h(src_App);\n  }\n}).$mount(\'#app\');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT81NDRmIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0FwcEhlYWRlci52dWU/ZDNkNCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BcHBIZWFkZXIudnVlPzVhODkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQXBwSGVhZGVyLnZ1ZT85OWQwIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0FwcEhlYWRlci52dWU/ZGViNSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9PZmZsaW5lU25hY2tiYXIudnVlPzczZGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvT2ZmbGluZVNuYWNrYmFyLnZ1ZT9lYzc4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL09mZmxpbmVTbmFja2Jhci52dWU/Mjk5MiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9PZmZsaW5lU25hY2tiYXIudnVlPzZlNmIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvVXBkYXRlU25hY2tiYXIudnVlPzRmMDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvVXBkYXRlU25hY2tiYXIudnVlPzk2YTMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvVXBkYXRlU25hY2tiYXIudnVlP2I0MzUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvVXBkYXRlU25hY2tiYXIudnVlP2IyYTgiLCJ3ZWJwYWNrOi8vLy4vc3JjL0FwcC52dWU/NGNlYiIsIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnZ1ZT83YjIyIiwid2VicGFjazovLy8uL3NyYy9BcHAudnVlPzg2ZDAiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdWdpbnMvY2xhc3MtY29tcG9uZW50Lmhvb2tzLnRzPzAyYzAiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL0hvbWUudnVlPzk3YjUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29ubmVjdERpYWxvZy52dWU/MzUwNSIsIndlYnBhY2s6Ly8vLi9zcmMvc2VydmljZXMvd2ViMy1wcm92aWRlci50cz81MDY3Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL05vQWNjZXNzTWVzc2FnZS52dWU/OGUyNyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ob0FjY2Vzc01lc3NhZ2UudnVlPzAyZTYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTm9BY2Nlc3NNZXNzYWdlLnZ1ZT9kMjlhIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL05vQWNjZXNzTWVzc2FnZS52dWU/NDhhNSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Db25uZWN0RGlhbG9nLnZ1ZT8yODVhIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0Nvbm5lY3REaWFsb2cudnVlPzI5NTkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvQ29ubmVjdERpYWxvZy52dWU/NWRiNyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ob1Rva2Vucy52dWU/ZmEyNSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ob1Rva2Vucy52dWU/OTdkOCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ob1Rva2Vucy52dWU/OTliZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ob1Rva2Vucy52dWU/ZDc1NCIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvSG9tZS52dWU/ZjYwMyIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvSG9tZS52dWU/MmViMCIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvSG9tZS52dWU/YzYxYiIsIndlYnBhY2s6Ly8vLi9zcmMvcm91dGVyL2luZGV4LnRzP2Q3ZGEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0b3JlL2luZGV4LnRzP2E2MzIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsYXNzLWNvbXBvbmVudC1ob29rcy50cz82YmU0Iiwid2VicGFjazovLy8uL3NyYy9zZXJ2aWNlcy9jb25maWctcHJvdmlkZXIudHM/YTFkNyIsIndlYnBhY2s6Ly8vLi9zcmMvc2VydmljZXMvcmFpZGVuLXNlcnZpY2UudHM/ODYzZSIsIndlYnBhY2s6Ly8vLi9zcmMvcGx1Z2lucy9yYWlkZW4udHM/MGNlNiIsIndlYnBhY2s6Ly8vLi9zcmMvc2VydmljZXMvaWRlbnRpY29uLWNhY2hlLnRzPzRkZjQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdWdpbnMvaWRlbnRpY29uLXBsdWdpbi50cz81YmU2Iiwid2VicGFjazovLy8uL3NyYy9pMThuLnRzP2NjN2EiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdWdpbnMvdnVldGlmeS50cz9mNzIxIiwid2VicGFjazovLy8uL3NyYy9yZWdpc3RlclNlcnZpY2VXb3JrZXIudHM/NmJlMSIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi50cz9iYzgyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxJQUFJLG1EQUFNLGdCQUFnQixhQUFhLDBCQUEwQix3QkFBd0IsbUJBQW1CLE9BQU8sV0FBVyxZQUFZLE9BQU8sNEJBQTRCLG9CQUFvQixPQUFPLGdCQUFnQixZQUFZLE9BQU8sNEJBQTRCLHFEQUFxRCx3REFBd0QsWUFBWSw4Q0FBOEMscUJBQXFCLFVBQVUsT0FBTyxnRUFBZ0U7QUFDcGhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEQSxJQUFJLHlEQUFNLGdCQUFnQixhQUFhLDBCQUEwQix3QkFBd0IsaUJBQWlCLHlCQUF5QixjQUFjLHFDQUFxQyxxREFBcUQsY0FBYyxPQUFPLGFBQWEsWUFBWSx1Q0FBdUMsWUFBWSw2Q0FBNkMsOEJBQThCLE9BQU8sbURBQW1ELEtBQUsseUJBQXlCLDZCQUE2QixjQUFjLE9BQU8sTUFBTSxtQkFBTyxDQUFDLE1BQTBCLHNCQUFzQix3REFBd0QsOENBQThDLGlHQUFpRyxnREFBZ0QsNkVBQTZFLDBDQUEwQyx5QkFBeUIsVUFBVSx5QkFBeUIscUNBQXFDLDRCQUE0Qix3Q0FBd0Msa0NBQWtD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QSxhQUFPLENBQUMsR0FBUixDQUFZLDJDQUFaO0FBQ0QsS0F6QmtEO0FBMEJuRCxXQTFCbUQscUJBMEI1QztBQUNMLGFBQU8sQ0FBQyxHQUFSLENBQ0UsK0RBREY7QUFHRCxLQTlCa0Q7QUErQm5ELFNBL0JtRCxpQkErQjdDLE1BL0I2QyxFQStCeEM7QUFDVCxhQUFPLENBQUMsS0FBUixDQUFjLDJDQUFkLEVBQTJELE1BQTNEO0FBQ0Q7QUFqQ2tELEdBQTdDLENBQVI7QUFtQ0QsQzs7QUM1Q0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxrQ0FBRyxDQUFDLE1BQUosQ0FBVyxhQUFYLEdBQTJCLEtBQTNCO0FBRUEseUNBQWE7QUFFYixrQ0FBRyxDQUFDLEdBQUosQ0FBUSxZQUFSO0FBQ0Esa0NBQUcsQ0FBQyxHQUFKLENBQVEsZUFBUjtBQUNBLGtDQUFHLENBQUMsR0FBSixDQUFRLDJDQUFSO0FBRUEsSUFBSSxrQ0FBSixDQUFRO0FBQ04sU0FBTyxFQUFQLE9BRE07QUFFTixRQUFNLEVBQU4sVUFGTTtBQUdOLE9BQUssRUFBTCxTQUhNO0FBSU4sTUFBSSxFQUFKLElBSk07QUFLTixRQUFNLEVBQUUsaUJBQUM7QUFBQSxXQUFJLENBQUMsQ0FBQyxPQUFELENBQUw7QUFBQTtBQUxILENBQVIsRUFNRyxNQU5ILENBTVUsTUFOViIsImZpbGUiOiJjZDQ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ3YtYXBwJyx7YXR0cnM6e1wiZGFya1wiOlwiXCJ9fSxbX2MoJ2Rpdicse2F0dHJzOntcImlkXCI6XCJhcHBsaWNhdGlvbi13cmFwcGVyXCJ9fSxbX2MoJ3JvdXRlci12aWV3Jyx7YXR0cnM6e1wibmFtZVwiOlwibW9kYWxcIn19KSxfYygnZGl2Jyx7YXR0cnM6e1wiaWRcIjpcImFwcGxpY2F0aW9uLWNvbnRlbnRcIn19LFtfYygnYXBwLWhlYWRlcicpLF9jKCd2LWNvbnRlbnQnLFtfYygndi1jb250YWluZXInLHtzdGF0aWNDbGFzczpcImFwcGxpY2F0aW9uX19jb250YWluZXIgZmlsbC1oZWlnaHRcIixhdHRyczp7XCJmbHVpZFwiOlwiXCJ9fSxbX2MoJ3JvdXRlci12aWV3JyldLDEpXSwxKV0sMSldLDEpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInBvbGljeVwifSxbX2MoJ2EnLHthdHRyczp7XCJocmVmXCI6XCJodHRwczovL3JhaWRlbi5uZXR3b3JrL3ByaXZhY3kuaHRtbFwiLFwidGFyZ2V0XCI6XCJfYmxhbmtcIn19LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS4kdCgnYXBwbGljYXRpb24ucHJpdmFjeS1wb2xpY3knKSkrXCIgXCIpXSldKSxfYygnb2ZmbGluZS1zbmFja2JhcicpLF9jKCd1cGRhdGUtc25hY2tiYXInKV0sMSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImFwcC1oZWFkZXJcIn0sW19jKCd2LXJvdycse3N0YXRpY0NsYXNzOlwiYXBwLWhlYWRlcl9fdG9wXCIsYXR0cnM6e1wianVzdGlmeVwiOlwiY2VudGVyXCIsXCJhbGlnblwiOlwiY2VudGVyXCIsXCJuby1ndXR0ZXJzXCI6XCJcIn19LFtfYygndi1jb2wnLHthdHRyczp7XCJjb2xzXCI6XCIxMlwifX0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImFwcC1oZWFkZXJfX3RvcF9fY29udGVudFwifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiYXBwLWhlYWRlcl9fdG9wX19jb250ZW50X19iYWNrXCJ9LFsoX3ZtLmNhbkdvQmFjayk/X2MoJ3YtYnRuJyx7YXR0cnM6e1wiaGVpZ2h0XCI6XCI0MHB4XCIsXCJ3aWR0aFwiOlwiNDBweFwiLFwidGV4dFwiOlwiXCIsXCJpY29uXCI6XCJcIn0sb246e1wiY2xpY2tcIjpmdW5jdGlvbigkZXZlbnQpe3JldHVybiBfdm0ub25CYWNrQ2xpY2tlZCgpfX19LFtfYygndi1pbWcnLHthdHRyczp7XCJzcmNcIjpyZXF1aXJlKCcuLi9hc3NldHMvYmFja19hcnJvdy5zdmcnKSxcIm1heC13aWR0aFwiOlwiMzRweFwifX0pXSwxKTpfdm0uX2UoKV0sMSksX2MoJ3Ytc3BhY2VyJyksX2MoJ3YtY29sJyxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiYXBwLWhlYWRlcl9fdG9wX19jb250ZW50X190aXRsZVwifSxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0uJHJvdXRlLm1ldGEudGl0bGUpK1wiIFwiKV0pLCghX3ZtLmxvYWRpbmcgJiYgX3ZtLmRlZmF1bHRBY2NvdW50KT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJhcHAtaGVhZGVyX190b3BfX2NvbnRlbnRfX25ldHdvcmtcIn0sW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLm5ldHdvcmspK1wiIFwiKV0pOl92bS5fZSgpXSksX2MoJ3Ytc3BhY2VyJyksX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcImFwcC1oZWFkZXJfX2FjY291bnQtd3JhcHBlclwifSxbX2MoJ2hlYWRlci1pZGVudGljb24nLHtuYXRpdmVPbjp7XCJjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7cmV0dXJuIF92bS5uYXZpZ2F0ZVRvR2VuZXJhbEhvbWUoKX19fSldLDEpXSwxKV0pXSwxKSxfYygndi1yb3cnLHtzdGF0aWNDbGFzczpcImFwcC1oZWFkZXJfX2JvdHRvbVwiLGF0dHJzOntcImFsaWduXCI6XCJjZW50ZXJcIixcIm5vLWd1dHRlcnNcIjpcIlwifX0sWyghX3ZtLmxvYWRpbmcgJiYgX3ZtLmRlZmF1bHRBY2NvdW50KT9fYygndi1jb2wnLHthdHRyczp7XCJjb2xzXCI6XCIxMlwifX0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImFwcC1oZWFkZXJfX2JvdHRvbV9fYWRkcmVzcyB0ZXh0LWxlZnRcIn0sW19jKCdhZGRyZXNzLWRpc3BsYXknLHthdHRyczp7XCJhZGRyZXNzXCI6X3ZtLmRlZmF1bHRBY2NvdW50fX0pXSwxKV0pOl92bS5fZSgpXSwxKV0sMSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5pbXBvcnQgeyBDb21wb25lbnQsIE1peGlucyB9IGZyb20gJ3Z1ZS1wcm9wZXJ0eS1kZWNvcmF0b3InO1xuaW1wb3J0IHsgbWFwR2V0dGVycywgbWFwU3RhdGUgfSBmcm9tICd2dWV4JztcbmltcG9ydCB7IFJvdXRlTmFtZXMgfSBmcm9tICdAL3JvdXRlci9yb3V0ZS1uYW1lcyc7XG5pbXBvcnQgTmF2aWdhdGlvbk1peGluIGZyb20gJ0AvbWl4aW5zL25hdmlnYXRpb24tbWl4aW4nO1xuaW1wb3J0IEhlYWRlcklkZW50aWNvbiBmcm9tICdAL2NvbXBvbmVudHMvSGVhZGVySWRlbnRpY29uLnZ1ZSc7XG5pbXBvcnQgQWRkcmVzc0Rpc3BsYXkgZnJvbSAnQC9jb21wb25lbnRzL0FkZHJlc3NEaXNwbGF5LnZ1ZSc7XG5cbkBDb21wb25lbnQoe1xuICBjb21wb25lbnRzOiB7XG4gICAgSGVhZGVySWRlbnRpY29uLFxuICAgIEFkZHJlc3NEaXNwbGF5XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgLi4ubWFwU3RhdGUoWydsb2FkaW5nJywgJ2RlZmF1bHRBY2NvdW50J10pLFxuICAgIC4uLm1hcEdldHRlcnMoWyduZXR3b3JrJ10pXG4gIH1cbn0pXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHBIZWFkZXIgZXh0ZW5kcyBNaXhpbnMoTmF2aWdhdGlvbk1peGluKSB7XG4gIGRlZmF1bHRBY2NvdW50ITogc3RyaW5nO1xuICBuZXR3b3JrITogc3RyaW5nO1xuXG4gIGdldCBjYW5Hb0JhY2soKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgcm91dGVzV2l0aG91dEJhY2tCdG46IHN0cmluZ1tdID0gW1xuICAgICAgUm91dGVOYW1lcy5IT01FLFxuICAgICAgUm91dGVOYW1lcy5UUkFOU0ZFUlxuICAgIF07XG4gICAgcmV0dXJuICFyb3V0ZXNXaXRob3V0QmFja0J0bi5pbmNsdWRlcyh0aGlzLiRyb3V0ZS5uYW1lISk7XG4gIH1cbn1cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xNC0wIS4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMTQtMyEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0yMS0wIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQXBwSGVhZGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTE0LTAhLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xNC0zIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BcHBIZWFkZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9BcHBIZWFkZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTZjY2YyMDg0JnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0FwcEhlYWRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0FwcEhlYWRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vQXBwSGVhZGVyLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTZjY2YyMDg0Jmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNmNjZjIwODRcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHNcblxuLyogdnVldGlmeS1sb2FkZXIgKi9cbmltcG9ydCBpbnN0YWxsQ29tcG9uZW50cyBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvcnVudGltZS9pbnN0YWxsQ29tcG9uZW50cy5qc1wiXG5pbXBvcnQgeyBWQnRuIH0gZnJvbSAndnVldGlmeS9saWIvY29tcG9uZW50cy9WQnRuJztcbmltcG9ydCB7IFZDb2wgfSBmcm9tICd2dWV0aWZ5L2xpYi9jb21wb25lbnRzL1ZHcmlkJztcbmltcG9ydCB7IFZJbWcgfSBmcm9tICd2dWV0aWZ5L2xpYi9jb21wb25lbnRzL1ZJbWcnO1xuaW1wb3J0IHsgVlJvdyB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkdyaWQnO1xuaW1wb3J0IHsgVlNwYWNlciB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkdyaWQnO1xuaW5zdGFsbENvbXBvbmVudHMoY29tcG9uZW50LCB7VkJ0bixWQ29sLFZJbWcsVlJvdyxWU3BhY2VyfSlcbiIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIChfdm0ub2ZmbGluZSk/X2MoJ3NwYW4nLFtfYygnYmx1cnJlZC1vdmVybGF5Jyx7YXR0cnM6e1wic2hvd1wiOl92bS5vZmZsaW5lLFwiZnVsbHNjcmVlblwiOnRydWV9fSksX2MoJ3Ytc25hY2tiYXInLHthdHRyczp7XCJ0aW1lb3V0XCI6MCxcImNvbG9yXCI6XCJlcnJvclwifSxtb2RlbDp7dmFsdWU6KF92bS5vZmZsaW5lKSxjYWxsYmFjazpmdW5jdGlvbiAoJCR2KSB7X3ZtLm9mZmxpbmU9JCR2fSxleHByZXNzaW9uOlwib2ZmbGluZVwifX0sW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLiR0KCdnZW5lcmFsLm9mZmxpbmUnKSkrXCIgXCIpLF9jKCd2LWljb24nLFtfdm0uX3YoXCJtZGktYWxlcnRcIildKV0sMSldLDEpOl92bS5fZSgpfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJcblxuXG5cblxuXG5cblxuXG5cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBWdWUgfSBmcm9tICd2dWUtcHJvcGVydHktZGVjb3JhdG9yJztcbmltcG9ydCBCbHVycmVkT3ZlcmxheSBmcm9tICdAL2NvbXBvbmVudHMvQmx1cnJlZE92ZXJsYXkudnVlJztcblxuQENvbXBvbmVudCh7IGNvbXBvbmVudHM6IHsgQmx1cnJlZE92ZXJsYXkgfSB9KVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2ZmbGluZVNuYWNrYmFyIGV4dGVuZHMgVnVlIHtcbiAgb2ZmbGluZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGhhbmRsZU9ubGluZSgpIHtcbiAgICB0aGlzLm9mZmxpbmUgPSBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZU9mZmxpbmUoKSB7XG4gICAgdGhpcy5vZmZsaW5lID0gdHJ1ZTtcbiAgfVxuXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5vZmZsaW5lID0gIW5hdmlnYXRvci5vbkxpbmU7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIHRoaXMuaGFuZGxlT2ZmbGluZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuaGFuZGxlT25saW5lKTtcbiAgfVxuXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCB0aGlzLmhhbmRsZU9mZmxpbmUpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvbmxpbmUnLCB0aGlzLmhhbmRsZU9ubGluZSk7XG4gIH1cbn1cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xNC0wIS4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMTQtMyEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0yMS0wIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vT2ZmbGluZVNuYWNrYmFyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTE0LTAhLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xNC0zIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9PZmZsaW5lU25hY2tiYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9PZmZsaW5lU25hY2tiYXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTExMjAwMjQyJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL09mZmxpbmVTbmFja2Jhci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL09mZmxpbmVTbmFja2Jhci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0c1xuXG4vKiB2dWV0aWZ5LWxvYWRlciAqL1xuaW1wb3J0IGluc3RhbGxDb21wb25lbnRzIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9ydW50aW1lL2luc3RhbGxDb21wb25lbnRzLmpzXCJcbmltcG9ydCB7IFZJY29uIH0gZnJvbSAndnVldGlmeS9saWIvY29tcG9uZW50cy9WSWNvbic7XG5pbXBvcnQgeyBWU25hY2tiYXIgfSBmcm9tICd2dWV0aWZ5L2xpYi9jb21wb25lbnRzL1ZTbmFja2Jhcic7XG5pbnN0YWxsQ29tcG9uZW50cyhjb21wb25lbnQsIHtWSWNvbixWU25hY2tiYXJ9KVxuIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gKF92bS51cGRhdGVBdmFpbGFibGUpP19jKCdzcGFuJyxbX2MoJ2JsdXJyZWQtb3ZlcmxheScse2F0dHJzOntcInNob3dcIjpfdm0udXBkYXRlQXZhaWxhYmxlLFwiZnVsbHNjcmVlblwiOnRydWV9fSksX2MoJ3Ytc25hY2tiYXInLHthdHRyczp7XCJ0aW1lb3V0XCI6MCxcImNvbG9yXCI6XCJwcmltYXJ5XCJ9LG1vZGVsOnt2YWx1ZTooX3ZtLnVwZGF0ZUF2YWlsYWJsZSksY2FsbGJhY2s6ZnVuY3Rpb24gKCQkdikge192bS51cGRhdGVBdmFpbGFibGU9JCR2fSxleHByZXNzaW9uOlwidXBkYXRlQXZhaWxhYmxlXCJ9fSxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0uJHQoJ3VwZGF0ZS5hdmFpbGFibGUnKSkrXCIgXCIpLF9jKCd2LWJ0bicse2F0dHJzOntcImRhcmtcIjpcIlwiLFwidGV4dFwiOlwiXCIsXCJsb2FkaW5nXCI6X3ZtLmlzVXBkYXRpbmd9LG9uOntcImNsaWNrXCI6X3ZtLnVwZGF0ZX19LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS4kdCgndXBkYXRlLnVwZGF0ZScpKStcIiBcIildKV0sMSldLDEpOl92bS5fZSgpfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG5pbXBvcnQgeyBDb21wb25lbnQsIFZ1ZSB9IGZyb20gJ3Z1ZS1wcm9wZXJ0eS1kZWNvcmF0b3InO1xuaW1wb3J0IEJsdXJyZWRPdmVybGF5IGZyb20gJ0AvY29tcG9uZW50cy9CbHVycmVkT3ZlcmxheS52dWUnO1xuXG5AQ29tcG9uZW50KHsgY29tcG9uZW50czogeyBCbHVycmVkT3ZlcmxheSB9IH0pXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVcGRhdGVTbmFja2JhciBleHRlbmRzIFZ1ZSB7XG4gIGlzVXBkYXRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgdXBkYXRlQXZhaWxhYmxlOiBib29sZWFuID0gZmFsc2U7XG4gIHN3UmVnaXN0cmF0aW9uOiBTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgY3JlYXRlZCgpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzd1VwZGF0ZWQnLCB0aGlzLmhhbmRsZVNXVXBkYXRlLCB7IG9uY2U6IHRydWUgfSk7XG5cbiAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdjb250cm9sbGVyY2hhbmdlJywgKCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgIH0sIDE1MDApO1xuICAgIH0pO1xuICB9XG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3dVcGRhdGVkJywgdGhpcy5oYW5kbGVTV1VwZGF0ZSk7XG4gIH1cblxuICBoYW5kbGVTV1VwZGF0ZShldmVudDogYW55KSB7XG4gICAgdGhpcy5zd1JlZ2lzdHJhdGlvbiA9IGV2ZW50LmRldGFpbDtcbiAgICB0aGlzLnVwZGF0ZUF2YWlsYWJsZSA9IHRydWU7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5pc1VwZGF0aW5nID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuc3dSZWdpc3RyYXRpb24gfHwgIXRoaXMuc3dSZWdpc3RyYXRpb24ud2FpdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN3UmVnaXN0cmF0aW9uLndhaXRpbmcucG9zdE1lc3NhZ2UoJ3NraXBXYWl0aW5nJyk7XG4gIH1cbn1cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xNC0wIS4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMTQtMyEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0yMS0wIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vVXBkYXRlU25hY2tiYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTQtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTE0LTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1VwZGF0ZVNuYWNrYmFyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vVXBkYXRlU25hY2tiYXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTFkNGVkMzA2JlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1VwZGF0ZVNuYWNrYmFyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vVXBkYXRlU25hY2tiYXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHNcblxuLyogdnVldGlmeS1sb2FkZXIgKi9cbmltcG9ydCBpbnN0YWxsQ29tcG9uZW50cyBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvcnVudGltZS9pbnN0YWxsQ29tcG9uZW50cy5qc1wiXG5pbXBvcnQgeyBWQnRuIH0gZnJvbSAndnVldGlmeS9saWIvY29tcG9uZW50cy9WQnRuJztcbmltcG9ydCB7IFZTbmFja2JhciB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVlNuYWNrYmFyJztcbmluc3RhbGxDb21wb25lbnRzKGNvbXBvbmVudCwge1ZCdG4sVlNuYWNrYmFyfSlcbiIsIlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmltcG9ydCB7IENvbXBvbmVudCwgV2F0Y2gsIE1peGlucyB9IGZyb20gJ3Z1ZS1wcm9wZXJ0eS1kZWNvcmF0b3InO1xuaW1wb3J0IHsgbWFwR2V0dGVycyB9IGZyb20gJ3Z1ZXgnO1xuaW1wb3J0IE5hdmlnYXRpb25NaXhpbiBmcm9tICcuL21peGlucy9uYXZpZ2F0aW9uLW1peGluJztcbmltcG9ydCBBcHBIZWFkZXIgZnJvbSAnQC9jb21wb25lbnRzL0FwcEhlYWRlci52dWUnO1xuaW1wb3J0IE9mZmxpbmVTbmFja2JhciBmcm9tICdAL2NvbXBvbmVudHMvT2ZmbGluZVNuYWNrYmFyLnZ1ZSc7XG5pbXBvcnQgVXBkYXRlU25hY2tiYXIgZnJvbSAnQC9jb21wb25lbnRzL1VwZGF0ZVNuYWNrYmFyLnZ1ZSc7XG5cbkBDb21wb25lbnQoe1xuICBjb21wdXRlZDoge1xuICAgIC4uLm1hcEdldHRlcnMoWydpc0Nvbm5lY3RlZCddKVxuICB9LFxuICBjb21wb25lbnRzOiB7XG4gICAgQXBwSGVhZGVyLFxuICAgIE9mZmxpbmVTbmFja2JhcixcbiAgICBVcGRhdGVTbmFja2JhclxuICB9XG59KVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwIGV4dGVuZHMgTWl4aW5zKE5hdmlnYXRpb25NaXhpbikge1xuICBpc0Nvbm5lY3RlZCE6IGJvb2xlYW47XG5cbiAgQFdhdGNoKCdpc0Nvbm5lY3RlZCcsIHsgaW1tZWRpYXRlOiB0cnVlIH0pXG4gIG9uSXNDb25uZWN0ZWRDaGFuZ2UoKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLm5hdmlnYXRlVG9Ib21lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveWVkKCkge1xuICAgIHRoaXMuJHJhaWRlbi5kaXNjb25uZWN0KCk7XG4gIH1cbn1cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xNC0wIS4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMTQtMyEuLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0yMS0wIS4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTE0LTAhLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xNC0zIS4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9BcHAudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9BcHAudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTUyYWEzNTVlJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTUyYWEzNTVlJmxhbmc9c2NzcyZzY29wZWQ9dHJ1ZSZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNTJhYTM1NWVcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHNcblxuLyogdnVldGlmeS1sb2FkZXIgKi9cbmltcG9ydCBpbnN0YWxsQ29tcG9uZW50cyBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvcnVudGltZS9pbnN0YWxsQ29tcG9uZW50cy5qc1wiXG5pbXBvcnQgeyBWQXBwIH0gZnJvbSAndnVldGlmeS9saWIvY29tcG9uZW50cy9WQXBwJztcbmltcG9ydCB7IFZDb250YWluZXIgfSBmcm9tICd2dWV0aWZ5L2xpYi9jb21wb25lbnRzL1ZHcmlkJztcbmltcG9ydCB7IFZDb250ZW50IH0gZnJvbSAndnVldGlmeS9saWIvY29tcG9uZW50cy9WQ29udGVudCc7XG5pbnN0YWxsQ29tcG9uZW50cyhjb21wb25lbnQsIHtWQXBwLFZDb250YWluZXIsVkNvbnRlbnR9KVxuIiwiLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cbmltcG9ydCBDb21wb25lbnQgZnJvbSAndnVlLWNsYXNzLWNvbXBvbmVudCc7XG5cbi8vIFJlZ2lzdGVyIHRoZSByb3V0ZXIgaG9va3Mgd2l0aCB0aGVpciBuYW1lc1xuQ29tcG9uZW50LnJlZ2lzdGVySG9va3MoW1xuICAnYmVmb3JlUm91dGVFbnRlcicsXG4gICdiZWZvcmVSb3V0ZUxlYXZlJyxcbiAgJ2JlZm9yZVJvdXRlVXBkYXRlJyAvLyBmb3IgdnVlLXJvdXRlciAyLjIrXG5dKTtcbiIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCd2LWNvbnRhaW5lcicse3N0YXRpY0NsYXNzOlwiaG9tZVwiLGF0dHJzOntcImZsdWlkXCI6XCJcIn19LFsoIV92bS5pbmFjY2Vzc2libGUgJiYgX3ZtLmlzQ29ubmVjdGVkKT9fYygnbm8tdG9rZW5zJyk6X2MoJ2RpdicsW19jKCd2LXJvdycse2F0dHJzOntcIm5vLWd1dHRlcnNcIjpcIlwifX0sW19jKCd2LWNvbCcse2F0dHJzOntcImNvbHNcIjpcIjEyXCJ9fSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiaG9tZV9fbG9nby1jb250YWluZXJcIn0sW19jKCd2LWltZycse3N0YXRpY0NsYXNzOlwiaG9tZV9fbG9nby1jb250YWluZXJfX2xvZ29cIixhdHRyczp7XCJzcmNcIjpyZXF1aXJlKCcuLi9hc3NldHMvbG9nby5zdmcnKSxcImFzcGVjdC1yYXRpb1wiOlwiMVwiLFwiY29udGFpblwiOlwiXCJ9fSldLDEpXSldLDEpLF9jKCd2LXJvdycse2F0dHJzOntcIm5vLWd1dHRlcnNcIjpcIlwifX0sW19jKCd2LWNvbCcse2F0dHJzOntcImNvbHNcIjpcIjEyXCJ9fSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiaG9tZV9fYXBwLXdlbGNvbWUgdGV4dC1jZW50ZXJcIn0sW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLiR0KCdob21lLndlbGNvbWUnKSkrXCIgXCIpXSldKV0sMSksX2MoJ3Ytcm93Jyx7YXR0cnM6e1wibm8tZ3V0dGVyc1wiOlwiXCJ9fSxbX2MoJ3YtY29sJyx7YXR0cnM6e1wiY29sc1wiOlwiMTJcIn19LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJob21lX19kaXNjbGFpbWVyIHRleHQtY2VudGVyIGZvbnQtd2VpZ2h0LWxpZ2h0XCJ9LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS4kdCgnaG9tZS5kaXNjbGFpbWVyJykpK1wiIFwiKV0pLF9jKCdpMThuJyx7c3RhdGljQ2xhc3M6XCJob21lX19nZXR0aW5nLXN0YXJ0ZWQgdGV4dC1jZW50ZXIgZm9udC13ZWlnaHQtbGlnaHRcIixhdHRyczp7XCJwYXRoXCI6XCJob21lLmdldHRpbmctc3RhcnRlZC5kZXNjcmlwdGlvblwiLFwidGFnXCI6XCJkaXZcIn19LFtfYygnYScse2F0dHJzOntcImhyZWZcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS9yYWlkZW4tbmV0d29yay9saWdodC1jbGllbnQjZ2V0dGluZy1zdGFydGVkXCIsXCJ0YXJnZXRcIjpcIl9ibGFua1wifX0sW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLiR0KCdob21lLmdldHRpbmctc3RhcnRlZC5saW5rLW5hbWUnKSkrXCIgXCIpXSldKV0sMSldLDEpLF9jKCdhY3Rpb24tYnV0dG9uJyx7YXR0cnM6e1wiZW5hYmxlZFwiOlwiXCIsXCJ0ZXh0XCI6X3ZtLiR0KCdob21lLmNvbm5lY3QtYnV0dG9uJyksXCJzdGlja3lcIjpcIlwifSxvbjp7XCJjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7X3ZtLmNvbm5lY3REaWFsb2cgPSB0cnVlfX19KSxfYygnY29ubmVjdC1kaWFsb2cnLHthdHRyczp7XCJjb25uZWN0aW5nXCI6X3ZtLmNvbm5lY3RpbmcsXCJjb25uZWN0aW5nLXN1YmtleVwiOl92bS5jb25uZWN0aW5nU3Via2V5LFwidmlzaWJsZVwiOl92bS5jb25uZWN0RGlhbG9nfSxvbjp7XCJjb25uZWN0XCI6X3ZtLmNvbm5lY3QsXCJjbG9zZVwiOmZ1bmN0aW9uKCRldmVudCl7X3ZtLmNvbm5lY3REaWFsb2cgPSBmYWxzZX19fSldLDEpXSwxKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ3JhaWRlbi1kaWFsb2cnLHtzdGF0aWNDbGFzczpcImNvbm5lY3RcIixhdHRyczp7XCJ2aXNpYmxlXCI6X3ZtLnZpc2libGUsXCJoaWRlLWNsb3NlXCI6X3ZtLmhpZGVDbG9zZX0sb246e1wiY2xvc2VcIjpfdm0uY2xvc2V9fSxbX2MoJ3YtY2FyZC10aXRsZScsW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLiR0KCdob21lLmNvbm5lY3QtZGlhbG9nLmNvbm5lY3QtdGl0bGUnKSkrXCIgXCIpXSksKF92bS5pbmplY3RlZFByb3ZpZGVyKT9fYygnZGl2JyxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY29ubmVjdF9fYnV0dG9uXCJ9LFtfYygnYWN0aW9uLWJ1dHRvbicse2F0dHJzOntcInRleHRcIjpfdm0uJHQoJ2hvbWUuY29ubmVjdC1kaWFsb2cud2ViMy1wcm92aWRlcicpLFwiZW5hYmxlZFwiOiFfdm0uY29ubmVjdGluZyAmJiAhX3ZtLmNvbm5lY3RpbmdTdWJrZXksXCJsb2FkaW5nXCI6X3ZtLmNvbm5lY3Rpbmd9LG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLmNvbm5lY3QoX3ZtLnN0YXRlQmFja3VwKX19fSldLDEpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInRleHQtY2VudGVyIGZvbnQtd2VpZ2h0LWxpZ2h0XCJ9LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS4kdCgnaG9tZS5jb25uZWN0LWRpYWxvZy5kaXZpZGVyJykpK1wiIFwiKV0pLCghX3ZtLmNvbm5lY3RpbmdTdWJrZXkpP19jKCdpMThuJyx7c3RhdGljQ2xhc3M6XCJjb25uZWN0X19yYWlkZW4tYWNjb3VudCB0ZXh0LWNlbnRlciBmb250LXdlaWdodC1saWdodFwiLGF0dHJzOntcInBhdGhcIjpcImhvbWUuY29ubmVjdC1kaWFsb2cucmFpZGVuLWFjY291bnQuZGVzY3JpcHRpb25cIixcInRhZ1wiOlwiZGl2XCJ9fSxbKCFfdm0uY29ubmVjdGluZyk/X2MoJ2EnLHtvbjp7XCJjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7cmV0dXJuIF92bS5jb25uZWN0KF92bS5zdGF0ZUJhY2t1cCwgdHJ1ZSl9fX0sW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLiR0KCdob21lLmNvbm5lY3QtZGlhbG9nLnJhaWRlbi1hY2NvdW50LmxpbmstbmFtZScpKStcIiBcIildKTpfYygnc3BhbicsW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLiR0KCdob21lLmNvbm5lY3QtZGlhbG9nLnJhaWRlbi1hY2NvdW50LmxpbmstbmFtZScpKStcIiBcIildKV0pOl9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbm5lY3RfX3JhaWRlbi1hY2NvdW50LXNwaW5uZXIgdGV4dC1jZW50ZXJcIn0sW19jKCd2LXByb2dyZXNzLWNpcmN1bGFyJyx7YXR0cnM6e1wic2l6ZVwiOjMwLFwid2lkdGhcIjoxLFwiaW5kZXRlcm1pbmF0ZVwiOlwiXCJ9fSldLDEpXSwxKTpfdm0uX2UoKSwoX3ZtLmFjY2Vzc0RlbmllZCk/X2MoJ25vLWFjY2Vzcy1tZXNzYWdlJyx7YXR0cnM6e1wicmVhc29uXCI6X3ZtLmFjY2Vzc0RlbmllZH19KTpfdm0uX2UoKSwoIV92bS5pbmplY3RlZFByb3ZpZGVyKT9fYygndi1jYXJkLXRleHQnLFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ0ZXh0LWNlbnRlclwifSxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0uJHQoJ2hvbWUuY29ubmVjdC1kaWFsb2cubm8tcHJvdmlkZXInKSkrXCIgXCIpXSldKTpfdm0uX2UoKV0sMSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsImV4cG9ydCBjbGFzcyBXZWIzUHJvdmlkZXIge1xuICBzdGF0aWMgYXN5bmMgcHJvdmlkZXIoY29uZmlnPzogeyBJTkZVUkFfRU5EUE9JTlQ6IHN0cmluZyB9KSB7XG4gICAgY29uc3QgZXRoZXJldW0gPSB3aW5kb3cuZXRoZXJldW07XG4gICAgbGV0IHByb3ZpZGVyID0gbnVsbDtcblxuICAgIGlmIChjb25maWcpIHtcbiAgICAgIHByb3ZpZGVyID0gYGh0dHBzOi8vJHtjb25maWcuSU5GVVJBX0VORFBPSU5UfWA7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXRoZXJldW0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhd2FpdCBldGhlcmV1bS5lbmFibGUoKTtcbiAgICAgIHByb3ZpZGVyID0gZXRoZXJldW07XG4gICAgfSBlbHNlIGlmICh3aW5kb3cud2ViMykge1xuICAgICAgcHJvdmlkZXIgPSB3aW5kb3cud2ViMy5jdXJyZW50UHJvdmlkZXI7XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAocHJvdmlkZXIgJiYgcHJvdmlkZXIuaXNNZXRhTWFzaykge1xuICAgICAgcHJvdmlkZXIuYXV0b1JlZnJlc2hPbk5ldHdvcmtDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIHByb3ZpZGVyLm9uKCduZXR3b3JrQ2hhbmdlZCcsICgpID0+XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfVxuXG4gIHN0YXRpYyBpbmplY3RlZFdlYjNBdmFpbGFibGUgPSAoKTogYm9vbGVhbiA9PiB3aW5kb3cuZXRoZXJldW0gfHwgd2luZG93LndlYjM7XG59XG4iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygndi1hbGVydCcse3N0YXRpY0NsYXNzOlwibm8tYWNjZXNzLW1lc3NhZ2VcIixhdHRyczp7XCJ2YWx1ZVwiOnRydWUsXCJjb2xvclwiOlwiZXJyb3JcIixcImljb25cIjpcIndhcm5pbmdcIn19LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJmb250LXdlaWdodC1saWdodCBuby1hY2Nlc3MtbWVzc2FnZV9fbWVzc2FnZVwifSxbKF92bS5uZXR3b3JrVW5zdXBwb3J0ZWQpP19jKCdzcGFuJyxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0uJHQoJ25vLWFjY2Vzcy51bnN1cHBvcnRlZC1uZXR3b3JrJykpK1wiIFwiKV0pOl92bS5fZSgpLChfdm0uaW5pdGlhbGl6YXRpb25GYWlsZWQpP19jKCdzcGFuJyxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0uJHQoJ25vLWFjY2Vzcy5zZGstaW5pdGlhbGl6YXRpb24tZmFpbHVyZScpKStcIiBcIildKTpfdm0uX2UoKSwoX3ZtLnJkblN0YXRlTWlncmF0aW9uKT9fYygnc3BhbicsW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLiR0KCduby1hY2Nlc3MucmRuLXN0YXRlLW1pZ3JhdGlvbicpKStcIiBcIildKTpfYygnc3BhbicsW192bS5fdihfdm0uX3MoX3ZtLiR0KCduby1hY2Nlc3MuZ2VuZXJpYy1lcnJvcicpKSldKV0pXSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIlxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmltcG9ydCB7IENvbXBvbmVudCwgUHJvcCwgVnVlIH0gZnJvbSAndnVlLXByb3BlcnR5LWRlY29yYXRvcic7XG5pbXBvcnQgeyBEZW5pZWRSZWFzb24gfSBmcm9tICdAL21vZGVsL3R5cGVzJztcblxuQENvbXBvbmVudCh7fSlcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vQWNjZXNzTWVzc2FnZSBleHRlbmRzIFZ1ZSB7XG4gIEBQcm9wKHsgcmVxdWlyZWQ6IHRydWUgfSlcbiAgcmVhc29uITogRGVuaWVkUmVhc29uO1xuXG4gIGdldCBuZXR3b3JrVW5zdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucmVhc29uID09PSBEZW5pZWRSZWFzb24uVU5TVVBQT1JURURfTkVUV09SSztcbiAgfVxuXG4gIGdldCBpbml0aWFsaXphdGlvbkZhaWxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5yZWFzb24gPT09IERlbmllZFJlYXNvbi5JTklUSUFMSVpBVElPTl9GQUlMRUQ7XG4gIH1cblxuICBnZXQgcmRuU3RhdGVNaWdyYXRpb24oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucmVhc29uID09PSBEZW5pZWRSZWFzb24uUkROX1NUQVRFX01JR1JBVElPTjtcbiAgfVxufVxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTE0LTAhLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xNC0zIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Ob0FjY2Vzc01lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTQtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTE0LTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL05vQWNjZXNzTWVzc2FnZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL05vQWNjZXNzTWVzc2FnZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9N2I5MmIwODMmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vTm9BY2Nlc3NNZXNzYWdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vTm9BY2Nlc3NNZXNzYWdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9Ob0FjY2Vzc01lc3NhZ2UudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9N2I5MmIwODMmc2NvcGVkPXRydWUmbGFuZz1zY3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCI3YjkyYjA4M1wiLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0c1xuXG4vKiB2dWV0aWZ5LWxvYWRlciAqL1xuaW1wb3J0IGluc3RhbGxDb21wb25lbnRzIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9ydW50aW1lL2luc3RhbGxDb21wb25lbnRzLmpzXCJcbmltcG9ydCB7IFZBbGVydCB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkFsZXJ0Jztcbmluc3RhbGxDb21wb25lbnRzKGNvbXBvbmVudCwge1ZBbGVydH0pXG4iLCJcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmltcG9ydCB7IENvbXBvbmVudCwgUHJvcCwgRW1pdCwgVnVlIH0gZnJvbSAndnVlLXByb3BlcnR5LWRlY29yYXRvcic7XG5pbXBvcnQgeyBtYXBTdGF0ZSB9IGZyb20gJ3Z1ZXgnO1xuaW1wb3J0IHsgV2ViM1Byb3ZpZGVyIH0gZnJvbSAnQC9zZXJ2aWNlcy93ZWIzLXByb3ZpZGVyJztcbmltcG9ydCB7IERlbmllZFJlYXNvbiB9IGZyb20gJy4uL21vZGVsL3R5cGVzJztcbmltcG9ydCBSYWlkZW5EaWFsb2cgZnJvbSAnQC9jb21wb25lbnRzL1JhaWRlbkRpYWxvZy52dWUnO1xuaW1wb3J0IEFjdGlvbkJ1dHRvbiBmcm9tICdAL2NvbXBvbmVudHMvQWN0aW9uQnV0dG9uLnZ1ZSc7XG5pbXBvcnQgTm9BY2Nlc3NNZXNzYWdlIGZyb20gJ0AvY29tcG9uZW50cy9Ob0FjY2Vzc01lc3NhZ2UudnVlJztcblxuQENvbXBvbmVudCh7XG4gIGNvbXBvbmVudHM6IHtcbiAgICBSYWlkZW5EaWFsb2csXG4gICAgQWN0aW9uQnV0dG9uLFxuICAgIE5vQWNjZXNzTWVzc2FnZVxuICB9LFxuICBjb21wdXRlZDogbWFwU3RhdGUoWydzdGF0ZUJhY2t1cCcsICdhY2Nlc3NEZW5pZWQnXSlcbn0pXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25uZWN0RGlhbG9nIGV4dGVuZHMgVnVlIHtcbiAgaGlkZUNsb3NlOiBib29sZWFuID0gZmFsc2U7XG4gIHN0YXRlQmFja3VwITogc3RyaW5nO1xuICBhY2Nlc3NEZW5pZWQhOiBEZW5pZWRSZWFzb247XG5cbiAgQFByb3AoeyByZXF1aXJlZDogdHJ1ZSwgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSlcbiAgdmlzaWJsZSE6IGJvb2xlYW47XG4gIEBQcm9wKHsgZGVmYXVsdDogZmFsc2UsIHJlcXVpcmVkOiB0cnVlLCB0eXBlOiBCb29sZWFuIH0pXG4gIGNvbm5lY3RpbmchOiBib29sZWFuO1xuICBAUHJvcCh7IGRlZmF1bHQ6IGZhbHNlLCByZXF1aXJlZDogdHJ1ZSwgdHlwZTogQm9vbGVhbiB9KVxuICBjb25uZWN0aW5nU3Via2V5ITogYm9vbGVhbjtcblxuICBARW1pdCgpXG4gIGNsb3NlKCkge31cblxuICBARW1pdCgpXG4gIGNvbm5lY3QodXBsb2FkZWRTdGF0ZTogc3RyaW5nLCBzdWJrZXk/OiB0cnVlKSB7XG4gICAgcmV0dXJuIHsgdXBsb2FkZWRTdGF0ZSwgc3Via2V5IH07XG4gIH1cblxuICBnZXQgaW5qZWN0ZWRQcm92aWRlcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gV2ViM1Byb3ZpZGVyLmluamVjdGVkV2ViM0F2YWlsYWJsZSgpO1xuICB9XG59XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTQtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTE0LTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0Nvbm5lY3REaWFsb2cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTQtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTE0LTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0Nvbm5lY3REaWFsb2cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9Db25uZWN0RGlhbG9nLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zNjA0YzIzYyZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9Db25uZWN0RGlhbG9nLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vQ29ubmVjdERpYWxvZy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vQ29ubmVjdERpYWxvZy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0zNjA0YzIzYyZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjM2MDRjMjNjXCIsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzXG5cbi8qIHZ1ZXRpZnktbG9hZGVyICovXG5pbXBvcnQgaW5zdGFsbENvbXBvbmVudHMgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL3J1bnRpbWUvaW5zdGFsbENvbXBvbmVudHMuanNcIlxuaW1wb3J0IHsgVkNhcmRUZXh0IH0gZnJvbSAndnVldGlmeS9saWIvY29tcG9uZW50cy9WQ2FyZCc7XG5pbXBvcnQgeyBWQ2FyZFRpdGxlIH0gZnJvbSAndnVldGlmeS9saWIvY29tcG9uZW50cy9WQ2FyZCc7XG5pbXBvcnQgeyBWUHJvZ3Jlc3NDaXJjdWxhciB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVlByb2dyZXNzQ2lyY3VsYXInO1xuaW5zdGFsbENvbXBvbmVudHMoY29tcG9uZW50LCB7VkNhcmRUZXh0LFZDYXJkVGl0bGUsVlByb2dyZXNzQ2lyY3VsYXJ9KVxuIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gKCFfdm0udG9rZW5zLmxlbmd0aCk/X2MoJ3YtY29udGFpbmVyJyx7c3RhdGljQ2xhc3M6XCJuZXctdG9rZW4gZmlsbC1oZWlnaHRcIixhdHRyczp7XCJmbHVpZFwiOlwiXCJ9fSxbX2MoJ3Ytcm93Jyx7YXR0cnM6e1wiYWxpZ25cIjpcImNlbnRlclwiLFwianVzdGlmeVwiOlwiY2VudGVyXCIsXCJuby1ndXR0ZXJzXCI6XCJcIn19LFtfYygndi1jb2wnLHtzdGF0aWNDbGFzczpcIm5ldy10b2tlbl9fYnV0dG9uXCIsYXR0cnM6e1wiY29sc1wiOlwiMTJcIn19LFtfYygndi1idG4nLHthdHRyczp7XCJmYWJcIjpcIlwiLFwiY29sb3JcIjpcInByaW1hcnlcIn0sb246e1wiY2xpY2tcIjpmdW5jdGlvbigkZXZlbnQpe3JldHVybiBfdm0ubmF2aWdhdGVUb1Rva2VuU2VsZWN0KCl9fX0sW19jKCd2LWljb24nLHthdHRyczp7XCJsYXJnZVwiOlwiXCJ9fSxbX3ZtLl92KFwibWRpLXBsdXNcIildKV0sMSldLDEpLF9jKCd2LWNvbCcse3N0YXRpY0NsYXNzOlwibmV3LXRva2VuX19oZWFkZXJcIixhdHRyczp7XCJjb2xzXCI6XCIxMlwifX0sW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLiR0KCd0b2tlbnMuY29ubmVjdC1uZXcnKSkrXCIgXCIpXSldLDEpXSwxKTpfdm0uX2UoKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5pbXBvcnQgeyBDb21wb25lbnQsIFdhdGNoLCBNaXhpbnMgfSBmcm9tICd2dWUtcHJvcGVydHktZGVjb3JhdG9yJztcbmltcG9ydCB7IG1hcEdldHRlcnMgfSBmcm9tICd2dWV4JztcbmltcG9ydCB7IFRva2VuTW9kZWwgfSBmcm9tICdAL21vZGVsL3R5cGVzJztcbmltcG9ydCBOYXZpZ2F0aW9uTWl4aW4gZnJvbSAnQC9taXhpbnMvbmF2aWdhdGlvbi1taXhpbic7XG5cbkBDb21wb25lbnQoe1xuICBjb21wdXRlZDoge1xuICAgIC4uLm1hcEdldHRlcnMoWyd0b2tlbnMnXSlcbiAgfVxufSlcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vVG9rZW5zIGV4dGVuZHMgTWl4aW5zKE5hdmlnYXRpb25NaXhpbikge1xuICB0b2tlbnMhOiBUb2tlbk1vZGVsW107XG5cbiAgQFdhdGNoKCd0b2tlbnMnLCB7IGltbWVkaWF0ZTogdHJ1ZSB9KVxuICBvbkNoYW5nZSh0b2tlbnM6IFRva2VuTW9kZWxbXSkge1xuICAgIGlmICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm5hdmlnYXRlVG9TZWxlY3RUcmFuc2ZlclRhcmdldCh0b2tlbnNbMF0uYWRkcmVzcyk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTQtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTE0LTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL05vVG9rZW5zLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTE0LTAhLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xNC0zIS4uLy4uL25vZGVfbW9kdWxlcy92dWV0aWZ5LWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTIxLTAhLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Ob1Rva2Vucy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL05vVG9rZW5zLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00ZjE2NDA4YSZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9Ob1Rva2Vucy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL05vVG9rZW5zLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9Ob1Rva2Vucy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD00ZjE2NDA4YSZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjRmMTY0MDhhXCIsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzXG5cbi8qIHZ1ZXRpZnktbG9hZGVyICovXG5pbXBvcnQgaW5zdGFsbENvbXBvbmVudHMgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL3J1bnRpbWUvaW5zdGFsbENvbXBvbmVudHMuanNcIlxuaW1wb3J0IHsgVkJ0biB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkJ0bic7XG5pbXBvcnQgeyBWQ29sIH0gZnJvbSAndnVldGlmeS9saWIvY29tcG9uZW50cy9WR3JpZCc7XG5pbXBvcnQgeyBWQ29udGFpbmVyIH0gZnJvbSAndnVldGlmeS9saWIvY29tcG9uZW50cy9WR3JpZCc7XG5pbXBvcnQgeyBWSWNvbiB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkljb24nO1xuaW1wb3J0IHsgVlJvdyB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkdyaWQnO1xuaW5zdGFsbENvbXBvbmVudHMoY29tcG9uZW50LCB7VkJ0bixWQ29sLFZDb250YWluZXIsVkljb24sVlJvd30pXG4iLCJcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5pbXBvcnQgeyBDb21wb25lbnQsIFZ1ZSB9IGZyb20gJ3Z1ZS1wcm9wZXJ0eS1kZWNvcmF0b3InO1xuaW1wb3J0IHsgbWFwU3RhdGUsIG1hcEdldHRlcnMgfSBmcm9tICd2dWV4JztcbmltcG9ydCB7IENvbm5lY3RPcHRpb25zIH0gZnJvbSAnQC90eXBlcyc7XG5pbXBvcnQgeyBEZW5pZWRSZWFzb24gfSBmcm9tICdAL21vZGVsL3R5cGVzJztcbmltcG9ydCBBY3Rpb25CdXR0b24gZnJvbSAnQC9jb21wb25lbnRzL0FjdGlvbkJ1dHRvbi52dWUnO1xuaW1wb3J0IENvbm5lY3REaWFsb2cgZnJvbSAnQC9jb21wb25lbnRzL0Nvbm5lY3REaWFsb2cudnVlJztcbmltcG9ydCBOb1Rva2VucyBmcm9tICdAL2NvbXBvbmVudHMvTm9Ub2tlbnMudnVlJztcblxuQENvbXBvbmVudCh7XG4gIGNvbXB1dGVkOiB7XG4gICAgLi4ubWFwU3RhdGUoWydsb2FkaW5nJywgJ2FjY2Vzc0RlbmllZCddKSxcbiAgICAuLi5tYXBHZXR0ZXJzKFsnaXNDb25uZWN0ZWQnXSlcbiAgfSxcbiAgY29tcG9uZW50czoge1xuICAgIEFjdGlvbkJ1dHRvbixcbiAgICBDb25uZWN0RGlhbG9nLFxuICAgIE5vVG9rZW5zXG4gIH1cbn0pXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIb21lIGV4dGVuZHMgVnVlIHtcbiAgaXNDb25uZWN0ZWQhOiBib29sZWFuO1xuICBjb25uZWN0RGlhbG9nOiBib29sZWFuID0gZmFsc2U7XG4gIGNvbm5lY3Rpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgY29ubmVjdGluZ1N1YmtleTogYm9vbGVhbiA9IGZhbHNlO1xuICBsb2FkaW5nITogYm9vbGVhbjtcbiAgYWNjZXNzRGVuaWVkITogRGVuaWVkUmVhc29uO1xuXG4gIGdldCBpbmFjY2Vzc2libGUoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuY29ubmVjdGluZyB8fFxuICAgICAgdGhpcy5sb2FkaW5nIHx8XG4gICAgICB0aGlzLmFjY2Vzc0RlbmllZCAhPT0gRGVuaWVkUmVhc29uLlVOREVGSU5FRFxuICAgICk7XG4gIH1cblxuICBhc3luYyBjb25uZWN0KGNvbm5lY3RPcHRpb25zOiBDb25uZWN0T3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXRlQmFja3VwID0gY29ubmVjdE9wdGlvbnMudXBsb2FkZWRTdGF0ZTtcbiAgICBsZXQgc3Via2V5ID0gY29ubmVjdE9wdGlvbnMuc3Via2V5O1xuXG4gICAgaWYgKHN1YmtleSkge1xuICAgICAgdGhpcy5jb25uZWN0aW5nU3Via2V5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb25uZWN0aW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLiRzdG9yZS5jb21taXQoJ3Jlc2V0Jyk7XG4gICAgYXdhaXQgdGhpcy4kcmFpZGVuLmNvbm5lY3Qoc3RhdGVCYWNrdXAsIHN1YmtleSk7XG4gICAgdGhpcy5jb25uZWN0aW5nU3Via2V5ID0gZmFsc2U7XG4gICAgdGhpcy5jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmFjY2Vzc0RlbmllZCkge1xuICAgICAgdGhpcy5jb25uZWN0RGlhbG9nID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTQtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTE0LTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0hvbWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTQtMCEuLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTE0LTMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXRpZnktbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMjEtMCEuLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0hvbWUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9Ib21lLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wMmVmODMxYSZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9Ib21lLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz10cyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vSG9tZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vSG9tZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0wMmVmODMxYSZsYW5nPXNjc3Mmc2NvcGVkPXRydWUmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjAyZWY4MzFhXCIsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzXG5cbi8qIHZ1ZXRpZnktbG9hZGVyICovXG5pbXBvcnQgaW5zdGFsbENvbXBvbmVudHMgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVldGlmeS1sb2FkZXIvbGliL3J1bnRpbWUvaW5zdGFsbENvbXBvbmVudHMuanNcIlxuaW1wb3J0IHsgVkNvbCB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkdyaWQnO1xuaW1wb3J0IHsgVkNvbnRhaW5lciB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkdyaWQnO1xuaW1wb3J0IHsgVkltZyB9IGZyb20gJ3Z1ZXRpZnkvbGliL2NvbXBvbmVudHMvVkltZyc7XG5pbXBvcnQgeyBWUm93IH0gZnJvbSAndnVldGlmeS9saWIvY29tcG9uZW50cy9WR3JpZCc7XG5pbnN0YWxsQ29tcG9uZW50cyhjb21wb25lbnQsIHtWQ29sLFZDb250YWluZXIsVkltZyxWUm93fSlcbiIsImltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCBSb3V0ZXIgZnJvbSAndnVlLXJvdXRlcic7XG5cbmltcG9ydCBIb21lIGZyb20gJy4uL3ZpZXdzL0hvbWUudnVlJztcbmltcG9ydCB7IFJvdXRlTmFtZXMgfSBmcm9tICdAL3JvdXRlci9yb3V0ZS1uYW1lcyc7XG5cblZ1ZS51c2UoUm91dGVyKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHJvdXRlciA9IG5ldyBSb3V0ZXIoe1xuICBtb2RlOiAnaGlzdG9yeScsXG4gIGJhc2U6IHByb2Nlc3MuZW52LkJBU0VfVVJMLFxuICByb3V0ZXM6IFtcbiAgICB7XG4gICAgICBwYXRoOiAnLycsXG4gICAgICBuYW1lOiBSb3V0ZU5hbWVzLkhPTUUsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIHRpdGxlOiAnUmFpZGVuIGRBcHAnXG4gICAgICB9LFxuICAgICAgY29tcG9uZW50OiBIb21lXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXRoOiAnKicsXG4gICAgICByZWRpcmVjdDogJy8nXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXRoOiAnL3RyYW5zZmVyLzp0b2tlbicsXG4gICAgICBuYW1lOiBSb3V0ZU5hbWVzLlRSQU5TRkVSLFxuICAgICAgbWV0YToge1xuICAgICAgICB0aXRsZTogJ1RyYW5zZmVyJ1xuICAgICAgfSxcbiAgICAgIGNvbXBvbmVudDogKCkgPT4gaW1wb3J0KCcuLi92aWV3cy9UcmFuc2Zlci52dWUnKVxuICAgIH0sXG4gICAge1xuICAgICAgcGF0aDogJy90cmFuc2Zlci86dG9rZW4vOnRhcmdldCcsXG4gICAgICBuYW1lOiBSb3V0ZU5hbWVzLlRSQU5TRkVSX1NURVBTLFxuICAgICAgbWV0YToge1xuICAgICAgICB0aXRsZTogJ1RyYW5zZmVyJ1xuICAgICAgfSxcbiAgICAgIGNvbXBvbmVudDogKCkgPT4gaW1wb3J0KCcuLi92aWV3cy9UcmFuc2ZlclN0ZXBzLnZ1ZScpXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXRoOiAnL2Nvbm5lY3QnLFxuICAgICAgbmFtZTogUm91dGVOYW1lcy5TRUxFQ1RfVE9LRU4sXG4gICAgICBtZXRhOiB7XG4gICAgICAgIHRpdGxlOiAnU2VsZWN0IFRva2VuJ1xuICAgICAgfSxcbiAgICAgIGNvbXBvbmVudDogKCkgPT4gaW1wb3J0KCcuLi92aWV3cy9TZWxlY3RUb2tlbi52dWUnKVxuICAgIH0sXG4gICAge1xuICAgICAgcGF0aDogJy9jb25uZWN0Lzp0b2tlbicsXG4gICAgICBuYW1lOiBSb3V0ZU5hbWVzLlNFTEVDVF9IVUIsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIHRpdGxlOiAnU2VsZWN0IEh1YidcbiAgICAgIH0sXG4gICAgICBjb21wb25lbnQ6ICgpID0+IGltcG9ydCgnLi4vdmlld3MvU2VsZWN0SHViLnZ1ZScpXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXRoOiAnL2Nvbm5lY3QvOnRva2VuLzpwYXJ0bmVyJyxcbiAgICAgIG5hbWU6IFJvdXRlTmFtZXMuT1BFTl9DSEFOTkVMLFxuICAgICAgbWV0YToge1xuICAgICAgICB0aXRsZTogJ09wZW4gQ2hhbm5lbCdcbiAgICAgIH0sXG4gICAgICBjb21wb25lbnQ6ICgpID0+IGltcG9ydCgnLi4vdmlld3MvT3BlbkNoYW5uZWwudnVlJylcbiAgICB9LFxuICAgIHtcbiAgICAgIHBhdGg6ICcvY2hhbm5lbHMvOnRva2VuJyxcbiAgICAgIG5hbWU6IFJvdXRlTmFtZXMuQ0hBTk5FTFMsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIHRpdGxlOiAnQ2hhbm5lbHMnXG4gICAgICB9LFxuICAgICAgY29tcG9uZW50OiAoKSA9PiBpbXBvcnQoJy4uL3ZpZXdzL0NoYW5uZWxzLnZ1ZScpXG4gICAgfSxcbiAgICB7XG4gICAgICBwYXRoOiAnL2dlbmVyYWwnLFxuICAgICAgbmFtZTogUm91dGVOYW1lcy5HRU5FUkFMLFxuICAgICAgYmVmb3JlRW50ZXI6ICh0bywgZnJvbSwgbmV4dCkgPT4ge1xuICAgICAgICAvLyBSZW1lbWJlcnMgdGhlIHJvdXRlIHRoYXQgd2FzIHZpc2l0ZWQganVzdCBiZWZvcmUgdGhlIEdlbmVyYWwgdmlldyBpcyBvcGVuZWQgYW5kXG4gICAgICAgIC8vIHRoZW4gbG9hZHMgdGhlIEdlbmVyYWwgdmlldyBpbiBhIHNlcGFyYXRlIDxyb3V0ZXItdmlldz4uIFRoZSBsYXN0IHZpc2l0ZWQgcm91dGVcbiAgICAgICAgLy8gaXMgbG9hZGVkIHdoZW4gY2xpY2tpbmcgb3V0IG9mIHRoZSBHZW5lcmFsIHZpZXcuXG4gICAgICAgIGlmIChmcm9tLm5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0KHtcbiAgICAgICAgICAgIG5hbWU6IFJvdXRlTmFtZXMuSE9NRVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRvLm1hdGNoZWQubGVuZ3RoKSB7XG4gICAgICAgICAgdG8ubWF0Y2hlZFswXS5jb21wb25lbnRzLmRlZmF1bHQgPSBmcm9tLm1hdGNoZWRbMF0uY29tcG9uZW50cy5kZWZhdWx0O1xuICAgICAgICAgIHRvLm1hdGNoZWRbMF0uY29tcG9uZW50cy5tb2RhbCA9ICgpID0+XG4gICAgICAgICAgICBpbXBvcnQoJy4uL3ZpZXdzL0dlbmVyYWxEaWFsb2cudnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwYXRoOiAnZ2VuZXJhbC1ob21lJyxcbiAgICAgICAgICBuYW1lOiBSb3V0ZU5hbWVzLkdFTkVSQUxfSE9NRSxcbiAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICB0aXRsZTogJ0dlbmVyYWwnXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wb25lbnQ6ICgpID0+IGltcG9ydCgnLi4vdmlld3MvR2VuZXJhbEhvbWUudnVlJylcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHBhdGg6ICdiYWNrdXAtc3RhdGUnLFxuICAgICAgICAgIG5hbWU6IFJvdXRlTmFtZXMuQkFDS1VQX1NUQVRFLFxuICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgIHRpdGxlOiAnQmFja3VwIFN0YXRlJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcG9uZW50OiAoKSA9PiBpbXBvcnQoJy4uL3ZpZXdzL0JhY2t1cFN0YXRlLnZ1ZScpXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9XG4gIF1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByb3V0ZXI7XG4iLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgVnVleCwgeyBTdG9yZU9wdGlvbnMgfSBmcm9tICd2dWV4JztcbmltcG9ydCB7IFJvb3RTdGF0ZSwgVG9rZW5zLCBUcmFuc2ZlcnMgfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7XG4gIENoYW5uZWxTdGF0ZSxcbiAgUmFpZGVuQ2hhbm5lbCxcbiAgUmFpZGVuQ2hhbm5lbHMsXG4gIFJhaWRlblRyYW5zZmVyXG59IGZyb20gJ3JhaWRlbi10cyc7XG5pbXBvcnQge1xuICBBY2NUb2tlbk1vZGVsLFxuICBEZW5pZWRSZWFzb24sXG4gIGVtcHR5VG9rZW5Nb2RlbCxcbiAgUGxhY2VIb2xkZXJOZXR3b3JrLFxuICBUb2tlbixcbiAgVG9rZW5Nb2RlbCxcbiAgUHJlc2VuY2VzXG59IGZyb20gJ0AvbW9kZWwvdHlwZXMnO1xuaW1wb3J0IG1hcCBmcm9tICdsb2Rhc2gvbWFwJztcbmltcG9ydCBmbGF0TWFwIGZyb20gJ2xvZGFzaC9mbGF0TWFwJztcbmltcG9ydCBmaWx0ZXIgZnJvbSAnbG9kYXNoL2ZpbHRlcic7XG5pbXBvcnQgY2xvbmUgZnJvbSAnbG9kYXNoL2Nsb25lJztcbmltcG9ydCByZWR1Y2UgZnJvbSAnbG9kYXNoL3JlZHVjZSc7XG5pbXBvcnQgb3JkZXJCeSBmcm9tICdsb2Rhc2gvb3JkZXJCeSc7XG5pbXBvcnQgaXNFcXVhbCBmcm9tICdsb2Rhc2gvaXNFcXVhbCc7XG5pbXBvcnQgaXNFbXB0eSBmcm9tICdsb2Rhc2gvaXNFbXB0eSc7XG5pbXBvcnQgeyBOZXR3b3JrLCBCaWdOdW1iZXIgfSBmcm9tICdldGhlcnMvdXRpbHMnO1xuXG5WdWUudXNlKFZ1ZXgpO1xuXG5jb25zdCBfZGVmYXVsdFN0YXRlOiBSb290U3RhdGUgPSB7XG4gIGxvYWRpbmc6IHRydWUsXG4gIGRlZmF1bHRBY2NvdW50OiAnJyxcbiAgYWNjb3VudEJhbGFuY2U6ICcwLjAnLFxuICByYWlkZW5BY2NvdW50QmFsYW5jZTogJycsXG4gIHByb3ZpZGVyRGV0ZWN0ZWQ6IHRydWUsXG4gIGFjY2Vzc0RlbmllZDogRGVuaWVkUmVhc29uLlVOREVGSU5FRCxcbiAgY2hhbm5lbHM6IHt9LFxuICB0b2tlbnM6IHt9LFxuICB0cmFuc2ZlcnM6IHt9LFxuICBwcmVzZW5jZXM6IHt9LFxuICBuZXR3b3JrOiBQbGFjZUhvbGRlck5ldHdvcmssXG4gIHN0YXRlQmFja3VwOiAnJ1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRTdGF0ZSgpOiBSb290U3RhdGUge1xuICByZXR1cm4gY2xvbmUoX2RlZmF1bHRTdGF0ZSk7XG59XG5cbmNvbnN0IHN0b3JlOiBTdG9yZU9wdGlvbnM8Um9vdFN0YXRlPiA9IHtcbiAgc3RhdGU6IGRlZmF1bHRTdGF0ZSgpLFxuICBtdXRhdGlvbnM6IHtcbiAgICBub1Byb3ZpZGVyKHN0YXRlOiBSb290U3RhdGUpIHtcbiAgICAgIHN0YXRlLnByb3ZpZGVyRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGFjY2Vzc0RlbmllZChzdGF0ZTogUm9vdFN0YXRlLCByZWFzb246IERlbmllZFJlYXNvbikge1xuICAgICAgc3RhdGUuYWNjZXNzRGVuaWVkID0gcmVhc29uO1xuICAgIH0sXG4gICAgYWNjb3VudChzdGF0ZTogUm9vdFN0YXRlLCBhY2NvdW50OiBzdHJpbmcpIHtcbiAgICAgIHN0YXRlLmRlZmF1bHRBY2NvdW50ID0gYWNjb3VudDtcbiAgICB9LFxuICAgIGxvYWRDb21wbGV0ZShzdGF0ZTogUm9vdFN0YXRlKSB7XG4gICAgICBzdGF0ZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgfSxcbiAgICBiYWxhbmNlKHN0YXRlOiBSb290U3RhdGUsIGJhbGFuY2U6IHN0cmluZykge1xuICAgICAgc3RhdGUuYWNjb3VudEJhbGFuY2UgPSBiYWxhbmNlO1xuICAgIH0sXG4gICAgcmFpZGVuQWNjb3VudEJhbGFuY2Uoc3RhdGU6IFJvb3RTdGF0ZSwgYmFsYW5jZTogc3RyaW5nKSB7XG4gICAgICBzdGF0ZS5yYWlkZW5BY2NvdW50QmFsYW5jZSA9IGJhbGFuY2U7XG4gICAgfSxcbiAgICB1cGRhdGVDaGFubmVscyhzdGF0ZTogUm9vdFN0YXRlLCBjaGFubmVsczogUmFpZGVuQ2hhbm5lbHMpIHtcbiAgICAgIHN0YXRlLmNoYW5uZWxzID0gY2hhbm5lbHM7XG4gICAgfSxcbiAgICB1cGRhdGVUb2tlbnMoc3RhdGU6IFJvb3RTdGF0ZSwgdG9rZW5zOiBUb2tlbnMpIHtcbiAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIHRva2VuXSBvZiBPYmplY3QuZW50cmllcyh0b2tlbnMpKVxuICAgICAgICBpZiAoYWRkcmVzcyBpbiBzdGF0ZS50b2tlbnMgJiYgaXNFcXVhbCh0b2tlbiwgc3RhdGUudG9rZW5zW2FkZHJlc3NdKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZWxzZSBpZiAoYWRkcmVzcyBpbiBzdGF0ZS50b2tlbnMpXG4gICAgICAgICAgc3RhdGUudG9rZW5zW2FkZHJlc3NdID0geyAuLi5zdGF0ZS50b2tlbnNbYWRkcmVzc10sIC4uLnRva2VuIH07XG4gICAgICAgIGVsc2Ugc3RhdGUudG9rZW5zID0geyAuLi5zdGF0ZS50b2tlbnMsIFthZGRyZXNzXTogdG9rZW4gfTtcbiAgICB9LFxuICAgIHVwZGF0ZVByZXNlbmNlKHN0YXRlOiBSb290U3RhdGUsIHByZXNlbmNlOiBQcmVzZW5jZXMpIHtcbiAgICAgIHN0YXRlLnByZXNlbmNlcyA9IHsgLi4uc3RhdGUucHJlc2VuY2VzLCAuLi5wcmVzZW5jZSB9O1xuICAgIH0sXG4gICAgbmV0d29yayhzdGF0ZTogUm9vdFN0YXRlLCBuZXR3b3JrOiBOZXR3b3JrKSB7XG4gICAgICBzdGF0ZS5uZXR3b3JrID0gbmV0d29yaztcbiAgICB9LFxuICAgIHJlc2V0KHN0YXRlOiBSb290U3RhdGUpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUsIGRlZmF1bHRTdGF0ZSgpKTtcbiAgICB9LFxuICAgIHVwZGF0ZVRyYW5zZmVycyhzdGF0ZTogUm9vdFN0YXRlLCB0cmFuc2ZlcjogUmFpZGVuVHJhbnNmZXIpIHtcbiAgICAgIHN0YXRlLnRyYW5zZmVycyA9IHsgLi4uc3RhdGUudHJhbnNmZXJzLCBbdHJhbnNmZXIuc2VjcmV0aGFzaF06IHRyYW5zZmVyIH07XG4gICAgfSxcbiAgICBiYWNrdXBTdGF0ZShzdGF0ZTogUm9vdFN0YXRlLCB1cGxvYWRlZFN0YXRlOiBzdHJpbmcpIHtcbiAgICAgIHN0YXRlLnN0YXRlQmFja3VwID0gdXBsb2FkZWRTdGF0ZTtcbiAgICB9XG4gIH0sXG4gIGFjdGlvbnM6IHt9LFxuICBnZXR0ZXJzOiB7XG4gICAgdG9rZW5zOiBmdW5jdGlvbihzdGF0ZTogUm9vdFN0YXRlKTogVG9rZW5Nb2RlbFtdIHtcbiAgICAgIGNvbnN0IHJlZHVjZXIgPSAoXG4gICAgICAgIGFjYzogQWNjVG9rZW5Nb2RlbCxcbiAgICAgICAgY2hhbm5lbDogUmFpZGVuQ2hhbm5lbFxuICAgICAgKTogQWNjVG9rZW5Nb2RlbCA9PiB7XG4gICAgICAgIGFjYy5hZGRyZXNzID0gY2hhbm5lbC50b2tlbjtcbiAgICAgICAgKGFjY1tjaGFubmVsLnN0YXRlXSBhcyBudW1iZXIpICs9IDE7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gbWFwKFxuICAgICAgICBmaWx0ZXIoZmxhdE1hcChzdGF0ZS5jaGFubmVscyksIGNoYW5uZWxzID0+ICFpc0VtcHR5KGNoYW5uZWxzKSksXG4gICAgICAgIHRva2VuQ2hhbm5lbHMgPT4ge1xuICAgICAgICAgIGNvbnN0IG1vZGVsID0gcmVkdWNlKHRva2VuQ2hhbm5lbHMsIHJlZHVjZXIsIGVtcHR5VG9rZW5Nb2RlbCgpKTtcbiAgICAgICAgICBjb25zdCB0b2tlbkluZm8gPSBzdGF0ZS50b2tlbnNbbW9kZWwuYWRkcmVzc107XG4gICAgICAgICAgaWYgKHRva2VuSW5mbykge1xuICAgICAgICAgICAgbW9kZWwubmFtZSA9IHRva2VuSW5mby5uYW1lIHx8ICcnO1xuICAgICAgICAgICAgbW9kZWwuc3ltYm9sID0gdG9rZW5JbmZvLnN5bWJvbCB8fCAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBhbGxUb2tlbnM6IChzdGF0ZTogUm9vdFN0YXRlKTogVG9rZW5bXSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzdGF0ZS50b2tlbnMpO1xuICAgIH0sXG4gICAgY2hhbm5lbHM6IChzdGF0ZTogUm9vdFN0YXRlKSA9PiAodG9rZW5BZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgICAgIGxldCBjaGFubmVsczogUmFpZGVuQ2hhbm5lbFtdID0gW107XG4gICAgICBjb25zdCB0b2tlbkNoYW5uZWxzID0gc3RhdGUuY2hhbm5lbHNbdG9rZW5BZGRyZXNzXTtcbiAgICAgIGlmICh0b2tlbkNoYW5uZWxzICYmICFpc0VtcHR5KHRva2VuQ2hhbm5lbHMpKSB7XG4gICAgICAgIGNoYW5uZWxzID0gZmxhdE1hcCh0b2tlbkNoYW5uZWxzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFubmVscztcbiAgICB9LFxuICAgIHRva2VuOiAoc3RhdGU6IFJvb3RTdGF0ZSkgPT4gKHRva2VuQWRkcmVzczogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAodG9rZW5BZGRyZXNzIGluIHN0YXRlLnRva2Vucykge1xuICAgICAgICByZXR1cm4gc3RhdGUudG9rZW5zW3Rva2VuQWRkcmVzc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5ldHdvcms6IChzdGF0ZTogUm9vdFN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gc3RhdGUubmV0d29yay5uYW1lIHx8IGBDaGFpbiAke3N0YXRlLm5ldHdvcmsuY2hhaW5JZH1gO1xuICAgIH0sXG4gICAgY2hhbm5lbFdpdGhCaWdnZXN0Q2FwYWNpdHk6IChfLCBnZXR0ZXJzKSA9PiAodG9rZW5BZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGNoYW5uZWxzOiBSYWlkZW5DaGFubmVsW10gPSBnZXR0ZXJzLmNoYW5uZWxzKHRva2VuQWRkcmVzcyk7XG4gICAgICBjb25zdCBvcGVuQ2hhbm5lbHMgPSBjaGFubmVscy5maWx0ZXIoXG4gICAgICAgIHZhbHVlID0+IHZhbHVlLnN0YXRlID09PSBDaGFubmVsU3RhdGUub3BlblxuICAgICAgKTtcbiAgICAgIHJldHVybiBvcmRlckJ5KG9wZW5DaGFubmVscywgWydjYXBhY2l0eSddLCBbJ2Rlc2MnXSlbMF07XG4gICAgfSxcbiAgICBwZW5kaW5nVHJhbnNmZXJzOiAoeyB0cmFuc2ZlcnMgfTogUm9vdFN0YXRlKSA9PlxuICAgICAgT2JqZWN0LmtleXModHJhbnNmZXJzKVxuICAgICAgICAuZmlsdGVyKHNlY3JldEhhc2ggPT4ge1xuICAgICAgICAgIGNvbnN0IHsgY29tcGxldGVkIH0gPSB0cmFuc2ZlcnNbc2VjcmV0SGFzaF07XG5cbiAgICAgICAgICAvLyByZXR1cm4gd2hldGhlciB0cmFuc2ZlciBpcyBwZW5kaW5nIG9yIG5vdFxuICAgICAgICAgIHJldHVybiAhY29tcGxldGVkO1xuICAgICAgICB9KVxuICAgICAgICAucmVkdWNlKChwZW5kaW5nVHJhbnNmZXJzOiBUcmFuc2ZlcnMsIHNlY3JldEhhc2g6IHN0cmluZykgPT4ge1xuICAgICAgICAgIHBlbmRpbmdUcmFuc2ZlcnNbc2VjcmV0SGFzaF0gPSB0cmFuc2ZlcnNbc2VjcmV0SGFzaF07XG4gICAgICAgICAgcmV0dXJuIHBlbmRpbmdUcmFuc2ZlcnM7XG4gICAgICAgIH0sIHt9KSxcbiAgICB0cmFuc2ZlcjogKHN0YXRlOiBSb290U3RhdGUpID0+IChwYXltZW50SWQ6IEJpZ051bWJlcikgPT4ge1xuICAgICAgY29uc3Qgc2VjcmV0SGFzaCA9IE9iamVjdC5rZXlzKHN0YXRlLnRyYW5zZmVycykuZmluZChcbiAgICAgICAgc2VjcmV0SGFzaCA9PiBzdGF0ZS50cmFuc2ZlcnNbc2VjcmV0SGFzaF0ucGF5bWVudElkID09PSBwYXltZW50SWRcbiAgICAgICk7XG5cbiAgICAgIGlmIChzZWNyZXRIYXNoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS50cmFuc2ZlcnNbc2VjcmV0SGFzaF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBpc0Nvbm5lY3RlZDogKHN0YXRlOiBSb290U3RhdGUpOiBib29sZWFuID0+XG4gICAgICAhIShzdGF0ZS5kZWZhdWx0QWNjb3VudCAmJiBzdGF0ZS5kZWZhdWx0QWNjb3VudCAhPT0gJycpLFxuICAgIGJhbGFuY2U6IChzdGF0ZTogUm9vdFN0YXRlKTogc3RyaW5nID0+IHtcbiAgICAgIHJldHVybiBzdGF0ZS5yYWlkZW5BY2NvdW50QmFsYW5jZVxuICAgICAgICA/IHN0YXRlLnJhaWRlbkFjY291bnRCYWxhbmNlXG4gICAgICAgIDogc3RhdGUuYWNjb3VudEJhbGFuY2U7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgVnVleC5TdG9yZShzdG9yZSk7XG4iLCIvKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICd2dWUtY2xhc3MtY29tcG9uZW50JztcblxuLy8gUmVnaXN0ZXIgdGhlIHJvdXRlciBob29rcyB3aXRoIHRoZWlyIG5hbWVzXG5Db21wb25lbnQucmVnaXN0ZXJIb29rcyhbXG4gICdiZWZvcmVSb3V0ZUVudGVyJyxcbiAgJ2JlZm9yZVJvdXRlTGVhdmUnLFxuICAnYmVmb3JlUm91dGVVcGRhdGUnXG5dKTtcbiIsImV4cG9ydCBjbGFzcyBDb25maWdQcm92aWRlciB7XG4gIHN0YXRpYyBhc3luYyBmZXRjaChcbiAgICB1cmw/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7IElORlVSQV9FTkRQT0lOVDogc3RyaW5nOyBQUklWQVRFX0tFWTogc3RyaW5nIH0gfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAodXJsKSByZXR1cm4gYXdhaXQgKGF3YWl0IGZldGNoKHVybCkpLmpzb24oKTtcblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIENoYW5nZUV2ZW50LFxuICBFdmVudFR5cGVzLFxuICBSYWlkZW4sXG4gIFJhaWRlblBhdGhzLFxuICBSYWlkZW5QRlNcbn0gZnJvbSAncmFpZGVuLXRzJztcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAndnVleCc7XG5pbXBvcnQgeyBSb290U3RhdGUsIFRva2VucyB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgV2ViM1Byb3ZpZGVyIH0gZnJvbSAnQC9zZXJ2aWNlcy93ZWIzLXByb3ZpZGVyJztcbmltcG9ydCB7IEJhbGFuY2VVdGlscyB9IGZyb20gJ0AvdXRpbHMvYmFsYW5jZS11dGlscyc7XG5pbXBvcnQgeyBEZW5pZWRSZWFzb24sIFByb2dyZXNzLCBUb2tlbiwgVG9rZW5Nb2RlbCB9IGZyb20gJ0AvbW9kZWwvdHlwZXMnO1xuaW1wb3J0IHsgQmlnTnVtYmVyLCBCaWdOdW1iZXJpc2ggfSBmcm9tICdldGhlcnMvdXRpbHMnO1xuaW1wb3J0IHsgZXhoYXVzdE1hcCwgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IGFzeW5jUG9vbCBmcm9tICd0aW55LWFzeW5jLXBvb2wnO1xuaW1wb3J0IHsgQ29uZmlnUHJvdmlkZXIgfSBmcm9tICcuL2NvbmZpZy1wcm92aWRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhaWRlblNlcnZpY2Uge1xuICBwcml2YXRlIF9yYWlkZW4/OiBSYWlkZW47XG4gIHByaXZhdGUgc3RvcmU6IFN0b3JlPFJvb3RTdGF0ZT47XG4gIHByaXZhdGUgX3VzZXJEZXBvc2l0VG9rZW5BZGRyZXNzOiBzdHJpbmcgPSAnJztcblxuICBwcml2YXRlIHN0YXRpYyBhc3luYyBjcmVhdGVSYWlkZW4oXG4gICAgcHJvdmlkZXI6IGFueSxcbiAgICBhY2NvdW50OiBzdHJpbmcgfCBudW1iZXIgPSAwLFxuICAgIHN0YXRlQmFja3VwPzogc3RyaW5nLFxuICAgIHN1YmtleT86IHRydWVcbiAgKTogUHJvbWlzZTxSYWlkZW4+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IFJhaWRlbi5jcmVhdGUoXG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBhY2NvdW50LFxuICAgICAgICB7XG4gICAgICAgICAgc3RvcmFnZTogd2luZG93LmxvY2FsU3RvcmFnZSxcbiAgICAgICAgICBzdGF0ZTogc3RhdGVCYWNrdXBcbiAgICAgICAgfSxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB7XG4gICAgICAgICAgcGZzU2FmZXR5TWFyZ2luOiAxLjEsXG4gICAgICAgICAgcGZzOiBwcm9jZXNzLmVudi5WVUVfQVBQX1BGUyxcbiAgICAgICAgICBtYXRyaXhTZXJ2ZXI6IHByb2Nlc3MuZW52LlZVRV9BUFBfVFJBTlNQT1JUXG4gICAgICAgIH0sXG4gICAgICAgIHN1YmtleVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgUmFpZGVuSW5pdGlhbGl6YXRpb25GYWlsZWQoZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXQgcmFpZGVuKCk6IFJhaWRlbiB7XG4gICAgaWYgKHRoaXMuX3JhaWRlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JhaWRlbiBpbnN0YW5jZSB3YXMgbm90IGluaXRpYWxpemVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9yYWlkZW47XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hUb2tlbkxpc3QoKSB7XG4gICAgY29uc3QgYWxsVG9rZW5zID0gYXdhaXQgdGhpcy5yYWlkZW4uZ2V0VG9rZW5MaXN0KCk7XG4gICAgY29uc3QgdG9GZXRjaDogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBwbGFjZWhvbGRlcnM6IFRva2VucyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiBhbGxUb2tlbnMpIHtcbiAgICAgIHRvRmV0Y2gucHVzaCh0b2tlbik7XG4gICAgICBwbGFjZWhvbGRlcnNbdG9rZW5dID0geyBhZGRyZXNzOiB0b2tlbiB9O1xuICAgIH1cblxuICAgIHRoaXMuc3RvcmUuY29tbWl0KCd1cGRhdGVUb2tlbnMnLCBwbGFjZWhvbGRlcnMpO1xuICAgIGF3YWl0IHRoaXMuZmV0Y2hUb2tlbkRhdGEodG9GZXRjaCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihzdG9yZTogU3RvcmU8Um9vdFN0YXRlPikge1xuICAgIHRoaXMuX3JhaWRlbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gIH1cblxuICBnZXQgdXNlckRlcG9zaXRUb2tlbkFkZHJlc3MoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuX3VzZXJEZXBvc2l0VG9rZW5BZGRyZXNzKSB0aHJvdyBuZXcgRXJyb3IoJ2FkZHJlc3MgZW1wdHknKTtcbiAgICByZXR1cm4gdGhpcy5fdXNlckRlcG9zaXRUb2tlbkFkZHJlc3M7XG4gIH1cblxuICBhc3luYyBlbnNSZXNvbHZlKG5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJhaWRlbi5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRW5zUmVzb2x2ZUZhaWxlZChlKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjb25uZWN0KHN0YXRlQmFja3VwPzogc3RyaW5nLCBzdWJrZXk/OiB0cnVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhaWRlblBhY2thZ2VDb25maWdVcmwgPSBwcm9jZXNzLmVudi5WVUVfQVBQX1JBSURFTl9QQUNLQUdFO1xuICAgICAgbGV0IGNvbmZpZztcbiAgICAgIGxldCBwcm92aWRlcjtcbiAgICAgIGxldCByYWlkZW47XG5cbiAgICAgIGlmIChyYWlkZW5QYWNrYWdlQ29uZmlnVXJsKSB7XG4gICAgICAgIGNvbmZpZyA9IGF3YWl0IENvbmZpZ1Byb3ZpZGVyLmZldGNoKHJhaWRlblBhY2thZ2VDb25maWdVcmwpO1xuICAgICAgICBwcm92aWRlciA9IGF3YWl0IFdlYjNQcm92aWRlci5wcm92aWRlcihjb25maWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdmlkZXIgPSBhd2FpdCBXZWIzUHJvdmlkZXIucHJvdmlkZXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aGlzLnN0b3JlLmNvbW1pdCgnbm9Qcm92aWRlcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgIHJhaWRlbiA9IGF3YWl0IFJhaWRlblNlcnZpY2UuY3JlYXRlUmFpZGVuKFxuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICBjb25maWcuUFJJVkFURV9LRVksXG4gICAgICAgICAgICBzdGF0ZUJhY2t1cCxcbiAgICAgICAgICAgIHN1YmtleVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFpZGVuID0gYXdhaXQgUmFpZGVuU2VydmljZS5jcmVhdGVSYWlkZW4oXG4gICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN0YXRlQmFja3VwLFxuICAgICAgICAgICAgc3Via2V5XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JhaWRlbiA9IHJhaWRlbjtcblxuICAgICAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50KCk7XG4gICAgICAgIHRoaXMuc3RvcmUuY29tbWl0KCdhY2NvdW50JywgYWNjb3VudCk7XG5cbiAgICAgICAgdGhpcy5fdXNlckRlcG9zaXRUb2tlbkFkZHJlc3MgPSBhd2FpdCByYWlkZW4udXNlckRlcG9zaXRUb2tlbkFkZHJlc3MoKTtcblxuICAgICAgICAvLyB1cGRhdGUgY29ubmVjdGVkIHRva2VucyBkYXRhIG9uIGVhY2ggbmV3QmxvY2tcbiAgICAgICAgcmFpZGVuLmV2ZW50cyRcbiAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgIGZpbHRlcih2YWx1ZSA9PiB2YWx1ZS50eXBlID09PSAnbmV3QmxvY2snKSxcbiAgICAgICAgICAgIGV4aGF1c3RNYXAoKCkgPT5cbiAgICAgICAgICAgICAgdGhpcy5mZXRjaFRva2VuRGF0YShcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlLmdldHRlcnMudG9rZW5zLm1hcCgobTogVG9rZW5Nb2RlbCkgPT4gbS5hZGRyZXNzKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICAgIC5zdWJzY3JpYmUoKTtcblxuICAgICAgICByYWlkZW4uZXZlbnRzJFxuICAgICAgICAgIC5waXBlKGZpbHRlcih2YWx1ZSA9PiB2YWx1ZS50eXBlID09PSAncmFpZGVuU2h1dGRvd24nKSlcbiAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuc3RvcmUuY29tbWl0KCdyZXNldCcpKTtcblxuICAgICAgICByYWlkZW4uZXZlbnRzJC5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSAndG9rZW5Nb25pdG9yZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlLmNvbW1pdCgndXBkYXRlVG9rZW5zJywge1xuICAgICAgICAgICAgICBbdmFsdWUucGF5bG9hZC50b2tlbl06IHsgYWRkcmVzczogdmFsdWUucGF5bG9hZC50b2tlbiB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVcGRhdGUgcHJlc2VuY2VzIG9uIG1hdHJpeCBwcmVzZW5jZSB1cGRhdGVzXG4gICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09ICdtYXRyaXgvcHJlc2VuY2Uvc3VjY2VzcycpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuY29tbWl0KCd1cGRhdGVQcmVzZW5jZScsIHtcbiAgICAgICAgICAgICAgW3ZhbHVlLm1ldGEuYWRkcmVzc106IHZhbHVlLnBheWxvYWQuYXZhaWxhYmxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJhaWRlbi5jaGFubmVscyQuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgICAgICB0aGlzLnN0b3JlLmNvbW1pdCgndXBkYXRlQ2hhbm5lbHMnLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBvdXIgcGVuZGluZyB0cmFuc2ZlcnNcbiAgICAgICAgcmFpZGVuLnRyYW5zZmVycyQuc3Vic2NyaWJlKHRyYW5zZmVyID0+IHtcbiAgICAgICAgICBpZiAodHJhbnNmZXIuaW5pdGlhdG9yID09PSBhY2NvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlLmNvbW1pdCgndXBkYXRlVHJhbnNmZXJzJywgdHJhbnNmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zdG9yZS5jb21taXQoJ25ldHdvcmsnLCByYWlkZW4ubmV0d29yayk7XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsICgpID0+IHRoaXMucmFpZGVuLnN0b3AoKSk7XG4gICAgICAgIHJhaWRlbi5zdGFydCgpO1xuICAgICAgICB0aGlzLnN0b3JlLmNvbW1pdCgnYmFsYW5jZScsIGF3YWl0IHRoaXMuZ2V0QmFsYW5jZSgpKTtcbiAgICAgICAgaWYgKHN1YmtleSkge1xuICAgICAgICAgIHRoaXMuc3RvcmUuY29tbWl0KFxuICAgICAgICAgICAgJ3JhaWRlbkFjY291bnRCYWxhbmNlJyxcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0QmFsYW5jZShyYWlkZW4uYWRkcmVzcylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbGV0IGRlbmllZFJlYXNvbjogRGVuaWVkUmVhc29uO1xuICAgICAgaWYgKGUubWVzc2FnZSAmJiBlLm1lc3NhZ2UuaW5kZXhPZignTm8gZGVwbG95IGluZm8gcHJvdmlkZWQnKSA+IC0xKSB7XG4gICAgICAgIGRlbmllZFJlYXNvbiA9IERlbmllZFJlYXNvbi5VTlNVUFBPUlRFRF9ORVRXT1JLO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgZS5tZXNzYWdlICYmXG4gICAgICAgIGUubWVzc2FnZS5pbmRleE9mKCdDb3VsZCBub3QgcmVwbGFjZSBzdG9yZWQgc3RhdGUnKSA+IC0xXG4gICAgICApIHtcbiAgICAgICAgZGVuaWVkUmVhc29uID0gRGVuaWVkUmVhc29uLlJETl9TVEFURV9NSUdSQVRJT047XG4gICAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBSYWlkZW5Jbml0aWFsaXphdGlvbkZhaWxlZCkge1xuICAgICAgICBkZW5pZWRSZWFzb24gPSBEZW5pZWRSZWFzb24uSU5JVElBTElaQVRJT05fRkFJTEVEO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVuaWVkUmVhc29uID0gRGVuaWVkUmVhc29uLk5PX0FDQ09VTlQ7XG4gICAgICB9XG4gICAgICB0aGlzLnN0b3JlLmNvbW1pdCgnYWNjZXNzRGVuaWVkJywgZGVuaWVkUmVhc29uKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JlLmNvbW1pdCgnbG9hZENvbXBsZXRlJyk7XG4gIH1cblxuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMucmFpZGVuLnN0b3AoKTtcbiAgfVxuXG4gIGFzeW5jIGdldEFjY291bnQoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5yYWlkZW4uYWRkcmVzcztcbiAgfVxuXG4gIGFzeW5jIGdldEJhbGFuY2UoYWRkcmVzcz86IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IHRoaXMucmFpZGVuLmdldEJhbGFuY2UoYWRkcmVzcyk7XG4gICAgcmV0dXJuIEJhbGFuY2VVdGlscy50b0V0aChiYWxhbmNlKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0VG9rZW4odG9rZW5BZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPFRva2VuIHwgbnVsbD4ge1xuICAgIGNvbnN0IHJhaWRlbiA9IHRoaXMucmFpZGVuO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBbYmFsYW5jZSwgeyBkZWNpbWFscywgc3ltYm9sLCBuYW1lIH1dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICByYWlkZW4uZ2V0VG9rZW5CYWxhbmNlKHRva2VuQWRkcmVzcyksXG4gICAgICAgIHJhaWRlbi5nZXRUb2tlbkluZm8odG9rZW5BZGRyZXNzKVxuICAgICAgXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBzeW1ib2w6IHN5bWJvbCxcbiAgICAgICAgYmFsYW5jZTogYmFsYW5jZSxcbiAgICAgICAgZGVjaW1hbHM6IGRlY2ltYWxzLFxuICAgICAgICBhZGRyZXNzOiB0b2tlbkFkZHJlc3NcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgb3BlbkNoYW5uZWwoXG4gICAgdG9rZW46IHN0cmluZyxcbiAgICBwYXJ0bmVyOiBzdHJpbmcsXG4gICAgYW1vdW50OiBCaWdOdW1iZXIsXG4gICAgcHJvZ3Jlc3M/OiAocHJvZ3Jlc3M6IFByb2dyZXNzKSA9PiB2b2lkXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHByb2dyZXNzVXBkYXRlciA9IChjdXJyZW50OiBudW1iZXIsIHRvdGFsOiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICBwcm9ncmVzcyh7XG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB0b3RhbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmFpZGVuID0gdGhpcy5yYWlkZW47XG4gICAgcHJvZ3Jlc3NVcGRhdGVyKDEsIDMpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHJhaWRlbi5vcGVuQ2hhbm5lbCh0b2tlbiwgcGFydG5lciwgeyBkZXBvc2l0OiBhbW91bnQgfSwgZSA9PlxuICAgICAgICBlLnR5cGUgPT09IEV2ZW50VHlwZXMuT1BFTkVEID8gcHJvZ3Jlc3NVcGRhdGVyKDIsIDMpIDogJydcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IENoYW5uZWxPcGVuRmFpbGVkKGUpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNsb3NlQ2hhbm5lbCh0b2tlbjogc3RyaW5nLCBwYXJ0bmVyOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5yYWlkZW4uY2xvc2VDaGFubmVsKHRva2VuLCBwYXJ0bmVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgQ2hhbm5lbENsb3NlRmFpbGVkKGUpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRlcG9zaXQodG9rZW46IHN0cmluZywgcGFydG5lcjogc3RyaW5nLCBhbW91bnQ6IEJpZ051bWJlcikge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnJhaWRlbi5kZXBvc2l0Q2hhbm5lbCh0b2tlbiwgcGFydG5lciwgYW1vdW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgQ2hhbm5lbERlcG9zaXRGYWlsZWQoZSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2V0dGxlQ2hhbm5lbCh0b2tlbjogc3RyaW5nLCBwYXJ0bmVyOiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5yYWlkZW4uc2V0dGxlQ2hhbm5lbCh0b2tlbiwgcGFydG5lcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IENoYW5uZWxTZXR0bGVGYWlsZWQoZSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hUb2tlbkRhdGEodG9rZW5zOiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdG9rZW5zLmxlbmd0aCkgcmV0dXJuO1xuICAgIGNvbnN0IGZldGNoVG9rZW4gPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PlxuICAgICAgdGhpcy5nZXRUb2tlbihhZGRyZXNzKS50aGVuKHRva2VuID0+IHtcbiAgICAgICAgaWYgKCF0b2tlbikgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0b3JlLmNvbW1pdCgndXBkYXRlVG9rZW5zJywgeyBbdG9rZW4uYWRkcmVzc106IHRva2VuIH0pO1xuICAgICAgfSk7XG5cbiAgICBhd2FpdCBhc3luY1Bvb2woNiwgdG9rZW5zLCBmZXRjaFRva2VuKTtcbiAgfVxuXG4gIGFzeW5jIHRyYW5zZmVyKFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgdGFyZ2V0OiBzdHJpbmcsXG4gICAgYW1vdW50OiBCaWdOdW1iZXIsXG4gICAgcGF0aHM6IFJhaWRlblBhdGhzLFxuICAgIHBheW1lbnRJZDogQmlnTnVtYmVyXG4gICkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZWNyZXRIYXNoID0gYXdhaXQgdGhpcy5yYWlkZW4udHJhbnNmZXIodG9rZW4sIHRhcmdldCwgYW1vdW50LCB7XG4gICAgICAgIHBheW1lbnRJZCxcbiAgICAgICAgcGF0aHNcbiAgICAgIH0pO1xuXG4gICAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiB0byBiZSBjb21wbGV0ZWRcbiAgICAgIGF3YWl0IHRoaXMucmFpZGVuLndhaXRUcmFuc2ZlcihzZWNyZXRIYXNoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgVHJhbnNmZXJGYWlsZWQoZSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZmluZFJvdXRlcyhcbiAgICB0b2tlbjogc3RyaW5nLFxuICAgIHRhcmdldDogc3RyaW5nLFxuICAgIGFtb3VudDogQmlnTnVtYmVyLFxuICAgIHJhaWRlblBGUz86IFJhaWRlblBGU1xuICApOiBQcm9taXNlPFJhaWRlblBhdGhzPiB7XG4gICAgbGV0IHJvdXRlczogUmFpZGVuUGF0aHM7XG5cbiAgICBhd2FpdCB0aGlzLnJhaWRlbi5nZXRBdmFpbGFiaWxpdHkodGFyZ2V0KTtcbiAgICByb3V0ZXMgPSBhd2FpdCB0aGlzLnJhaWRlbi5maW5kUm91dGVzKHRva2VuLCB0YXJnZXQsIGFtb3VudCwge1xuICAgICAgcGZzOiByYWlkZW5QRlNcbiAgICB9KTtcblxuICAgIHJldHVybiByb3V0ZXM7XG4gIH1cblxuICBhc3luYyBmZXRjaFNlcnZpY2VzKCk6IFByb21pc2U8UmFpZGVuUEZTW10+IHtcbiAgICBsZXQgcmFpZGVuUEZTOiBSYWlkZW5QRlNbXTtcbiAgICByYWlkZW5QRlMgPSBhd2FpdCB0aGlzLnJhaWRlbi5maW5kUEZTKCk7XG4gICAgcmV0dXJuIHJhaWRlblBGUztcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGFzeW5jIGRpcmVjdFJvdXRlKFxuICAgIHRva2VuOiBzdHJpbmcsXG4gICAgdGFyZ2V0OiBzdHJpbmcsXG4gICAgdmFsdWU6IEJpZ051bWJlcmlzaFxuICApOiBQcm9taXNlPFJhaWRlblBhdGhzIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmFpZGVuLmRpcmVjdFJvdXRlKHRva2VuLCB0YXJnZXQsIHZhbHVlKTtcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGFzeW5jIG1pbnQodG9rZW46IHN0cmluZywgYW1vdW50OiBCaWdOdW1iZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnJhaWRlbi5taW50KHRva2VuLCBhbW91bnQpO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgYXN5bmMgZGVwb3NpdFRvVURDKGFtb3VudDogQmlnTnVtYmVyLCBkZXBvc2l0aW5nOiAoKSA9PiB2b2lkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5yYWlkZW4uZGVwb3NpdFRvVURDKFxuICAgICAgYW1vdW50LFxuICAgICAgKGV2ZW50OiBDaGFuZ2VFdmVudDxFdmVudFR5cGVzLCB7IHR4SGFzaDogc3RyaW5nIH0+KSA9PlxuICAgICAgICBldmVudC50eXBlID09PSBFdmVudFR5cGVzLkFQUFJPVkVEID8gZGVwb3NpdGluZygpIDogbnVsbFxuICAgICk7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBhc3luYyBnZXRVRENDYXBhY2l0eSgpOiBQcm9taXNlPEJpZ051bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLnJhaWRlbi5nZXRVRENDYXBhY2l0eSgpO1xuICB9XG5cbiAgYXN5bmMgZ2V0QXZhaWxhYmlsaXR5KGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGF2YWlsYWJsZSB9ID0gYXdhaXQgdGhpcy5yYWlkZW4uZ2V0QXZhaWxhYmlsaXR5KGFkZHJlc3MpO1xuICAgICAgcmV0dXJuIGF2YWlsYWJsZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLnN0b3JlLmNvbW1pdCgndXBkYXRlUHJlc2VuY2UnLCB7IFthZGRyZXNzXTogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgYXN5bmMgZ2V0U3RhdGUoKSB7XG4gICAgdGhpcy5fcmFpZGVuPy5zdG9wKCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JhaWRlbj8uc3RhdGUkLnRvUHJvbWlzZSgpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDaGFubmVsU2V0dGxlRmFpbGVkIGV4dGVuZHMgRXJyb3Ige31cblxuZXhwb3J0IGNsYXNzIENoYW5uZWxDbG9zZUZhaWxlZCBleHRlbmRzIEVycm9yIHt9XG5cbmV4cG9ydCBjbGFzcyBDaGFubmVsT3BlbkZhaWxlZCBleHRlbmRzIEVycm9yIHt9XG5cbmV4cG9ydCBjbGFzcyBDaGFubmVsRGVwb3NpdEZhaWxlZCBleHRlbmRzIEVycm9yIHt9XG5cbmV4cG9ydCBjbGFzcyBFbnNSZXNvbHZlRmFpbGVkIGV4dGVuZHMgRXJyb3Ige31cblxuZXhwb3J0IGNsYXNzIFRyYW5zZmVyRmFpbGVkIGV4dGVuZHMgRXJyb3Ige31cblxuZXhwb3J0IGNsYXNzIFJhaWRlbkluaXRpYWxpemF0aW9uRmFpbGVkIGV4dGVuZHMgRXJyb3Ige31cbiIsImltcG9ydCBfVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgUmFpZGVuU2VydmljZSBmcm9tICdAL3NlcnZpY2VzL3JhaWRlbi1zZXJ2aWNlJztcbmltcG9ydCBzdG9yZSBmcm9tICdAL3N0b3JlL2luZGV4JztcblxuZXhwb3J0IGZ1bmN0aW9uIFJhaWRlblBsdWdpbihWdWU6IHR5cGVvZiBfVnVlLCBfb3B0aW9ucz86IGFueSk6IHZvaWQge1xuICBWdWUucHJvdG90eXBlLiRyYWlkZW4gPSBuZXcgUmFpZGVuU2VydmljZShzdG9yZSk7XG59XG5cbmRlY2xhcmUgbW9kdWxlICd2dWUvdHlwZXMvdnVlJyB7XG4gIC8vIDMuIERlY2xhcmUgYXVnbWVudGF0aW9uIGZvciBWdWVcbiAgaW50ZXJmYWNlIFZ1ZSB7XG4gICAgJHJhaWRlbjogUmFpZGVuU2VydmljZTtcbiAgfVxufVxuIiwiaW1wb3J0IG1ha2VCbG9ja2llIGZyb20gJ2V0aGVyZXVtLWJsb2NraWVzLWJhc2U2NCc7XG5cbmV4cG9ydCBjbGFzcyBJZGVudGljb25DYWNoZSB7XG4gIHByaXZhdGUgY2FjaGU6IHsgW2lkOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICBwdWJsaWMgZ2V0SWRlbnRpY29uKGFkZHJlc3M6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5jYWNoZVthZGRyZXNzXTtcblxuICAgIGlmICghY2FjaGVkKSB7XG4gICAgICBjb25zdCBnZW5lcmF0ZWQgPSBtYWtlQmxvY2tpZShhZGRyZXNzKTtcbiAgICAgIHRoaXMuY2FjaGVbYWRkcmVzc10gPSBnZW5lcmF0ZWQ7XG4gICAgICByZXR1cm4gZ2VuZXJhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IF9WdWUgZnJvbSAndnVlJztcbmltcG9ydCB7IElkZW50aWNvbkNhY2hlIH0gZnJvbSAnQC9zZXJ2aWNlcy9pZGVudGljb24tY2FjaGUnO1xuXG5leHBvcnQgZnVuY3Rpb24gSWRlbnRpY29uUGx1Z2luKFZ1ZTogdHlwZW9mIF9WdWUsIF9vcHRpb25zPzogYW55KTogdm9pZCB7XG4gIFZ1ZS5wcm90b3R5cGUuJGlkZW50aWNvbiA9IG5ldyBJZGVudGljb25DYWNoZSgpO1xufVxuXG5kZWNsYXJlIG1vZHVsZSAndnVlL3R5cGVzL3Z1ZScge1xuICAvLyAzLiBEZWNsYXJlIGF1Z21lbnRhdGlvbiBmb3IgVnVlXG4gIGludGVyZmFjZSBWdWUge1xuICAgICRpZGVudGljb246IElkZW50aWNvbkNhY2hlO1xuICB9XG59XG4iLCIvKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IFZ1ZUkxOG4sIHsgTG9jYWxlTWVzc2FnZXMgfSBmcm9tICd2dWUtaTE4bic7XG5cblZ1ZS51c2UoVnVlSTE4bik7XG5cbmZ1bmN0aW9uIGxvYWRMb2NhbGVNZXNzYWdlcygpOiBMb2NhbGVNZXNzYWdlcyB7XG4gIGNvbnN0IGxvY2FsZXMgPSByZXF1aXJlLmNvbnRleHQoXG4gICAgJy4vbG9jYWxlcycsXG4gICAgdHJ1ZSxcbiAgICAvW0EtWmEtejAtOS1fLFxcc10rXFwuanNvbiQvaVxuICApO1xuICBjb25zdCBtZXNzYWdlczogTG9jYWxlTWVzc2FnZXMgPSB7fTtcbiAgbG9jYWxlcy5rZXlzKCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IG1hdGNoZWQgPSBrZXkubWF0Y2goLyhbQS1aYS16MC05LV9dKylcXC4vaSk7XG4gICAgaWYgKG1hdGNoZWQgJiYgbWF0Y2hlZC5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBsb2NhbGUgPSBtYXRjaGVkWzFdO1xuICAgICAgbWVzc2FnZXNbbG9jYWxlXSA9IGxvY2FsZXMoa2V5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWVzc2FnZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBWdWVJMThuKHtcbiAgbG9jYWxlOiBwcm9jZXNzLmVudi5WVUVfQVBQX0kxOE5fTE9DQUxFIHx8ICdlbicsXG4gIGZhbGxiYWNrTG9jYWxlOiBwcm9jZXNzLmVudi5WVUVfQVBQX0kxOE5fRkFMTEJBQ0tfTE9DQUxFIHx8ICdlbicsXG4gIG1lc3NhZ2VzOiBsb2FkTG9jYWxlTWVzc2FnZXMoKVxufSk7XG4iLCIvKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuaW1wb3J0ICdAbWRpL2ZvbnQvY3NzL21hdGVyaWFsZGVzaWduaWNvbnMuY3NzJztcbmltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCBWdWV0aWZ5IGZyb20gJ3Z1ZXRpZnkvbGliJztcblxuVnVlLnVzZShWdWV0aWZ5KTtcblxuZXhwb3J0IGRlZmF1bHQgbmV3IFZ1ZXRpZnkoe1xuICBpY29uczoge1xuICAgIGljb25mb250OiAnbWRpJ1xuICB9LFxuICB0aGVtZToge1xuICAgIGRhcms6IHRydWUsXG4gICAgdGhlbWVzOiB7XG4gICAgICBkYXJrOiB7XG4gICAgICAgIHByaW1hcnk6ICcjMjhBNUM4JyxcbiAgICAgICAgc2Vjb25kYXJ5OiAnIzBBNkU4NydcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cblxuaW1wb3J0IHsgcmVnaXN0ZXIgfSBmcm9tICdyZWdpc3Rlci1zZXJ2aWNlLXdvcmtlcic7XG5cbmlmIChcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJlxuICAhcHJvY2Vzcy5lbnYuVlVFX0FQUF9SQUlERU5fUEFDS0FHRVxuKSB7XG4gIHJlZ2lzdGVyKGAke3Byb2Nlc3MuZW52LkJBU0VfVVJMfXNlcnZpY2Utd29ya2VyLmpzYCwge1xuICAgIHJlYWR5KCkge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICdBcHAgaXMgYmVpbmcgc2VydmVkIGZyb20gY2FjaGUgYnkgYSBzZXJ2aWNlIHdvcmtlci5cXG4nICtcbiAgICAgICAgICAnRm9yIG1vcmUgZGV0YWlscywgdmlzaXQgaHR0cHM6Ly9nb28uZ2wvQUZza3FCJ1xuICAgICAgKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyZWQocmVnaXN0cmF0aW9uOiBTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uKSB7XG4gICAgICAvLyBDaGVjayBwZXJpb2RpY2FsbHkgZm9yIHVwZGF0ZXMgZXZlcnkgbWludXRlXG4gICAgICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHJlZ2lzdHJhdGlvbi51cGRhdGUoKTtcbiAgICAgIH0sIDEwMDAgKiA2MCk7XG4gICAgICBjb25zb2xlLmxvZygnU2VydmljZSB3b3JrZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZC4nKTtcbiAgICB9LFxuICAgIGNhY2hlZCgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdDb250ZW50IGhhcyBiZWVuIGNhY2hlZCBmb3Igb2ZmbGluZSB1c2UuJyk7XG4gICAgfSxcbiAgICB1cGRhdGVmb3VuZCgpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdOZXcgY29udGVudCBpcyBkb3dubG9hZGluZy4nKTtcbiAgICB9LFxuICAgIHVwZGF0ZWQocmVnaXN0cmF0aW9uOiBTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uKSB7XG4gICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KFxuICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoJ3N3VXBkYXRlZCcsIHsgZGV0YWlsOiByZWdpc3RyYXRpb24gfSlcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZygnTmV3IGNvbnRlbnQgaXMgYXZhaWxhYmxlOyBwbGVhc2UgcmVmcmVzaC4nKTtcbiAgICB9LFxuICAgIG9mZmxpbmUoKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgJ05vIGludGVybmV0IGNvbm5lY3Rpb24gZm91bmQuIEFwcCBpcyBydW5uaW5nIGluIG9mZmxpbmUgbW9kZS4nXG4gICAgICApO1xuICAgIH0sXG4gICAgZXJyb3IoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBzZXJ2aWNlIHdvcmtlciByZWdpc3RyYXRpb246JywgZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59XG4iLCIvKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IEFwcCBmcm9tICcuL0FwcC52dWUnO1xuaW1wb3J0ICdAL3BsdWdpbnMvY2xhc3MtY29tcG9uZW50Lmhvb2tzJztcbmltcG9ydCAnQC9maWx0ZXJzJztcbmltcG9ydCByb3V0ZXIgZnJvbSAnLi9yb3V0ZXIvaW5kZXgnO1xuaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmUvaW5kZXgnO1xuaW1wb3J0IHsgc2V0dXBMb2dTdG9yZSB9IGZyb20gJy4vdXRpbHMvbG9nc3RvcmUnO1xuaW1wb3J0ICcuL2NsYXNzLWNvbXBvbmVudC1ob29rcyc7XG5pbXBvcnQgeyBSYWlkZW5QbHVnaW4gfSBmcm9tICdAL3BsdWdpbnMvcmFpZGVuJztcbmltcG9ydCB7IElkZW50aWNvblBsdWdpbiB9IGZyb20gJ0AvcGx1Z2lucy9pZGVudGljb24tcGx1Z2luJztcbmltcG9ydCBpMThuIGZyb20gJy4vaTE4bic7XG5pbXBvcnQgdnVldGlmeSBmcm9tICdAL3BsdWdpbnMvdnVldGlmeSc7XG5pbXBvcnQgVnVlVmlydHVhbFNjcm9sbGVyIGZyb20gJ3Z1ZS12aXJ0dWFsLXNjcm9sbGVyJztcbmltcG9ydCAndnVlLXZpcnR1YWwtc2Nyb2xsZXIvZGlzdC92dWUtdmlydHVhbC1zY3JvbGxlci5jc3MnO1xuaW1wb3J0ICcuL3JlZ2lzdGVyU2VydmljZVdvcmtlcic7XG5cblZ1ZS5jb25maWcucHJvZHVjdGlvblRpcCA9IGZhbHNlO1xuXG5zZXR1cExvZ1N0b3JlKCk7XG5cblZ1ZS51c2UoUmFpZGVuUGx1Z2luKTtcblZ1ZS51c2UoSWRlbnRpY29uUGx1Z2luKTtcblZ1ZS51c2UoVnVlVmlydHVhbFNjcm9sbGVyKTtcblxubmV3IFZ1ZSh7XG4gIHZ1ZXRpZnksXG4gIHJvdXRlcixcbiAgc3RvcmUsXG4gIGkxOG4sXG4gIHJlbmRlcjogaCA9PiBoKEFwcClcbn0pLiRtb3VudCgnI2FwcCcpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///cd49\n')},df2d:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9CbHVycmVkT3ZlcmxheS52dWU/MjMyNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJkZjJkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///df2d\n")},e1fc:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9BZGRyZXNzRGlzcGxheS52dWU/MTJkNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJlMWZjLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///e1fc\n")},edd4:function(module){eval('module.exports = JSON.parse("{\\"home\\":{\\"welcome\\":\\"Welcome to the Raiden dApp\\",\\"connect-button\\":\\"Connect\\",\\"disclaimer\\":\\"The Raiden dApp is a reference implementation of the Raiden Light Client SDK. It is work in progress and can only be used on Ethereum testnets.\\",\\"getting-started\\":{\\"description\\":\\"Read the {0} for detailed information on how to use the Raiden dApp.\\",\\"link-name\\":\\"getting started guide\\"},\\"connect-dialog\\":{\\"connect-title\\":\\"Connect\\",\\"divider\\":\\"-OR-\\",\\"web3-provider\\":\\"Use Web3 Provider\\",\\"raiden-account\\":{\\"description\\":\\"Connect to Web3 and re-generate a {0}\\",\\"link-name\\":\\"dedicated Raiden account.\\"},\\"no-provider\\":\\"No Web3 provider detected, please install e.g. MetaMask.\\"}},\\"general\\":{\\"buttons\\":{\\"cancel\\":\\"Cancel\\",\\"transfer\\":\\"Transfer\\",\\"continue\\":\\"Continue\\",\\"confirm\\":\\"Confirm\\"},\\"offline\\":\\"Please connect to the internet.\\"},\\"general-menu\\":{\\"account-details\\":\\"Account Details\\",\\"address\\":\\"Address:\\",\\"currency\\":\\"ETH:\\",\\"menu-items\\":{\\"backup-state-title\\":\\"Backup state\\",\\"backup-state-subtitle\\":\\"Download & upload your state\\",\\"report-bugs-title\\":\\"Report bugs\\",\\"report-bugs-subtitle\\":\\"Download logs\\"}},\\"backup-state\\":{\\"description\\":\\"The state holds all account information except the private key. You can backup your state to make sure the dApp is kept in sync when switching between browsers.\\",\\"disabled-download\\":\\"Downloading the state is only possible when connected to the dApp\\",\\"disabled-upload\\":\\"Uploading the state is only possible when the dApp is disconnected\\",\\"download\\":\\"Download State\\",\\"download-warning\\":\\"Downloading the state will force the dApp to shut down\\",\\"download-button\\":\\"Download\\",\\"upload\\":\\"Upload State\\",\\"upload-drag-and-drop\\":\\"Drag and drop state file\\",\\"upload-divider\\":\\"or\\",\\"upload-button\\":\\"Browse files\\",\\"upload-error\\":\\"Only one state file in valid JSON format can be uploaded\\"},\\"update\\":{\\"available\\":\\"A new version is available.\\",\\"update\\":\\"Refresh\\"},\\"address-input\\":{\\"input\\":{\\"placeholder\\":\\"Enter an address or ENS name...\\"},\\"blockie-alt\\":\\"Selected token address blockie\\",\\"error\\":{\\"invalid-address\\":\\"Please enter a valid address or ENS name\\",\\"no-checksum\\":\\"Please enter an address in checksum format. You can convert your address on https://ethsum.netlify.com\\",\\"empty\\":\\"Please enter an address or ENS name\\",\\"ens-resolve-failed\\":\\"Please enter a resolvable ENS name\\",\\"invalid-excluded-address\\":\\"Please enter a different address or ENS name. You can\'t use your own address or the address of the token network.\\",\\"channel-not-open\\":\\"Please enter a hub address you have an open channel with.\\",\\"target-offline\\":\\"Target is offline.\\"}},\\"amount-input\\":{\\"input\\":{\\"hint\\":\\"Please enter an amount\\"},\\"error\\":{\\"empty\\":\\"Please enter an amount\\",\\"too-many-decimals\\":\\"Please use only up to {decimals} decimals for this token\\",\\"not-enough-funds\\":\\"Your maximum usable amount is {funds} {symbol}\\",\\"zero\\":\\"Please enter an amount larger than zero\\",\\"invalid\\":\\"Please enter a valid amount\\"}},\\"address-display\\":{\\"copy\\":\\"Click to copy\\",\\"copied\\":\\"Copied!\\"},\\"app-header\\":{\\"currency\\":\\"ETH\\",\\"pending-transfers\\":\\"no pending transfers | 1 pending transfer | {amount} pending transfers\\"},\\"channel-actions\\":{\\"deposit\\":\\"Deposit\\",\\"close\\":\\"Close\\",\\"settle\\":\\"Settle\\"},\\"channel-deposit\\":{\\"buttons\\":{\\"confirm\\":\\"Deposit\\"},\\"input\\":{\\"label\\":\\"Amount\\"}},\\"find-routes\\":{\\"hops\\":\\"Hops\\",\\"price\\":\\"Price\\",\\"sub-title\\":\\"Route(s) provided by {subdomain} including number of hops and estimated fee\\",\\"error\\":{\\"title\\":\\"Oops, something went wrong\\"}},\\"stepper\\":{\\"steps\\":{\\"open\\":{\\"title\\":\\"Open\\",\\"description\\":\\"You can deposit more tokens \\\\n or close the channel.\\"},\\"closed\\":{\\"title\\":\\"Closed\\",\\"description\\":\\"Please wait until your channel is settleable. \\\\nthis may take some time.\\"},\\"settleable\\":{\\"title\\":\\"Settleable\\",\\"description\\":\\"Settle your channel to transfer \\\\n your tokens back to your account.\\"}}},\\"channels\\":{\\"open\\":{\\"header\\":\\"Open\\"},\\"closed\\":{\\"header\\":\\"Closed\\"},\\"settleable\\":{\\"header\\":\\"Settleable\\"},\\"snackbar-close\\":\\"Close\\"},\\"channel-list\\":{\\"channel\\":{\\"blockie_alt\\":\\"Partner address blockie\\",\\"state\\":\\"Deposit {deposit} | State: {state}\\",\\"close_dialog\\":{\\"title\\":\\"Close Channel\\",\\"description\\":\\"Are you sure you want to close this channel? This action cannot be undone.\\"},\\"settle_dialog\\":{\\"title\\":\\"Settle Channel\\",\\"description\\":\\"Are you sure you want to settle the channel with hub {partner} for token {token}?\\"}},\\"messages\\":{\\"close\\":{\\"success\\":\\"Channel closed successfully\\",\\"failure\\":\\"Channel close failed\\"},\\"deposit\\":{\\"success\\":\\"Deposit was successful\\",\\"failure\\":\\"Deposit failed\\"},\\"settle\\":{\\"success\\":\\"Channel settle was successful\\",\\"failure\\":\\"Channel settle failed\\"}}},\\"confirmation\\":{\\"buttons\\":{\\"cancel\\":\\"Cancel\\",\\"close\\":\\"Close\\",\\"settle\\":\\"Settle\\"}},\\"confirmation-dialog\\":{\\"buttons\\":{\\"cancel\\":\\"Cancel\\",\\"confirm\\":\\"Confirm\\"}},\\"error-screen\\":{\\"title\\":\\"Error\\"},\\"no-access\\":{\\"unsupported-network\\":\\"The current network is unsupported. Please choose a different network.\\",\\"sdk-initialization-failure\\":\\"SDK initialization failed. Please check the console for more information.\\",\\"rdn-state-migration\\":\\"Cannot replace state with older uploaded state.\\",\\"generic-error\\":\\"A valid account could not be detected. Please make sure that your provider is unlocked and accessible.\\"},\\"tokens\\":{\\"connected\\":{\\"header\\":\\"Connected Tokens\\",\\"token\\":{\\"blockie-alt\\":\\"Partner address blockie\\",\\"token-info\\":\\"{symbol} | {name}\\",\\"buttons\\":{\\"disconnect\\":\\"Disconnect Token\\",\\"view-channels\\":\\"View Channels\\"}}},\\"connect-new\\":\\"Connect new token\\",\\"disconnect-dialog\\":{\\"header\\":\\"Disconnect token\\",\\"confirmation-message\\":\\"This action will close all channels for the {symbol} token! {address}\\"},\\"leave-progress\\":{\\"label\\":\\"Disconnect\\",\\"title\\":\\"Disconnecting from the token network\\",\\"description\\":\\"Closing the channels\\"},\\"leave-done\\":{\\"label\\":\\"Done\\",\\"title\\":\\"Disconnected from the token network\\",\\"description\\":\\"All your channels were successfully closed\\"}},\\"application\\":{\\"privacy-policy\\":\\"Privacy Policy, Disclaimer & Imprint\\"},\\"mint-deposit-dialog\\":{\\"button\\":\\"Mint and deposit\\",\\"available\\":\\"Available {currency} to pay for on-chain transaction: {balance} {currency}\\",\\"error\\":\\"The mint and deposit operation failed.\\",\\"progress\\":{\\"mint\\":\\"Minting {currency} tokens\\",\\"approve\\":\\"Allow UDC to access {currency} tokens\\",\\"deposit\\":\\"Deposit {currency} tokens to the UDC\\"}},\\"transfer\\":{\\"deposit-button\\":\\"Deposit\\",\\"channel-button\\":\\"Channels\\",\\"capacity-label\\":\\"Capacity\\",\\"recipient-label\\":\\"Recipient\\",\\"amount-label\\":\\"Amount\\",\\"amount-placeholder\\":\\"Specify amount...\\",\\"error\\":{\\"button\\":\\"Dismiss\\",\\"title\\":\\"Token transfer unsuccessful\\",\\"deposit-title\\":\\"Deposit failed, please try again.\\"},\\"steps\\":{\\"request-route\\":{\\"title\\":\\"Request Route\\",\\"tooltip\\":\\"Mint and deposit {token} to the User Deposit Contract to pay for PFS requests\\",\\"udc-description\\":\\"Balance to pay the Pathfinding Service\\",\\"udc-description-low-balance\\":\\"Your {token} token balance is to low to pay for the Pathfinding Service. Use the button above to mint and deposit more tokens.\\",\\"in-progress\\":\\"Paying for the route request\\",\\"searching-for-route\\":\\"Searching for route...\\",\\"done\\":\\"Route request payment complete\\"},\\"select-route\\":{\\"title\\":\\"Select Route\\"},\\"confirm-transfer\\":{\\"title\\":\\"Confirm Transfer\\",\\"total-amount\\":\\"Total Amount\\"},\\"call-to-action\\":{\\"1\\":{\\"default\\":\\"Transfer Route Request\\",\\"amount\\":\\"Confirm PFS Fee of {amount} {symbol}\\"},\\"2\\":{\\"default\\":\\"Confirm Mediation Fees\\",\\"amount\\":\\"Confirm Mediation Fee of {amount} {symbol}\\"},\\"3\\":{\\"amount\\":\\"Transfer {amount} {symbol}\\"}},\\"transfer\\":{\\"title\\":\\"Transferring Tokens\\",\\"description\\":\\"Sign the transaction in MetaMask and close this dialogue to continue using the dApp. Your transfer will finish in the background.\\"},\\"done\\":{\\"title\\":\\"Send Successful\\",\\"description\\":\\"Your transfer was successful.\\"},\\"deposit\\":{\\"label\\":\\"Deposit\\",\\"title\\":\\"Depositing Tokens\\",\\"description\\":\\"Sign the transaction in MetaMask and close this dialogue to continue using the dApp.\\"},\\"deposit-done\\":{\\"label\\":\\"Done\\",\\"title\\":\\"Deposit Successful\\",\\"description\\":\\"Your tokens have been successfully deposited.\\"},\\"summary\\":{\\"headline\\":\\"Summary\\",\\"route-request\\":\\"Route Request\\",\\"pfs\\":\\"Pathfinding Service\\",\\"service-fee\\":\\"Service Fee\\",\\"mediated-transfer\\":\\"Mediated Transfer\\",\\"direct-transfer\\":\\"Direct Transfer\\",\\"target\\":\\"Target\\",\\"transfer-amount\\":\\"Transfer Amount\\",\\"total-amount\\":\\"Total Amount\\",\\"mediation-fee\\":\\"Mediation Fee\\",\\"identifier\\":\\"Identifier\\",\\"footnotes\\":{\\"one\\":\\"1\\",\\"direct-transfer\\":\\"Route request and selection skipped, because you are performing a direct transfer.\\",\\"route-selection-skipped\\":\\"Automatically skipped route selection, because there was only a single route with zero fees.\\"}}}},\\"select-token\\":{\\"header\\":\\"Available\\",\\"tokens\\":{\\"token\\":{\\"blockie-alt\\":\\"Token address blockie\\",\\"token-information\\":\\"{symbol} | {name}\\"}}},\\"select-hub\\":{\\"select-button\\":\\"Select Hub\\"},\\"open-channel\\":{\\"error\\":{\\"title\\":\\"Ops, something went wrong\\",\\"button\\":\\"Dismiss\\",\\"deposit-failed\\":\\"Could not deposit to the channel.\\",\\"open-failed\\":\\"Channel open failed.\\"},\\"open-button\\":\\"Open Channel\\",\\"hub\\":\\"Hub\\",\\"steps\\":{\\"open\\":{\\"label\\":\\"Open\\",\\"title\\":\\"Opening a new channel\\",\\"description\\":\\"Please do not close the browser and confirm the transaction with MetaMask.\\"},\\"transfer\\":{\\"label\\":\\"Transfer\\",\\"title\\":\\"Transferring tokens to the network and deposit into the channel\\",\\"description\\":\\"Please do not close the browser and confirm two (2) transactions with MetaMask.\\"},\\"deposit\\":{\\"label\\":\\"Deposit\\",\\"title\\":\\"Not implemented - split title above, when done\\",\\"description\\":\\"Not implemented - split description above, when done\\"},\\"done\\":{\\"label\\":\\"Done\\",\\"title\\":\\"New Channel opened\\",\\"description\\":\\"A new channel was successfully opened. You can now start making transfers.\\"}},\\"confirmation\\":\\"Channel opening is in progress, are you sure you want to leave?\\"},\\"token-information\\":{\\"title\\":\\"Token\\",\\"description\\":\\"{symbol} | {name}\\",\\"balance\\":\\"Balance\\"},\\"pathfinding-services\\":{\\"title\\":\\"Select Pathfinding Service\\",\\"rtt\\":\\"{time} ms\\",\\"headers\\":{\\"host\\":\\"Pathfinding Service\\",\\"rtt\\":\\"Ping\\",\\"price\\":\\"Price\\"}},\\"mint-dialog\\":{\\"title\\":\\"Mint {symbol}\\",\\"description\\":\\"If you continue, you will get prompted by MetaMask to sign off a minting transction. In order to mint tokens, you need test net ETH in your wallet.\\"},\\"error-message\\":{\\"problem\\":\\"Problem:\\",\\"solution\\":\\"Solution:\\"},\\"errors\\":{\\"RDN_GENERAL_ERROR\\":{\\"title\\":\\"An error occured\\",\\"problem\\":\\"We do not know this error, sorry.\\",\\"solution\\":[\\"Please help us and report the issue\\",\\"Click on your identicon in the top right corner\\",\\"Click on Report Bugs / Download logs\\",\\"File a new issue on https://github.com/raiden-network/light-client\\",\\"Upload logs to the issue\\"]},\\"RDN_MINT_FAILED\\":{\\"title\\":\\"Could not mint token\\",\\"problem\\":\\"It looks like the Light Client does not support minting out-of-the-box for this token contract.\\",\\"solution\\":\\"You may try to mint manually via MetaMask and Etherscan. You can find a step-by-step guide on https://github.com/raiden-network/light-client#minting-manually.\\"},\\"PFS_UNKNOWN_TOKEN_NETWORK\\":{\\"title\\":\\"No open channels\\",\\"problem\\":\\"You don\'t seem to have open channels on this token network.\\",\\"solution\\":[\\"Hit the ← button in the top left\\",\\"Click on the current token network\\",\\"Select Connect new token\\",\\"Select the token you want to transfer\\",\\"Proceed with the flow to open a new channel\\"]},\\"PFS_INVALID_INFO\\":{\\"title\\":\\"Couldn\'t understand Pathfinding Service\\",\\"problem\\":\\"The Light Client has received a response from the Pathfinding Service that it couldn\'t understand. It\'s possible that the current Light Client version is out-of-sync with the Pathfinding Service.\\",\\"solution\\":[\\"Update the dApp by reloading the page\\",\\"Attempt a new transfer\\",\\"If the problem persists, please help us and report the issue\\",\\"Click on your identicon in the top right corner\\",\\"Click on Report Bugs / Download logs\\",\\"File a new issue on https://github.com/raiden-network/light-client\\",\\"Upload logs to the issue\\"]},\\"PFS_NO_ROUTES_FOUND\\":{\\"title\\":\\"No routes found\\",\\"problem\\":\\"Pathfinding Service wasn\'t able to find a route in the Raiden Network to perform your transfer.\\",\\"solution\\":\\"Make sure that you either have a direct channel with the target or that both of you are connected to a well-connected hub.\\"},\\"PFS_ERROR_RESPONSE\\":{\\"title\\":\\"Pathfinding replied with an error\\",\\"problem\\":\\"While communicating with the Pathfinding Service, you have received an error response that we don\'t actively handle yet.\\",\\"solution\\":[\\"Simply retry your last action\\",\\"If the problem persists, please help us and report the issue\\",\\"Click on your identicon in the top right corner\\",\\"Click on Report Bugs / Download logs\\",\\"File a new issue on https://github.com/raiden-network/light-client\\",\\"Upload logs to the issue\\"]},\\"PFS_DISABLED\\":{\\"title\\":\\"Pathfinding Service disabled\\",\\"problem\\":\\"You tried to find a route in the Raiden Network but Pathfinding was either disabled in your configuration or you did not select a valid Pathfinding Service.\\",\\"solution\\":\\"Try to restart the Light Client by reloading the page and attempt a new transfer.\\"},\\"PFS_TARGET_OFFLINE\\":{\\"title\\":\\"Target address is offline\\",\\"problem\\":\\"You are trying to send tokens to an offline target.\\",\\"solution\\":\\"Hit the ← button and verify that the address is online or choose a different target address.\\"},\\"PFS_LAST_IOU_REQUEST_FAILED\\":{\\"title\\":\\"Error while depositing tokens for Pathfinding Service\\",\\"problem\\":\\"While trying to deposit tokens for route requests, the Pathfinding Service returned an error.\\",\\"solution\\":[\\"This should happen very rarely, please retry to deposit\\",\\"If the problem persists, please help us and report the issue\\",\\"Click on your identicon in the top right corner\\",\\"Click on Report Bugs / Download logs\\",\\"File a new issue on https://github.com/raiden-network/light-client\\",\\"Upload logs to the issue\\"]},\\"PFS_IOU_SIGNATURE_MISMATCH\\":{\\"title\\":\\"Error while depositing tokens for Pathfinding Service\\",\\"problem\\":\\"While trying to deposit tokens for route requests, the Pathfinding Service encountered mismatching signatures.\\",\\"solution\\":[\\"This should happen very rarely, please retry to deposit\\",\\"If the problem persists, please help us and report the issue\\",\\"Click on your identicon in the top right corner\\",\\"Click on Report Bugs / Download logs\\",\\"File a new issue on https://github.com/raiden-network/light-client\\",\\"Upload logs to the issue\\"]}},\\"versions\\":{\\"sdk\\":\\"Raiden SDK: {version}\\",\\"contracts\\":\\"Raiden Contracts: {version}\\"},\\"scan\\":{\\"permission\\":{\\"title\\":\\"Grant Camera Access\\",\\"description\\":\\"In order to scan QR codes, you will need to allow camera access.\\"}},\\"progress-steps\\":{\\"transfer\\":{\\"PENDING\\":\\"Transfer sent\\",\\"RECEIVED\\":\\"Transfer acknowledged by partner\\",\\"REFUNDED\\":\\"Transfer refunded\\",\\"CLOSED\\":\\"Channel closed early\\",\\"REVEALED\\":\\"Secret revealed to target\\",\\"UNLOCKING\\":\\"Unlock sent to partner\\",\\"EXPIRING\\":\\"Lock expired\\",\\"UNLOCKED\\":\\"Unlock acknowledged\\",\\"EXPIRED\\":\\"Lock expired acknowledged\\",\\"REQUESTED\\":\\"Secret requested by target\\",\\"REGISTERED\\":\\"Secret registered on-chain\\"}}}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJlZGQ0LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///edd4\n')},f33c:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Db25uZWN0RGlhbG9nLnZ1ZT83ZDA5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImYzM2MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///f33c\n")},f455:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ raiden_Raiden; });\n__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ ChannelState; });\n__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ EventTypes; });\n\n// UNUSED EXPORTS: RaidenState, encodeRaidenState, ShutdownReason, RaidenTransferStatus, RaidenConfig, AssertionError, assert, decode, isntNil, BigNumberC, HexString, Int, UInt, Signature, Hash, Secret, PrivateKey, Address, Timed, timed, Signed, instanceOf, ErrorCodes, ErrorDetails, RaidenError, ErrorCodec\n\n// NAMESPACE OBJECT: ../raiden-ts/dist/channels/actions.js\nvar channels_actions_namespaceObject = {};\n__webpack_require__.r(channels_actions_namespaceObject);\n__webpack_require__.d(channels_actions_namespaceObject, "newBlock", function() { return newBlock; });\n__webpack_require__.d(channels_actions_namespaceObject, "tokenMonitored", function() { return tokenMonitored; });\n__webpack_require__.d(channels_actions_namespaceObject, "channelOpen", function() { return channelOpen; });\n__webpack_require__.d(channels_actions_namespaceObject, "channelMonitor", function() { return channelMonitor; });\n__webpack_require__.d(channels_actions_namespaceObject, "channelDeposit", function() { return channelDeposit; });\n__webpack_require__.d(channels_actions_namespaceObject, "channelWithdrawn", function() { return channelWithdrawn; });\n__webpack_require__.d(channels_actions_namespaceObject, "channelClose", function() { return channelClose; });\n__webpack_require__.d(channels_actions_namespaceObject, "channelSettleable", function() { return channelSettleable; });\n__webpack_require__.d(channels_actions_namespaceObject, "channelSettle", function() { return channelSettle; });\n\n// NAMESPACE OBJECT: ../raiden-ts/dist/transport/actions.js\nvar transport_actions_namespaceObject = {};\n__webpack_require__.r(transport_actions_namespaceObject);\n__webpack_require__.d(transport_actions_namespaceObject, "matrixSetup", function() { return matrixSetup; });\n__webpack_require__.d(transport_actions_namespaceObject, "matrixPresence", function() { return matrixPresence; });\n__webpack_require__.d(transport_actions_namespaceObject, "matrixRoom", function() { return matrixRoom; });\n__webpack_require__.d(transport_actions_namespaceObject, "matrixRoomLeave", function() { return matrixRoomLeave; });\n__webpack_require__.d(transport_actions_namespaceObject, "rtcChannel", function() { return rtcChannel; });\n\n// NAMESPACE OBJECT: ../raiden-ts/dist/messages/actions.js\nvar messages_actions_namespaceObject = {};\n__webpack_require__.r(messages_actions_namespaceObject);\n__webpack_require__.d(messages_actions_namespaceObject, "messageSend", function() { return messageSend; });\n__webpack_require__.d(messages_actions_namespaceObject, "messageGlobalSend", function() { return messageGlobalSend; });\n__webpack_require__.d(messages_actions_namespaceObject, "messageReceived", function() { return messageReceived; });\n\n// NAMESPACE OBJECT: ../raiden-ts/dist/transfers/actions.js\nvar transfers_actions_namespaceObject = {};\n__webpack_require__.r(transfers_actions_namespaceObject);\n__webpack_require__.d(transfers_actions_namespaceObject, "transfer", function() { return actions_transfer; });\n__webpack_require__.d(transfers_actions_namespaceObject, "transferSigned", function() { return transferSigned; });\n__webpack_require__.d(transfers_actions_namespaceObject, "transferProcessed", function() { return transferProcessed; });\n__webpack_require__.d(transfers_actions_namespaceObject, "transferSecret", function() { return transferSecret; });\n__webpack_require__.d(transfers_actions_namespaceObject, "transferSecretRegister", function() { return transferSecretRegister; });\n__webpack_require__.d(transfers_actions_namespaceObject, "transferSecretRequest", function() { return transferSecretRequest; });\n__webpack_require__.d(transfers_actions_namespaceObject, "transferSecretReveal", function() { return transferSecretReveal; });\n__webpack_require__.d(transfers_actions_namespaceObject, "transferUnlock", function() { return transferUnlock; });\n__webpack_require__.d(transfers_actions_namespaceObject, "transferUnlockProcessed", function() { return transferUnlockProcessed; });\n__webpack_require__.d(transfers_actions_namespaceObject, "transferExpire", function() { return transferExpire; });\n__webpack_require__.d(transfers_actions_namespaceObject, "transferExpireProcessed", function() { return transferExpireProcessed; });\n__webpack_require__.d(transfers_actions_namespaceObject, "transferRefunded", function() { return transferRefunded; });\n__webpack_require__.d(transfers_actions_namespaceObject, "transferClear", function() { return transferClear; });\n__webpack_require__.d(transfers_actions_namespaceObject, "withdrawReceive", function() { return withdrawReceive; });\n\n// NAMESPACE OBJECT: ../raiden-ts/dist/path/actions.js\nvar path_actions_namespaceObject = {};\n__webpack_require__.r(path_actions_namespaceObject);\n__webpack_require__.d(path_actions_namespaceObject, "pathFind", function() { return pathFind; });\n__webpack_require__.d(path_actions_namespaceObject, "pfsListUpdated", function() { return pfsListUpdated; });\n__webpack_require__.d(path_actions_namespaceObject, "iouPersist", function() { return iouPersist; });\n__webpack_require__.d(path_actions_namespaceObject, "iouClear", function() { return iouClear; });\n\n// NAMESPACE OBJECT: ../raiden-ts/dist/channels/epics.js\nvar epics_namespaceObject = {};\n__webpack_require__.r(epics_namespaceObject);\n__webpack_require__.d(epics_namespaceObject, "initNewBlockEpic", function() { return epics_initNewBlockEpic; });\n__webpack_require__.d(epics_namespaceObject, "initTokensRegistryEpic", function() { return epics_initTokensRegistryEpic; });\n__webpack_require__.d(epics_namespaceObject, "initMonitorChannelsEpic", function() { return epics_initMonitorChannelsEpic; });\n__webpack_require__.d(epics_namespaceObject, "initMonitorProviderEpic", function() { return epics_initMonitorProviderEpic; });\n__webpack_require__.d(epics_namespaceObject, "tokenMonitoredEpic", function() { return epics_tokenMonitoredEpic; });\n__webpack_require__.d(epics_namespaceObject, "channelOpenedEpic", function() { return epics_channelOpenedEpic; });\n__webpack_require__.d(epics_namespaceObject, "channelMonitoredEpic", function() { return epics_channelMonitoredEpic; });\n__webpack_require__.d(epics_namespaceObject, "channelOpenEpic", function() { return epics_channelOpenEpic; });\n__webpack_require__.d(epics_namespaceObject, "channelDepositEpic", function() { return epics_channelDepositEpic; });\n__webpack_require__.d(epics_namespaceObject, "channelCloseEpic", function() { return epics_channelCloseEpic; });\n__webpack_require__.d(epics_namespaceObject, "channelUpdateEpic", function() { return epics_channelUpdateEpic; });\n__webpack_require__.d(epics_namespaceObject, "channelSettleEpic", function() { return epics_channelSettleEpic; });\n__webpack_require__.d(epics_namespaceObject, "channelSettleableEpic", function() { return epics_channelSettleableEpic; });\n__webpack_require__.d(epics_namespaceObject, "channelUnlockEpic", function() { return epics_channelUnlockEpic; });\n__webpack_require__.d(epics_namespaceObject, "confirmationEpic", function() { return epics_confirmationEpic; });\n\n// NAMESPACE OBJECT: ../raiden-ts/dist/transport/epics.js\nvar transport_epics_namespaceObject = {};\n__webpack_require__.r(transport_epics_namespaceObject);\n__webpack_require__.d(transport_epics_namespaceObject, "initMatrixEpic", function() { return epics_initMatrixEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixShutdownEpic", function() { return epics_matrixShutdownEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixMonitorPresenceEpic", function() { return epics_matrixMonitorPresenceEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixPresenceUpdateEpic", function() { return epics_matrixPresenceUpdateEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixCreateRoomEpic", function() { return epics_matrixCreateRoomEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixInviteEpic", function() { return epics_matrixInviteEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixHandleInvitesEpic", function() { return epics_matrixHandleInvitesEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixLeaveExcessRoomsEpic", function() { return epics_matrixLeaveExcessRoomsEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixLeaveUnknownRoomsEpic", function() { return epics_matrixLeaveUnknownRoomsEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixCleanLeftRoomsEpic", function() { return epics_matrixCleanLeftRoomsEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixCleanMissingRoomsEpic", function() { return epics_matrixCleanMissingRoomsEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixMessageSendEpic", function() { return epics_matrixMessageSendEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixMessageGlobalSendEpic", function() { return epics_matrixMessageGlobalSendEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixMessageReceivedEpic", function() { return epics_matrixMessageReceivedEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixMessageReceivedUpdateRoomEpic", function() { return epics_matrixMessageReceivedUpdateRoomEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "matrixMonitorChannelPresenceEpic", function() { return epics_matrixMonitorChannelPresenceEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "deliveredEpic", function() { return epics_deliveredEpic; });\n__webpack_require__.d(transport_epics_namespaceObject, "rtcConnectEpic", function() { return epics_rtcConnectEpic; });\n\n// NAMESPACE OBJECT: ../raiden-ts/dist/transfers/epics/index.js\nvar transfers_epics_namespaceObject = {};\n__webpack_require__.r(transfers_epics_namespaceObject);\n__webpack_require__.d(transfers_epics_namespaceObject, "transferChannelClosedEpic", function() { return close_transferChannelClosedEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferAutoExpireEpic", function() { return expire_transferAutoExpireEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferGenerateAndSignEnvelopeMessageEpic", function() { return locked_transferGenerateAndSignEnvelopeMessageEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "initQueuePendingEnvelopeMessagesEpic", function() { return init_initQueuePendingEnvelopeMessagesEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "initQueuePendingReceivedEpic", function() { return init_initQueuePendingReceivedEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferMediateEpic", function() { return mediate_transferMediateEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferProcessedReceivedEpic", function() { return processed_transferProcessedReceivedEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferProcessedSendEpic", function() { return processed_transferProcessedSendEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferUnlockProcessedReceivedEpic", function() { return processed_transferUnlockProcessedReceivedEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferExpireProcessedEpic", function() { return processed_transferExpireProcessedEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferReceivedReplyProcessedEpic", function() { return processed_transferReceivedReplyProcessedEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferRefundedEpic", function() { return refund_transferRefundedEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferRetryMessageEpic", function() { return retry_transferRetryMessageEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferSecretRequestedEpic", function() { return secret_transferSecretRequestedEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferSecretRevealEpic", function() { return secret_transferSecretRevealEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferSecretRevealedEpic", function() { return secret_transferSecretRevealedEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferRequestUnlockEpic", function() { return secret_transferRequestUnlockEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "monitorSecretRegistryEpic", function() { return secret_monitorSecretRegistryEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferSuccessOnSecretRegisteredEpic", function() { return secret_transferSuccessOnSecretRegisteredEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferAutoRegisterEpic", function() { return secret_transferAutoRegisterEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "transferSecretRegisterEpic", function() { return secret_transferSecretRegisterEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "withdrawRequestReceivedEpic", function() { return withdraw_withdrawRequestReceivedEpic; });\n__webpack_require__.d(transfers_epics_namespaceObject, "withdrawSendConfirmationEpic", function() { return withdraw_withdrawSendConfirmationEpic; });\n\n// NAMESPACE OBJECT: ../raiden-ts/dist/path/epics.js\nvar path_epics_namespaceObject = {};\n__webpack_require__.r(path_epics_namespaceObject);\n__webpack_require__.d(path_epics_namespaceObject, "pathFindServiceEpic", function() { return epics_pathFindServiceEpic; });\n__webpack_require__.d(path_epics_namespaceObject, "pfsCapacityUpdateEpic", function() { return epics_pfsCapacityUpdateEpic; });\n__webpack_require__.d(path_epics_namespaceObject, "pfsFeeUpdateEpic", function() { return epics_pfsFeeUpdateEpic; });\n__webpack_require__.d(path_epics_namespaceObject, "pfsServiceRegistryMonitorEpic", function() { return epics_pfsServiceRegistryMonitorEpic; });\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\nvar regenerator = __webpack_require__("a34a");\nvar regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/symbol-observable/es/index.js\nvar es = __webpack_require__("a755");\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/isomorphic-fetch/fetch-npm-browserify.js\nvar fetch_npm_browserify = __webpack_require__("86ae");\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/abort-controller/polyfill.mjs + 2 modules\nvar polyfill = __webpack_require__("fa1e");\n\n// EXTERNAL MODULE: ./node_modules/loglevel/lib/loglevel.js\nvar loglevel = __webpack_require__("5c7d");\nvar loglevel_default = /*#__PURE__*/__webpack_require__.n(loglevel);\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/matrix-js-sdk/lib/logger.js\nvar lib_logger = __webpack_require__("51b1");\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/matrix-js-sdk/lib/browser-index.js\nvar browser_index = __webpack_require__("aadd");\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/wrtc/lib/browser.js\nvar browser = __webpack_require__("eb32");\nvar browser_default = /*#__PURE__*/__webpack_require__.n(browser);\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/matrix-js-sdk/lib/webrtc/call.js\nvar call = __webpack_require__("4f34");\n\n// CONCATENATED MODULE: ../raiden-ts/dist/polyfills.js\n\n\n // matrix-js-sdk monkey-patch root methodFactory\n\n\nvar methodFactory = loglevel_default.a.methodFactory;\n\nObject.assign(loglevel_default.a, {\n  methodFactory: methodFactory\n}); // revert\n\nlib_logger["logger"].setLevel(loglevel_default.a.levels.DEBUG); // apply\n// request.abort() is called when shutting down matrix; this patch clears some timeouts left behind\n\n\nvar origRequest = Object(browser_index["getRequest"])(); // \'request\' replaces matrix\'s request\n\nObject(browser_index["request"])(function (opts, cb) {\n  var req = origRequest(opts, cb);\n  var origAbort = req.abort.bind(req);\n  return Object.assign(req, {\n    abort: function abort() {\n      origAbort();\n      cb(new Error(\'aborted!\')); // also call callback when aborting, to clear pending timeouts\n    }\n  });\n});\n\n\nif (!(\'RTCPeerConnection\' in globalThis)) {\n  Object.assign(globalThis, browser_default.a);\n} // patch createNewMatrixCall to prevent matrix-js-sdk from hooking WebRTC events in browser;\n// ugly, but there\'s no option to prevent MatrixClient to handle m.call.* events\n\n\n\nObject.assign(call, {\n  createNewMatrixCall: function createNewMatrixCall() {\n    return null;\n  }\n});\n// EXTERNAL MODULE: ./node_modules/ethers/providers/index.js\nvar providers = __webpack_require__("686e");\n\n// EXTERNAL MODULE: ./node_modules/ethers/utils/index.js\nvar utils = __webpack_require__("6934");\n\n// EXTERNAL MODULE: ./node_modules/ethers/constants.js\nvar constants = __webpack_require__("8404");\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/redux/es/redux.js\nvar redux = __webpack_require__("7508");\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/redux-observable/lib/esm/createEpicMiddleware.js + 9 modules\nvar createEpicMiddleware = __webpack_require__("733d");\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/redux-logger/dist/redux-logger.js\nvar redux_logger = __webpack_require__("371e");\n\n// EXTERNAL MODULE: ./node_modules/lodash/constant.js\nvar constant = __webpack_require__("72f0");\nvar constant_default = /*#__PURE__*/__webpack_require__.n(constant);\n\n// EXTERNAL MODULE: ./node_modules/lodash/memoize.js\nvar memoize = __webpack_require__("e380");\nvar memoize_default = /*#__PURE__*/__webpack_require__.n(memoize);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js\nvar ReplaySubject = __webpack_require__("4b96");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/AsyncSubject.js\nvar AsyncSubject = __webpack_require__("b2f7");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js\nvar merge = __webpack_require__("a748");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js\nvar defer = __webpack_require__("9586");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js\nvar empty = __webpack_require__("1b92");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js\nvar of = __webpack_require__("17f5");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/skip.js\nvar skip = __webpack_require__("d263");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js\nvar map = __webpack_require__("ebb6");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js\nvar filter = __webpack_require__("5670");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/first.js\nvar first = __webpack_require__("3fab");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js\nvar mergeMap = __webpack_require__("a6c5");\n\n// EXTERNAL MODULE: ./node_modules/ethers/dist/ethers.min.js\nvar ethers_min = __webpack_require__("e7ea");\n\n// CONCATENATED MODULE: ../raiden-ts/dist/contracts/TokenNetworkRegistryFactory.ts\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/* Generated by ts-generator ver. 0.0.8 */\n\n/* tslint:disable */\n\nvar TokenNetworkRegistryFactory_TokenNetworkRegistryFactory = /*#__PURE__*/function () {\n  function TokenNetworkRegistryFactory() {\n    _classCallCheck(this, TokenNetworkRegistryFactory);\n  }\n\n  _createClass(TokenNetworkRegistryFactory, null, [{\n    key: "connect",\n    value: function connect(address, signerOrProvider) {\n      return new ethers_min["Contract"](address, _abi, signerOrProvider);\n    }\n  }]);\n\n  return TokenNetworkRegistryFactory;\n}();\nvar _abi = [{\n  inputs: [{\n    internalType: "address",\n    name: "_secret_registry_address",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "_chain_id",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_settlement_timeout_min",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_settlement_timeout_max",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_max_token_networks",\n    type: "uint256"\n  }],\n  stateMutability: "nonpayable",\n  type: "constructor"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "address",\n    name: "token_address",\n    type: "address"\n  }, {\n    indexed: true,\n    internalType: "address",\n    name: "token_network_address",\n    type: "address"\n  }],\n  name: "TokenNetworkCreated",\n  type: "event"\n}, {\n  inputs: [],\n  name: "chain_id",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "contract_address",\n    type: "address"\n  }],\n  name: "contractExists",\n  outputs: [{\n    internalType: "bool",\n    name: "",\n    type: "bool"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_token_address",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "_channel_participant_deposit_limit",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_token_network_deposit_limit",\n    type: "uint256"\n  }],\n  name: "createERC20TokenNetwork",\n  outputs: [{\n    internalType: "address",\n    name: "token_network_address",\n    type: "address"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [],\n  name: "deprecation_executor",\n  outputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "max_token_networks",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "secret_registry_address",\n  outputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "settlement_timeout_max",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "settlement_timeout_min",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "token_network_created",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  name: "token_to_token_networks",\n  outputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  stateMutability: "view",\n  type: "function"\n}];\n// CONCATENATED MODULE: ../raiden-ts/dist/contracts/TokenNetworkFactory.ts\nfunction TokenNetworkFactory_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TokenNetworkFactory_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TokenNetworkFactory_createClass(Constructor, protoProps, staticProps) { if (protoProps) TokenNetworkFactory_defineProperties(Constructor.prototype, protoProps); if (staticProps) TokenNetworkFactory_defineProperties(Constructor, staticProps); return Constructor; }\n\n/* Generated by ts-generator ver. 0.0.8 */\n\n/* tslint:disable */\n\nvar TokenNetworkFactory_TokenNetworkFactory = /*#__PURE__*/function () {\n  function TokenNetworkFactory() {\n    TokenNetworkFactory_classCallCheck(this, TokenNetworkFactory);\n  }\n\n  TokenNetworkFactory_createClass(TokenNetworkFactory, null, [{\n    key: "connect",\n    value: function connect(address, signerOrProvider) {\n      return new ethers_min["Contract"](address, TokenNetworkFactory_abi, signerOrProvider);\n    }\n  }]);\n\n  return TokenNetworkFactory;\n}();\nvar TokenNetworkFactory_abi = [{\n  inputs: [{\n    internalType: "address",\n    name: "_token_address",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "_secret_registry",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "_chain_id",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_settlement_timeout_min",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_settlement_timeout_max",\n    type: "uint256"\n  }, {\n    internalType: "address",\n    name: "_deprecation_executor",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "_channel_participant_deposit_limit",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_token_network_deposit_limit",\n    type: "uint256"\n  }],\n  stateMutability: "nonpayable",\n  type: "constructor"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    indexed: true,\n    internalType: "address",\n    name: "closing_participant",\n    type: "address"\n  }, {\n    indexed: true,\n    internalType: "uint256",\n    name: "nonce",\n    type: "uint256"\n  }, {\n    indexed: false,\n    internalType: "bytes32",\n    name: "balance_hash",\n    type: "bytes32"\n  }],\n  name: "ChannelClosed",\n  type: "event"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    indexed: true,\n    internalType: "address",\n    name: "participant",\n    type: "address"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "total_deposit",\n    type: "uint256"\n  }],\n  name: "ChannelNewDeposit",\n  type: "event"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    indexed: true,\n    internalType: "address",\n    name: "participant1",\n    type: "address"\n  }, {\n    indexed: true,\n    internalType: "address",\n    name: "participant2",\n    type: "address"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "settle_timeout",\n    type: "uint256"\n  }],\n  name: "ChannelOpened",\n  type: "event"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "participant1_amount",\n    type: "uint256"\n  }, {\n    indexed: false,\n    internalType: "bytes32",\n    name: "participant1_locksroot",\n    type: "bytes32"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "participant2_amount",\n    type: "uint256"\n  }, {\n    indexed: false,\n    internalType: "bytes32",\n    name: "participant2_locksroot",\n    type: "bytes32"\n  }],\n  name: "ChannelSettled",\n  type: "event"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    indexed: true,\n    internalType: "address",\n    name: "receiver",\n    type: "address"\n  }, {\n    indexed: true,\n    internalType: "address",\n    name: "sender",\n    type: "address"\n  }, {\n    indexed: false,\n    internalType: "bytes32",\n    name: "locksroot",\n    type: "bytes32"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "unlocked_amount",\n    type: "uint256"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "returned_tokens",\n    type: "uint256"\n  }],\n  name: "ChannelUnlocked",\n  type: "event"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    indexed: true,\n    internalType: "address",\n    name: "participant",\n    type: "address"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "total_withdraw",\n    type: "uint256"\n  }],\n  name: "ChannelWithdraw",\n  type: "event"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: "bool",\n    name: "new_value",\n    type: "bool"\n  }],\n  name: "DeprecationSwitch",\n  type: "event"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    indexed: true,\n    internalType: "address",\n    name: "closing_participant",\n    type: "address"\n  }, {\n    indexed: true,\n    internalType: "uint256",\n    name: "nonce",\n    type: "uint256"\n  }, {\n    indexed: false,\n    internalType: "bytes32",\n    name: "balance_hash",\n    type: "bytes32"\n  }],\n  name: "NonClosingBalanceProofUpdated",\n  type: "event"\n}, {\n  inputs: [],\n  name: "MAX_SAFE_UINT256",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "chain_id",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "channel_counter",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "channel_participant_deposit_limit",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  name: "channels",\n  outputs: [{\n    internalType: "uint256",\n    name: "settle_block_number",\n    type: "uint256"\n  }, {\n    internalType: "enum TokenNetwork.ChannelState",\n    name: "state",\n    type: "uint8"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    internalType: "address",\n    name: "non_closing_participant",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "closing_participant",\n    type: "address"\n  }, {\n    internalType: "bytes32",\n    name: "balance_hash",\n    type: "bytes32"\n  }, {\n    internalType: "uint256",\n    name: "nonce",\n    type: "uint256"\n  }, {\n    internalType: "bytes32",\n    name: "additional_hash",\n    type: "bytes32"\n  }, {\n    internalType: "bytes",\n    name: "non_closing_signature",\n    type: "bytes"\n  }, {\n    internalType: "bytes",\n    name: "closing_signature",\n    type: "bytes"\n  }],\n  name: "closeChannel",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "contract_address",\n    type: "address"\n  }],\n  name: "contractExists",\n  outputs: [{\n    internalType: "bool",\n    name: "",\n    type: "bool"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "deprecate",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [],\n  name: "deprecation_executor",\n  outputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "participant",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "partner",\n    type: "address"\n  }],\n  name: "getChannelIdentifier",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    internalType: "address",\n    name: "participant1",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "participant2",\n    type: "address"\n  }],\n  name: "getChannelInfo",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }, {\n    internalType: "enum TokenNetwork.ChannelState",\n    name: "",\n    type: "uint8"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    internalType: "address",\n    name: "participant",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "partner",\n    type: "address"\n  }],\n  name: "getChannelParticipantInfo",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }, {\n    internalType: "bool",\n    name: "",\n    type: "bool"\n  }, {\n    internalType: "bytes32",\n    name: "",\n    type: "bytes32"\n  }, {\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }, {\n    internalType: "bytes32",\n    name: "",\n    type: "bytes32"\n  }, {\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "participant",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "partner",\n    type: "address"\n  }],\n  name: "getParticipantsHash",\n  outputs: [{\n    internalType: "bytes32",\n    name: "",\n    type: "bytes32"\n  }],\n  stateMutability: "pure",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    internalType: "address",\n    name: "sender",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "receiver",\n    type: "address"\n  }],\n  name: "getUnlockIdentifier",\n  outputs: [{\n    internalType: "bytes32",\n    name: "",\n    type: "bytes32"\n  }],\n  stateMutability: "pure",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "participant1",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "participant2",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "settle_timeout",\n    type: "uint256"\n  }],\n  name: "openChannel",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "bytes32",\n    name: "",\n    type: "bytes32"\n  }],\n  name: "participants_hash_to_channel_identifier",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "safety_deprecation_switch",\n  outputs: [{\n    internalType: "bool",\n    name: "",\n    type: "bool"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "secret_registry",\n  outputs: [{\n    internalType: "contract SecretRegistry",\n    name: "",\n    type: "address"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    internalType: "address",\n    name: "participant",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "total_deposit",\n    type: "uint256"\n  }, {\n    internalType: "address",\n    name: "partner",\n    type: "address"\n  }],\n  name: "setTotalDeposit",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    internalType: "address",\n    name: "participant",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "total_withdraw",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "expiration_block",\n    type: "uint256"\n  }, {\n    internalType: "bytes",\n    name: "participant_signature",\n    type: "bytes"\n  }, {\n    internalType: "bytes",\n    name: "partner_signature",\n    type: "bytes"\n  }],\n  name: "setTotalWithdraw",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    internalType: "address",\n    name: "participant1",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "participant1_transferred_amount",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "participant1_locked_amount",\n    type: "uint256"\n  }, {\n    internalType: "bytes32",\n    name: "participant1_locksroot",\n    type: "bytes32"\n  }, {\n    internalType: "address",\n    name: "participant2",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "participant2_transferred_amount",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "participant2_locked_amount",\n    type: "uint256"\n  }, {\n    internalType: "bytes32",\n    name: "participant2_locksroot",\n    type: "bytes32"\n  }],\n  name: "settleChannel",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [],\n  name: "settlement_timeout_max",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "settlement_timeout_min",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "signature_prefix",\n  outputs: [{\n    internalType: "string",\n    name: "",\n    type: "string"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "token",\n  outputs: [{\n    internalType: "contract Token",\n    name: "",\n    type: "address"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "token_network_deposit_limit",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    internalType: "address",\n    name: "receiver",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "sender",\n    type: "address"\n  }, {\n    internalType: "bytes",\n    name: "locks",\n    type: "bytes"\n  }],\n  name: "unlock",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "channel_identifier",\n    type: "uint256"\n  }, {\n    internalType: "address",\n    name: "closing_participant",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "non_closing_participant",\n    type: "address"\n  }, {\n    internalType: "bytes32",\n    name: "balance_hash",\n    type: "bytes32"\n  }, {\n    internalType: "uint256",\n    name: "nonce",\n    type: "uint256"\n  }, {\n    internalType: "bytes32",\n    name: "additional_hash",\n    type: "bytes32"\n  }, {\n    internalType: "bytes",\n    name: "closing_signature",\n    type: "bytes"\n  }, {\n    internalType: "bytes",\n    name: "non_closing_signature",\n    type: "bytes"\n  }],\n  name: "updateNonClosingBalanceProof",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}];\n// CONCATENATED MODULE: ../raiden-ts/dist/contracts/HumanStandardTokenFactory.ts\nfunction HumanStandardTokenFactory_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction HumanStandardTokenFactory_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction HumanStandardTokenFactory_createClass(Constructor, protoProps, staticProps) { if (protoProps) HumanStandardTokenFactory_defineProperties(Constructor.prototype, protoProps); if (staticProps) HumanStandardTokenFactory_defineProperties(Constructor, staticProps); return Constructor; }\n\n/* Generated by ts-generator ver. 0.0.8 */\n\n/* tslint:disable */\n\nvar HumanStandardTokenFactory_HumanStandardTokenFactory = /*#__PURE__*/function () {\n  function HumanStandardTokenFactory() {\n    HumanStandardTokenFactory_classCallCheck(this, HumanStandardTokenFactory);\n  }\n\n  HumanStandardTokenFactory_createClass(HumanStandardTokenFactory, null, [{\n    key: "connect",\n    value: function connect(address, signerOrProvider) {\n      return new ethers_min["Contract"](address, HumanStandardTokenFactory_abi, signerOrProvider);\n    }\n  }]);\n\n  return HumanStandardTokenFactory;\n}();\nvar HumanStandardTokenFactory_abi = [{\n  inputs: [{\n    internalType: "uint256",\n    name: "_initialAmount",\n    type: "uint256"\n  }, {\n    internalType: "uint8",\n    name: "_decimalUnits",\n    type: "uint8"\n  }, {\n    internalType: "string",\n    name: "_tokenName",\n    type: "string"\n  }, {\n    internalType: "string",\n    name: "_tokenSymbol",\n    type: "string"\n  }],\n  stateMutability: "nonpayable",\n  type: "constructor"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "address",\n    name: "_owner",\n    type: "address"\n  }, {\n    indexed: true,\n    internalType: "address",\n    name: "_spender",\n    type: "address"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "_value",\n    type: "uint256"\n  }],\n  name: "Approval",\n  type: "event"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "address",\n    name: "_from",\n    type: "address"\n  }, {\n    indexed: true,\n    internalType: "address",\n    name: "_to",\n    type: "address"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "_value",\n    type: "uint256"\n  }],\n  name: "Transfer",\n  type: "event"\n}, {\n  stateMutability: "nonpayable",\n  type: "fallback"\n}, {\n  inputs: [],\n  name: "_decimals",\n  outputs: [{\n    internalType: "uint8",\n    name: "",\n    type: "uint8"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_owner",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "_spender",\n    type: "address"\n  }],\n  name: "allowance",\n  outputs: [{\n    internalType: "uint256",\n    name: "remaining",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_spender",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "_value",\n    type: "uint256"\n  }],\n  name: "approve",\n  outputs: [{\n    internalType: "bool",\n    name: "success",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_spender",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "_value",\n    type: "uint256"\n  }, {\n    internalType: "bytes",\n    name: "_extraData",\n    type: "bytes"\n  }],\n  name: "approveAndCall",\n  outputs: [{\n    internalType: "bool",\n    name: "success",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_owner",\n    type: "address"\n  }],\n  name: "balanceOf",\n  outputs: [{\n    internalType: "uint256",\n    name: "balance",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  name: "balances",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "decimals",\n  outputs: [{\n    internalType: "uint8",\n    name: "decimals",\n    type: "uint8"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "name",\n  outputs: [{\n    internalType: "string",\n    name: "",\n    type: "string"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "symbol",\n  outputs: [{\n    internalType: "string",\n    name: "",\n    type: "string"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "totalSupply",\n  outputs: [{\n    internalType: "uint256",\n    name: "supply",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_to",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "_value",\n    type: "uint256"\n  }],\n  name: "transfer",\n  outputs: [{\n    internalType: "bool",\n    name: "success",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_from",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "_to",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "_value",\n    type: "uint256"\n  }],\n  name: "transferFrom",\n  outputs: [{\n    internalType: "bool",\n    name: "success",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [],\n  name: "version",\n  outputs: [{\n    internalType: "string",\n    name: "",\n    type: "string"\n  }],\n  stateMutability: "view",\n  type: "function"\n}];\n// CONCATENATED MODULE: ../raiden-ts/dist/contracts/ServiceRegistryFactory.ts\nfunction ServiceRegistryFactory_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction ServiceRegistryFactory_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction ServiceRegistryFactory_createClass(Constructor, protoProps, staticProps) { if (protoProps) ServiceRegistryFactory_defineProperties(Constructor.prototype, protoProps); if (staticProps) ServiceRegistryFactory_defineProperties(Constructor, staticProps); return Constructor; }\n\n/* Generated by ts-generator ver. 0.0.8 */\n\n/* tslint:disable */\n\nvar ServiceRegistryFactory_ServiceRegistryFactory = /*#__PURE__*/function () {\n  function ServiceRegistryFactory() {\n    ServiceRegistryFactory_classCallCheck(this, ServiceRegistryFactory);\n  }\n\n  ServiceRegistryFactory_createClass(ServiceRegistryFactory, null, [{\n    key: "connect",\n    value: function connect(address, signerOrProvider) {\n      return new ethers_min["Contract"](address, ServiceRegistryFactory_abi, signerOrProvider);\n    }\n  }]);\n\n  return ServiceRegistryFactory;\n}();\nvar ServiceRegistryFactory_abi = [{\n  inputs: [{\n    internalType: "address",\n    name: "_token_for_registration",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "_controller",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "_initial_price",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_price_bump_numerator",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_price_bump_denominator",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_decay_constant",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_min_price",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_registration_duration",\n    type: "uint256"\n  }],\n  stateMutability: "nonpayable",\n  type: "constructor"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "address",\n    name: "service",\n    type: "address"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "valid_till",\n    type: "uint256"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "deposit_amount",\n    type: "uint256"\n  }, {\n    indexed: false,\n    internalType: "contract Deposit",\n    name: "deposit_contract",\n    type: "address"\n  }],\n  name: "RegisteredService",\n  type: "event"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "_price_bump_numerator",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_price_bump_denominator",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_decay_constant",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_min_price",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_registration_duration",\n    type: "uint256"\n  }],\n  name: "changeParameters",\n  outputs: [{\n    internalType: "bool",\n    name: "_success",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "contract_address",\n    type: "address"\n  }],\n  name: "contractExists",\n  outputs: [{\n    internalType: "bool",\n    name: "",\n    type: "bool"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "controller",\n  outputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "currentPrice",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "decay_constant",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "_set_price",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "_seconds_passed",\n    type: "uint256"\n  }],\n  name: "decayedPrice",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "_limit_amount",\n    type: "uint256"\n  }],\n  name: "deposit",\n  outputs: [{\n    internalType: "bool",\n    name: "_success",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [],\n  name: "deprecated",\n  outputs: [{\n    internalType: "bool",\n    name: "",\n    type: "bool"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "everMadeDepositsLen",\n  outputs: [{\n    internalType: "uint256",\n    name: "_len",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  name: "ever_made_deposits",\n  outputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_address",\n    type: "address"\n  }],\n  name: "hasValidRegistration",\n  outputs: [{\n    internalType: "bool",\n    name: "_has_registration",\n    type: "bool"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "min_price",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "price_bump_denominator",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "price_bump_numerator",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "registration_duration",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  name: "service_valid_till",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "setDeprecationSwitch",\n  outputs: [{\n    internalType: "bool",\n    name: "_success",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "string",\n    name: "new_url",\n    type: "string"\n  }],\n  name: "setURL",\n  outputs: [{\n    internalType: "bool",\n    name: "_success",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [],\n  name: "set_price",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "set_price_at",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "token",\n  outputs: [{\n    internalType: "contract Token",\n    name: "",\n    type: "address"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  name: "urls",\n  outputs: [{\n    internalType: "string",\n    name: "",\n    type: "string"\n  }],\n  stateMutability: "view",\n  type: "function"\n}];\n// CONCATENATED MODULE: ../raiden-ts/dist/contracts/CustomTokenFactory.ts\nfunction CustomTokenFactory_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction CustomTokenFactory_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction CustomTokenFactory_createClass(Constructor, protoProps, staticProps) { if (protoProps) CustomTokenFactory_defineProperties(Constructor.prototype, protoProps); if (staticProps) CustomTokenFactory_defineProperties(Constructor, staticProps); return Constructor; }\n\n/* Generated by ts-generator ver. 0.0.8 */\n\n/* tslint:disable */\n\nvar CustomTokenFactory_CustomTokenFactory = /*#__PURE__*/function () {\n  function CustomTokenFactory() {\n    CustomTokenFactory_classCallCheck(this, CustomTokenFactory);\n  }\n\n  CustomTokenFactory_createClass(CustomTokenFactory, null, [{\n    key: "connect",\n    value: function connect(address, signerOrProvider) {\n      return new ethers_min["Contract"](address, CustomTokenFactory_abi, signerOrProvider);\n    }\n  }]);\n\n  return CustomTokenFactory;\n}();\nvar CustomTokenFactory_abi = [{\n  inputs: [{\n    internalType: "uint256",\n    name: "initial_supply",\n    type: "uint256"\n  }, {\n    internalType: "uint8",\n    name: "decimal_units",\n    type: "uint8"\n  }, {\n    internalType: "string",\n    name: "token_name",\n    type: "string"\n  }, {\n    internalType: "string",\n    name: "token_symbol",\n    type: "string"\n  }],\n  stateMutability: "nonpayable",\n  type: "constructor"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "address",\n    name: "_owner",\n    type: "address"\n  }, {\n    indexed: true,\n    internalType: "address",\n    name: "_spender",\n    type: "address"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "_value",\n    type: "uint256"\n  }],\n  name: "Approval",\n  type: "event"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "address",\n    name: "_to",\n    type: "address"\n  }, {\n    indexed: true,\n    internalType: "uint256",\n    name: "_num",\n    type: "uint256"\n  }],\n  name: "Minted",\n  type: "event"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "address",\n    name: "_from",\n    type: "address"\n  }, {\n    indexed: true,\n    internalType: "address",\n    name: "_to",\n    type: "address"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "_value",\n    type: "uint256"\n  }],\n  name: "Transfer",\n  type: "event"\n}, {\n  inputs: [],\n  name: "_decimals",\n  outputs: [{\n    internalType: "uint8",\n    name: "",\n    type: "uint8"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_owner",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "_spender",\n    type: "address"\n  }],\n  name: "allowance",\n  outputs: [{\n    internalType: "uint256",\n    name: "remaining",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_spender",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "_value",\n    type: "uint256"\n  }],\n  name: "approve",\n  outputs: [{\n    internalType: "bool",\n    name: "success",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_owner",\n    type: "address"\n  }],\n  name: "balanceOf",\n  outputs: [{\n    internalType: "uint256",\n    name: "balance",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  name: "balances",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "decimals",\n  outputs: [{\n    internalType: "uint8",\n    name: "decimals",\n    type: "uint8"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "num",\n    type: "uint256"\n  }],\n  name: "mint",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "num",\n    type: "uint256"\n  }, {\n    internalType: "address",\n    name: "target",\n    type: "address"\n  }],\n  name: "mintFor",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [],\n  name: "multiplier",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "name",\n  outputs: [{\n    internalType: "string",\n    name: "",\n    type: "string"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "owner_address",\n  outputs: [{\n    internalType: "address payable",\n    name: "",\n    type: "address"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "symbol",\n  outputs: [{\n    internalType: "string",\n    name: "",\n    type: "string"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "totalSupply",\n  outputs: [{\n    internalType: "uint256",\n    name: "supply",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_to",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "_value",\n    type: "uint256"\n  }],\n  name: "transfer",\n  outputs: [{\n    internalType: "bool",\n    name: "success",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_from",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "_to",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "_value",\n    type: "uint256"\n  }],\n  name: "transferFrom",\n  outputs: [{\n    internalType: "bool",\n    name: "success",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [],\n  name: "transferFunds",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [],\n  name: "version",\n  outputs: [{\n    internalType: "string",\n    name: "",\n    type: "string"\n  }],\n  stateMutability: "view",\n  type: "function"\n}];\n// CONCATENATED MODULE: ../raiden-ts/dist/contracts/UserDepositFactory.ts\nfunction UserDepositFactory_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction UserDepositFactory_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction UserDepositFactory_createClass(Constructor, protoProps, staticProps) { if (protoProps) UserDepositFactory_defineProperties(Constructor.prototype, protoProps); if (staticProps) UserDepositFactory_defineProperties(Constructor, staticProps); return Constructor; }\n\n/* Generated by ts-generator ver. 0.0.8 */\n\n/* tslint:disable */\n\nvar UserDepositFactory_UserDepositFactory = /*#__PURE__*/function () {\n  function UserDepositFactory() {\n    UserDepositFactory_classCallCheck(this, UserDepositFactory);\n  }\n\n  UserDepositFactory_createClass(UserDepositFactory, null, [{\n    key: "connect",\n    value: function connect(address, signerOrProvider) {\n      return new ethers_min["Contract"](address, UserDepositFactory_abi, signerOrProvider);\n    }\n  }]);\n\n  return UserDepositFactory;\n}();\nvar UserDepositFactory_abi = [{\n  inputs: [{\n    internalType: "address",\n    name: "_token_address",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "_whole_balance_limit",\n    type: "uint256"\n  }],\n  stateMutability: "nonpayable",\n  type: "constructor"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "address",\n    name: "owner",\n    type: "address"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "newBalance",\n    type: "uint256"\n  }],\n  name: "BalanceReduced",\n  type: "event"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "address",\n    name: "withdrawer",\n    type: "address"\n  }, {\n    indexed: false,\n    internalType: "uint256",\n    name: "plannedBalance",\n    type: "uint256"\n  }],\n  name: "WithdrawPlanned",\n  type: "event"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  name: "balances",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "contract_address",\n    type: "address"\n  }],\n  name: "contractExists",\n  outputs: [{\n    internalType: "bool",\n    name: "",\n    type: "bool"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "beneficiary",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "new_total_deposit",\n    type: "uint256"\n  }],\n  name: "deposit",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "owner",\n    type: "address"\n  }],\n  name: "effectiveBalance",\n  outputs: [{\n    internalType: "uint256",\n    name: "remaining_balance",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "_msc_address",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "_one_to_n_address",\n    type: "address"\n  }],\n  name: "init",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [],\n  name: "msc_address",\n  outputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "one_to_n_address",\n  outputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "amount",\n    type: "uint256"\n  }],\n  name: "planWithdraw",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [],\n  name: "token",\n  outputs: [{\n    internalType: "contract Token",\n    name: "",\n    type: "address"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  name: "total_deposit",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "sender",\n    type: "address"\n  }, {\n    internalType: "address",\n    name: "receiver",\n    type: "address"\n  }, {\n    internalType: "uint256",\n    name: "amount",\n    type: "uint256"\n  }],\n  name: "transfer",\n  outputs: [{\n    internalType: "bool",\n    name: "success",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [],\n  name: "whole_balance",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [],\n  name: "whole_balance_limit",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "uint256",\n    name: "amount",\n    type: "uint256"\n  }],\n  name: "withdraw",\n  outputs: [],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [],\n  name: "withdraw_delay",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "address",\n    name: "",\n    type: "address"\n  }],\n  name: "withdraw_plans",\n  outputs: [{\n    internalType: "uint256",\n    name: "amount",\n    type: "uint256"\n  }, {\n    internalType: "uint256",\n    name: "withdraw_block",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}];\n// CONCATENATED MODULE: ../raiden-ts/dist/contracts/SecretRegistryFactory.ts\nfunction SecretRegistryFactory_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction SecretRegistryFactory_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction SecretRegistryFactory_createClass(Constructor, protoProps, staticProps) { if (protoProps) SecretRegistryFactory_defineProperties(Constructor.prototype, protoProps); if (staticProps) SecretRegistryFactory_defineProperties(Constructor, staticProps); return Constructor; }\n\n/* Generated by ts-generator ver. 0.0.8 */\n\n/* tslint:disable */\n\nvar SecretRegistryFactory_SecretRegistryFactory = /*#__PURE__*/function () {\n  function SecretRegistryFactory() {\n    SecretRegistryFactory_classCallCheck(this, SecretRegistryFactory);\n  }\n\n  SecretRegistryFactory_createClass(SecretRegistryFactory, null, [{\n    key: "connect",\n    value: function connect(address, signerOrProvider) {\n      return new ethers_min["Contract"](address, SecretRegistryFactory_abi, signerOrProvider);\n    }\n  }]);\n\n  return SecretRegistryFactory;\n}();\nvar SecretRegistryFactory_abi = [{\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: "bytes32",\n    name: "secrethash",\n    type: "bytes32"\n  }, {\n    indexed: false,\n    internalType: "bytes32",\n    name: "secret",\n    type: "bytes32"\n  }],\n  name: "SecretRevealed",\n  type: "event"\n}, {\n  inputs: [{\n    internalType: "bytes32",\n    name: "secrethash",\n    type: "bytes32"\n  }],\n  name: "getSecretRevealBlockHeight",\n  outputs: [{\n    internalType: "uint256",\n    name: "",\n    type: "uint256"\n  }],\n  stateMutability: "view",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "bytes32",\n    name: "secret",\n    type: "bytes32"\n  }],\n  name: "registerSecret",\n  outputs: [{\n    internalType: "bool",\n    name: "",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}, {\n  inputs: [{\n    internalType: "bytes32[]",\n    name: "secrets",\n    type: "bytes32[]"\n  }],\n  name: "registerSecretBatch",\n  outputs: [{\n    internalType: "bool",\n    name: "",\n    type: "bool"\n  }],\n  stateMutability: "nonpayable",\n  type: "function"\n}];\n// EXTERNAL MODULE: ../raiden-ts/dist/versions.json\nvar versions = __webpack_require__("bf6c");\n\n// CONCATENATED MODULE: ../raiden-ts/dist/types.js\nvar EventTypes;\n\n(function (EventTypes) {\n  EventTypes["OPENED"] = "OPENED";\n  EventTypes["APPROVED"] = "APPROVED";\n  EventTypes["DEPOSITED"] = "DEPOSITED";\n  EventTypes["CONFIRMED"] = "CONFIRMED";\n})(EventTypes || (EventTypes = {}));\n// CONCATENATED MODULE: ../raiden-ts/dist/constants.js\n\nvar SignatureZero = Object(utils["padZeros"])([], 65);\nvar ShutdownReason;\n\n(function (ShutdownReason) {\n  ShutdownReason["STOP"] = "raidenStopped";\n  ShutdownReason["ACCOUNT_CHANGED"] = "providerAccountChanged";\n  ShutdownReason["NETWORK_CHANGED"] = "providerNetworkChanged";\n})(ShutdownReason || (ShutdownReason = {}));\n\nvar Capabilities;\n\n(function (Capabilities) {\n  // opt-out capabilities, for backwards compatibility\n  Capabilities["NO_RECEIVE"] = "noReceive";\n  Capabilities["NO_MEDIATE"] = "noMediate";\n  Capabilities["NO_DELIVERY"] = "noDelivery";\n  Capabilities["WEBRTC"] = "webRTC";\n})(Capabilities || (Capabilities = {}));\n// EXTERNAL MODULE: ../raiden-ts/node_modules/io-ts/es6/index.js + 4 modules\nvar es6 = __webpack_require__("bef3");\n\n// EXTERNAL MODULE: ./node_modules/lodash/debounce.js\nvar debounce = __webpack_require__("b047c");\nvar debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/io-ts/lib/ThrowReporter.js\nvar ThrowReporter = __webpack_require__("ffa9");\n\n// CONCATENATED MODULE: ../raiden-ts/dist/utils/types.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction types_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\n\n\n\n/**\n * Error for assertion functions/type guards\n */\n\nvar AssertionError = /*#__PURE__*/function (_Error) {\n  _inherits(AssertionError, _Error);\n\n  var _super = _createSuper(AssertionError);\n\n  function AssertionError() {\n    types_classCallCheck(this, AssertionError);\n\n    return _super.apply(this, arguments);\n  }\n\n  return AssertionError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * Type-safe assertion function (TS3.7)\n *\n * @param condition - Condition to validate as truthy\n * @param msg - Message to throw if condition is falsy\n * @param log - Logger to log error to\n */\n\nfunction assert(condition, msg, log) {\n  if (!condition) {\n    log === null || log === void 0 ? void 0 : log(\'AssertionError\', condition, msg);\n    throw new AssertionError(msg !== null && msg !== void 0 ? msg : \'AssertionError\');\n  }\n}\n\nfunction reporterAssert(value) {\n  ThrowReporter["ThrowReporter"].report(value);\n}\n/**\n * Decode/validate like codec.decode, but throw or return right instead of Either\n *\n * @param codec - io-ts codec to be used for decoding/validation\n * @param data - data to decode/validate\n * @returns Decoded value of codec type\n */\n\n\nfunction decode(codec, data) {\n  var decoded = codec.decode(data);\n  reporterAssert(decoded);\n  return decoded.right;\n}\n/**\n * Test for value\'s non-nulliness\n * Like lodash\'s negate(isNil), but also works as type guard (e.g. useful for filters)\n *\n * @param value - to be tested\n * @returns true if value is not null nor undefined\n */\n\nfunction isntNil(value) {\n  return value != null;\n}\n/**\n * Codec of ethers.utils.BigNumber objects\n *\n * Input can be anything bigNumberify-able: number, string, LosslessNumber or BigNumber\n * Output is string, so we can JSON-serialize with \'number\'s types bigger than JS VM limits\n * of ±2^53, as Raiden python client stdlib json encode longs as string.\n */\n\nvar BigNumberC = new es6["a" /* Type */](\'BigNumber\', utils["BigNumber"].isBigNumber, function (u, c) {\n  var _a, _b;\n\n  if (utils["BigNumber"].isBigNumber(u)) return es6["r" /* success */](u);\n\n  try {\n    // decode by trying to bigNumberify string representation of anything\n    return es6["r" /* success */](Object(utils["bigNumberify"])(((_b = (_a = u) === null || _a === void 0 ? void 0 : _a._hex) !== null && _b !== void 0 ? _b : u).toString()));\n  } catch (err) {\n    return es6["f" /* failure */](u, c);\n  }\n}, function (a) {\n  return a.toString();\n});\n/**\n * Helper function to create codecs to validate an arbitrary or variable-sized hex bytestring\n * A branded codec to indicate validated hex-strings\n *\n * @param size - Required number of bytes. Pass undefined or zero to have a variable-sized type\n * @returns branded codec for hex-encoded bytestrings\n */\n\nvar HexString = memoize_default()(function (size) {\n  return es6["e" /* brand */](es6["q" /* string */], function (n) {\n    return typeof n === \'string\' && (size ? Object(utils["hexDataLength"])(n) === size : Object(utils["isHexString"])(n));\n  }, \'HexString\');\n});\n/**\n * Helper function to create codecs to validate an arbitrary or variable-sized BigNumbers\n * A branded codec/type to indicate size-validated BigNumbers\n *\n * @param size - Required number of bytes. Pass undefined to have a variable-sized type\n * @returns branded codec for hex-encoded bytestrings\n */\n\nvar Int = memoize_default()(function (size) {\n  var min = size ? constants["Zero"].sub(constants["Two"].pow(size * 8 - 1)) : undefined,\n      max = size ? constants["Two"].pow(size * 8 - 1) : undefined;\n  return es6["e" /* brand */](BigNumberC, function (n) {\n    return BigNumberC.is(n) && (!min || !max || n.gte(min) && n.lt(max));\n  }, \'Int\');\n});\n/**\n * Helper function to create codecs to validate an arbitrary or variable-sized BigNumbers\n * A branded codec/type to indicate size-validated BigNumbers\n *\n * @param size - Required number of bytes. Pass undefined to have a variable-sized type\n * @returns branded codec for hex-encoded bytestrings\n */\n\nvar UInt = memoize_default()(function (size) {\n  var min = size ? constants["Zero"] : undefined,\n      max = size ? constants["Two"].pow(size * 8) : undefined;\n  return es6["e" /* brand */](BigNumberC, function (n) {\n    return BigNumberC.is(n) && (!min || !max || n.gte(min) && n.lt(max));\n  }, \'UInt\');\n}); // specific types\n// strig brand: ECDSA signature as an hex-string\n\nvar Signature = HexString(65); // string brand: 256-bit hash, usually keccak256 or sha256\n\nvar Hash = HexString(32); // string brand: a secret bytearray, 32 bytes\n\nvar Secret = HexString(32); // string brand: ECDSA private key, 32 bytes\n\nvar PrivateKey = HexString(32);\nvar Address = new es6["a" /* Type */](\'Address\', function (u) {\n  try {\n    return HexString(20).is(u) && Object(utils["getAddress"])(u) === u;\n  } catch (e) {\n    return false;\n  }\n}, function (u, c) {\n  if (!HexString(20).is(u)) return es6["f" /* failure */](u, c);\n  var addr;\n\n  try {\n    addr = Object(utils["getAddress"])(u);\n  } catch (e) {\n    return es6["f" /* failure */](u, c);\n  }\n\n  if (!addr) return es6["f" /* failure */](u, c);\n  return es6["r" /* success */](addr);\n}, es6["g" /* identity */]);\n/**\n * Helper function to create codecs to validate [timestamp, value] tuples\n *\n * @param codec - Codec to compose with a timestamp in a tuple\n * @returns Codec of a tuple of timestamp and codec type\n */\n\nvar Timed = memoize_default()(function (codec) {\n  return es6["s" /* tuple */]([es6["l" /* number */], codec]);\n});\n/**\n * Given a value of type T, returns a Timed<T> tuple with current time as first value\n *\n * @param v - Value to return with time\n * @returns Tuple of call timestamp as first elemtn and value passed as parameter as second\n */\n\nfunction timed(v) {\n  return [Date.now(), v];\n} // generic type codec for messages that must be signed\n// use it like: Codec = Signed(Message)\n// The t.TypeOf<typeof codec> will be Signed<Message>, defined later\n\nvar Signed = memoize_default()(function (codec) {\n  return es6["h" /* intersection */]([codec, es6["n" /* readonly */](es6["t" /* type */]({\n    signature: Signature\n  }))]);\n});\n/**\n * Memoized factory to create codecs validating an arbitrary class C\n *\n * @param C - Class to create a codec for\n * @returns Codec validating class C\n */\n\nvar instanceOf = memoize_default()(function (C) {\n  return new es6["a" /* Type */]("instanceOf(".concat(C.name, ")"), function (v) {\n    return v instanceof C;\n  }, function (i, c) {\n    return i instanceof C ? es6["r" /* success */](i) : es6["f" /* failure */](i, c);\n  }, es6["g" /* identity */]);\n});\n// EXTERNAL MODULE: ./node_modules/ethers/utils/networks.js\nvar networks = __webpack_require__("6f0b");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js\nvar fromEventPattern = __webpack_require__("9044");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js\nvar combineLatest = __webpack_require__("7738");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js + 6 modules\nvar from = __webpack_require__("d3fb");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/share.js\nvar share = __webpack_require__("4b59");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMap.js\nvar switchMap = __webpack_require__("d792");\n\n// EXTERNAL MODULE: ./node_modules/lodash/flatten.js\nvar flatten = __webpack_require__("4d8c");\nvar flatten_default = /*#__PURE__*/__webpack_require__.n(flatten);\n\n// EXTERNAL MODULE: ./node_modules/lodash/sortBy.js\nvar sortBy = __webpack_require__("c707");\nvar sortBy_default = /*#__PURE__*/__webpack_require__.n(sortBy);\n\n// CONCATENATED MODULE: ../raiden-ts/dist/utils/ethers.js\n\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\n\n\n\n\n\n\n/**\n * Like rxjs\' fromEvent, but event can be an EventFilter\n *\n * @param target - Object to hook event listener, maybe a Provider or Contract\n * @param event - EventFilter or string representing the event to listen to\n * @param resultSelector - A map of events arguments to output parameters\n *      Default is to pass only first parameter\n * @returns Observable of target.on(event) events\n */\n\nfunction fromEthersEvent(target, event, resultSelector) {\n  return Object(fromEventPattern["a" /* fromEventPattern */])(function (handler) {\n    return target.on(event, handler);\n  }, function (handler) {\n    return target.removeListener(event, handler);\n  }, resultSelector);\n}\n/**\n * getEventsStream returns a stream of T-type tuples (arrays) from Contract\'s\n * events from filters. These events are polled since provider\'s [re]setEventsBlock to newest\n * polled block. If both \'fromBlock$\' and \'lastSeenBlock$\' are specified, also fetch past events\n * since fromBlock up to lastSeenBlock$ === provider.resetEventsBlock - 1\n * T must be a tuple-like type receiving all filters arguments plus the respective Event in the end\n *\n * @param contract - Contract source instance for filters, connected to a provider\n * @param filters - array of OR filters from tokenNetwork\n * @param fromBlock$ - Observable of a past blockNumber since when to fetch past events\n *                     If not provided, last resetEventsBlock is automatically used.\n * @returns Observable of contract\'s events\n */\n\nfunction getEventsStream(contract, filters, fromBlock$) {\n  var provider = contract.provider;\n\n  var logToEvent = function logToEvent(log) {\n    // parse log into [...args, event: Event] array,\n    // the same that contract.on events/callbacks\n    var parsed = contract.interface.parseLog(log); // ignore removed (reorg\'d) events (reorgs are handled by ConfirmableActions logic)\n    // and parse errors (shouldn\'t happen)\n\n    if (log.removed === true || !parsed) return;\n    var args = Array.prototype.slice.call(parsed.values); // not all parameters quite needed right now, but let\'s comply with the interface\n\n    var event = Object.assign(Object.assign(Object.assign({}, log), parsed), {\n      args: args,\n      removeListener: function removeListener() {\n        /* getLogs don\'t install filter */\n      },\n      getBlock: function getBlock() {\n        return provider.getBlock(log.blockHash);\n      },\n      getTransaction: function getTransaction() {\n        return provider.getTransaction(log.transactionHash);\n      },\n      getTransactionReceipt: function getTransactionReceipt() {\n        return provider.getTransactionReceipt(log.transactionHash);\n      },\n      decode: function decode(data, topics) {\n        return parsed.decode(data, topics || log.topics);\n      }\n    });\n    return [].concat(_toConsumableArray(args), [event]);\n  }; // past events (in the closed-interval=[fromBlock, lastSeenBlock]),\n  // fetch once, sort by blockNumber, emit all, complete\n\n\n  var pastEvents$ = empty["a" /* EMPTY */],\n      // of(constant) ensures newEvents$ is registered immediately if fromBlock$ not provided\n  nextBlock$ = Object(of["a" /* of */])(-1);\n\n  if (fromBlock$) {\n    // if fetching pastEvents$, nextBlock$ is used to sync/avoid intersection between Events$\n    // pastEvents$ => [fromBlock$, nextBlock$], newEvents$ => ]nextBlock$, ...latest]\n    nextBlock$ = Object(defer["a" /* defer */])(function () {\n      return provider.blockNumber ? Object(of["a" /* of */])(provider.blockNumber) : fromEthersEvent(provider, \'block\').pipe(Object(first["a" /* first */])(), Object(map["a" /* map */])(function (b) {\n        var _a;\n\n        return (_a = provider.blockNumber) !== null && _a !== void 0 ? _a : b;\n      }));\n    }).pipe(Object(share["a" /* share */])());\n    pastEvents$ = Object(combineLatest["a" /* combineLatest */])(fromBlock$, nextBlock$).pipe(Object(first["a" /* first */])(), Object(switchMap["a" /* switchMap */])(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          fromBlock = _ref2[0],\n          toBlock = _ref2[1];\n\n      return Promise.all(filters.map(function (filter) {\n        return provider.getLogs(Object.assign(Object.assign({}, filter), {\n          fromBlock: fromBlock,\n          toBlock: toBlock\n        }));\n      }));\n    }), // flatten array of each getLogs query response and sort them\n    // emit log array elements as separate logs into stream (unwind)\n    Object(mergeMap["a" /* mergeMap */])(function (logs) {\n      return Object(from["a" /* from */])(sortBy_default()(flatten_default()(logs), [\'blockNumber\']));\n    }), Object(map["a" /* map */])(logToEvent), Object(filter["a" /* filter */])(isntNil));\n  } // new events (in open-interval=]lastSeenBlock, latest])\n  // where lastSeenBlock is the currentBlock at call time\n  // doesn\'t complete, keep emitting events for each new block (if any) until unsubscription\n\n\n  var newEvents$ = nextBlock$.pipe(Object(switchMap["a" /* switchMap */])(function () {\n    return Object(from["a" /* from */])(filters);\n  }), Object(mergeMap["a" /* mergeMap */])(function (filter) {\n    return fromEthersEvent(provider, filter);\n  }), Object(map["a" /* map */])(logToEvent), Object(filter["a" /* filter */])(isntNil));\n  return Object(merge["a" /* merge */])(pastEvents$, newEvents$);\n}\n/**\n * Like Provider.getNetwork, but fetches every time instead of using cached property\n *\n * @param provider - Provider to fetch data from\n * @returns Promise of Network info\n */\n\nfunction getNetwork(provider) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.t0 = networks["getNetwork"];\n            _context.t1 = parseInt;\n            _context.next = 4;\n            return provider.send(\'net_version\', []);\n\n          case 4:\n            _context.t2 = _context.sent;\n            _context.t3 = (0, _context.t1)(_context.t2);\n            return _context.abrupt("return", (0, _context.t0)(_context.t3));\n\n          case 7:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n/**\n * Patch JsonRpcProvider.send to try personal_sign first, and fallback to eth_sign if it fails\n * Call it once on the provider instance\n *\n * @param provider - A JsonRpcProvider instance to patch\n */\n\nfunction patchSignSend(provider) {\n  var origSend = provider.send;\n\n  provider.send = function (method, params) {\n    return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee2() {\n      return regenerator_default.a.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(method === \'eth_sign\')) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt("return", origSend.apply(this, [\'personal_sign\', [params[1], params[0]]]).catch(function (err) {\n                // on first error, if personal_sign isn\'t available\n                if (err instanceof Error && (err.message.includes(\'The method personal_sign does not exist\') || err.message.includes(\'Method personal_sign not supported\'))) {\n                  provider.send = origSend; // un-patch\n\n                  return provider.send(method, params); // and retry with eth_sign\n                }\n\n                throw err; // else, re-raise\n              }));\n\n            case 2:\n              return _context2.abrupt("return", origSend.apply(this, [method, params]));\n\n            case 3:\n            case "end":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n  };\n}\n/**\n * Return a network name, if known, or stringified chainId otherwise\n *\n * @param network - Network to get name from\n * @returns name or chainId as string\n */\n\nfunction getNetworkName(network) {\n  return network.name !== \'unknown\' ? network.name : network.chainId.toString();\n}\n// CONCATENATED MODULE: ../raiden-ts/dist/config.js\nvar _t$keyof;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\nvar RTCIceServer = es6["t" /* type */]({\n  urls: es6["v" /* union */]([es6["q" /* string */], es6["c" /* array */](es6["q" /* string */])])\n});\n/**\n * A Raiden configuration object with required and optional params from [[PartialRaidenConfig]].\n *\n * Notice partial/undefined values are special: when a raidenConfigUpdate is called with an\n * undefined value, it won\'t be set, as they can\'t be [re]stored in the JSON state, but instead\n * means it\'ll be *reset* to the default value; therefore, if a partial value has a defined\n * default, it can\'t be unset; if you want to support "empty" values, use null, empty string or\n * other falsy serializable types, and/or ensure it never gets a default\n *\n * - matrixServerLookup - Matrix server URL to fetch existing matrix servers from.\n *      After intializing a [[Raiden]] instance, the matrix server can\'t be changed later on.\n * - revealTimeout - Timeout for secrets to be revealed\n * - settleTimeout - Timeout for channels to be settled\n * - httpTimeout - Used in http fetch requests\n * - discoveryRoom - Discovery Room to auto-join, use null to disable\n * - pfsRoom - PFS Room to auto-join and send PFSCapacityUpdate to, use null to disable\n * - pfs - Path Finding Service URL or Address. Set to null to disable, or empty string to enable\n *         automatic fetching from ServiceRegistry.\n * - pfsSafetyMargin - Safety margin to be added to fees received from PFS. Use `1.1` to add a 10%\n *                     safety margin.\n * - matrixExcessRooms - Keep this much rooms for a single user of interest (partner, target).\n *                       Leave LRU beyond this threshold.\n * - confirmationBlocks - How many blocks to wait before considering a transaction as confirmed\n * - logger - String specifying the console log level of redux-logger. Use \'\' to silence.\n * - caps - Own transport capabilities\n * - matrixServer? - Specify a matrix server to use.\n * - subkey? - When using subkey, this sets the behavior when { subkey } option isn\'t explicitly\n *             set in on-chain method calls. false (default) = use main key; true = use subkey\n */\n\nvar RaidenConfig = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  matrixServerLookup: es6["q" /* string */],\n  revealTimeout: es6["l" /* number */],\n  settleTimeout: es6["l" /* number */],\n  httpTimeout: es6["l" /* number */],\n  discoveryRoom: es6["v" /* union */]([es6["q" /* string */], es6["k" /* null */]]),\n  pfsRoom: es6["v" /* union */]([es6["q" /* string */], es6["k" /* null */]]),\n  pfs: es6["v" /* union */]([Address, es6["q" /* string */], es6["k" /* null */]]),\n  pfsSafetyMargin: es6["l" /* number */],\n  matrixExcessRooms: es6["l" /* number */],\n  confirmationBlocks: es6["l" /* number */],\n  logger: es6["i" /* keyof */]((_t$keyof = {}, _defineProperty(_t$keyof, \'\', null), _defineProperty(_t$keyof, "trace", null), _defineProperty(_t$keyof, "debug", null), _defineProperty(_t$keyof, "info", null), _defineProperty(_t$keyof, "warn", null), _defineProperty(_t$keyof, "error", null), _t$keyof)),\n  caps: es6["n" /* readonly */](es6["p" /* record */](es6["q" /* string */]\n  /* Capabilities */\n  , es6["b" /* any */])),\n  fallbackIceServers: es6["c" /* array */](RTCIceServer)\n}), es6["m" /* partial */]({\n  matrixServer: es6["q" /* string */],\n  subkey: es6["d" /* boolean */]\n})]));\nvar PartialRaidenConfig = es6["n" /* readonly */](es6["m" /* partial */](Object.assign(Object.assign({}, RaidenConfig.type.types[\'0\'].props), RaidenConfig.type.types[\'1\'].props)));\n/**\n * Create a RaidenConfig from some common options\n *\n * @param obj - Object containing common parameters for config\n * @param obj.network - ether\'s Network object for the current blockchain\n * @param overwrites - Overwrites values from default config\n * @returns A full config object\n */\n\nfunction makeDefaultConfig(_ref, overwrites) {\n  var _caps;\n\n  var network = _ref.network;\n  return Object.assign({\n    matrixServerLookup: \'https://raw.githubusercontent.com/raiden-network/raiden-transport/master/known_servers.test.yaml\',\n    settleTimeout: 500,\n    revealTimeout: 50,\n    httpTimeout: 30e3,\n    discoveryRoom: "raiden_".concat(getNetworkName(network), "_discovery"),\n    pfsRoom: "raiden_".concat(getNetworkName(network), "_path_finding"),\n    pfs: \'\',\n    matrixExcessRooms: 3,\n    pfsSafetyMargin: 1.0,\n    confirmationBlocks: 5,\n    logger: \'info\',\n    caps: (_caps = {}, _defineProperty(_caps, Capabilities.NO_DELIVERY, true), _defineProperty(_caps, Capabilities.NO_RECEIVE, true), _defineProperty(_caps, Capabilities.NO_MEDIATE, true), _defineProperty(_caps, Capabilities.WEBRTC, true), _caps),\n    fallbackIceServers: [{\n      urls: \'stun:stun.l.google.com:19302\'\n    }]\n  }, overwrites);\n}\n// EXTERNAL MODULE: ./node_modules/lodash/isMatchWith.js\nvar isMatchWith = __webpack_require__("f49b");\nvar isMatchWith_default = /*#__PURE__*/__webpack_require__.n(isMatchWith);\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/fp-ts/lib/Either.js\nvar Either = __webpack_require__("3498");\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/fp-ts/lib/pipeable.js\nvar pipeable = __webpack_require__("6f95");\n\n// EXTERNAL MODULE: ./node_modules/lodash/findKey.js\nvar findKey = __webpack_require__("74c8");\nvar findKey_default = /*#__PURE__*/__webpack_require__.n(findKey);\n\n// CONCATENATED MODULE: ../raiden-ts/dist/utils/error.js\nfunction error_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { error_typeof = function _typeof(obj) { return typeof obj; }; } else { error_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return error_typeof(obj); }\n\nfunction error_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction error_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction error_createClass(Constructor, protoProps, staticProps) { if (protoProps) error_defineProperties(Constructor.prototype, protoProps); if (staticProps) error_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction error_createSuper(Derived) { return function () { var Super = error_getPrototypeOf(Derived), result; if (error_isNativeReflectConstruct()) { var NewTarget = error_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return error_possibleConstructorReturn(this, result); }; }\n\nfunction error_possibleConstructorReturn(self, call) { if (call && (error_typeof(call) === "object" || typeof call === "function")) { return call; } return error_assertThisInitialized(self); }\n\nfunction error_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction error_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) error_setPrototypeOf(subClass, superClass); }\n\nfunction error_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; error_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !error_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return error_construct(Class, arguments, error_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return error_setPrototypeOf(Wrapper, Class); }; return error_wrapNativeSuper(Class); }\n\nfunction error_construct(Parent, args, Class) { if (error_isNativeReflectConstruct()) { error_construct = Reflect.construct; } else { error_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) error_setPrototypeOf(instance, Class.prototype); return instance; }; } return error_construct.apply(null, arguments); }\n\nfunction error_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction error_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\n\nfunction error_setPrototypeOf(o, p) { error_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return error_setPrototypeOf(o, p); }\n\nfunction error_getPrototypeOf(o) { error_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return error_getPrototypeOf(o); }\n\n\n\n\n\nvar ErrorCodes;\n\n(function (ErrorCodes) {\n  // Path errors\n  ErrorCodes["PFS_EMPTY_URL"] = "A registered Pathfinding Service returned an empty service URL.";\n  ErrorCodes["PFS_INVALID_URL"] = "A registered Pathfinding Service returned an invalid service URL.";\n  ErrorCodes["PFS_INVALID_INFO"] = "Could not find any valid Pathfinding service. Client and PFS versions are possibly out-of-sync.";\n  ErrorCodes["PFS_NO_ROUTES_FOUND"] = "No valid routes found.";\n  ErrorCodes["PFS_ERROR_RESPONSE"] = "Pathfinding Service request returned an error";\n  ErrorCodes["PFS_DISABLED"] = "Pathfinding Service is disabled and no direct route is available.";\n  ErrorCodes["PFS_UNKNOWN_TOKEN_NETWORK"] = "No open channels on this token network.";\n  ErrorCodes["PFS_TARGET_OFFLINE"] = "The requested target is offline.";\n  ErrorCodes["PFS_TARGET_NO_RECEIVE"] = "The requested target doesn\'t receive transfers.";\n  ErrorCodes["PFS_LAST_IOU_REQUEST_FAILED"] = "The request for the last IOU has failed.";\n  ErrorCodes["PFS_IOU_SIGNATURE_MISMATCH"] = "The signature of the last IOU did not match."; // Channel errors\n\n  ErrorCodes["CNL_INVALID_STATE"] = "Invalid channel state.";\n  ErrorCodes["CNL_TOKEN_NOT_FOUND"] = "Could not find token for token network.";\n  ErrorCodes["CNL_NO_OPEN_CHANNEL_FOUND"] = "No open channel has been found.";\n  ErrorCodes["CNL_NO_OPEN_OR_CLOSING_CHANNEL_FOUND"] = "No open or closing channel has been found.";\n  ErrorCodes["CNL_NO_SETTLEABLE_OR_SETTLING_CHANNEL_FOUND"] = "No settleable or settling channel has been found.";\n  ErrorCodes["CNL_APPROVE_TRANSACTION_FAILED"] = "Token approve transaction failed.";\n  ErrorCodes["CNL_OPENCHANNEL_FAILED"] = "Token networks openChannel transaction failed.";\n  ErrorCodes["CNL_SETTOTALDEPOSIT_FAILED"] = "Token networks setTotalDeposit transaction failed.";\n  ErrorCodes["CNL_CLOSECHANNEL_FAILED"] = "Token networks closeChannel transaction failed.";\n  ErrorCodes["CNL_SETTLECHANNEL_FAILED"] = "Token networks settleChannel transaction failed.";\n  ErrorCodes["CNL_UPDATE_NONCLOSING_BP_FAILED"] = "updateNonClosingBalanceProof transaction failed.";\n  ErrorCodes["CNL_ONCHAIN_UNLOCK_FAILED"] = "on-chain unlock transaction failed."; // Transfer errors\n\n  ErrorCodes["XFER_EXPIRED"] = "Transfer expired.";\n  ErrorCodes["XFER_CHANNEL_CLOSED_PREMATURELY"] = "Channel was closed before secret got reveiled or transfer unlocked.";\n  ErrorCodes["XFER_REFUNDED"] = "Transfer has been refunded.";\n  ErrorCodes["XFER_INVALID_SECRETREQUEST"] = "Invalid SecretRequest received";\n  ErrorCodes["XFER_ALREADY_COMPLETED"] = "Not waiting for transfer, it\'s already completed.";\n  ErrorCodes["XFER_REGISTERSECRET_TX_FAILED"] = "SecretRegistry.registerSecret transaction failed"; // Transport errors\n\n  ErrorCodes["TRNS_NO_MATRIX_SERVERS"] = "Could not contact any Matrix servers.";\n  ErrorCodes["TRNS_NO_VALID_USER"] = "Could not find a user with a valid signature.";\n  ErrorCodes["TRNS_NO_SERVERNAME"] = "Could not get server name from Matrix server.";\n  ErrorCodes["TRNS_MESSAGE_SIGNATURE_MISMATCH"] = "Unable to decode message due to signature mismatch."; // Raiden main class errors\n\n  ErrorCodes["RDN_GENERAL_ERROR"] = "An unknown error occured.";\n  ErrorCodes["RDN_MINT_FAILED"] = "Failed to mint tokens.";\n  ErrorCodes["RDN_APPROVE_TRANSACTION_FAILED"] = "Approve transaction has failed.";\n  ErrorCodes["RDN_DEPOSIT_TRANSACTION_FAILED"] = "Deposit transaction has failed.";\n  ErrorCodes["RDN_TRANSFER_ONCHAIN_BALANCE_FAILED"] = "Failed to transfer on-chain balance.";\n  ErrorCodes["RDN_TRANSFER_ONCHAIN_TOKENS_FAILED"] = "Failed to transfer on-chain tokens.";\n  ErrorCodes["RDN_UNRECOGNIZED_NETWORK"] = "No deploy info provided nor recognized network.";\n  ErrorCodes["RDN_SIGNER_NOT_CONNECTED"] = "The signing account is not connected to the provider.";\n  ErrorCodes["RDN_ACCOUNT_NOT_FOUND"] = "Account not found in provider.";\n  ErrorCodes["RDN_STRING_ACCOUNT_INVALID"] = "String account must be either a 0x-encoded address or private key.";\n  ErrorCodes["RDN_TRANSACTION_REORG"] = "Transaction has been mined but got removed by a reorg.";\n  ErrorCodes["RDN_STATE_MIGRATION"] = "Could not replace stored state with older, provided state."; // Data errors\n\n  ErrorCodes["DTA_NEGATIVE_NUMBER"] = "Encountered negative number while encoding to HEX string.";\n  ErrorCodes["DTA_NUMBER_TOO_LARGE"] = "Encountered a number that is too large to be encoded.";\n  ErrorCodes["DTA_ARRAY_LENGTH_DIFFRENCE"] = "Expected length of HEX string differs from integer array input.";\n  ErrorCodes["DTA_UNENCODABLE_DATA"] = "Passed data is not a HEX string nor integer array.";\n})(ErrorCodes || (ErrorCodes = {}));\n\nvar ErrorDetails = es6["p" /* record */](es6["q" /* string */], es6["v" /* union */]([es6["q" /* string */], es6["l" /* number */], es6["d" /* boolean */], es6["k" /* null */]]));\nvar error_RaidenError = /*#__PURE__*/function (_Error) {\n  error_inherits(RaidenError, _Error);\n\n  var _super = error_createSuper(RaidenError);\n\n  function RaidenError(message) {\n    var _this;\n\n    var details = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    error_classCallCheck(this, RaidenError);\n\n    _this = _super.call(this, message !== null && message !== void 0 ? message : ErrorCodes.RDN_GENERAL_ERROR);\n    _this.details = details;\n    _this.name = \'RaidenError\';\n    _this._code = undefined;\n    Object.setPrototypeOf(error_assertThisInitialized(_this), RaidenError.prototype);\n    return _this;\n  }\n\n  error_createClass(RaidenError, [{\n    key: "code",\n    get: function get() {\n      var _this2 = this;\n\n      var _a; // to need to search for _code before first access\n\n\n      if (this._code === undefined) this._code = (_a = findKey_default()(ErrorCodes, function (message) {\n        return message === _this2.message;\n      })) !== null && _a !== void 0 ? _a : \'RDN_GENERAL_ERROR\';\n      return this._code;\n    }\n  }]);\n\n  return RaidenError;\n}( /*#__PURE__*/error_wrapNativeSuper(Error));\nvar serializedErr = es6["h" /* intersection */]([es6["t" /* type */]({\n  name: es6["q" /* string */]\n}), es6["m" /* partial */]({\n  message: es6["q" /* string */],\n  stack: es6["q" /* string */],\n  details: ErrorDetails\n})]);\n/**\n * Simple Error codec\n *\n * This codec doesn\'t decode to an instance of the exact same error class object, but instead to\n * a generic Error, but assigning \'name\', \'stack\' & \'message\' properties, more as an informative\n * object.\n */\n\nvar ErrorCodec = new es6["a" /* Type */](\'Error\', // if it quacks like a duck... without relying on instanceof\nfunction (u) {\n  return error_typeof(u) === \'object\' && !!u && \'name\' in u && \'message\' in u;\n}, function (u) {\n  return Object(pipeable["pipe"])(serializedErr.decode(u), Object(Either["map"])(function (error) {\n    if (\'details\' in error) {\n      return Object.assign(new error_RaidenError(error.message, error.details), {\n        name: error.name,\n        stack: error.stack\n      });\n    } else {\n      return Object.assign(new Error(error.message), {\n        name: error.name,\n        stack: error.stack\n      });\n    }\n  }));\n}, function (error) {\n  return Object.assign({\n    name: error.name,\n    message: error.message,\n    stack: error.stack\n  }, \'details\' in error ? {\n    details: error.details\n  } : {});\n});\n// CONCATENATED MODULE: ../raiden-ts/dist/utils/actions.js\n\n\nfunction actions_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction actions_toConsumableArray(arr) { return actions_arrayWithoutHoles(arr) || actions_iterableToArray(arr) || actions_unsupportedIterableToArray(arr) || actions_nonIterableSpread(); }\n\nfunction actions_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction actions_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return actions_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return actions_arrayLikeToArray(o, minLen); }\n\nfunction actions_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction actions_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return actions_arrayLikeToArray(arr); }\n\nfunction actions_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar actions_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/class-name-casing */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\n\n\n\n\n\n/**\n * Curried typeguard function (arity=2) which validates 2nd param is of type of some ActionCreators\n *\n * @param ac - Single or array of ActionCreators\n * @param args - if an object is passed, verify it, else returns a function which does\n * @returns boolean indicating object is of type of action, if passing 2nd argument,\n *      or typeguard function\n */\n\nfunction isActionOf(ac) {\n  var arr = Array.isArray(ac) ? ac : [ac];\n\n  function _isActionOf(action) {\n    return action != null && arr.some(function (a) {\n      return a.is(action);\n    });\n  }\n\n  if ((arguments.length <= 1 ? 0 : arguments.length - 1) > 0) return _isActionOf(arguments.length <= 1 ? undefined : arguments[1]);\n  return _isActionOf;\n}\n/**\n * Create a typesafe, serializable ActionCreator from type, payload codec, meta codec & error flag\n *\n * Pass undefined for indermediary arguments if they aren\'t needed\n * e.g. action with meta and without payload:\n *   const addTodo = createAction(\'ADD_TODO\', undefined, t.type({ folder: t.string }));\n *\n * @param args - typesafe args tuple\n * @param args.0 - type literal string tag for action\n * @param args.1 - payload codec, optional\n * @param args.2 - meta codec, optional\n * @param args.3 - error flag, will only be present if defined (either false or true)\n * @returns ActionCreator factory function with useful properties. See [[ActionCreatorMembers]]\n */\n\nfunction createAction() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var type = args[0],\n      payloadC = args[1],\n      metaC = args[2],\n      error = args[3]; // action codec\n\n  var codec = es6["t" /* type */](Object.assign(Object.assign(Object.assign({\n    type: es6["j" /* literal */](type)\n  }, payloadC ? {\n    payload: payloadC\n  } : null), metaC ? {\n    meta: metaC\n  } : null), error ? {\n    error: es6["j" /* literal */](error)\n  } : null)); // member typeguard\n  // like codec.is, but on production, switches to more performant check of \'type\' tag only\n\n  var is =  false ? undefined : function (action) {\n    var _a;\n\n    return ((_a = action) === null || _a === void 0 ? void 0 : _a[\'type\']) === type;\n  };\n  return Object.assign(function (payload, meta) {\n    return Object.assign(Object.assign(Object.assign({\n      type: type\n    }, payloadC ? {\n      payload: payload\n    } : null), metaC ? {\n      meta: meta\n    } : null), error !== undefined ? {\n      error: error\n    } : null);\n  }, {\n    codec: codec,\n    type: type,\n    is: is\n  }, error !== undefined ? {\n    error: error\n  } : null);\n}\n/**\n * Create a set of async actions\n *\n * Here, meta is first class citizen, as it\'s required and what links a request with its responses\n * (success or failure).\n * An \'isResponseOf\' member function is provided which accepts \'meta\' (e.g. from request) and\n * returns a type guard function/filter which returns true only if passed a respective deep-equal\n * \'meta\' success|failure action.\n *\n * @param meta - Meta object common to these async actions\n * @param rtype - Request literal string tag\n * @param stype - Success literal string tag\n * @param ftype - Failure literal string tag\n * @param rpayload - Request payload codec\n * @param spayload - Success payload codec\n * @param args - Optional fpayload - Failure payload codec, defaults to ErrorCodec\n * @returns Async actions\n */\n\nfunction createAsyncAction(meta, rtype, stype, ftype, rpayload, spayload) {\n  var fpayload = (arguments.length <= 6 ? 0 : arguments.length - 6) ? arguments.length <= 6 ? undefined : arguments[6] : ErrorCodec;\n  var request = createAction(rtype, rpayload, meta);\n  var success = createAction(stype, spayload, meta);\n  var failure = createAction(ftype, fpayload, meta, true);\n  return {\n    request: request,\n    success: success,\n    failure: failure\n  };\n}\n/**\n * Match a passed meta with an action if returns true if metas are from corresponding actions\n *\n * curried (arity=2) for action passed as 2nd param.\n *\n * @param meta - meta base for comparison\n * @param args - curried args array\n * @param args.0 - action to test meta against the 1st param\n * @returns true if metas are compatible, false otherwise\n */\n\nfunction matchMeta(meta) {\n  var _match = function _match(action) {\n    return (// like isEqual, but for BigNumbers, use .eq\n      isMatchWith_default()(action.meta, meta, function (objVal, othVal) {\n        return (// any is to avoid lodash\'s issue with undefined-returning isMatchWithCustomizer cb type\n          BigNumberC.is(objVal) && BigNumberC.is(othVal) ? objVal.eq(othVal) : undefined\n        );\n      })\n    );\n  };\n\n  if (arguments.length <= 1 ? 0 : arguments.length - 1) return _match(arguments.length <= 1 ? undefined : arguments[1]);\n  return _match;\n}\n/**\n * Given an AsyncActionCreator and a respective \'meta\' object, returns a type guard function for\n * responses actions (success|failure) matching given \'meta\'\n *\n * This function receives 2-3 params. If it receives 2, it returns the type guard function, to be\n * used for filtering. Otherwise, it performs the check on the 3rd param.\n *\n * @param asyncAction - AsyncActionCreator object\n * @param meta - meta object to filter matching actions\n * @param args - curried last param\n * @returns type guard function to filter deep-equal meta success|failure actions\n */\n\n\nfunction isResponseOf(asyncAction, meta) {\n  var _isResponseOf = function _isResponseOf(action) {\n    return isActionOf([asyncAction.success, asyncAction.failure], action) && matchMeta(meta, action);\n  };\n\n  if (arguments.length <= 2 ? 0 : arguments.length - 2) return _isResponseOf(arguments.length <= 2 ? undefined : arguments[2]);\n  return _isResponseOf;\n}\n/**\n * Like isResponseOf, but ignores non-confirmed (or removed by a reorg) success action\n *\n * Confirmable success actions are emitted twice: first with payload.confirmed=undefined, then with\n * either confirmed=true, if tx still present after confirmation blocks, or confirmed=false, if tx\n * was removed from blockchain by a reorg.\n * This curied helper filter function ensures only one of the later causes a positive filter.\n *\n * @param asyncAction - AsyncActionCreator object\n * @param meta - meta object to filter matching actions\n * @param args - curried last param\n * @returns type guard function to filter deep-equal meta success|failure actions\n */\n\nfunction isConfirmationResponseOf(asyncAction, meta) {\n  function _isConfirmation(action) {\n    var _a, _b;\n\n    return typeof ((_b = (_a = action) === null || _a === void 0 ? void 0 : _a[\'payload\']) === null || _b === void 0 ? void 0 : _b[\'confirmed\']) === \'boolean\';\n  }\n\n  var _isResponseOf = function _isResponseOf(action) {\n    return isResponseOf(asyncAction, meta, action) && (asyncAction.failure.is(action) || _isConfirmation(action));\n  };\n\n  if (arguments.length <= 2 ? 0 : arguments.length - 2) return _isResponseOf(arguments.length <= 2 ? undefined : arguments[2]);\n  return _isResponseOf;\n}\n/**\n * Watch a stream of actions and resolves on meta-matching success or rejects on failure\n *\n * @param asyncAction - async actions object to wait for\n * @param meta - meta object of a request to wait for the respective response\n * @param action$ - actions stream to watch for responses\n * @param confirmed - set if should ignore non-confirmed success response\n * @returns Promise which rejects with payload in case of failure, or resolves payload otherwise\n */\n\nfunction asyncActionToPromise(asyncAction, meta, action$) {\n  var confirmed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return actions_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt("return", action$.pipe(Object(first["a" /* first */])(confirmed ? isConfirmationResponseOf(asyncAction, meta) : isResponseOf(asyncAction, meta)), Object(map["a" /* map */])(function (action) {\n              if (asyncAction.failure.is(action)) throw action.payload;else if (action.payload.confirmed === false) throw new error_RaidenError(ErrorCodes.RDN_TRANSACTION_REORG, {\n                transactionHash: action.payload.txHash\n              });\n              return action.payload;\n            })).toPromise());\n\n          case 1:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n/**\n * Create a reducer which can be extended with additional actions handlers\n *\n * Usage:\n *   const reducer = createReducer(State)\n *      .handle(action, (s, a): State => ...)\n *      .handle(...)\n *      .handle(...);\n *\n * @param initialState - state for initialization (if no state is passed on reducer call)\n * @returns A reducer function, extended with a handle method to extend it\n */\n\nfunction createReducer(initialState) {\n  // make a reducer function for given handlers\n  function makeReducer(handlers) {\n    var reducer = function reducer() {\n      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n      var action = arguments.length > 1 ? arguments[1] : undefined;\n      if (action.type in handlers && handlers[action.type][0].is(action)) return handlers[action.type][1](state, action); // calls registered handler\n\n      return state; // fallback returns unchanged state\n    }; // circular dependency on generic params forbids an already handled action from being accepted\n\n\n    function handle(ac, handler) {\n      var arr = Array.isArray(ac) ? ac : [ac];\n      assert(!arr.some(function (a) {\n        return a.type in handlers;\n      }), \'Already handled\');\n      return makeReducer(Object.assign.apply(Object, [{}, handlers].concat(actions_toConsumableArray(arr.map(function (ac) {\n        return actions_defineProperty({}, ac.type, [ac, handler]);\n      })))));\n    } // grow reducer function with our `handle` extender\n\n\n    return Object.assign(reducer, {\n      handle: handle\n    });\n  } // initially makes a reducer which doesn\'t handle anything (just returns unchanged state)\n\n\n  return makeReducer({});\n}\n// CONCATENATED MODULE: ../raiden-ts/dist/channels/types.js\n\n // Represents a HashTime-Locked amount in a channel\n\nvar Lock = es6["t" /* type */]({\n  amount: UInt(32),\n  expiration: UInt(32),\n  secrethash: Hash\n}, \'Lock\');\n/**\n * Balance Proof constructed from an EnvelopeMessage\n * Either produced by us or received from the partner, the BPs are generated from the messages\n * because BP signature requires the hash of the message, for authentication of data not included\n * nor relevant for the smartcontract/BP itself, but so for the peers (e.g. payment_id)\n */\n\nvar SignedBalanceProof = es6["t" /* type */]({\n  // channel data\n  chainId: UInt(32),\n  tokenNetworkAddress: Address,\n  channelId: UInt(32),\n  // balance proof data\n  nonce: UInt(8),\n  transferredAmount: UInt(32),\n  lockedAmount: UInt(32),\n  locksroot: Hash,\n  messageHash: Hash,\n  signature: Signature,\n  sender: Address\n});\n// CONCATENATED MODULE: ../raiden-ts/dist/channels/actions.js\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/class-name-casing */\n\n\n\n // interfaces need to be exported, and we need/want to support `import * as RaidenActions`\n\nvar ChannelId = es6["t" /* type */]({\n  tokenNetwork: Address,\n  partner: Address\n});\n/* A new head in the blockchain is detected by provider */\n\nvar newBlock = createAction(\'newBlock\', es6["t" /* type */]({\n  blockNumber: es6["l" /* number */]\n}));\n/**\n * A new token network is detected in the TokenNetworkRegistry instance\n * fromBlock is only set on the first time, to fetch and handle past events\n */\n\nvar tokenMonitored = createAction(\'tokenMonitored\', es6["h" /* intersection */]([es6["t" /* type */]({\n  token: Address,\n  tokenNetwork: Address\n}), es6["m" /* partial */]({\n  fromBlock: es6["l" /* number */]\n})]));\n/**\n * Channel actions receive ChannelId as \'meta\' action property\n * This way, \'meta\' can be used equally for request, success and error actions\n */\n\nvar channelOpen = createAsyncAction(ChannelId, \'channel/open/request\', \'channel/open/success\', \'channel/open/failed\', es6["m" /* partial */]({\n  settleTimeout: es6["l" /* number */],\n  subkey: es6["d" /* boolean */],\n  deposit: UInt(32)\n}), es6["t" /* type */]({\n  id: es6["l" /* number */],\n  settleTimeout: es6["l" /* number */],\n  isFirstParticipant: es6["d" /* boolean */],\n  txHash: Hash,\n  txBlock: es6["l" /* number */],\n  confirmed: es6["v" /* union */]([es6["u" /* undefined */], es6["d" /* boolean */]])\n}));\n/* Channel with meta:ChannelId + payload.id should be monitored */\n\nvar channelMonitor = createAction(\'channel/monitor\', es6["h" /* intersection */]([es6["t" /* type */]({\n  id: es6["l" /* number */]\n}), es6["m" /* partial */]({\n  fromBlock: es6["l" /* number */]\n})]), ChannelId);\nvar channelDeposit = createAsyncAction(ChannelId, \'channel/deposit/request\', \'channel/deposit/success\', \'channel/deposit/failure\', es6["h" /* intersection */]([es6["t" /* type */]({\n  deposit: UInt(32)\n}), es6["m" /* partial */]({\n  subkey: es6["d" /* boolean */]\n})]), es6["t" /* type */]({\n  id: es6["l" /* number */],\n  participant: Address,\n  totalDeposit: UInt(32),\n  txHash: Hash,\n  txBlock: es6["l" /* number */],\n  confirmed: es6["v" /* union */]([es6["u" /* undefined */], es6["d" /* boolean */]])\n}));\n/* A withdraw is detected on-chain */\n\nvar channelWithdrawn = createAction(\'channel/withdraw/success\', es6["t" /* type */]({\n  id: es6["l" /* number */],\n  participant: Address,\n  totalWithdraw: UInt(32),\n  txHash: Hash,\n  txBlock: es6["l" /* number */],\n  confirmed: es6["v" /* union */]([es6["u" /* undefined */], es6["d" /* boolean */]])\n}), ChannelId);\nvar channelClose = createAsyncAction(ChannelId, \'channel/close/request\', \'channel/close/success\', \'channel/close/failure\', es6["v" /* union */]([es6["m" /* partial */]({\n  subkey: es6["d" /* boolean */]\n}), es6["u" /* undefined */]]), es6["t" /* type */]({\n  id: es6["l" /* number */],\n  participant: Address,\n  txHash: Hash,\n  txBlock: es6["l" /* number */],\n  confirmed: es6["v" /* union */]([es6["u" /* undefined */], es6["d" /* boolean */]])\n}));\n/* A channel meta:ChannelId becomes settleable, starting from payload.settleableBlock */\n\nvar channelSettleable = createAction(\'channel/settleable\', es6["t" /* type */]({\n  settleableBlock: es6["l" /* number */]\n}), ChannelId);\nvar channelSettle = createAsyncAction(ChannelId, \'channel/settle/request\', \'channel/settle/success\', \'channel/settle/failure\', es6["v" /* union */]([es6["m" /* partial */]({\n  subkey: es6["d" /* boolean */]\n}), es6["u" /* undefined */]]), es6["h" /* intersection */]([es6["t" /* type */]({\n  id: es6["l" /* number */],\n  txHash: Hash,\n  txBlock: es6["l" /* number */],\n  confirmed: es6["v" /* union */]([es6["u" /* undefined */], es6["d" /* boolean */]])\n}), es6["m" /* partial */]({\n  locks: es6["o" /* readonlyArray */](Lock)\n})]));\n// CONCATENATED MODULE: ../raiden-ts/dist/transport/state.js\n\nvar RaidenMatrixSetup = es6["n" /* readonly */](es6["t" /* type */]({\n  userId: es6["q" /* string */],\n  accessToken: es6["q" /* string */],\n  deviceId: es6["q" /* string */],\n  displayName: es6["q" /* string */]\n}));\n// CONCATENATED MODULE: ../raiden-ts/dist/transport/actions.js\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/class-name-casing */\n\n\n\n\nvar NodeId = es6["t" /* type */]({\n  address: Address\n});\n/* MatrixClient instance is ready and logged in to payload.server with credentials payload.setup */\n\nvar matrixSetup = createAction(\'matrixSetup\', es6["t" /* type */]({\n  server: es6["q" /* string */],\n  setup: RaidenMatrixSetup\n}));\nvar matrixPresence = createAsyncAction(NodeId, \'matrix/presence/request\', \'matrix/presence/success\', \'matrix/presence/failure\', undefined, es6["h" /* intersection */]([es6["t" /* type */]({\n  userId: es6["q" /* string */],\n  available: es6["d" /* boolean */],\n  ts: es6["l" /* number */]\n}), es6["m" /* partial */]({\n  caps: es6["p" /* record */](es6["q" /* string */], es6["b" /* any */])\n})]));\n/* payload.roomId must go front on meta.address\'s room queue */\n\nvar matrixRoom = createAction(\'matrixRoom\', es6["t" /* type */]({\n  roomId: es6["q" /* string */]\n}), NodeId);\n/* payload.roomId must be excluded from meta.address room queue, if present */\n\nvar matrixRoomLeave = createAction(\'matrixRoomLeave\', es6["t" /* type */]({\n  roomId: es6["q" /* string */]\n}), NodeId);\nvar rtcChannel = createAction(\'rtcChannel\', es6["v" /* union */]([es6["u" /* undefined */], instanceOf(RTCDataChannel)]), NodeId);\n// CONCATENATED MODULE: ../raiden-ts/dist/messages/types.js\n/* istanbul ignore file */\n\n/* eslint-disable @typescript-eslint/camelcase */\n\n/**\n * These io-ts codecs validate and decode JSON Raiden messages\n * They include BigNumber strings validation, enum validation (if needed), Address checksum\n * validation, etc, and converting everything to its respective object, where needed.\n */\n\n\n // types\n\nvar MessageType;\n\n(function (MessageType) {\n  MessageType["DELIVERED"] = "Delivered";\n  MessageType["PROCESSED"] = "Processed";\n  MessageType["SECRET_REQUEST"] = "SecretRequest";\n  MessageType["SECRET_REVEAL"] = "RevealSecret";\n  MessageType["LOCKED_TRANSFER"] = "LockedTransfer";\n  MessageType["REFUND_TRANSFER"] = "RefundTransfer";\n  MessageType["UNLOCK"] = "Unlock";\n  MessageType["LOCK_EXPIRED"] = "LockExpired";\n  MessageType["WITHDRAW_REQUEST"] = "WithdrawRequest";\n  MessageType["WITHDRAW_CONFIRMATION"] = "WithdrawConfirmation";\n  MessageType["WITHDRAW_EXPIRED"] = "WithdrawExpired";\n  MessageType["PFS_CAPACITY_UPDATE"] = "PFSCapacityUpdate";\n  MessageType["PFS_FEE_UPDATE"] = "PFSFeeUpdate";\n})(MessageType || (MessageType = {})); // Mixin of a message that contains an identifier and should be ack\'ed with a respective Delivered\n\n\nvar RetrieableMessage = es6["n" /* readonly */](es6["t" /* type */]({\n  message_identifier: UInt(8)\n})); // Acknowledges to the sender that a RetrieableMessage was received\n\nvar Delivered = es6["n" /* readonly */](es6["t" /* type */]({\n  type: es6["j" /* literal */](MessageType.DELIVERED),\n  delivered_message_identifier: UInt(8)\n})); // Confirms some message that required state validation was successfuly processed\n\nvar Processed = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  type: es6["j" /* literal */](MessageType.PROCESSED)\n}), RetrieableMessage])); // Requests the initiator to reveal the secret for a LockedTransfer targeted to us\n\nvar SecretRequest = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  type: es6["j" /* literal */](MessageType.SECRET_REQUEST),\n  payment_identifier: UInt(8),\n  secrethash: Hash,\n  amount: UInt(32),\n  expiration: UInt(32)\n}), RetrieableMessage])); // Reveal to the target or the previous hop a secret we just learned off-chain\n\nvar SecretReveal = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  type: es6["j" /* literal */](MessageType.SECRET_REVEAL),\n  secret: Secret\n}), RetrieableMessage])); // Mixin for messages containing a balance proof\n\nvar EnvelopeMessage = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  chain_id: UInt(32),\n  token_network_address: Address,\n  channel_identifier: UInt(32),\n  nonce: UInt(8),\n  transferred_amount: UInt(32),\n  locked_amount: UInt(32),\n  locksroot: Hash\n}), RetrieableMessage]));\nvar RouteMetadata = es6["n" /* readonly */](es6["t" /* type */]({\n  route: es6["o" /* readonlyArray */](Address)\n}));\nvar Metadata = es6["n" /* readonly */](es6["t" /* type */]({\n  routes: es6["o" /* readonlyArray */](RouteMetadata)\n})); // base for locked and refund transfer, they differentiate only on the type tag\n\nvar LockedTransferBase = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  payment_identifier: UInt(8),\n  token: Address,\n  recipient: Address,\n  lock: Lock,\n  target: Address,\n  initiator: Address,\n  metadata: Metadata\n}), EnvelopeMessage])); // a mediated transfer containing a locked amount\n\nvar LockedTransfer = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  type: es6["j" /* literal */](MessageType.LOCKED_TRANSFER)\n}), LockedTransferBase])); // if a mediated transfer didn\'t succeed, mediator can refund the amount with the same secrethash\n// so the previous hop can retry it with another neighbor\n\nvar RefundTransfer = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  type: es6["j" /* literal */](MessageType.REFUND_TRANSFER)\n}), LockedTransferBase])); // when the secret is revealed, unlock sends a new balance proof without the lock and increasing\n// the total transfered to finish the offchain transfer\n\nvar Unlock = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  type: es6["j" /* literal */](MessageType.UNLOCK),\n  payment_identifier: UInt(8),\n  secret: Secret\n}), EnvelopeMessage])); // after mediated transfer fails and the lock expire, clean it from the locks tree\n\nvar LockExpired = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  type: es6["j" /* literal */](MessageType.LOCK_EXPIRED),\n  recipient: Address,\n  secrethash: Hash\n}), EnvelopeMessage]));\nvar WithdrawBase = es6["n" /* readonly */](es6["t" /* type */]({\n  chain_id: UInt(32),\n  token_network_address: Address,\n  channel_identifier: UInt(32),\n  participant: Address,\n  total_withdraw: UInt(32),\n  nonce: UInt(8),\n  expiration: UInt(32)\n}));\nvar WithdrawRequest = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  type: es6["j" /* literal */](MessageType.WITHDRAW_REQUEST)\n}), WithdrawBase, RetrieableMessage]));\nvar WithdrawConfirmation = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  type: es6["j" /* literal */](MessageType.WITHDRAW_CONFIRMATION)\n}), WithdrawBase, RetrieableMessage]));\nvar WithdrawExpired = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  type: es6["j" /* literal */](MessageType.WITHDRAW_EXPIRED)\n}), WithdrawBase, RetrieableMessage]));\nvar PFSCapacityUpdate = es6["n" /* readonly */](es6["t" /* type */]({\n  type: es6["j" /* literal */](MessageType.PFS_CAPACITY_UPDATE),\n  canonical_identifier: es6["n" /* readonly */](es6["t" /* type */]({\n    chain_identifier: UInt(32),\n    token_network_address: Address,\n    channel_identifier: UInt(32)\n  })),\n  updating_participant: Address,\n  other_participant: Address,\n  updating_nonce: UInt(8),\n  other_nonce: UInt(8),\n  updating_capacity: UInt(32),\n  other_capacity: UInt(32),\n  reveal_timeout: UInt(32)\n}));\nvar PFSFeeUpdate = es6["n" /* readonly */](es6["t" /* type */]({\n  type: es6["j" /* literal */](MessageType.PFS_FEE_UPDATE),\n  canonical_identifier: es6["n" /* readonly */](es6["t" /* type */]({\n    chain_identifier: UInt(32),\n    token_network_address: Address,\n    channel_identifier: UInt(32)\n  })),\n  updating_participant: Address,\n  timestamp: es6["q" /* string */],\n  fee_schedule: es6["t" /* type */]({\n    cap_fees: es6["d" /* boolean */],\n    // if not null, it should be an array of [tokenAmount, fee] tuples\n    imbalance_penalty: es6["v" /* union */]([es6["k" /* null */], es6["c" /* array */](es6["s" /* tuple */]([UInt(32), Int(32)]))]),\n    proportional: Int(32),\n    flat: Int(32)\n  })\n}));\nvar Message = es6["v" /* union */]([Delivered, Processed, SecretRequest, SecretReveal, LockedTransfer, RefundTransfer, Unlock, LockExpired, WithdrawRequest, WithdrawConfirmation, WithdrawExpired, PFSCapacityUpdate, PFSFeeUpdate]);\n// CONCATENATED MODULE: ../raiden-ts/dist/messages/actions.js\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/class-name-casing */\n\n\n\n\n/** One-shot send payload.message to meta.address user in transport */\n\nvar messageSend = createAsyncAction(es6["t" /* type */]({\n  address: Address,\n  msgId: es6["q" /* string */]\n}), \'message/send/request\', \'message/send/success\', \'message/send/failure\', es6["t" /* type */]({\n  message: es6["v" /* union */]([es6["q" /* string */], Signed(Message)])\n}), undefined);\n/** One-shot send payload.message to a global room in transport */\n\nvar messageGlobalSend = createAction(\'messageGlobalSend\', es6["t" /* type */]({\n  message: es6["v" /* union */]([es6["q" /* string */], Signed(Message)])\n}), es6["t" /* type */]({\n  roomName: es6["q" /* string */]\n}));\n/**\n * payload.message was received on payload.ts (timestamp) from meta.address\n * payload.userId and payload.roomId are optional and specific to matrix transport, as sender info\n */\n\nvar messageReceived = createAction(\'messageReceived\', es6["h" /* intersection */]([es6["t" /* type */]({\n  text: es6["q" /* string */],\n  ts: es6["l" /* number */]\n}), es6["m" /* partial */]({\n  message: es6["v" /* union */]([Message, Signed(Message)]),\n  userId: es6["q" /* string */],\n  roomId: es6["q" /* string */]\n})]), es6["t" /* type */]({\n  address: Address\n}));\n// CONCATENATED MODULE: ../raiden-ts/dist/path/types.js\n\n\n/**\n * Codec for PFS API returned data\n */\n\nvar PathResults = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  result: es6["c" /* array */](es6["n" /* readonly */](es6["t" /* type */]({\n    path: es6["o" /* readonlyArray */](Address),\n\n    /* eslint-disable-next-line @typescript-eslint/camelcase */\n    estimated_fee: Int(32)\n  })))\n}), es6["m" /* partial */]({\n  /* eslint-disable-next-line @typescript-eslint/camelcase */\n  feedback_token: es6["q" /* string */]\n})]));\n/**\n * Codec for raiden-ts internal representation of a PFS result/routes\n */\n\nvar Paths = es6["c" /* array */](es6["n" /* readonly */](es6["t" /* type */]({\n  path: es6["o" /* readonlyArray */](Address),\n  fee: Int(32)\n})));\n/**\n * A PFS server/service instance info\n */\n\nvar PFS = es6["n" /* readonly */](es6["t" /* type */]({\n  address: Address,\n  url: es6["q" /* string */],\n  rtt: es6["l" /* number */],\n  price: UInt(32),\n  token: Address\n}));\n/**\n * An IOU used to pay the services\n */\n\nvar IOU = es6["n" /* readonly */](es6["t" /* type */]({\n  sender: Address,\n  receiver: Address,\n  amount: UInt(32),\n  // eslint-disable-next-line @typescript-eslint/camelcase\n  expiration_block: UInt(32),\n  // eslint-disable-next-line @typescript-eslint/camelcase\n  one_to_n_address: Address,\n  // eslint-disable-next-line @typescript-eslint/camelcase\n  chain_id: UInt(32)\n}));\nvar LastIOUResults = es6["n" /* readonly */](es6["t" /* type */]({\n  // eslint-disable-next-line @typescript-eslint/camelcase\n  last_iou: Signed(IOU)\n}));\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/actions.js\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/class-name-casing */\n\n\n\n\n\n\nvar TransferId = es6["t" /* type */]({\n  secrethash: Hash,\n  direction: es6["i" /* keyof */]({\n    sent: null,\n    received: null\n  })\n});\n/**\n * A transfer async action set\n *\n * A transfer is considered as having succeeded from the time the secret is revealed to the target,\n * as from there, target and mediators can claim the payment down to us. But the full off-chain\n * happy case completes only after partner/neighbor acknowledges receiving the Unlock.\n * So, we usually only emits this action in the end of the happy case, and it\'ll then contain the\n * unlock\'s balanceProof, which indicates the full off-chain path succeeded.\n * It\'ll be emitted without a balanceProof if something forces the transfer to complete\n * (e.g.  channel closed), the secret was revealed (so target was paid) but for any reason the\n * unlock didn\'t happen yet.\n *\n * transfer.failure is emitted as soon as we know the transfer failed definitely, like when a\n * RefundTransfer is received or the lock expires before revealing the secret. It notifies the user\n * (e.g. pending Promises) that the transfer failed and won\'t be paid (eventually, locked amount\n * will be recovered by expiring the lock).\n */\n\nvar actions_transfer = createAsyncAction(TransferId, \'transfer/request\', \'transfer/success\', \'transfer/failure\', es6["h" /* intersection */]([es6["t" /* type */]({\n  tokenNetwork: Address,\n  target: Address,\n  value: UInt(32),\n  paths: Paths,\n  paymentId: UInt(8)\n}), es6["m" /* partial */]({\n  secret: Secret,\n  expiration: es6["l" /* number */],\n  initiator: Address\n})]), es6["m" /* partial */]({\n  balanceProof: SignedBalanceProof\n}));\n/** A LockedTransfer was signed and should be sent to partner */\n\nvar transferSigned = createAction(\'transferSigned\', es6["t" /* type */]({\n  message: Signed(LockedTransfer),\n  fee: Int(32)\n}), TransferId);\n/** Partner acknowledge they received and processed our LockedTransfer */\n\nvar transferProcessed = createAction(\'transferProcessed\', es6["t" /* type */]({\n  message: Signed(Processed)\n}), TransferId);\n/** Register a secret */\n\nvar transferSecret = createAction(\'transferSecret\', es6["t" /* type */]({\n  secret: Secret\n}), TransferId);\nvar transferSecretRegister = createAsyncAction(TransferId, \'transferSecret/register/request\', \'transferSecret/register/success\', \'transferSecret/register/failure\', es6["h" /* intersection */]([es6["t" /* type */]({\n  secret: Secret\n}), es6["m" /* partial */]({\n  subkey: es6["d" /* boolean */]\n})]), es6["t" /* type */]({\n  secret: Secret,\n  txHash: Hash,\n  txBlock: es6["l" /* number */],\n  // ConfirmableAction\n  confirmed: es6["v" /* union */]([es6["u" /* undefined */], es6["d" /* boolean */]])\n}));\n/** A valid SecretRequest received from target */\n\nvar transferSecretRequest = createAction(\'transferSecretRequest\', es6["t" /* type */]({\n  message: Signed(SecretRequest)\n}), TransferId);\n/** A SecretReveal sent to target */\n\nvar transferSecretReveal = createAction(\'transferSecretReveal\', es6["t" /* type */]({\n  message: Signed(SecretReveal)\n}), TransferId);\nvar transferUnlock = createAsyncAction(TransferId, \'transfer/unlock/request\', \'transfer/unlock/success\', \'transfer/unlock/failure\', undefined, es6["t" /* type */]({\n  message: Signed(Unlock)\n}));\n/** Partner acknowledge they received and processed our Unlock */\n\nvar transferUnlockProcessed = createAction(\'transferUnlockProcessed\', es6["t" /* type */]({\n  message: Signed(Processed)\n}), TransferId);\n/**\n * A request to expire a given transfer\n *\n * A transfer expiration request may fail for any reason\n * e.g. user rejected sign promopt. It should eventually get prompted again, on a future newBlock\n * action which sees this transfer should be expired but sent.lockExpired didn\'t get set yet.\n */\n\nvar transferExpire = createAsyncAction(TransferId, \'transfer/expire/request\', \'transfer/expire/success\', \'transfer/expire/failure\', undefined, es6["t" /* type */]({\n  message: Signed(LockExpired)\n}));\n/** Partner acknowledge they received and processed our LockExpired */\n\nvar transferExpireProcessed = createAction(\'transferExpireProcessed\', es6["t" /* type */]({\n  message: Signed(Processed)\n}), TransferId);\n/** A transfer was refunded */\n\nvar transferRefunded = createAction(\'transferRefunded\', es6["t" /* type */]({\n  message: Signed(RefundTransfer)\n}), TransferId);\n/** A pending transfer isn\'t needed anymore and should be cleared from state */\n\nvar transferClear = createAction(\'transferClear\', undefined, TransferId); // Withdraw actions\n\nvar WithdrawId = es6["t" /* type */]({\n  tokenNetwork: Address,\n  partner: Address,\n  totalWithdraw: UInt(32),\n  expiration: es6["l" /* number */]\n});\n/** A WithdrawRequest was received from partner */\n\nvar withdrawReceive = createAsyncAction(WithdrawId, \'withdraw/receive/request\', \'withdraw/receive/success\', \'withdraw/receive/failure\', es6["t" /* type */]({\n  message: Signed(WithdrawRequest)\n}), es6["t" /* type */]({\n  message: Signed(WithdrawConfirmation)\n}));\n// CONCATENATED MODULE: ../raiden-ts/dist/path/actions.js\n/* eslint-disable @typescript-eslint/no-namespace */\n\n/* eslint-disable @typescript-eslint/class-name-casing */\n\n\n\n\nvar PathId = es6["t" /* type */]({\n  tokenNetwork: Address,\n  target: Address,\n  value: UInt(32)\n});\nvar ServiceId = es6["t" /* type */]({\n  tokenNetwork: Address,\n  serviceAddress: Address\n});\nvar pathFind = createAsyncAction(PathId, \'path/find/request\', \'path/find/success\', \'path/find/failure\', es6["m" /* partial */]({\n  paths: Paths,\n  pfs: es6["v" /* union */]([PFS, es6["k" /* null */]])\n}), es6["t" /* type */]({\n  paths: Paths\n}));\nvar pfsListUpdated = createAction(\'pfsListUpdated\', es6["t" /* type */]({\n  pfsList: es6["o" /* readonlyArray */](Address)\n}));\nvar iouPersist = createAction(\'iouPersist\', es6["t" /* type */]({\n  iou: Signed(IOU)\n}), ServiceId);\nvar iouClear = createAction(\'iouClear\', undefined, ServiceId);\n// CONCATENATED MODULE: ../raiden-ts/dist/actions.js\n/* eslint-disable @typescript-eslint/class-name-casing */\n\n/**\n * Aggregate types and exported properties from actions from all modules\n */\n\n\n\n\n\n\n\n\n\n\nvar raidenShutdown = createAction(\'raidenShutdown\', es6["t" /* type */]({\n  reason: es6["v" /* union */]([es6["j" /* literal */](ShutdownReason.STOP), es6["j" /* literal */](ShutdownReason.ACCOUNT_CHANGED), es6["j" /* literal */](ShutdownReason.NETWORK_CHANGED), ErrorCodec])\n}));\nvar raidenConfigUpdate = createAction(\'raidenConfigUpdate\', PartialRaidenConfig);\nvar RaidenActions = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({\n  raidenShutdown: raidenShutdown,\n  raidenConfigUpdate: raidenConfigUpdate\n}, channels_actions_namespaceObject), transport_actions_namespaceObject), messages_actions_namespaceObject), transfers_actions_namespaceObject), path_actions_namespaceObject);\n/* Mapping { [type: string]: Action } of a subset of RaidenActions exposed as events */\n\nvar RaidenEvents = [RaidenActions.raidenShutdown, RaidenActions.newBlock, RaidenActions.matrixPresence.success, RaidenActions.tokenMonitored];\n/**\n * Set of [serializable] actions which are first emitted with\n * payload.confirmed=undefined, then, after confirmation blocks, either with confirmed=true if tx\n * is still present on blockchain, or confirmed=false if it got removed by a reorg.\n *\n * These actions must comply with the following type:\n * {\n *   payload: {\n *     txHash: Hash;\n *     txBlock: number;\n *     confirmed: undefined | boolean;\n *   };\n *   meta: any;\n * }\n */\n\nvar ConfirmableActions = [channelOpen.success, channelDeposit.success, channelWithdrawn, channelClose.success, channelSettle.success, transferSecretRegister.success];\n/**\n * Union of codecs of actions above\n */\n\nvar ConfirmableAction = es6["v" /* union */]([channelOpen.success.codec, channelDeposit.success.codec, channelWithdrawn.codec, channelClose.success.codec, channelSettle.success.codec, transferSecretRegister.success.codec]);\n// CONCATENATED MODULE: ../raiden-ts/dist/migration/0.js\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Migrate previous state to version 0\n *\n * @param state - RaidenState version -1\n * @returns State version 0\n */\nfunction migrate0(state) {\n  return Object.assign(Object.assign({}, state), {\n    version: 0\n  });\n}\n// CONCATENATED MODULE: ../raiden-ts/dist/migration/1.js\nfunction _1_slicedToArray(arr, i) { return _1_arrayWithHoles(arr) || _1_iterableToArrayLimit(arr, i) || _1_unsupportedIterableToArray(arr, i) || _1_nonIterableRest(); }\n\nfunction _1_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _1_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _1_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _1_arrayLikeToArray(o, minLen); }\n\nfunction _1_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _1_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _1_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Move secrets to \'secret\' member of the respective TransferState\n *\n * @param state - RaidenState version 0\n * @returns State version 1\n */\nfunction migrate1(state) {\n  var _a, _b, _c;\n\n  var sent = state.sent;\n\n  for (var _i = 0, _Object$entries = Object.entries(sent); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _1_slicedToArray(_Object$entries[_i], 2),\n        h = _Object$entries$_i[0],\n        t = _Object$entries$_i[1];\n\n    if (state.secrets[h]) {\n      Object.assign(t, {\n        secret: [(_b = (_a = t.secretReveal) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : t.transfer[0], {\n          value: state.secrets[h].secret,\n          registerBlock: (_c = state.secrets[h].registerBlock) !== null && _c !== void 0 ? _c : 0\n        }]\n      });\n    }\n  }\n\n  delete state[\'secrets\'];\n  return state;\n}\n// CONCATENATED MODULE: ../raiden-ts/dist/migration/2.js\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Adds: Channel.closeParticipant, TransferState.partner & RaidenState.received\n *\n * @param state - RaidenState version 1\n * @returns State version 2\n */\nfunction migrate2(state) {\n  for (var _i = 0, _Object$values = Object.values(state.channels); _i < _Object$values.length; _i++) {\n    var partnerChannels = _Object$values[_i];\n\n    for (var _i2 = 0, _Object$values2 = Object.values(partnerChannels); _i2 < _Object$values2.length; _i2++) {\n      var channel = _Object$values2[_i2];\n\n      if (channel.closeBlock) {\n        // assume we were the ones closing the channel\n        Object.assign(channel, {\n          closeParticipant: state.address\n        });\n      }\n    }\n  }\n\n  var sent = state.sent;\n\n  for (var _i3 = 0, _Object$values3 = Object.values(sent); _i3 < _Object$values3.length; _i3++) {\n    var t = _Object$values3[_i3];\n    Object.assign(t, {\n      partner: t.transfer[1].recipient\n    });\n  }\n\n  Object.assign(state, {\n    received: {}\n  });\n  return state;\n}\n// CONCATENATED MODULE: ../raiden-ts/dist/migration/index.js\nfunction migration_slicedToArray(arr, i) { return migration_arrayWithHoles(arr) || migration_iterableToArrayLimit(arr, i) || migration_unsupportedIterableToArray(arr, i) || migration_nonIterableRest(); }\n\nfunction migration_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction migration_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return migration_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return migration_arrayLikeToArray(o, minLen); }\n\nfunction migration_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction migration_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction migration_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\n\n\n // import above and populate this dict with new migrator functions\n// must be ordered, continuous, and last one MUST be state.CURRENT_STATE_VERSION\n\nvar migrations = {\n  0: migrate0,\n  1: migrate1,\n  2: migrate2\n};\n/**\n * Migrate a RaidenState from any previous version to latest one\n *\n * @param state - Previous raiden state\n * @param toVersion - Migrate up to this version\n * @returns A current RaidenState (hopefully), to be validated\n */\n\nfunction migrateState(state, toVersion) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    log: loglevel_default.a\n  },\n      log = _ref.log;\n\n  var _a;\n\n  for (var v = 0; v <= toVersion; v++) {\n    assert(v in migrations, "missing migration for ".concat(v));\n  }\n\n  for (var _i = 0, _Object$entries = Object.entries(migrations); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = migration_slicedToArray(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        migrate = _Object$entries$_i[1];\n\n    var version = +key;\n    if (((_a = state === null || state === void 0 ? void 0 : state.version) !== null && _a !== void 0 ? _a : -1) !== version - 1) continue;\n    if (version > toVersion) continue;\n\n    try {\n      state = Object.assign(migrate(state), {\n        version: version\n      });\n    } catch (err) {\n      log.error("Error migrating state from version ".concat(version - 1, " to ").concat(version), state, err);\n      throw err;\n    }\n  } // this must be validated as RaidenState, but is done in decodeRaidenState to avoid cyclic import\n\n\n  return state;\n}\n// EXTERNAL MODULE: ./node_modules/ethers/utils/bytes.js\nvar bytes = __webpack_require__("948b");\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/lossless-json/dist/lossless-json.js\nvar lossless_json = __webpack_require__("ad02");\n\n// CONCATENATED MODULE: ../raiden-ts/dist/utils/data.js\nfunction _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\n\n\n\n\n/**\n * Encode data to hex string of exactly length size (in bytes)\n * Throw if data can\'t be made to fit in length.\n *\n * @param data - May be of multiple types:\n *      - number|BigNumber: Encoded in the big-endian byte-order and left-zero-padded to length\n *      - string: Must be hex-encoded string of length bytes\n *      - number[] Must be of exactly of length size (left/right-pad it before if needed)\n * @param length - The expected length of the hex string, in bytes\n * @returns HexString byte-array of length\n */\n\nfunction encode(data, length) {\n  var hex;\n  if (typeof data === \'boolean\') data = data ? constants["One"] : constants["Zero"];else if (typeof data === \'number\') data = Object(utils["bigNumberify"])(data);\n  if (typeof data === \'string\' && !Object(bytes["isHexString"])(data)) data = Object(utils["toUtf8Bytes"])(data);\n  if (Object(bytes["isArrayish"])(data)) data = Object(bytes["hexlify"])(data);\n\n  if (BigNumberC.is(data)) {\n    if (data.lt(0)) throw new error_RaidenError(ErrorCodes.DTA_NEGATIVE_NUMBER);\n    if (data.gte(constants["Two"].pow(length * 8))) throw new error_RaidenError(ErrorCodes.DTA_NUMBER_TOO_LARGE);\n    hex = Object(bytes["hexZeroPad"])(Object(bytes["hexlify"])(data), length);\n  } else if (typeof data === \'string\') {\n    if (Object(bytes["hexDataLength"])(data) !== length) throw new error_RaidenError(ErrorCodes.DTA_ARRAY_LENGTH_DIFFRENCE);\n    hex = data;\n  } else {\n    throw new error_RaidenError(ErrorCodes.DTA_UNENCODABLE_DATA);\n  }\n\n  return hex;\n}\n\nvar isLosslessNumber = function isLosslessNumber(u) {\n  return (// eslint-disable-next-line @typescript-eslint/no-explicit-any\n    u != null && u[\'isLosslessNumber\']\n  );\n};\n/**\n * Opportunistic JSON.parse regarding numbers\n * If possible to decode a JSON number as JS number (i.e. value < 2^53) and return \'number\',\n * otherwise returns BigNumber object\n * Throws if handled invalid JSON\n *\n * @param text - JSON string to parse\n * @returns Decoded object\n */\n\n\nfunction losslessParse(text) {\n  return lossless_json["parse"](text, function (_ref, value) {\n    _objectDestructuringEmpty(_ref);\n\n    if (isLosslessNumber(value)) {\n      try {\n        return value.valueOf(); // return number, if possible, or throw if > 2^53\n      } catch (e) {\n        // else, convert early to BigNumber\n        return Object(utils["bigNumberify"])(value.toString());\n      }\n    }\n\n    return value;\n  });\n}\n/**\n * Stringify object losslessly, by converting BigNumbers to \'string\'s\n *\n * @param value - Object to be serialized as a string\n * @param replacer - Replacer function. Leave default to stringify BigNumbers\n * @param space - indentation spaces\n * @returns serialized representation of value\n */\n\nfunction losslessStringify(value) {\n  var replacer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (_ref2, value) {\n    _objectDestructuringEmpty(_ref2);\n\n    return utils["BigNumber"].isBigNumber(value) ? value.toString() : value;\n  };\n  var space = arguments.length > 2 ? arguments[2] : undefined;\n  return lossless_json["stringify"](value, replacer, space);\n}\n// CONCATENATED MODULE: ../raiden-ts/dist/channels/state.js\n\n\n\nvar ChannelState;\n\n(function (ChannelState) {\n  ChannelState["opening"] = "opening";\n  ChannelState["open"] = "open";\n  ChannelState["closing"] = "closing";\n  ChannelState["closed"] = "closed";\n  ChannelState["settleable"] = "settleable";\n  ChannelState["settling"] = "settling";\n  ChannelState["settled"] = "settled";\n})(ChannelState || (ChannelState = {}));\n/**\n * Contains info of each side of a channel\n */\n\n\nvar ChannelEnd = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  deposit: UInt(32)\n}), es6["m" /* partial */]({\n  locks: es6["o" /* readonlyArray */](Lock),\n  balanceProof: SignedBalanceProof,\n  withdraw: UInt(32)\n})]));\nvar Channel = es6["h" /* intersection */]([es6["n" /* readonly */](es6["t" /* type */]({\n  own: ChannelEnd,\n  partner: ChannelEnd\n})), es6["v" /* union */]([\n/* union of types with literals intersection allows narrowing other props presence. e.g.:\n * if (channel.state === ChannelState.open) {\n *   id = channel.id; // <- id can\'t be undefined\n *   closeBlock = channel.closeBlock; // error: closeBlock only exist on states closed|settling\n * }\n */\nes6["n" /* readonly */](es6["t" /* type */]({\n  state: es6["j" /* literal */](ChannelState.opening)\n})), es6["n" /* readonly */](es6["t" /* type */]({\n  state: es6["v" /* union */]([es6["j" /* literal */](ChannelState.open), es6["j" /* literal */](ChannelState.closing)]),\n  id: es6["l" /* number */],\n  settleTimeout: es6["l" /* number */],\n  openBlock: es6["l" /* number */],\n  isFirstParticipant: es6["d" /* boolean */]\n})), es6["n" /* readonly */](es6["t" /* type */]({\n  state: es6["v" /* union */]([es6["j" /* literal */](ChannelState.closed), es6["j" /* literal */](ChannelState.settleable), es6["j" /* literal */](ChannelState.settling)]),\n  id: es6["l" /* number */],\n  settleTimeout: es6["l" /* number */],\n  openBlock: es6["l" /* number */],\n  isFirstParticipant: es6["d" /* boolean */],\n  closeBlock: es6["l" /* number */],\n  closeParticipant: Address\n}))])]);\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/state.js\n\n\n\nvar Direction;\n\n(function (Direction) {\n  Direction["SENT"] = "sent";\n  Direction["RECEIVED"] = "received";\n})(Direction || (Direction = {}));\n/**\n * This struct holds the relevant messages exchanged in a transfer\n * The transfer state is defined by the exchanged messages\n */\n\n\nvar TransferState = es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n  /** -> outgoing locked transfer */\n  transfer: Timed(Signed(LockedTransfer)),\n  fee: Int(32),\n  partner: Address\n}), es6["m" /* partial */]({\n  /**\n   * Transfer secret, if known\n   * registerBlock is 0 if not yet registered on-chain\n   * */\n  secret: Timed(es6["t" /* type */]({\n    value: Secret,\n    registerBlock: es6["l" /* number */]\n  })),\n\n  /** <- incoming processed for locked transfer */\n  transferProcessed: Timed(Signed(Processed)),\n\n  /**\n   * <- incoming refund transfer (if so)\n   * If this is set, transfer failed and partner tried refunding the transfer to us. We don\'t\n   * handle receiving transfers, but just store it here to mark this transfer as failed with a\n   * refund, until the lock expires normally\n   */\n  refund: Timed(Signed(RefundTransfer)),\n\n  /**\n   * !! channel was closed !!\n   * In the case a channel is closed (possibly middle transfer), this will be the txHash of the\n   * CloseChannel transaction. No further actions are possible after it\'s set.\n   */\n  channelClosed: Timed(Hash),\n\n  /**\n   * <- incoming secret request from target\n   * If this is set, it means the target requested the secret, not necessarily with a valid\n   * amount (an invalid amount < value == lock - fee, means transfer failed)\n   */\n  secretRequest: Timed(Signed(SecretRequest)),\n\n  /**\n   * -> outgoing secret reveal to target\n   * If this is set, it means the secret was revealed (so transfer succeeded, even if it didn\'t\n   * complete yet)\n   */\n  secretReveal: Timed(Signed(SecretReveal)),\n\n  /**\n   * -> outgoing unlock to recipient\n   * If this is set, it means the Unlock was sent (even if partner didn\'t acknowledge it yet)\n   */\n  unlock: Timed(Signed(Unlock)),\n\n  /**\n   * -> outgoing lock expired (if so)\n   * If this is set, transfer failed, and we expired the lock (retrieving the locked amount).\n   * Transfer failed may not have completed yet, e.g. waiting for LockExpired\'s Processed reply\n   */\n  lockExpired: Timed(Signed(LockExpired)),\n\n  /**\n   * <- incoming processed for Unlock message\n   * If this is set, the protocol completed by the transfer succeeding and partner\n   * acknowledging validity of our off-chain unlock\n   */\n  unlockProcessed: Timed(Signed(Processed)),\n\n  /**\n   * <- incoming processed for LockExpired message\n   * If this is set, the protocol completed by the transfer failing and partner acknowledging\n   * this transfer can\'t be claimed anymore\n   */\n  lockExpiredProcessed: Timed(Signed(Processed))\n})]));\n/**\n * Mapping of outgoing transfers, indexed by the secrethash\n */\n\nvar TransfersState = es6["n" /* readonly */](es6["p" /* record */](es6["q" /* string */]\n/* secrethash: Hash */\n, TransferState));\nvar RaidenTransferStatus;\n\n(function (RaidenTransferStatus) {\n  RaidenTransferStatus["pending"] = "PENDING";\n  RaidenTransferStatus["received"] = "RECEIVED";\n  RaidenTransferStatus["refunded"] = "REFUNDED";\n  RaidenTransferStatus["closed"] = "CLOSED";\n  RaidenTransferStatus["requested"] = "REQUESTED";\n  RaidenTransferStatus["revealed"] = "REVEALED";\n  RaidenTransferStatus["registered"] = "REGISTERED";\n  RaidenTransferStatus["unlocking"] = "UNLOCKING";\n  RaidenTransferStatus["expiring"] = "EXPIRING";\n  RaidenTransferStatus["unlocked"] = "UNLOCKED";\n  RaidenTransferStatus["expired"] = "EXPIRED";\n})(RaidenTransferStatus || (RaidenTransferStatus = {}));\n// CONCATENATED MODULE: ../raiden-ts/dist/state.js\n\n\nvar state_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/* eslint-disable @typescript-eslint/camelcase */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n // same as highest migrator function in migration.index.migrators\n\nvar CURRENT_STATE_VERSION = 2; // types\n\nvar RaidenState = es6["n" /* readonly */](es6["t" /* type */]({\n  address: Address,\n  version: es6["j" /* literal */](CURRENT_STATE_VERSION),\n  chainId: es6["l" /* number */],\n  registry: Address,\n  blockNumber: es6["l" /* number */],\n  config: PartialRaidenConfig,\n  channels: es6["n" /* readonly */](es6["p" /* record */](es6["q" /* string */]\n  /* tokenNetwork: Address */\n  , es6["n" /* readonly */](es6["p" /* record */](es6["q" /* string */]\n  /* partner: Address */\n  , Channel)))),\n  tokens: es6["n" /* readonly */](es6["p" /* record */](es6["q" /* string */]\n  /* token: Address */\n  , Address)),\n  transport: es6["n" /* readonly */](es6["m" /* partial */]({\n    matrix: es6["n" /* readonly */](es6["h" /* intersection */]([es6["t" /* type */]({\n      server: es6["q" /* string */]\n    }), es6["m" /* partial */]({\n      setup: RaidenMatrixSetup,\n      rooms: es6["n" /* readonly */](es6["p" /* record */](es6["q" /* string */]\n      /* partner: Address */\n      , es6["c" /* array */](es6["q" /* string */])))\n    })]))\n  })),\n  sent: TransfersState,\n  received: TransfersState,\n  path: es6["t" /* type */]({\n    iou: es6["n" /* readonly */](es6["p" /* record */](es6["q" /* string */]\n    /* tokenNetwork: Address */\n    , es6["p" /* record */](es6["q" /* string */]\n    /* service: Address */\n    , Signed(IOU))))\n  }),\n  pendingTxs: es6["o" /* readonlyArray */](ConfirmableAction)\n})); // helpers, utils & constants\n\n/**\n * Encode RaidenState to a JSON string\n * For Raiden client compliance, this JSON encodes BigNumbers as \'number\' (using lossless-json lib)\n * which is valid json though not very common as common JS implementations lose precision when\n * decoding through JSON.parse. This is solved in SDK by both encoding and decoding BigNumbers\n * using lossless-json, without going through the intermediary JS-number form.\n *\n * @param state - RaidenState object\n * @returns JSON encoded string\n */\n\nfunction encodeRaidenState(state) {\n  return losslessStringify(RaidenState.encode(state), undefined, 2);\n}\n/**\n * Try to migrate & decode data as RaidenState.\n * If handled a string, will parse it with lossless-json, to preserve BigNumbers encoded as JSON\n * \'number\'. The data may be migrated from previous versions, then validated as current RaidenState\n *\n * @param data - string | any which may be decoded as RaidenState\n * @returns RaidenState parsed, migrated and validated\n */\n\nfunction decodeRaidenState(data) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    log: loglevel_default.a\n  },\n      log = _ref.log;\n\n  if (typeof data === \'string\') data = losslessParse(data);\n  var state = migrateState(data, CURRENT_STATE_VERSION, {\n    log: log\n  }); // validates and returns as current state\n\n  try {\n    return decode(RaidenState, state);\n  } catch (err) {\n    log.error("Error validating migrated state version=".concat(state === null || state === void 0 ? void 0 : state.version), state);\n    throw err;\n  }\n}\n/**\n * Create an initial RaidenState from common parameters (including default config)\n *\n * @param obj - Object containing common parameters for state\n * @param obj.network - ether\'s Network object for the current blockchain\n * @param obj.address - current account\'s address\n * @param overwrites - A partial object to overwrite top-level properties of the returned config\n * @returns A full config object\n */\n\nfunction makeInitialState(_ref2) {\n  var network = _ref2.network,\n      address = _ref2.address,\n      contractsInfo = _ref2.contractsInfo;\n  var overwrites = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  return {\n    address: address,\n    version: CURRENT_STATE_VERSION,\n    chainId: network.chainId,\n    registry: contractsInfo.TokenNetworkRegistry.address,\n    blockNumber: contractsInfo.TokenNetworkRegistry.block_number,\n    config: (_a = overwrites.config) !== null && _a !== void 0 ? _a : {},\n    channels: {},\n    tokens: {},\n    transport: {},\n    sent: {},\n    received: {},\n    path: {\n      iou: {}\n    },\n    pendingTxs: []\n  };\n}\n/**\n * state constant used as default state reducer parameter only.\n * To build an actual initial state at runtime, use [[makeInitialState]] instead.\n */\n\nvar state_initialState = makeInitialState({\n  network: Object(utils["getNetwork"])(\'unspecified\'),\n  address: constants["AddressZero"],\n  contractsInfo: {\n    TokenNetworkRegistry: {\n      address: constants["AddressZero"],\n      block_number: 0\n    },\n    ServiceRegistry: {\n      address: constants["AddressZero"],\n      block_number: 0\n    },\n    UserDeposit: {\n      address: constants["AddressZero"],\n      block_number: 0\n    },\n    SecretRegistry: {\n      address: constants["AddressZero"],\n      block_number: 0\n    }\n  }\n});\n/**\n * Checks whether `storageOrState` is [[Storage]]\n *\n * @param storage - either state or [[Storage]]\n * @returns true if storageOrState is [[Storage]]\n */\n\nvar isStorage = function isStorage(storage) {\n  return storage && typeof storage.getItem === \'function\';\n};\n/**\n * Loads state from `storageOrState`. Returns the initial [[RaidenState]] if\n * `storageOrState` does not exist.\n *\n * @param network - current network\n * @param contracts - current contracts\n * @param address - current address of the signer\n * @param storageOrState - either [[Storage]] or [[RaidenState]] or\n *        { storage: [[Storage]]; state?: [[RaidenState]] }\n * @param config - raiden config\n * @returns true if storageOrState is [[Storage]]\n */\n\n\nvar state_getState = function getState(network, contracts, address, storageOrState, config) {\n  return state_awaiter(void 0, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    var log, onState, onStateComplete, storage, providedState, state, ns, storedData, storedState, debouncedState, defaultConfig;\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            log = loglevel_default.a.getLogger("raiden:".concat(address));\n\n            if (isStorage(storageOrState)) {\n              // stateOrStorage is storage\n              storage = storageOrState;\n              providedState = undefined;\n            } else if (isStorage(storageOrState === null || storageOrState === void 0 ? void 0 : storageOrState.storage)) {\n              // stateOrStorage is in the format { storage: Storage; state?: RaidenState | unknown }\n              storage = storageOrState.storage;\n              providedState = storageOrState.state;\n            } else {\n              // stateOrStorage is state, no storage provided\n              storage = undefined;\n              providedState = storageOrState;\n            }\n\n            state = undefined;\n\n            if (providedState) {\n              state = decodeRaidenState(providedState, {\n                log: log\n              });\n            }\n\n            if (!storage) {\n              _context.next = 23;\n              break;\n            }\n\n            ns = "raiden_".concat(getNetworkName(network), "_").concat(contracts.TokenNetworkRegistry.address, "_").concat(address);\n            _context.next = 8;\n            return storage.getItem(ns);\n\n          case 8:\n            storedData = _context.sent;\n\n            if (!storedData) {\n              _context.next = 20;\n              break;\n            }\n\n            storedState = decodeRaidenState(storedData, {\n              log: log\n            });\n\n            if (!state\n            /* provided */\n            ) {\n              _context.next = 19;\n              break;\n            }\n\n            if (!(state.blockNumber < storedState.blockNumber)) {\n              _context.next = 16;\n              break;\n            }\n\n            throw new error_RaidenError(ErrorCodes.RDN_STATE_MIGRATION, {\n              storedStateBlockNumber: storedState.blockNumber,\n              providedStateBlockNumber: state.blockNumber\n            });\n\n          case 16:\n            log.warn("Replacing stored state @blockNumber=".concat(storedState.blockNumber, " with newer provided state @blockNumber=").concat(state.blockNumber));\n\n          case 17:\n            _context.next = 20;\n            break;\n\n          case 19:\n            // no provided state but there\'s a stored one, use it\n            state = storedState;\n\n          case 20:\n            // else, no stored state, initialize a new one below, if needed\n            // to be subscribed on raiden.state$\n            debouncedState = debounce_default()(function (state) {\n              storage.setItem(ns, encodeRaidenState(state));\n            }, 1000, {\n              maxWait: 5000\n            });\n            onState = debouncedState;\n\n            onStateComplete = function onStateComplete() {\n              return debouncedState.flush();\n            };\n\n          case 23:\n            // if no provided nor stored state, initialize a pristine one\n            if (!state) state = makeInitialState({\n              network: network,\n              address: address,\n              contractsInfo: contracts\n            });\n            defaultConfig = makeDefaultConfig({\n              network: network\n            }, config);\n            return _context.abrupt("return", {\n              state: state,\n              onState: onState,\n              onStateComplete: onStateComplete,\n              defaultConfig: defaultConfig\n            });\n\n          case 26:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n};\n// EXTERNAL MODULE: ./node_modules/lodash/fp/unset.js\nvar unset = __webpack_require__("9bf7");\nvar unset_default = /*#__PURE__*/__webpack_require__.n(unset);\n\n// EXTERNAL MODULE: ./node_modules/lodash/fp/get.js\nvar fp_get = __webpack_require__("76e3");\nvar get_default = /*#__PURE__*/__webpack_require__.n(fp_get);\n\n// EXTERNAL MODULE: ./node_modules/lodash/fp/set.js\nvar set = __webpack_require__("9aca");\nvar set_default = /*#__PURE__*/__webpack_require__.n(set);\n\n// EXTERNAL MODULE: ./node_modules/lodash/fp/getOr.js\nvar getOr = __webpack_require__("0cdc");\nvar getOr_default = /*#__PURE__*/__webpack_require__.n(getOr);\n\n// CONCATENATED MODULE: ../raiden-ts/dist/utils/redux.js\nfunction redux_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Like redux\'s combineReducers, but allows passing only a partial reducer mapping\n * redux\'s combineReducers output state must be exactly the mapping passed as parameter,\n * which doesn\'t allow to only provide a partial set of reducers and passthrough the other state\'s\n * keys. This function allows that, also preserving state/object reference when reducers don\'t\n * change state value.\n *\n * @param reducers - A mapping of a subset of state\'s key to nested reducers functions\n * @param initialState - global initial state, required when initializing first object with partial\n *                      reducers\n * @returns Full reducer for state S and actions A\n */\nfunction partialCombineReducers(reducers, initialState) {\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n    var action = arguments.length > 1 ? arguments[1] : undefined;\n\n    var _a;\n\n    for (var key in reducers) {\n      var reducer = reducers[key];\n      if (!reducer) continue; // shouldn\'t happen, only here for type safety below\n\n      var subState = (_a = state[key]) !== null && _a !== void 0 ? _a : initialState[key];\n      var newSubState = reducer(subState, action);\n\n      if (newSubState !== subState) {\n        state = Object.assign(Object.assign({}, state), redux_defineProperty({}, key, newSubState));\n      }\n    }\n\n    return state;\n  };\n}\n// CONCATENATED MODULE: ../raiden-ts/dist/channels/reducer.js\nfunction reducer_toConsumableArray(arr) { return reducer_arrayWithoutHoles(arr) || reducer_iterableToArray(arr) || reducer_unsupportedIterableToArray(arr) || reducer_nonIterableSpread(); }\n\nfunction reducer_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction reducer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return reducer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return reducer_arrayLikeToArray(o, minLen); }\n\nfunction reducer_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction reducer_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return reducer_arrayLikeToArray(arr); }\n\nfunction reducer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction reducer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction reducer_objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }\n\n\n\n\n\n\n\n\n\n\n\n // state.blockNumber specific reducer, handles only newBlock action\n\nvar reducer_blockNumber = createReducer(state_initialState.blockNumber).handle(newBlock, function (_ref, _ref2) {\n  reducer_objectDestructuringEmpty(_ref);\n\n  var payload = _ref2.payload;\n  return payload.blockNumber;\n}); // state.tokens specific reducer, handles only tokenMonitored action\n\nvar tokens = createReducer(state_initialState.tokens).handle(tokenMonitored, function (state, _ref3) {\n  var _ref3$payload = _ref3.payload,\n      token = _ref3$payload.token,\n      tokenNetwork = _ref3$payload.tokenNetwork;\n  return Object.assign(Object.assign({}, state), reducer_defineProperty({}, token, tokenNetwork));\n}); // Reducers for different actions\n\nfunction channelOpenRequestReducer(state, action) {\n  var path = [action.meta.tokenNetwork, action.meta.partner];\n  if (get_default()(path, state)) return state; // there\'s already a channel with partner\n\n  var channel = {\n    state: ChannelState.opening,\n    own: {\n      deposit: constants["Zero"]\n    },\n    partner: {\n      deposit: constants["Zero"]\n    }\n  };\n  return set_default()(path, channel, state);\n}\n\nfunction channelOpenSuccessReducer(state, action) {\n  var path = [action.meta.tokenNetwork, action.meta.partner]; // ignore if older than currently set channel, or unconfirmed or removed\n\n  if (getOr_default()(0, [].concat(path, [\'openBlock\']), state) >= action.payload.txBlock || !action.payload.confirmed) return state;\n  var channel = {\n    state: ChannelState.open,\n    own: {\n      deposit: constants["Zero"]\n    },\n    partner: {\n      deposit: constants["Zero"]\n    },\n    id: action.payload.id,\n    settleTimeout: action.payload.settleTimeout,\n    isFirstParticipant: action.payload.isFirstParticipant,\n    openBlock: action.payload.txBlock\n  };\n  return set_default()(path, channel, state);\n}\n\nfunction channelOpenFailureReducer(state, action) {\n  var path = [action.meta.tokenNetwork, action.meta.partner];\n  if (get_default()([].concat(path, [\'state\']), state) !== ChannelState.opening) return state;\n  return unset_default()(path, state);\n}\n\nfunction channelUpdateOnchainBalanceStateReducer(state, action) {\n  // ignore event if unconfirmed or removed\n  if (!action.payload.confirmed) return state;\n  var path = [action.meta.tokenNetwork, action.meta.partner];\n  var channel = get_default()(path, state);\n  if (!channel || channel.state !== ChannelState.open || channel.id !== action.payload.id) return state;\n  var key = channelWithdrawn.is(action) ? \'withdraw\' : \'deposit\';\n  var total = channelWithdrawn.is(action) ? action.payload.totalWithdraw : action.payload.totalDeposit;\n  var isPartner = action.payload.participant === action.meta.partner;\n  var channelSide = isPartner ? \'partner\' : \'own\';\n  var channelEndData = isPartner ? channel.partner : channel.own;\n  channel = Object.assign(Object.assign({}, channel), reducer_defineProperty({}, channelSide, Object.assign(Object.assign({}, channelEndData), reducer_defineProperty({}, key, total))));\n  return set_default()(path, channel, state);\n}\n\nfunction channelCloseSuccessReducer(state, action) {\n  var path = [action.meta.tokenNetwork, action.meta.partner];\n  var channel = get_default()(path, state);\n  if (!channel || !(channel.state === ChannelState.open || channel.state === ChannelState.closing) || channel.id !== action.payload.id) return state; // even on non-confirmed action, already set channel state as closing, so it can\'t be used for new transfers\n\n  if (action.payload.confirmed === undefined && channel.state === ChannelState.open) channel = Object.assign(Object.assign({}, channel), {\n    state: ChannelState.closing\n  });else if (action.payload.confirmed) channel = Object.assign(Object.assign({}, channel), {\n    state: ChannelState.closed,\n    closeBlock: action.payload.txBlock,\n    closeParticipant: action.payload.participant\n  });else return state;\n  return set_default()(path, channel, state);\n}\n\nfunction channelUpdateStateReducer(state, action) {\n  var path = [action.meta.tokenNetwork, action.meta.partner];\n  var channel = get_default()(path, state);\n  if (!channel) return state;\n\n  if (channelClose.request.is(action) && channel.state === ChannelState.open) {\n    channel = Object.assign(Object.assign({}, channel), {\n      state: ChannelState.closing\n    });\n  } else if (channelSettle.request.is(action) && channel.state === ChannelState.settleable) {\n    channel = Object.assign(Object.assign({}, channel), {\n      state: ChannelState.settling\n    });\n  } else if (channelSettleable.is(action) && channel.state === ChannelState.closed) {\n    channel = Object.assign(Object.assign({}, channel), {\n      state: ChannelState.settleable\n    });\n  } else {\n    return state;\n  }\n\n  return set_default()(path, channel, state);\n}\n\nfunction channelSettleSuccessReducer(state, action) {\n  var path = [action.meta.tokenNetwork, action.meta.partner];\n  var channel = get_default()(path, state);\n  if (!channel || channel.state === ChannelState.opening || channel.state === ChannelState.open || channel.state === ChannelState.closing || channel.id !== action.payload.id) return state; // even on non-confirmed action, already set channel as settling\n\n  if (action.payload.confirmed === undefined && channel.state !== ChannelState.settling) return set_default()(path, Object.assign(Object.assign({}, channel), {\n    state: ChannelState.settling\n  }), state);else if (action.payload.confirmed) return unset_default()(path, state);else return state;\n} // handles all channel actions and requests\n\n\nvar reducer_channels = createReducer(state_initialState.channels).handle(channelOpen.request, channelOpenRequestReducer).handle(channelOpen.success, channelOpenSuccessReducer).handle(channelOpen.failure, channelOpenFailureReducer).handle([channelDeposit.success, channelWithdrawn], channelUpdateOnchainBalanceStateReducer).handle([channelClose.request, channelSettleable, channelSettle.request], channelUpdateStateReducer).handle(channelClose.success, channelCloseSuccessReducer).handle(channelSettle.success, channelSettleSuccessReducer);\n\nvar reducer_pendingTxs = function pendingTxs() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : state_initialState.pendingTxs;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n  // filter out non-ConfirmableActions\'s\n  if (!isActionOf(ConfirmableActions, action)) return state; // if confirmed==undefined, add action to state\n  else if (action.payload.confirmed === undefined) return [].concat(reducer_toConsumableArray(state), [action]); // else (either confirmed or removed), remove from state\n    else {\n        var newState = state.filter(function (a) {\n          return a.type !== action.type || action.payload.txHash !== a.payload.txHash;\n        });\n        if (newState.length !== state.length) return newState;\n        return state;\n      }\n};\n/**\n * Nested/combined reducer for channels\n * blockNumber, tokens & channels reducers get its own slice of the state, corresponding to the\n * name of the reducer. channels root reducer instead must be handled the complete state instead,\n * so it compose the output with each key/nested/combined state.\n */\n\n\nvar channelsReducer = partialCombineReducers({\n  blockNumber: reducer_blockNumber,\n  tokens: tokens,\n  channels: reducer_channels,\n  pendingTxs: reducer_pendingTxs\n}, state_initialState);\n// CONCATENATED MODULE: ../raiden-ts/dist/path/reducer.js\n/**\n * state.path reducer\n * Handles all path actions and requests\n *\n * @param state - Current RaidenState[\'path\'] slice\n * @param action - RaidenAction to handle\n * @returns New RaidenState[\'path\'] slice\n */\n\n\n\n\n\n\nvar reducer_path = createReducer(state_initialState.path).handle(iouPersist, function (state, action) {\n  var path = [\'iou\', action.meta.tokenNetwork, action.meta.serviceAddress];\n  return set_default()(path, action.payload.iou, state);\n}).handle(iouClear, function (state, action) {\n  var path = [\'iou\', action.meta.tokenNetwork, action.meta.serviceAddress];\n  return unset_default()(path, state);\n});\n/**\n * Nested combined reducer for path\n * Handles the \'path\' substate.\n */\n\nvar pathReducer = partialCombineReducers({\n  path: reducer_path\n}, state_initialState);\n// EXTERNAL MODULE: ./node_modules/lodash/fp/isEmpty.js\nvar isEmpty = __webpack_require__("2890");\nvar isEmpty_default = /*#__PURE__*/__webpack_require__.n(isEmpty);\n\n// CONCATENATED MODULE: ../raiden-ts/dist/transport/reducer.js\nfunction transport_reducer_toConsumableArray(arr) { return transport_reducer_arrayWithoutHoles(arr) || transport_reducer_iterableToArray(arr) || transport_reducer_unsupportedIterableToArray(arr) || transport_reducer_nonIterableSpread(); }\n\nfunction transport_reducer_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction transport_reducer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return transport_reducer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transport_reducer_arrayLikeToArray(o, minLen); }\n\nfunction transport_reducer_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction transport_reducer_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return transport_reducer_arrayLikeToArray(arr); }\n\nfunction transport_reducer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar __rest = undefined && undefined.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\n\n\n\n\n\n\n\n\n\n/**\n * state.transport reducer\n * Handles all transport actions and requests\n *\n * @param state - Current RaidenState[\'transport\'] slice\n * @param action - RaidenAction to handle\n * @returns New RaidenState[\'transport\'] slice\n */\n\nvar transport = createReducer(state_initialState.transport).handle(matrixSetup, function (state, action) {\n  var _a; // immutably remove rooms from state.matrix\n\n\n  var _b = Object.assign({}, state.matrix),\n      _ = _b.rooms,\n      noRooms = __rest(_b, ["rooms"]);\n\n  return Object.assign(Object.assign({}, state), {\n    matrix: Object.assign(Object.assign({}, ((_a = state.matrix) === null || _a === void 0 ? void 0 : _a.server) !== action.payload.server ? noRooms : state.matrix), action.payload)\n  });\n}).handle(matrixRoom, function (state, action) {\n  var path = [\'matrix\', \'rooms\', action.meta.address];\n  return set_default()(path, [action.payload.roomId].concat(transport_reducer_toConsumableArray(getOr_default()([], path, state).filter(function (room) {\n    return room !== action.payload.roomId;\n  }))), state);\n}).handle(matrixRoomLeave, function (state, action) {\n  var path = [\'matrix\', \'rooms\', action.meta.address];\n  state = set_default()(path, getOr_default()([], path, state).filter(function (r) {\n    return r !== action.payload.roomId;\n  }), state);\n  if (isEmpty_default()(get_default()(path, state))) state = unset_default()(path, state);\n  return state;\n});\n/**\n * Nested/combined reducer for transport\n * Currently only handles \'transport\' substate\n */\n\nvar transportReducer = partialCombineReducers({\n  transport: transport\n}, state_initialState);\n// EXTERNAL MODULE: ./node_modules/ethers/utils/rlp.js\nvar rlp = __webpack_require__("3b2b");\n\n// CONCATENATED MODULE: ../raiden-ts/dist/messages/utils.js\n\n\nvar _CMDIDs;\n\nfunction utils_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { utils_typeof = function _typeof(obj) { return typeof obj; }; } else { utils_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return utils_typeof(obj); }\n\nfunction utils_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar utils_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\n\n\n\n\n\n\n\n\n\n\nvar CMDIDs = (_CMDIDs = {}, utils_defineProperty(_CMDIDs, MessageType.DELIVERED, 12), utils_defineProperty(_CMDIDs, MessageType.PROCESSED, 0), utils_defineProperty(_CMDIDs, MessageType.SECRET_REQUEST, 3), utils_defineProperty(_CMDIDs, MessageType.SECRET_REVEAL, 11), utils_defineProperty(_CMDIDs, MessageType.LOCKED_TRANSFER, 7), utils_defineProperty(_CMDIDs, MessageType.REFUND_TRANSFER, 8), utils_defineProperty(_CMDIDs, MessageType.UNLOCK, 4), utils_defineProperty(_CMDIDs, MessageType.LOCK_EXPIRED, 13), utils_defineProperty(_CMDIDs, MessageType.WITHDRAW_REQUEST, 15), utils_defineProperty(_CMDIDs, MessageType.WITHDRAW_CONFIRMATION, 16), utils_defineProperty(_CMDIDs, MessageType.WITHDRAW_EXPIRED, 17), utils_defineProperty(_CMDIDs, MessageType.PFS_CAPACITY_UPDATE, -1), utils_defineProperty(_CMDIDs, MessageType.PFS_FEE_UPDATE, -1), _CMDIDs); // raiden_contracts.constants.MessageTypeId\n\nvar MessageTypeId;\n\n(function (MessageTypeId) {\n  MessageTypeId[MessageTypeId["BALANCE_PROOF"] = 1] = "BALANCE_PROOF";\n  MessageTypeId[MessageTypeId["WITHDRAW"] = 3] = "WITHDRAW";\n  MessageTypeId[MessageTypeId["IOU"] = 5] = "IOU";\n})(MessageTypeId || (MessageTypeId = {}));\n/**\n * Create the hash of Metadata structure.\n *\n * @param metadata - The LockedTransfer metadata\n * @returns Hash of the metadata.\n */\n\n\nfunction createMetadataHash(metadata) {\n  var routeHashes = metadata.routes.map(function (value) {\n    return Object(utils["keccak256"])(utils["RLP"].encode(value.route));\n  });\n  return Object(utils["keccak256"])(utils["RLP"].encode(routeHashes));\n}\n/**\n * Returns a balance_hash from transferred&locked amounts & locksroot\n *\n * @param transferredAmount - EnvelopeMessage.transferred_amount\n * @param lockedAmount - EnvelopeMessage.locked_amount\n * @param locksroot - Hash of all current locks\n * @returns Hash of the balance\n */\n\nfunction createBalanceHash(transferredAmount, lockedAmount, locksroot) {\n  return transferredAmount.isZero() && lockedAmount.isZero() && locksroot === constants["HashZero"] ? constants["HashZero"] : Object(utils["keccak256"])(Object(bytes["concat"])([encode(transferredAmount, 32), encode(lockedAmount, 32), encode(locksroot, 32)]));\n}\n/**\n * Create the messageHash for a given EnvelopeMessage\n *\n * @param message - EnvelopeMessage to pack\n * @returns Hash of the message pack\n */\n\nfunction createMessageHash(message) {\n  switch (message.type) {\n    case MessageType.LOCKED_TRANSFER:\n    case MessageType.REFUND_TRANSFER:\n      // hash of packed representation of the whole message\n      var packed = Object(bytes["concat"])([encode(CMDIDs[message.type], 1), encode(message.message_identifier, 8), encode(message.payment_identifier, 8), encode(message.lock.expiration, 32), encode(message.token, 20), encode(message.recipient, 20), encode(message.target, 20), encode(message.initiator, 20), encode(message.lock.secrethash, 32), encode(message.lock.amount, 32)]);\n      if (message.type === MessageType.LOCKED_TRANSFER) packed = Object(bytes["concat"])([packed, createMetadataHash(message.metadata)]);\n      return Object(utils["keccak256"])(packed);\n\n    case MessageType.UNLOCK:\n      return Object(utils["keccak256"])(Object(bytes["concat"])([encode(CMDIDs[message.type], 1), encode(message.message_identifier, 8), encode(message.payment_identifier, 8), encode(message.secret, 32)]));\n\n    case MessageType.LOCK_EXPIRED:\n      return Object(utils["keccak256"])(Object(bytes["concat"])([encode(CMDIDs[message.type], 1), encode(message.message_identifier, 8), encode(message.recipient, 20), encode(message.secrethash, 32)]));\n  }\n}\n/**\n * Pack a message in a hex-string format, **without** signature\n * This packed hex-byte-array can then be used for signing.\n * On Raiden python client, this is the output of `_data_to_sign` method of the messages, as the\n * actual packed encoding was once used for binary transport protocols, but nowadays is used only\n * for generating data to be signed, which is the purpose of our implementation.\n *\n * @param message - Message to be packed\n * @returns HexBytes hex-encoded string data representing message in binary format\n */\n\nfunction packMessage(message) {\n  var _a;\n\n  switch (message.type) {\n    case MessageType.DELIVERED:\n      return Object(bytes["hexlify"])(Object(bytes["concat"])([encode(CMDIDs[message.type], 1), encode(0, 3), encode(message.delivered_message_identifier, 8)]));\n\n    case MessageType.PROCESSED:\n      return Object(bytes["hexlify"])(Object(bytes["concat"])([encode(CMDIDs[message.type], 1), encode(0, 3), encode(message.message_identifier, 8)]));\n\n    case MessageType.LOCKED_TRANSFER:\n    case MessageType.REFUND_TRANSFER:\n    case MessageType.UNLOCK:\n    case MessageType.LOCK_EXPIRED:\n      {\n        var messageHash = createMessageHash(message),\n            balanceHash = createBalanceHash(message.transferred_amount, message.locked_amount, message.locksroot);\n        return Object(bytes["hexlify"])(Object(bytes["concat"])([encode(message.token_network_address, 20), encode(message.chain_id, 32), encode(MessageTypeId.BALANCE_PROOF, 32), encode(message.channel_identifier, 32), encode(balanceHash, 32), encode(message.nonce, 32), encode(messageHash, 32)]));\n      }\n\n    case MessageType.SECRET_REQUEST:\n      return Object(bytes["hexlify"])(Object(bytes["concat"])([encode(CMDIDs[message.type], 1), encode(0, 3), encode(message.message_identifier, 8), encode(message.payment_identifier, 8), encode(message.secrethash, 32), encode(message.amount, 32), encode(message.expiration, 32)]));\n\n    case MessageType.SECRET_REVEAL:\n      return Object(bytes["hexlify"])(Object(bytes["concat"])([encode(CMDIDs[message.type], 1), encode(0, 3), encode(message.message_identifier, 8), encode(message.secret, 32)]));\n\n    case MessageType.WITHDRAW_REQUEST:\n    case MessageType.WITHDRAW_CONFIRMATION:\n      return Object(bytes["hexlify"])(Object(bytes["concat"])([encode(message.token_network_address, 20), encode(message.chain_id, 32), encode(MessageTypeId.WITHDRAW, 32), encode(message.channel_identifier, 32), encode(message.participant, 20), encode(message.total_withdraw, 32), encode(message.expiration, 32)]));\n\n    case MessageType.WITHDRAW_EXPIRED:\n      return Object(bytes["hexlify"])(Object(bytes["concat"])([encode(CMDIDs[message.type], 1), encode(0, 3), encode(message.nonce, 32), encode(message.message_identifier, 8), encode(message.token_network_address, 20), encode(message.chain_id, 32), encode(MessageTypeId.WITHDRAW, 32), encode(message.channel_identifier, 32), encode(message.participant, 20), encode(message.total_withdraw, 32), encode(message.expiration, 32)]));\n\n    case MessageType.PFS_CAPACITY_UPDATE:\n      return Object(bytes["hexlify"])(Object(bytes["concat"])([encode(message.canonical_identifier.chain_identifier, 32), encode(message.canonical_identifier.token_network_address, 20), encode(message.canonical_identifier.channel_identifier, 32), encode(message.updating_participant, 20), encode(message.other_participant, 20), encode(message.updating_nonce, 8), encode(message.other_nonce, 8), encode(message.updating_capacity, 32), encode(message.other_capacity, 32), encode(message.reveal_timeout, 32)]));\n\n    case MessageType.PFS_FEE_UPDATE:\n      return Object(bytes["hexlify"])(Object(bytes["concat"])([encode(message.canonical_identifier.chain_identifier, 32), encode(message.canonical_identifier.token_network_address, 20), encode(message.canonical_identifier.channel_identifier, 32), encode(message.updating_participant, 20), encode(message.fee_schedule.cap_fees, 1), encode(message.fee_schedule.flat, 32), encode(message.fee_schedule.proportional, 32), Object(rlp["encode"])((_a = message.fee_schedule.imbalance_penalty) !== null && _a !== void 0 ? _a : \'0x\'), encode(message.timestamp, 19)]));\n    // variable size of fee_schedule.imbalance_penalty rlpEncoding, when not null\n  }\n}\n/**\n * Typeguard to check if a message contains a valid signature\n *\n * @param message - May or may not be a signed message\n * @returns Boolean if message is signed\n */\n\nfunction isSigned(message) {\n  return Signature.is(message.signature);\n}\n/**\n * Requires a signed message and returns its signer address\n *\n * @param message - Signed message to retrieve signer address\n * @returns Address which signed message\n */\n\nfunction getMessageSigner(message) {\n  return Object(utils["verifyMessage"])(Object(bytes["arrayify"])(packMessage(message)), message.signature);\n}\n/**\n * Get the SignedBalanceProof associated with an EnvelopeMessage\n *\n * @param message - Signed EnvelopeMessage\n * @returns SignedBalanceProof object for message\n */\n\nfunction getBalanceProofFromEnvelopeMessage(message) {\n  return {\n    chainId: message.chain_id,\n    tokenNetworkAddress: message.token_network_address,\n    channelId: message.channel_identifier,\n    nonce: message.nonce,\n    transferredAmount: message.transferred_amount,\n    lockedAmount: message.locked_amount,\n    locksroot: message.locksroot,\n    messageHash: createMessageHash(message),\n    signature: message.signature,\n    sender: getMessageSigner(message)\n  };\n}\n/**\n * Encode a Message as a JSON string\n * Uses lossless-json to encode BigNumbers as JSON \'string\' type, as Raiden\n *\n * @param message - Message object to be serialized\n * @returns JSON string\n */\n\nfunction encodeJsonMessage(message) {\n  if (\'signature\' in message) return losslessStringify(Signed(Message).encode(message));\n  return losslessStringify(Message.encode(message));\n}\n/**\n * Try to decode text as a Message, using lossless-json to decode BigNumbers\n * Throws if can\'t decode, or message is invalid regarding any of the encoded constraints\n *\n * @param text - JSON string to try to decode\n * @returns Message object\n */\n\nfunction decodeJsonMessage(text) {\n  var parsed = losslessParse(text);\n  assert(parsed && utils_typeof(parsed) === \'object\' && \'type\' in parsed && Object.values(MessageType).some(function (t) {\n    return t === parsed[\'type\'];\n  }), "Invalid message type: ".concat(parsed === null || parsed === void 0 ? void 0 : parsed[\'type\']));\n  if (\'signature\' in parsed) return decode(Signed(Message), parsed);\n  return decode(Message, parsed);\n}\n/**\n * Pack message and request signer to sign it, and returns signed message\n *\n * @param signer - Signer instance\n * @param message - Unsigned message to pack and sign\n * @returns Promise to signed message\n */\n\nfunction signMessage(signer, message) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    log: loglevel_default.a\n  },\n      log = _ref.log;\n\n  return utils_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    var signature;\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!isSigned(message)) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt("return", message);\n\n          case 2:\n            log.debug("Signing message \\"".concat(message.type, "\\""), message);\n            _context.next = 5;\n            return signer.signMessage(Object(bytes["arrayify"])(packMessage(message)));\n\n          case 5:\n            signature = _context.sent;\n            return _context.abrupt("return", Object.assign(Object.assign({}, message), {\n              signature: signature\n            }));\n\n          case 7:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n/**\n * Typeguard to ensure an action is a messageReceived of any of a set of Message types\n *\n * @param messageCodecs - Message codec to test action.payload.message against\n * @returns Typeguard intersecting messageReceived action and payload.message schemas\n */\n\nfunction isMessageReceivedOfType(messageCodecs) {\n  return function (action) {\n    return messageReceived.is(action) && (Array.isArray(messageCodecs) ? es6["v" /* union */](messageCodecs).is(action.payload.message) : messageCodecs.is(action.payload.message));\n  };\n}\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/utils.js\nvar _statusesMap;\n\nfunction utils_slicedToArray(arr, i) { return utils_arrayWithHoles(arr) || utils_iterableToArrayLimit(arr, i) || utils_unsupportedIterableToArray(arr, i) || utils_nonIterableRest(); }\n\nfunction utils_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction utils_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction utils_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction transfers_utils_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = utils_unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction utils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return utils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return utils_arrayLikeToArray(o, minLen); }\n\nfunction utils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\n\n\n/**\n * Get the locksroot of a given array of pending locks\n * On Alderaan, it\'s the keccak256 hash of the concatenation of the ordered locks data\n *\n * @param locks - Lock array to calculate the locksroot from\n * @returns hash of the locks array\n */\n\nfunction getLocksroot(locks) {\n  var encoded = [];\n\n  var _iterator = _createForOfIteratorHelper(locks),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var lock = _step.value;\n      encoded.push(encode(lock.expiration, 32), encode(lock.amount, 32), lock.secrethash);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return Object(utils["keccak256"])(Object(bytes["concat"])(encoded));\n}\n/**\n * Return the secrethash of a given secret\n * On Alderaan, the sha256 hash is used for the secret.\n *\n * @param secret - Secret to get the hash from\n * @returns hash of the secret\n */\n\nfunction getSecrethash(secret) {\n  return Object(utils["sha256"])(secret);\n}\n/**\n * Generates a random secret of given length, as an HexString<32>\n *\n * @param length - of the secret to generate\n * @returns HexString<32>\n */\n\nfunction makeSecret() {\n  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n  return Object(bytes["hexlify"])(Object(utils["randomBytes"])(length));\n}\n/**\n * Generates a random payment identifier, as an UInt<8> (64 bits)\n *\n * @returns UInt<8>\n */\n\nfunction makePaymentId() {\n  return Object(utils["bigNumberify"])(Date.now());\n}\n/**\n * Generates a message identifier, as an UInt<8> (64 bits)\n *\n * @returns UInt<8>\n */\n\nfunction makeMessageId() {\n  return Object(utils["bigNumberify"])(Date.now());\n}\n\nfunction getTimeIfPresent(k) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (o) {\n    return o[k] ? o[k][0] : undefined;\n  };\n}\n\nvar statusesMap = (_statusesMap = {}, transfers_utils_defineProperty(_statusesMap, RaidenTransferStatus.expired, getTimeIfPresent(\'lockExpiredProcessed\')), transfers_utils_defineProperty(_statusesMap, RaidenTransferStatus.unlocked, getTimeIfPresent(\'unlockProcessed\')), transfers_utils_defineProperty(_statusesMap, RaidenTransferStatus.expiring, getTimeIfPresent(\'lockExpired\')), transfers_utils_defineProperty(_statusesMap, RaidenTransferStatus.unlocking, getTimeIfPresent(\'unlock\')), transfers_utils_defineProperty(_statusesMap, RaidenTransferStatus.registered, function (sent) {\n  var _a, _b; // only set status as registered if there\'s a valid registerBlock\n\n\n  return ((_b = (_a = sent.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) ? sent.secret[0] : undefined;\n}), transfers_utils_defineProperty(_statusesMap, RaidenTransferStatus.revealed, getTimeIfPresent(\'secretReveal\')), transfers_utils_defineProperty(_statusesMap, RaidenTransferStatus.requested, getTimeIfPresent(\'secretRequest\')), transfers_utils_defineProperty(_statusesMap, RaidenTransferStatus.closed, getTimeIfPresent(\'channelClosed\')), transfers_utils_defineProperty(_statusesMap, RaidenTransferStatus.refunded, getTimeIfPresent(\'refund\')), transfers_utils_defineProperty(_statusesMap, RaidenTransferStatus.received, getTimeIfPresent(\'transferProcessed\')), transfers_utils_defineProperty(_statusesMap, RaidenTransferStatus.pending, getTimeIfPresent(\'transfer\')), _statusesMap);\n/**\n * Convert a state.sent: TransferState to a public RaidenTransfer object\n *\n * @param sent - RaidenState.sent value\n * @returns Public raiden sent transfer info object\n */\n\nfunction raidenSentTransfer(sent) {\n  var _a, _b, _c, _d;\n\n  var startedAt = new Date(sent.transfer[0]);\n  var changedAt = startedAt;\n  var status = RaidenTransferStatus.pending; // order matters! from top to bottom priority, first match breaks loop\n\n  for (var _i = 0, _Object$entries = Object.entries(statusesMap); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = utils_slicedToArray(_Object$entries[_i], 2),\n        s = _Object$entries$_i[0],\n        g = _Object$entries$_i[1];\n\n    var ts = g(sent);\n\n    if (ts !== undefined) {\n      status = s;\n      changedAt = new Date(ts);\n      break;\n    }\n  }\n\n  var transfer = sent.transfer[1];\n  var value = transfer.lock.amount.sub(sent.fee);\n  var invalidSecretRequest = sent.secretRequest && sent.secretRequest[1].amount.lt(value);\n  var success = sent.secretReveal || sent.unlock || ((_b = (_a = sent.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) ? true : invalidSecretRequest || sent.refund || sent.lockExpired || sent.channelClosed ? false : undefined;\n  var completed = !!(sent.unlockProcessed || sent.lockExpiredProcessed || ((_d = (_c = sent.secret) === null || _c === void 0 ? void 0 : _c[1]) === null || _d === void 0 ? void 0 : _d.registerBlock) || sent.channelClosed);\n  return {\n    secrethash: transfer.lock.secrethash,\n    direction: \'sent\',\n    status: status,\n    initiator: transfer.initiator,\n    partner: transfer.recipient,\n    target: transfer.target,\n    metadata: transfer.metadata,\n    paymentId: transfer.payment_identifier,\n    chainId: transfer.chain_id.toNumber(),\n    token: transfer.token,\n    tokenNetwork: transfer.token_network_address,\n    channelId: transfer.channel_identifier,\n    value: value,\n    fee: sent.fee,\n    amount: transfer.lock.amount,\n    expirationBlock: transfer.lock.expiration.toNumber(),\n    startedAt: startedAt,\n    changedAt: changedAt,\n    success: success,\n    completed: completed\n  };\n}\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/reducer.js\nvar _END;\n\nfunction reducer_slicedToArray(arr, i) { return reducer_arrayWithHoles(arr) || reducer_iterableToArrayLimit(arr, i) || transfers_reducer_unsupportedIterableToArray(arr, i) || reducer_nonIterableRest(); }\n\nfunction reducer_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction reducer_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction reducer_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction transfers_reducer_toConsumableArray(arr) { return transfers_reducer_arrayWithoutHoles(arr) || transfers_reducer_iterableToArray(arr) || transfers_reducer_unsupportedIterableToArray(arr) || transfers_reducer_nonIterableSpread(); }\n\nfunction transfers_reducer_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction transfers_reducer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return transfers_reducer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transfers_reducer_arrayLikeToArray(o, minLen); }\n\nfunction transfers_reducer_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction transfers_reducer_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return transfers_reducer_arrayLikeToArray(arr); }\n\nfunction transfers_reducer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction transfers_reducer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar END = (_END = {}, transfers_reducer_defineProperty(_END, Direction.SENT, \'own\'), transfers_reducer_defineProperty(_END, Direction.RECEIVED, \'partner\'), _END); // Reducers for different actions\n\nfunction transferSecretReducer(state, action) {\n  var _a, _b, _c, _d, _e, _f;\n\n  var secrethash = action.meta.secrethash; // store when seeing unconfirmed, but registerBlock only after confirmation\n\n  var registerBlock = transferSecretRegister.success.is(action) && action.payload.confirmed ? action.payload.txBlock : (_d = (_c = (_b = (_a = state[action.meta.direction][secrethash]) === null || _a === void 0 ? void 0 : _a.secret) === null || _b === void 0 ? void 0 : _b[1]) === null || _c === void 0 ? void 0 : _c.registerBlock) !== null && _d !== void 0 ? _d : 0; // don\'t overwrite registerBlock if secret already stored with it\n\n  if (secrethash in state[action.meta.direction] && ((_f = (_e = state[action.meta.direction][secrethash].secret) === null || _e === void 0 ? void 0 : _e[1]) === null || _f === void 0 ? void 0 : _f.registerBlock) !== registerBlock) state = Object.assign(Object.assign({}, state), transfers_reducer_defineProperty({}, action.meta.direction, Object.assign(Object.assign({}, state[action.meta.direction]), transfers_reducer_defineProperty({}, secrethash, Object.assign(Object.assign({}, state[action.meta.direction][secrethash]), {\n    secret: timed({\n      value: action.payload.secret,\n      registerBlock: registerBlock\n    })\n  })))));\n  return state;\n}\n\nfunction transferSignedReducer(state, action) {\n  var _a, _b, _c;\n\n  var transfer = action.payload.message;\n  var lock = transfer.lock;\n  var secrethash = lock.secrethash;\n  var partner = action.meta.direction === Direction.SENT ? transfer.recipient : getMessageSigner(transfer);\n  var end = END[action.meta.direction]; // transferSigned must be the first action, to init TransferState state\n\n  if (secrethash in state[action.meta.direction]) return state;\n  var channelPath = [\'channels\', transfer.token_network_address, partner];\n  var channel = get_default()(channelPath, state);\n  if (!channel) return state;\n  var locks = [].concat(transfers_reducer_toConsumableArray((_a = channel[end].locks) !== null && _a !== void 0 ? _a : []), [lock]); // append lock\n\n  var locksroot = getLocksroot(locks);\n  if (transfer.locksroot !== locksroot || // nonce must be next\n  !transfer.nonce.eq((channel[end].balanceProof ? channel[end].balanceProof.nonce : constants["Zero"]).add(1)) || !transfer.transferred_amount.eq(channel[end].balanceProof ? channel[end].balanceProof.transferredAmount : constants["Zero"]) || !transfer.locked_amount.eq(((_c = (_b = channel[end].balanceProof) === null || _b === void 0 ? void 0 : _b.lockedAmount) !== null && _c !== void 0 ? _c : constants["Zero"]).add(lock.amount))) return state;\n  channel = Object.assign(Object.assign({}, channel), transfers_reducer_defineProperty({}, end, Object.assign(Object.assign({}, channel[end]), {\n    locks: locks,\n    // set current/latest channel[end].balanceProof to LockedTransfer\'s\n    balanceProof: getBalanceProofFromEnvelopeMessage(transfer)\n  })));\n  var transferState = {\n    transfer: timed(transfer),\n    fee: action.payload.fee,\n    partner: partner\n  };\n  state = set_default()(channelPath, channel, state);\n  state = set_default()([action.meta.direction, secrethash], transferState, state);\n  return state;\n}\n\nfunction transferSecretRequestedReducer(state, action) {\n  var secrethash = action.meta.secrethash;\n  if (!(secrethash in state[action.meta.direction])) return state;\n  return Object.assign(Object.assign({}, state), transfers_reducer_defineProperty({}, action.meta.direction, Object.assign(Object.assign({}, state[action.meta.direction]), transfers_reducer_defineProperty({}, secrethash, Object.assign(Object.assign({}, state[action.meta.direction][secrethash]), {\n    secretRequest: timed(action.payload.message)\n  })))));\n}\n\nfunction transferSecretReveledReducer(state, action) {\n  var secrethash = action.meta.secrethash;\n  if (!(secrethash in state[action.meta.direction]) || state[action.meta.direction][secrethash].secretReveal) return state;\n  return Object.assign(Object.assign({}, state), transfers_reducer_defineProperty({}, action.meta.direction, Object.assign(Object.assign({}, state[action.meta.direction]), transfers_reducer_defineProperty({}, secrethash, Object.assign(Object.assign({}, state[action.meta.direction][secrethash]), {\n    secretReveal: timed(action.payload.message)\n  })))));\n}\n\nfunction transferUnlockSuccessReducer(state, action) {\n  var unlock = action.payload.message;\n  var secrethash = action.meta.secrethash;\n  if (!(secrethash in state[action.meta.direction]) || state[action.meta.direction][secrethash].unlock) return state;\n  var transfer = state[action.meta.direction][secrethash].transfer[1];\n  var partner = state[action.meta.direction][secrethash].partner;\n  var end = END[action.meta.direction];\n  var lock = transfer.lock;\n  var channelPath = [\'channels\', transfer.token_network_address, partner];\n  var channel = get_default()(channelPath, state);\n  if (!channel || !channel[end].locks || !channel[end].balanceProof) return state;\n  var locks = channel[end].locks.filter(function (l) {\n    return l.secrethash !== secrethash;\n  });\n  var locksroot = getLocksroot(locks);\n  if (unlock.locksroot !== locksroot || !channel[end].balanceProof.nonce.add(1).eq(unlock.nonce) || // nonce must be next\n  !unlock.transferred_amount.eq(channel[end].balanceProof.transferredAmount.add(lock.amount)) || !unlock.locked_amount.eq(channel[end].balanceProof.lockedAmount.sub(lock.amount))) return state;\n  channel = Object.assign(Object.assign({}, channel), transfers_reducer_defineProperty({}, end, Object.assign(Object.assign({}, channel[end]), {\n    locks: locks,\n    // set current/latest channel[end].balanceProof to Unlock\'s\n    balanceProof: getBalanceProofFromEnvelopeMessage(unlock)\n  })));\n  var transferState = Object.assign(Object.assign({}, state[action.meta.direction][secrethash]), {\n    unlock: timed(unlock)\n  });\n  state = set_default()(channelPath, channel, state);\n  state = set_default()([action.meta.direction, secrethash], transferState, state);\n  return state;\n}\n\nfunction transferExpireSuccessReducer(state, action) {\n  var expired = action.payload.message;\n  var secrethash = action.meta.secrethash;\n  if (!(secrethash in state[action.meta.direction]) || state[action.meta.direction][secrethash].unlock || // don\'t accept expire if already unlocked\n  state[action.meta.direction][secrethash].lockExpired // already expired\n  ) return state;\n  var transfer = state[action.meta.direction][secrethash].transfer[1];\n  var partner = state[action.meta.direction][secrethash].partner;\n  var end = END[action.meta.direction];\n  var lock = transfer.lock;\n  var channelPath = [\'channels\', transfer.token_network_address, partner];\n  var channel = get_default()(channelPath, state);\n  if (!channel || !channel[end].locks || !channel[end].balanceProof) return state;\n  var locks = channel[end].locks.filter(function (l) {\n    return l.secrethash !== secrethash;\n  });\n  var locksroot = getLocksroot(locks);\n  if (expired.locksroot !== locksroot || !channel[end].balanceProof.nonce.add(1).eq(expired.nonce) || // nonce must be next\n  !expired.transferred_amount.eq(channel[end].balanceProof.transferredAmount) || !expired.locked_amount.eq(channel[end].balanceProof.lockedAmount.sub(lock.amount))) return state;\n  channel = Object.assign(Object.assign({}, channel), transfers_reducer_defineProperty({}, end, Object.assign(Object.assign({}, channel[end]), {\n    locks: locks,\n    // set current/latest channel[end].balanceProof to LockExpired\'s\n    balanceProof: getBalanceProofFromEnvelopeMessage(expired)\n  })));\n  var transferState = Object.assign(Object.assign({}, state[action.meta.direction][secrethash]), {\n    lockExpired: timed(expired)\n  });\n  state = set_default()(channelPath, channel, state);\n  state = set_default()([action.meta.direction, secrethash], transferState, state);\n  return state;\n}\n\nfunction transferStateReducer(state, action) {\n  var secrethash = action.meta.secrethash;\n  if (!(secrethash in state[action.meta.direction])) return state;\n  var key;\n\n  if (transferProcessed.is(action)) {\n    key = \'transferProcessed\';\n  } else if (transferUnlockProcessed.is(action)) {\n    key = \'unlockProcessed\';\n  } else if (transferExpireProcessed.is(action)) {\n    key = \'lockExpiredProcessed\';\n  } else if (transferRefunded.is(action)) {\n    key = \'refund\';\n  } else {\n    return state;\n  }\n\n  if (state[action.meta.direction][secrethash][key]) return state;\n  return Object.assign(Object.assign({}, state), transfers_reducer_defineProperty({}, action.meta.direction, Object.assign(Object.assign({}, state[action.meta.direction]), transfers_reducer_defineProperty({}, secrethash, Object.assign(Object.assign({}, state[action.meta.direction][secrethash]), transfers_reducer_defineProperty({}, key, timed(action.payload.message)))))));\n}\n\nfunction reducer_channelCloseSuccessReducer(state, action) {\n  var sent = state.sent;\n\n  for (var _i = 0, _Object$entries = Object.entries(sent); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = reducer_slicedToArray(_Object$entries[_i], 2),\n        secrethash = _Object$entries$_i[0],\n        v = _Object$entries$_i[1];\n\n    var transfer = v.transfer[1];\n    if (!transfer.channel_identifier.eq(action.payload.id) || transfer.recipient !== action.meta.partner || transfer.token_network_address !== action.meta.tokenNetwork) continue;\n    sent = Object.assign(Object.assign({}, sent), transfers_reducer_defineProperty({}, secrethash, Object.assign(Object.assign({}, v), {\n      channelClosed: timed(action.payload.txHash)\n    })));\n  }\n\n  if (sent !== state.sent) state = Object.assign(Object.assign({}, state), {\n    sent: sent\n  });\n  var received = state.received;\n\n  for (var _i2 = 0, _Object$entries2 = Object.entries(received); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = reducer_slicedToArray(_Object$entries2[_i2], 2),\n        _secrethash = _Object$entries2$_i[0],\n        _v = _Object$entries2$_i[1];\n\n    var _transfer = _v.transfer[1];\n    if (!_transfer.channel_identifier.eq(action.payload.id) || _transfer.recipient !== action.meta.partner || _transfer.token_network_address !== action.meta.tokenNetwork) continue;\n    received = Object.assign(Object.assign({}, received), transfers_reducer_defineProperty({}, _secrethash, Object.assign(Object.assign({}, _v), {\n      channelClosed: timed(action.payload.txHash)\n    })));\n  }\n\n  if (received !== state.received) state = Object.assign(Object.assign({}, state), {\n    received: received\n  });\n  return state;\n}\n\nfunction transferClearReducer(state, action) {\n  var secrethash = action.meta.secrethash;\n  if (!(secrethash in state[action.meta.direction])) return state;\n  state = unset_default()([action.meta.direction, secrethash], state);\n  return state;\n}\n\nfunction withdrawReceiveSuccessReducer(state, action) {\n  // TODO: subtract this pending withdraw request from partner\'s capacity (maybe some pending\n  // withdraws state), revert upon expiration or consolidate on confirmed channelWithdrawn\n  var message = action.payload.message;\n  var channelPath = [\'channels\', action.meta.tokenNetwork, action.meta.partner];\n  var channel = get_default()(channelPath, state);\n  if (!channel || channel.state !== ChannelState.open) return state; // current own balanceProof, or zero balance proof, with some known fields filled\n\n  var balanceProof = channel.own.balanceProof || {\n    chainId: message.chain_id,\n    tokenNetworkAddress: action.meta.tokenNetwork,\n    channelId: message.channel_identifier,\n    // balance proof data\n    nonce: constants["Zero"],\n    transferredAmount: constants["Zero"],\n    lockedAmount: constants["Zero"],\n    locksroot: constants["HashZero"],\n    messageHash: constants["HashZero"],\n    signature: Object(utils["hexlify"])(SignatureZero),\n    sender: state.address\n  }; // if it\'s the next nonce, update balance proof\n\n  if (message.nonce.eq(balanceProof.nonce.add(1)) && message.expiration.gt(state.blockNumber)) {\n    channel = Object.assign(Object.assign({}, channel), {\n      own: Object.assign(Object.assign({}, channel.own), {\n        balanceProof: Object.assign(Object.assign({}, balanceProof), {\n          nonce: message.nonce\n        })\n      })\n    });\n    state = set_default()(channelPath, channel, state);\n  }\n\n  return state;\n}\n/**\n * Handles all transfers actions and requests\n */\n\n\nvar transfersReducer = createReducer(state_initialState).handle([transferSecret, transferSecretRegister.success], transferSecretReducer).handle(transferSigned, transferSignedReducer).handle([transferProcessed, transferUnlockProcessed, transferExpireProcessed, transferRefunded], transferStateReducer).handle(transferSecretRequest, transferSecretRequestedReducer).handle(transferSecretReveal, transferSecretReveledReducer).handle(transferUnlock.success, transferUnlockSuccessReducer).handle(transferExpire.success, transferExpireSuccessReducer).handle(channelClose.success, reducer_channelCloseSuccessReducer).handle(transferClear, transferClearReducer).handle(withdrawReceive.success, withdrawReceiveSuccessReducer);\n// CONCATENATED MODULE: ../raiden-ts/dist/reducer.js\nfunction dist_reducer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction dist_reducer_slicedToArray(arr, i) { return dist_reducer_arrayWithHoles(arr) || dist_reducer_iterableToArrayLimit(arr, i) || dist_reducer_unsupportedIterableToArray(arr, i) || dist_reducer_nonIterableRest(); }\n\nfunction dist_reducer_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction dist_reducer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dist_reducer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dist_reducer_arrayLikeToArray(o, minLen); }\n\nfunction dist_reducer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction dist_reducer_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction dist_reducer_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n // update state.config on raidenConfigUpdate action\n// resets key to default value if value is undefined, otherwise overwrites it\n\nvar configReducer = createReducer(state_initialState).handle(raidenConfigUpdate, function (state, _ref) {\n  var payload = _ref.payload;\n  var config = state.config;\n\n  for (var _i = 0, _Object$entries = Object.entries(payload); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = dist_reducer_slicedToArray(_Object$entries[_i], 2),\n        k = _Object$entries$_i[0],\n        v = _Object$entries$_i[1];\n\n    if (v !== undefined) config = Object.assign(Object.assign({}, config), dist_reducer_defineProperty({}, k, v));else if (k in config) config = unset_default()(k, config);\n  }\n\n  if (config === state.config) return state;\n  return Object.assign(Object.assign({}, state), {\n    config: config\n  });\n});\nvar raidenReducers = {\n  configReducer: configReducer,\n  channelsReducer: channelsReducer,\n  pathReducer: pathReducer,\n  transportReducer: transportReducer,\n  transfersReducer: transfersReducer\n};\n/**\n * Raiden root reducer\n * Apply action over each submodule root reducer in a flattened manner (iteratively).\n * Notice the submodules reducers aren\'t handled only a partial/deep property of the state\n * (as combineReducers), but instead receive the whole state, so they can act on any part of the\n * state. This approach is similar to `reduce-reducers` util.\n * Each submodule root reducer may then choose to split its concerns into nested or flattened\n * reducers (like this one).\n *\n * @param state - Current RaidenState to reduce\n * @param action - RaidenAction to apply over state\n * @returns New RaidenState\n */\n\nvar reducer_raidenReducer = function raidenReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : state_initialState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n  return Object.values(raidenReducers).reduce(function (s, reducer) {\n    return reducer(s, action);\n  }, state);\n};\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/pluck.js\nvar pluck = __webpack_require__("1585");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js\nvar startWith = __webpack_require__("a744");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/scan.js\nvar scan = __webpack_require__("742d");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeWhile.js\nvar takeWhile = __webpack_require__("8ef6");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js\nvar takeUntil = __webpack_require__("9f2d");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/catchError.js\nvar catchError = __webpack_require__("f59d");\n\n// EXTERNAL MODULE: ./node_modules/lodash/negate.js\nvar negate = __webpack_require__("a0ac");\nvar negate_default = /*#__PURE__*/__webpack_require__.n(negate);\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js\nvar distinctUntilChanged = __webpack_require__("69dd");\n\n// CONCATENATED MODULE: ../raiden-ts/dist/utils/rx.js\n\n/**\n * Maps each source value (an object) to its specified nested property,\n * and emits only if the value changed since last emission\n *\n * It\'s a combination of `pluck` and `distinctUntilChanged` operators.\n \n * @param properties - The nested properties to pluck from each source value (an object).\n * @returns A new Observable of property values from the source values.\n */\n\nfunction pluckDistinct() {\n  for (var _len = arguments.length, properties = new Array(_len), _key = 0; _key < _len; _key++) {\n    properties[_key] = arguments[_key];\n  }\n\n  return function (source) {\n    return source.pipe(pluck["a" /* pluck */].apply(void 0, properties), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());\n  };\n}\n// CONCATENATED MODULE: ../raiden-ts/dist/transport/utils.js\nfunction transport_utils_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n/**\n * Helper to map/get an aggregated Presences observable from action$ bus\n * Known presences as { address: <last seen MatrixPresenceUpdateAction> } mapping\n * It\'s memoized and shared, so all subscriptions share the same mapped/output object, but the type\n * is explicitly set to avoid requiring the exported MemoizedFunction type\n *\n * @param action$ - Observable\n * @returns Observable of aggregated Presences from subscription to now\n */\n\nvar getPresences$ = memoize_default()(function (action$) {\n  return action$.pipe(Object(filter["a" /* filter */])(matrixPresence.success.is), Object(scan["a" /* scan */])( // scan all presence update actions and populate/output a per-address mapping\n  function (presences, update) {\n    return Object.assign(Object.assign({}, presences), transport_utils_defineProperty({}, update.meta.address, update));\n  }, {}), Object(share["a" /* share */])(), Object(startWith["a" /* startWith */])({}));\n});\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/timer.js\nvar timer = __webpack_require__("808d");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/throwError.js\nvar throwError = __webpack_require__("5e53");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js + 1 modules\nvar concat = __webpack_require__("744c");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js\nvar observable_interval = __webpack_require__("c575");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/retryWhen.js\nvar retryWhen = __webpack_require__("66aa");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/take.js\nvar take = __webpack_require__("b7d7");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js\nvar mapTo = __webpack_require__("6863");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/exhaustMap.js\nvar exhaustMap = __webpack_require__("e95d");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/groupBy.js\nvar groupBy = __webpack_require__("2313");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js\nvar withLatestFrom = __webpack_require__("fcf1");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/publishReplay.js\nvar publishReplay = __webpack_require__("b389");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js + 1 modules\nvar tap = __webpack_require__("c4cc");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/ignoreElements.js\nvar ignoreElements = __webpack_require__("0ca2");\n\n// EXTERNAL MODULE: ./node_modules/lodash/isEmpty.js\nvar lodash_isEmpty = __webpack_require__("13ea");\nvar lodash_isEmpty_default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty);\n\n// CONCATENATED MODULE: ../raiden-ts/dist/channels/index.js\n\n\n// EXTERNAL MODULE: ./node_modules/ethers/abstract-signer.js\nvar abstract_signer = __webpack_require__("8358");\n\n// EXTERNAL MODULE: ./node_modules/ethers/wallet.js\nvar wallet = __webpack_require__("ddfd");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatMap.js\nvar concatMap = __webpack_require__("3e18");\n\n// EXTERNAL MODULE: ./node_modules/lodash/pick.js\nvar pick = __webpack_require__("2593");\nvar pick_default = /*#__PURE__*/__webpack_require__.n(pick);\n\n// EXTERNAL MODULE: ./node_modules/lodash/transform.js\nvar transform = __webpack_require__("50ca");\nvar transform_default = /*#__PURE__*/__webpack_require__.n(transform);\n\n// CONCATENATED MODULE: ../raiden-ts/dist/channels/utils.js\n\n\n\n\n\n/**\n * Calculates and returns partial and total amounts of given channel state\n *\n * @param channel - A Channel state to calculate amounts from\n * @returns An object holding own&partner\'s deposit, withdraw, transferred, locked, balance and\n *          capacity.\n */\n\nfunction channelAmounts(channel) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n  var Zero32 = constants["Zero"];\n  if (channel.state !== ChannelState.open) return {\n    ownDeposit: Zero32,\n    ownWithdraw: Zero32,\n    ownTransferred: Zero32,\n    ownLocked: Zero32,\n    ownBalance: Zero32,\n    ownCapacity: Zero32,\n    partnerDeposit: Zero32,\n    partnerWithdraw: Zero32,\n    partnerTransferred: Zero32,\n    partnerLocked: Zero32,\n    partnerBalance: Zero32,\n    partnerCapacity: Zero32\n  };\n  var ownWithdraw = (_a = channel.own.withdraw) !== null && _a !== void 0 ? _a : Zero32,\n      partnerWithdraw = (_b = channel.partner.withdraw) !== null && _b !== void 0 ? _b : Zero32,\n      ownTransferred = (_d = (_c = channel.own.balanceProof) === null || _c === void 0 ? void 0 : _c.transferredAmount) !== null && _d !== void 0 ? _d : Zero32,\n      partnerTransferred = (_f = (_e = channel.partner.balanceProof) === null || _e === void 0 ? void 0 : _e.transferredAmount) !== null && _f !== void 0 ? _f : Zero32,\n      ownLocked = (_h = (_g = channel.own.balanceProof) === null || _g === void 0 ? void 0 : _g.lockedAmount) !== null && _h !== void 0 ? _h : Zero32,\n      partnerLocked = (_k = (_j = channel.partner.balanceProof) === null || _j === void 0 ? void 0 : _j.lockedAmount) !== null && _k !== void 0 ? _k : Zero32,\n      ownBalance = partnerTransferred.sub(ownTransferred),\n      partnerBalance = ownTransferred.sub(partnerTransferred),\n      // == -ownBalance\n  ownCapacity = channel.own.deposit.sub(ownWithdraw).sub(ownLocked).add(ownBalance),\n      partnerCapacity = channel.partner.deposit.sub(partnerWithdraw).sub(partnerLocked).add(partnerBalance);\n  return {\n    ownDeposit: channel.own.deposit,\n    ownWithdraw: ownWithdraw,\n    ownTransferred: ownTransferred,\n    ownLocked: ownLocked,\n    ownBalance: ownBalance,\n    ownCapacity: ownCapacity,\n    partnerDeposit: channel.partner.deposit,\n    partnerWithdraw: partnerWithdraw,\n    partnerTransferred: partnerTransferred,\n    partnerLocked: partnerLocked,\n    partnerBalance: partnerBalance,\n    partnerCapacity: partnerCapacity\n  };\n}\n/**\n * Custom operator to wait & assert transaction success\n *\n * @param method - method name to use in logs\n * @param error - ErrorCode to throw if transaction fails\n * @param deps - object containing logger\n * @returns operator function to wait for transaction and output hash\n */\n\nfunction assertTx(method, error, _ref) {\n  var log = _ref.log;\n  return function (tx) {\n    return tx.pipe(Object(tap["a" /* tap */])(function (tx) {\n      return log.debug("sent ".concat(method, " tx \\"").concat(tx.hash, "\\" to \\"").concat(tx.to, "\\""));\n    }), Object(mergeMap["a" /* mergeMap */])(function (tx) {\n      return Object(from["a" /* from */])(tx.wait()).pipe(Object(map["a" /* map */])(function (receipt) {\n        if (!receipt.status) throw new error_RaidenError(error, {\n          transactionHash: tx.hash\n        });\n        log.debug("".concat(method, " tx \\"").concat(tx.hash, "\\" successfuly mined!"));\n        return tx.hash;\n      }));\n    }));\n  };\n}\n// EXTERNAL MODULE: ../raiden-ts/dist/deployment/deployment_ropsten.json\nvar deployment_ropsten = __webpack_require__("a0df");\n\n// EXTERNAL MODULE: ../raiden-ts/dist/deployment/deployment_rinkeby.json\nvar deployment_rinkeby = __webpack_require__("31a7");\n\n// EXTERNAL MODULE: ../raiden-ts/dist/deployment/deployment_goerli.json\nvar deployment_goerli = __webpack_require__("c998");\n\n// EXTERNAL MODULE: ../raiden-ts/dist/deployment/deployment_services_ropsten.json\nvar deployment_services_ropsten = __webpack_require__("b4cc");\n\n// EXTERNAL MODULE: ../raiden-ts/dist/deployment/deployment_services_rinkeby.json\nvar deployment_services_rinkeby = __webpack_require__("0ff6");\n\n// EXTERNAL MODULE: ../raiden-ts/dist/deployment/deployment_services_goerli.json\nvar deployment_services_goerli = __webpack_require__("4e0b2");\n\n// CONCATENATED MODULE: ../raiden-ts/dist/helpers.js\n\n\nfunction helpers_toConsumableArray(arr) { return helpers_arrayWithoutHoles(arr) || helpers_iterableToArray(arr) || helpers_unsupportedIterableToArray(arr) || helpers_nonIterableSpread(); }\n\nfunction helpers_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction helpers_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction helpers_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return helpers_arrayLikeToArray(arr); }\n\nfunction helpers_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction helpers_slicedToArray(arr, i) { return helpers_arrayWithHoles(arr) || helpers_iterableToArrayLimit(arr, i) || helpers_unsupportedIterableToArray(arr, i) || helpers_nonIterableRest(); }\n\nfunction helpers_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction helpers_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return helpers_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return helpers_arrayLikeToArray(o, minLen); }\n\nfunction helpers_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction helpers_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction helpers_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar helpers_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Returns contract information depending on the passed [[Network]]. Currently, only\n * `rinkeby`, `ropsten` and `goerli` are supported.\n * Throws an exception if called with another [[Network]].\n *\n * @param network - an account used for signing\n * @returns deployed contract information of the network\n */\n\nvar helpers_getContracts = function getContracts(network) {\n  switch (network.name) {\n    case \'rinkeby\':\n      return Object.assign(Object.assign({}, deployment_rinkeby.contracts), deployment_services_rinkeby.contracts);\n\n    case \'ropsten\':\n      return Object.assign(Object.assign({}, deployment_ropsten.contracts), deployment_services_ropsten.contracts);\n\n    case \'goerli\':\n      return Object.assign(Object.assign({}, deployment_goerli.contracts), deployment_services_goerli.contracts);\n\n    default:\n      throw new error_RaidenError(ErrorCodes.RDN_UNRECOGNIZED_NETWORK, {\n        network: network.name\n      });\n  }\n};\n/**\n * Generate, sign and return a subkey from provided main account\n *\n * @param network - Network to include in message\n * @param main - Main signer to derive subkey from\n * @returns Subkey\'s signer & address\n */\n\nfunction genSubkey(network, main) {\n  var _a, _b;\n\n  return helpers_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    var url, message, signature, pk, signer;\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            url = (_b = (_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.location) === null || _a === void 0 ? void 0 : _a.origin) !== null && _b !== void 0 ? _b : \'unknown\';\n            message = "=== RAIDEN SUBKEY GENERATION ===\\n\\nNetwork: ".concat(getNetworkName(network).toUpperCase(), "\\nRaiden dApp URL: ").concat(url, "\\n\\nWARNING: ensure this signature is being requested from Raiden dApp running at URL above by comparing it to your browser\'s url bar.\\nSigning this message at any other address WILL give it FULL control of this subkey\'s funds, tokens and Raiden channels!");\n            _context.next = 4;\n            return main.signMessage(Object(utils["toUtf8Bytes"])(message));\n\n          case 4:\n            signature = _context.sent;\n            pk = Object(utils["sha256"])(signature);\n            signer = new wallet["Wallet"](pk, main.provider);\n            return _context.abrupt("return", {\n              signer: signer,\n              address: signer.address\n            });\n\n          case 8:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n/**\n * Returns a [[Signer]] based on the `account` and `provider`.\n * Throws an exception if the `account` is not a valid address or private key.\n *\n * @param account - an account used for signing\n * @param provider - a provider\n * @param subkey - Whether to generate a subkey\n * @returns a [[Signer]] or [[Wallet]] that can be used for signing\n */\n\n\nvar helpers_getSigner = function getSigner(account, provider, subkey) {\n  return helpers_awaiter(void 0, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee2() {\n    var signer, address, main, accounts, _yield$genSubkey;\n\n    return regenerator_default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!abstract_signer["Signer"].isSigner(account)) {\n              _context2.next = 15;\n              break;\n            }\n\n            if (!(account.provider === provider)) {\n              _context2.next = 5;\n              break;\n            }\n\n            signer = account;\n            _context2.next = 10;\n            break;\n\n          case 5:\n            if (!(account instanceof wallet["Wallet"])) {\n              _context2.next = 9;\n              break;\n            }\n\n            signer = account.connect(provider);\n            _context2.next = 10;\n            break;\n\n          case 9:\n            throw new error_RaidenError(ErrorCodes.RDN_SIGNER_NOT_CONNECTED, {\n              account: account.toString(),\n              provider: provider.toString()\n            });\n\n          case 10:\n            _context2.next = 12;\n            return signer.getAddress();\n\n          case 12:\n            address = _context2.sent;\n            _context2.next = 38;\n            break;\n\n          case 15:\n            if (!(typeof account === \'number\')) {\n              _context2.next = 22;\n              break;\n            }\n\n            // index of account in provider\n            signer = provider.getSigner(account);\n            _context2.next = 19;\n            return signer.getAddress();\n\n          case 19:\n            address = _context2.sent;\n            _context2.next = 38;\n            break;\n\n          case 22:\n            if (!Address.is(account)) {\n              _context2.next = 32;\n              break;\n            }\n\n            _context2.next = 25;\n            return provider.listAccounts();\n\n          case 25:\n            accounts = _context2.sent;\n\n            if (accounts.includes(account)) {\n              _context2.next = 28;\n              break;\n            }\n\n            throw new error_RaidenError(ErrorCodes.RDN_ACCOUNT_NOT_FOUND, {\n              account: account,\n              accounts: JSON.stringify(accounts)\n            });\n\n          case 28:\n            signer = provider.getSigner(account);\n            address = account;\n            _context2.next = 38;\n            break;\n\n          case 32:\n            if (!PrivateKey.is(account)) {\n              _context2.next = 37;\n              break;\n            }\n\n            // private key\n            signer = new wallet["Wallet"](account, provider);\n            address = signer.address;\n            _context2.next = 38;\n            break;\n\n          case 37:\n            throw new error_RaidenError(ErrorCodes.RDN_STRING_ACCOUNT_INVALID);\n\n          case 38:\n            if (!subkey) {\n              _context2.next = 50;\n              break;\n            }\n\n            main = {\n              signer: signer,\n              address: address\n            };\n            _context2.t0 = genSubkey;\n            _context2.next = 43;\n            return provider.getNetwork();\n\n          case 43:\n            _context2.t1 = _context2.sent;\n            _context2.t2 = main.signer;\n            _context2.next = 47;\n            return (0, _context2.t0)(_context2.t1, _context2.t2);\n\n          case 47:\n            _yield$genSubkey = _context2.sent;\n            signer = _yield$genSubkey.signer;\n            address = _yield$genSubkey.address;\n\n          case 50:\n            return _context2.abrupt("return", {\n              signer: signer,\n              address: address,\n              main: main\n            });\n\n          case 51:\n          case "end":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n};\n/**\n * Initializes the [[transfers$]] observable\n *\n * @param state$ - Observable of the current RaidenState\n * @returns observable of sent and completed Raiden transfers\n */\n\nvar helpers_initTransfers$ = function initTransfers$(state$) {\n  return state$.pipe(pluckDistinct(\'sent\'), Object(concatMap["a" /* concatMap */])(function (sent) {\n    return Object(from["a" /* from */])(Object.entries(sent));\n  }),\n  /* this scan stores a reference to each [key,value] in \'acc\', and emit as \'changed\' iff it\n   * changes from last time seen. It relies on value references changing only if needed */\n  Object(scan["a" /* scan */])(function (_ref, _ref2) {\n    var acc = _ref.acc;\n\n    var _ref3 = helpers_slicedToArray(_ref2, 2),\n        secrethash = _ref3[0],\n        sent = _ref3[1];\n\n    return (// if ref didn\'t change, emit previous accumulator, without \'changed\' value\n      acc[secrethash] === sent ? {\n        acc: acc\n      } : // else, update ref in \'acc\' and emit value in \'changed\' prop\n      {\n        acc: Object.assign(Object.assign({}, acc), helpers_defineProperty({}, secrethash, sent)),\n        changed: sent\n      }\n    );\n  }, {\n    acc: {}\n  }), Object(pluck["a" /* pluck */])(\'changed\'), Object(filter["a" /* filter */])(isntNil), // filter out if reference didn\'t change from last emit\n  // from here, we get TransferState objects which changed from previous state (all on first)\n  Object(map["a" /* map */])(raidenSentTransfer));\n};\n/**\n * Returns an object that maps partner addresses to their [[RaidenChannel]].\n *\n * @param partnerChannelMap - an object that maps partnerAddress to a channel\n * @param token - a token address\n * @param tokenNetwork - a token network\n * @returns raiden channel\n */\n\nvar helpers_mapPartnerToChannel = function mapPartnerToChannel(partnerChannelMap, token, tokenNetwork) {\n  return transform_default()( // transform Channel to RaidenChannel, with more info\n  partnerChannelMap, function (partner2raidenChannel, channel, partner) {\n    var _channelAmounts = channelAmounts(channel),\n        ownDeposit = _channelAmounts.ownDeposit,\n        partnerDeposit = _channelAmounts.partnerDeposit,\n        balance = _channelAmounts.ownBalance,\n        capacity = _channelAmounts.ownCapacity;\n\n    partner2raidenChannel[partner] = Object.assign(Object.assign({\n      state: channel.state\n    }, pick_default()(channel, [\'id\', \'settleTimeout\', \'openBlock\', \'closeBlock\'])), {\n      token: token,\n      tokenNetwork: tokenNetwork,\n      partner: partner,\n      ownDeposit: ownDeposit,\n      partnerDeposit: partnerDeposit,\n      balance: balance,\n      capacity: capacity\n    });\n  });\n};\n/**\n * Transforms the redux channel state to [[RaidenChannels]]\n *\n * @param state - current state\n * @returns raiden channels\n */\n\n\nvar helpers_mapTokenToPartner = function mapTokenToPartner(state) {\n  return transform_default()( // transform state.channels to token-partner-raidenChannel map\n  state.channels, function (result, partnerChannelMap, tokenNetwork) {\n    var token = findKey_default()(state.tokens, function (tn) {\n      return tn === tokenNetwork;\n    });\n    if (!token) return; // shouldn\'t happen, token mapping is always bi-directional\n\n    result[token] = helpers_mapPartnerToChannel(partnerChannelMap, token, tokenNetwork);\n  });\n};\n/**\n * Return signer & address to use for on-chain txs depending on subkey param\n *\n * @param deps - RaidenEpicDeps subset\n * @param subkey - Whether to prefer the subkey or the main key\n * @returns Signer & Address to use for on-chain operations\n */\n\nfunction chooseOnchainAccount(_ref4, subkey) {\n  var signer = _ref4.signer,\n      address = _ref4.address,\n      main = _ref4.main;\n  if (main && !subkey) return main;\n  return {\n    signer: signer,\n    address: address\n  };\n}\n/**\n * Returns a contract instance with attached signer\n *\n * @param contract - Contract instance\n * @param signer - Signer to use on contract\n * @returns contract instance with signer\n */\n\nfunction getContractWithSigner(contract, signer) {\n  if (contract.signer === signer) return contract;\n  return contract.connect(signer);\n}\n/**\n * Calls a contract method and wait for it to be mined successfuly, rejects otherwise\n *\n * @param contract - Contract instance\n * @param method - Method name\n * @param params - Params tuple to method\n * @param errorCode - ErrorCode to throw in case of failure\n * @returns Promise to successful receipt\n */\n\nfunction callAndWaitMined(contract, method, params, errorCode) {\n  var _ref5 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n    log: loglevel_default.a\n  },\n      log = _ref5.log;\n\n  return helpers_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee3() {\n    var tx, _contract$functions, receipt;\n\n    return regenerator_default.a.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            _context3.next = 3;\n            return (_contract$functions = contract.functions)[method].apply(_contract$functions, helpers_toConsumableArray(params));\n\n          case 3:\n            tx = _context3.sent;\n            _context3.next = 10;\n            break;\n\n          case 6:\n            _context3.prev = 6;\n            _context3.t0 = _context3["catch"](0);\n            log.error("Error sending ".concat(method, " tx"), _context3.t0);\n            throw new error_RaidenError(errorCode, {\n              error: _context3.t0.message\n            });\n\n          case 10:\n            log.debug("sent ".concat(method, " tx \\"").concat(tx.hash, "\\" to \\"").concat(contract.address, "\\""));\n            _context3.prev = 11;\n            _context3.next = 14;\n            return tx.wait();\n\n          case 14:\n            receipt = _context3.sent;\n            assert(receipt.status, "tx status: ".concat(receipt.status));\n            _context3.next = 22;\n            break;\n\n          case 18:\n            _context3.prev = 18;\n            _context3.t1 = _context3["catch"](11);\n            log.error("Error mining ".concat(method, " tx"), _context3.t1);\n            throw new error_RaidenError(errorCode, {\n              transactionHash: tx.hash\n            });\n\n          case 22:\n            log.debug("".concat(method, " tx \\"").concat(tx.hash, "\\" successfuly mined!"));\n            return _context3.abrupt("return", receipt);\n\n          case 24:\n          case "end":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[0, 6], [11, 18]]);\n  }));\n}\n/**\n * Waits for a given receipt to be confirmed; throws if it gets removed by a reorg instead\n *\n * @param receipt - Receipt to wait for confirmation\n * @param deps - RaidenEpicDeps\n * @param confBlocks - Overwrites config\n * @returns Promise final block of transaction\n */\n\nfunction waitConfirmation(receipt, _ref6, confBlocks) {\n  var latest$ = _ref6.latest$,\n      config$ = _ref6.config$,\n      provider = _ref6.provider;\n  return helpers_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee4() {\n    var txBlock, txHash;\n    return regenerator_default.a.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            txBlock = receipt.blockNumber;\n            txHash = receipt.transactionHash;\n            return _context4.abrupt("return", latest$.pipe(pluckDistinct(\'state\', \'blockNumber\'), Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(filter["a" /* filter */])(function (_ref7) {\n              var _ref8 = helpers_slicedToArray(_ref7, 2),\n                  blockNumber = _ref8[0],\n                  confirmationBlocks = _ref8[1].confirmationBlocks;\n\n              return txBlock + (confBlocks !== null && confBlocks !== void 0 ? confBlocks : confirmationBlocks) <= blockNumber;\n            }), Object(exhaustMap["a" /* exhaustMap */])(function (_ref9) {\n              var _ref10 = helpers_slicedToArray(_ref9, 2),\n                  blockNumber = _ref10[0],\n                  confirmationBlocks = _ref10[1].confirmationBlocks;\n\n              return Object(defer["a" /* defer */])(function () {\n                return provider.getTransactionReceipt(txHash);\n              }).pipe(Object(map["a" /* map */])(function (receipt) {\n                if ((receipt === null || receipt === void 0 ? void 0 : receipt.confirmations) && receipt.confirmations >= (confBlocks !== null && confBlocks !== void 0 ? confBlocks : confirmationBlocks)) return receipt.blockNumber;else if (txBlock + 2 * (confBlocks !== null && confBlocks !== void 0 ? confBlocks : confirmationBlocks) < blockNumber) throw new error_RaidenError(ErrorCodes.RDN_TRANSACTION_REORG, {\n                  transactionHash: txHash\n                });\n              }));\n            }), Object(first["a" /* first */])(isntNil)).toPromise());\n\n          case 3:\n          case "end":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n}\n/*\n * Returns true if `url` is a valid URL or domain.\n * On production `https://` is required for URLs, otherwise `http://` matches as well.\n *\n * @param url - A URL or hostname\n * @returns true if valid URL or domain\n */\n\nvar isValidUrl = function isValidUrl(url) {\n  var regex =  true ? /^(?:https:\\/\\/)?[^\\s\\/$.?#&"\']+\\.[^\\s\\/$?#&"\']+$/ : undefined;\n  return regex.test(url);\n};\n// CONCATENATED MODULE: ../raiden-ts/dist/channels/epics.js\n\n\nfunction epics_toConsumableArray(arr) { return epics_arrayWithoutHoles(arr) || epics_iterableToArray(arr) || epics_unsupportedIterableToArray(arr) || epics_nonIterableSpread(); }\n\nfunction epics_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction epics_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction epics_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return epics_arrayLikeToArray(arr); }\n\nfunction epics_slicedToArray(arr, i) { return epics_arrayWithHoles(arr) || epics_iterableToArrayLimit(arr, i) || epics_unsupportedIterableToArray(arr, i) || epics_nonIterableRest(); }\n\nfunction epics_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction epics_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return epics_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return epics_arrayLikeToArray(o, minLen); }\n\nfunction epics_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction epics_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction epics_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction epics_objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Receives an async function and returns an observable which will retry it every interval until it\n * resolves, or throw if it can\'t succeed after 10 retries.\n * It is needed e.g. on provider methods which perform RPC requests directly, as they can fail\n * temporarily due to network errors, so they need to be retried for a while.\n * JsonRpcProvider._doPoll also catches, suppresses & retry\n *\n * @param func - An async function (e.g. a Promise factory, like a defer callback)\n * @param interval - Interval to retry in case of rejection\n * @param retries - Max number of times to retry\n * @returns Observable version of async function, with retries\n */\n\nfunction retryAsync$(func) {\n  var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e3;\n  var retries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n  return Object(defer["a" /* defer */])(func).pipe(Object(retryWhen["a" /* retryWhen */])(function (err$) {\n    return err$.pipe(Object(mergeMap["a" /* mergeMap */])(function (err, i) {\n      return i < retries ? Object(timer["a" /* timer */])(interval) : Object(throwError["a" /* throwError */])(err);\n    }));\n  }));\n}\n/**\n * Fetch current blockNumber, register for new block events and emit newBlock actions\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param provider - RaidenEpicDeps members\n * @returns Observable of newBlock actions\n */\n\n\nvar epics_initNewBlockEpic = function initNewBlockEpic(_ref, _ref2, _ref3) {\n  epics_objectDestructuringEmpty(_ref);\n\n  epics_objectDestructuringEmpty(_ref2);\n\n  var provider = _ref3.provider;\n  return retryAsync$(function () {\n    return provider.getBlockNumber();\n  }, provider.pollingInterval).pipe(Object(mergeMap["a" /* mergeMap */])(function (blockNumber) {\n    return Object(merge["a" /* merge */])(Object(of["a" /* of */])(blockNumber), fromEthersEvent(provider, \'block\'));\n  }), Object(map["a" /* map */])(function (blockNumber) {\n    return newBlock({\n      blockNumber: blockNumber\n    });\n  }));\n};\n/**\n * On first run, scan registry and token networks for registered TokenNetworks of interest\n * (ones which has/had channels with us) and monitors them. On next runs, just monitors the\n * previously monitored ones.\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param registryContract,contractsInfo - RaidenEpicDeps members\n * @returns Observable of tokenMonitored actions\n */\n\nvar epics_initTokensRegistryEpic = function initTokensRegistryEpic(_ref4, state$, _ref5) {\n  epics_objectDestructuringEmpty(_ref4);\n\n  var address = _ref5.address,\n      provider = _ref5.provider,\n      registryContract = _ref5.registryContract,\n      contractsInfo = _ref5.contractsInfo;\n  return state$.pipe(Object(take["a" /* take */])(1), Object(mergeMap["a" /* mergeMap */])(function (state) {\n    var encodedAddress = utils["defaultAbiCoder"].encode([\'address\'], [address]); // if tokens are already initialized, use it\n\n    if (!lodash_isEmpty_default()(state.tokens)) return Object(from["a" /* from */])(Object.entries(state.tokens).map(function (_ref6) {\n      var _ref7 = epics_slicedToArray(_ref6, 2),\n          token = _ref7[0],\n          tokenNetwork = _ref7[1];\n\n      return tokenMonitored({\n        token: token,\n        tokenNetwork: tokenNetwork\n      });\n    })); // else, do an initial registry scan, from deploy to now\n    else return retryAsync$(function () {\n        return provider.getLogs(Object.assign(Object.assign({}, registryContract.filters.TokenNetworkCreated(null, null)), {\n          fromBlock: contractsInfo.TokenNetworkRegistry.block_number,\n          toBlock: \'latest\'\n        }));\n      }, provider.pollingInterval).pipe(Object(mergeMap["a" /* mergeMap */])(function (logs) {\n        return Object(from["a" /* from */])(logs);\n      }), Object(map["a" /* map */])(function (log) {\n        return {\n          log: log,\n          parsed: registryContract.interface.parseLog(log)\n        };\n      }), Object(filter["a" /* filter */])(function (_ref8) {\n        var parsed = _ref8.parsed;\n\n        var _a;\n\n        return !!((_a = parsed.values) === null || _a === void 0 ? void 0 : _a.token_network_address);\n      }), // for each TokenNetwork found, scan for channels with us\n      Object(mergeMap["a" /* mergeMap */])(function (_ref9) {\n        var log = _ref9.log,\n            parsed = _ref9.parsed;\n        return Object(concat["a" /* concat */])( // concat channels opened by us and to us separately\n        // take(1) won\'t subscribe the later if something is found on former\n        retryAsync$(function () {\n          var _a;\n\n          return provider.getLogs({\n            address: parsed.values.token_network_address,\n            topics: [null, null, encodedAddress],\n            fromBlock: (_a = log.blockNumber) !== null && _a !== void 0 ? _a : contractsInfo.TokenNetworkRegistry.block_number,\n            toBlock: \'latest\'\n          });\n        }, provider.pollingInterval).pipe(Object(mergeMap["a" /* mergeMap */])(from["a" /* from */])), retryAsync$(function () {\n          return provider.getLogs({\n            address: parsed.values.token_network_address,\n            topics: [null, null, null, encodedAddress],\n            fromBlock: log.blockNumber,\n            toBlock: \'latest\'\n          });\n        }, provider.pollingInterval).pipe(Object(mergeMap["a" /* mergeMap */])(from["a" /* from */]))).pipe( // if found at least one, register this TokenNetwork as of interest\n        // else, do nothing\n        Object(take["a" /* take */])(1), Object(mapTo["a" /* mapTo */])(tokenMonitored({\n          token: parsed.values.token_address,\n          tokenNetwork: parsed.values.token_network_address,\n          fromBlock: log.blockNumber\n        })));\n      }, 5));\n  }));\n};\n/**\n * Monitor channels previously already on state\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of channelMonitor actions\n */\n\nvar epics_initMonitorChannelsEpic = function initMonitorChannelsEpic(_ref10, state$) {\n  epics_objectDestructuringEmpty(_ref10);\n\n  return state$.pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee(state) {\n    var _i2, _Object$entries, _Object$entries$_i, tokenNetwork, obj, _i3, _Object$entries2, _Object$entries2$_i, partner, channel;\n\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _i2 = 0, _Object$entries = Object.entries(state.channels);\n\n          case 1:\n            if (!(_i2 < _Object$entries.length)) {\n              _context.next = 16;\n              break;\n            }\n\n            _Object$entries$_i = epics_slicedToArray(_Object$entries[_i2], 2), tokenNetwork = _Object$entries$_i[0], obj = _Object$entries$_i[1];\n            _i3 = 0, _Object$entries2 = Object.entries(obj);\n\n          case 4:\n            if (!(_i3 < _Object$entries2.length)) {\n              _context.next = 13;\n              break;\n            }\n\n            _Object$entries2$_i = epics_slicedToArray(_Object$entries2[_i3], 2), partner = _Object$entries2$_i[0], channel = _Object$entries2$_i[1];\n\n            if (!(channel.state === ChannelState.opening)) {\n              _context.next = 8;\n              break;\n            }\n\n            return _context.abrupt("continue", 10);\n\n          case 8:\n            _context.next = 10;\n            return channelMonitor({\n              id: channel.id\n            }, {\n              tokenNetwork: tokenNetwork,\n              partner: partner\n            });\n\n          case 10:\n            _i3++;\n            _context.next = 4;\n            break;\n\n          case 13:\n            _i2++;\n            _context.next = 1;\n            break;\n\n          case 16:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })));\n};\n/**\n * Monitor provider to ensure account continues to be available and network stays the same\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param address,network,provider - RaidenEpicDeps members\n * @returns Observable of raidenShutdown actions\n */\n\nvar epics_initMonitorProviderEpic = function initMonitorProviderEpic(_ref11, _ref12, _ref13) {\n  epics_objectDestructuringEmpty(_ref11);\n\n  epics_objectDestructuringEmpty(_ref12);\n\n  var address = _ref13.address,\n      network = _ref13.network,\n      provider = _ref13.provider;\n  return retryAsync$(function () {\n    return provider.listAccounts();\n  }, provider.pollingInterval).pipe( // at init time, check if our address is in provider\'s accounts list\n  // if not, it means Signer is a local Wallet or another non-provider-side account\n  // if yes, poll accounts every 1s and monitors if address is still there\n  // also, every 1s poll current provider network and monitors if it\'s the same\n  // if any check fails, emits RaidenShutdownAction, nothing otherwise\n  // Poll reason from: https://github.com/MetaMask/faq/blob/master/DEVELOPERS.md\n  // first/init-time check\n  Object(map["a" /* map */])(function (accounts) {\n    return accounts.includes(address);\n  }), Object(mergeMap["a" /* mergeMap */])(function (isProviderAccount) {\n    return Object(observable_interval["a" /* interval */])(provider.pollingInterval).pipe(Object(exhaustMap["a" /* exhaustMap */])(function () {\n      return Object(merge["a" /* merge */])( // if isProviderAccount, also polls and monitors accounts list\n      isProviderAccount ? retryAsync$(function () {\n        return provider.listAccounts();\n      }, provider.pollingInterval).pipe(Object(mergeMap["a" /* mergeMap */])(function (accounts) {\n        return !accounts.includes(address) ? Object(of["a" /* of */])(raidenShutdown({\n          reason: ShutdownReason.ACCOUNT_CHANGED\n        })) : empty["a" /* EMPTY */];\n      })) : empty["a" /* EMPTY */], // unconditionally monitors network changes\n      retryAsync$(function () {\n        return getNetwork(provider);\n      }, provider.pollingInterval).pipe(Object(mergeMap["a" /* mergeMap */])(function (curNetwork) {\n        return curNetwork.chainId !== network.chainId ? Object(of["a" /* of */])(raidenShutdown({\n          reason: ShutdownReason.NETWORK_CHANGED\n        })) : empty["a" /* EMPTY */];\n      })));\n    }));\n  }));\n};\n/**\n * Starts monitoring a token network for events\n * When this action goes through (because a former or new token registry event was deteceted),\n * subscribe to events and emit respective actions to the stream. Currently:\n * - ChannelOpened events with us or by us\n *\n * @param action$ - Observable of tokenMonitored actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of channelOpen.success actions\n */\n\nvar epics_tokenMonitoredEpic = function tokenMonitoredEpic(action$, _ref14, _ref15) {\n  epics_objectDestructuringEmpty(_ref14);\n\n  var address = _ref15.address,\n      getTokenNetworkContract = _ref15.getTokenNetworkContract;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(tokenMonitored)), Object(groupBy["a" /* groupBy */])(function (action) {\n    return action.payload.tokenNetwork;\n  }), Object(mergeMap["a" /* mergeMap */])(function (grouped$) {\n    return grouped$.pipe(Object(exhaustMap["a" /* exhaustMap */])(function (action) {\n      var tokenNetworkContract = getTokenNetworkContract(action.payload.tokenNetwork); // type of elements emitted by getEventsStream (past and new events coming from\n      // contract): [channelId, partner1, partner2, settleTimeout, Event]\n\n      return getEventsStream(tokenNetworkContract, // it\'s cheaper for monitoring to fetch all channels and filter client-side,\n      // than to query/create/request 2 filters on every block (from and to us)\n      [tokenNetworkContract.filters.ChannelOpened(null, null, null, null)], // if first time monitoring this token network,\n      // fetch TokenNetwork\'s pastEvents since registry deployment as fromBlock$\n      action.payload.fromBlock ? Object(of["a" /* of */])(action.payload.fromBlock) : undefined).pipe(Object(filter["a" /* filter */])(function (_ref16) {\n        var _ref17 = epics_slicedToArray(_ref16, 3),\n            p1 = _ref17[1],\n            p2 = _ref17[2];\n\n        return p1 === address || p2 === address;\n      }), Object(map["a" /* map */])(function (_ref18) {\n        var _ref19 = epics_slicedToArray(_ref18, 5),\n            id = _ref19[0],\n            p1 = _ref19[1],\n            p2 = _ref19[2],\n            settleTimeout = _ref19[3],\n            event = _ref19[4];\n\n        return channelOpen.success({\n          id: id.toNumber(),\n          settleTimeout: settleTimeout.toNumber(),\n          isFirstParticipant: address === p1,\n          txHash: event.transactionHash,\n          txBlock: event.blockNumber,\n          confirmed: undefined\n        }, {\n          tokenNetwork: tokenNetworkContract.address,\n          partner: address === p1 ? p2 : p1\n        });\n      }));\n    }));\n  }));\n};\n/**\n * When we see a new ChannelOpenedAction event, starts monitoring channel\n *\n * @param action$ - Observable of channelOpen.success actions\n * @returns Observable of channelMonitor actions\n */\n\nvar epics_channelOpenedEpic = function channelOpenedEpic(action$) {\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(channelOpen.success)), Object(filter["a" /* filter */])(function (action) {\n    return !!action.payload.confirmed;\n  }), Object(map["a" /* map */])(function (action) {\n    return channelMonitor({\n      id: action.payload.id,\n      // fetch past events as well, if needed, including events before confirmation\n      fromBlock: action.payload.txBlock\n    }, action.meta);\n  }));\n};\n/**\n * Monitors a channel for channel Events\n * Can be called either at initialization time (for previously known channels on previously\n * monitored TokenNetwork) or by a new detected ChannelOpenedAction. On the later case,\n * also fetches events since Channel.openBlock.\n * Currently monitored events:\n * - ChannelNewDeposit, fires a channelDeposit.success action\n * - ChannelClosedEvent, fires a channelClose.success action\n * - ChannelSettledEvent, fires a channelSettle.success action and completes that channel observable\n *\n * @param action$ - Observable of channelMonitor actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of channelDeposit.success,channelClose.success,channelSettle.success actions\n */\n\nvar epics_channelMonitoredEpic = function channelMonitoredEpic(action$, state$, _ref20) {\n  var getTokenNetworkContract = _ref20.getTokenNetworkContract;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(channelMonitor)), Object(groupBy["a" /* groupBy */])(function (action) {\n    return "".concat(action.payload.id, "#").concat(action.meta.partner, "@").concat(action.meta.tokenNetwork);\n  }), Object(mergeMap["a" /* mergeMap */])(function (grouped$) {\n    return grouped$.pipe(Object(exhaustMap["a" /* exhaustMap */])(function (action) {\n      var _action$meta = action.meta,\n          tokenNetwork = _action$meta.tokenNetwork,\n          partner = _action$meta.partner;\n      var tokenNetworkContract = getTokenNetworkContract(tokenNetwork);\n      var depositFilter = tokenNetworkContract.filters.ChannelNewDeposit(action.payload.id, null, null),\n          withdrawFilter = tokenNetworkContract.filters.ChannelWithdraw(action.payload.id, null, null),\n          closedFilter = tokenNetworkContract.filters.ChannelClosed(action.payload.id, null, null, null),\n          settledFilter = tokenNetworkContract.filters.ChannelSettled(action.payload.id, null, null, null, null),\n          mergedFilter = {\n        address: tokenNetworkContract.address,\n        topics: [[depositFilter.topics[0], withdrawFilter.topics[0], closedFilter.topics[0], settledFilter.topics[0]], [settledFilter.topics[1]]]\n      };\n      /**\n       * Guards that an event data tuple matches the type of a given filter\n       *\n       * Type must be explicitly passed as generic type parameter, and a corresponding filter\n       * as first parameter\n       *\n       * @param filter - Filter of an event of type T\n       * @param data - event data tuple, where last element is the Event object\n       * @returns Truty if event data matches filter\n       */\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      function isEvent(filter, data) {\n        var event = data[data.length - 1];\n        if (!event || !event.topics || !filter.topics) return false;\n        var topic0 = filter.topics[0];\n        return Array.isArray(topic0) ? topic0.includes(event.topics[0]) : topic0 === event.topics[0];\n      }\n\n      return getEventsStream(tokenNetworkContract, [mergedFilter], // if channelMonitor triggered by channelOpen.success,\n      // fetch Channel\'s pastEvents since channelOpen.success blockNumber as fromBlock$\n      action.payload.fromBlock ? Object(of["a" /* of */])(action.payload.fromBlock) : undefined).pipe(Object(withLatestFrom["a" /* withLatestFrom */])(state$.pipe(Object(pluck["a" /* pluck */])(\'channels\'), Object(startWith["a" /* startWith */])({}))), Object(map["a" /* map */])(function (_ref21) {\n        var _ref22 = epics_slicedToArray(_ref21, 2),\n            data = _ref22[0],\n            channels = _ref22[1];\n\n        var _a, _b, _c;\n\n        if (isEvent(depositFilter, data)) {\n          var _data = epics_slicedToArray(data, 4),\n              id = _data[0],\n              participant = _data[1],\n              totalDeposit = _data[2],\n              event = _data[3];\n\n          return channelDeposit.success({\n            id: id.toNumber(),\n            participant: participant,\n            totalDeposit: totalDeposit,\n            txHash: event.transactionHash,\n            txBlock: event.blockNumber,\n            confirmed: undefined\n          }, action.meta);\n        } else if (isEvent(withdrawFilter, data)) {\n          var _data2 = epics_slicedToArray(data, 4),\n              _id = _data2[0],\n              _participant = _data2[1],\n              totalWithdraw = _data2[2],\n              _event = _data2[3];\n\n          return channelWithdrawn({\n            id: _id.toNumber(),\n            participant: _participant,\n            totalWithdraw: totalWithdraw,\n            txHash: _event.transactionHash,\n            txBlock: _event.blockNumber,\n            confirmed: undefined\n          }, action.meta);\n        } else if (isEvent(closedFilter, data)) {\n          var _data3 = epics_slicedToArray(data, 5),\n              _id2 = _data3[0],\n              _participant2 = _data3[1],\n              _event2 = _data3[4];\n\n          return channelClose.success({\n            id: _id2.toNumber(),\n            participant: _participant2,\n            txHash: _event2.transactionHash,\n            txBlock: _event2.blockNumber,\n            confirmed: undefined\n          }, action.meta);\n        } else if (isEvent(settledFilter, data)) {\n          var _data4 = epics_slicedToArray(data, 6),\n              _id3 = _data4[0],\n              _event3 = _data4[5];\n\n          return channelSettle.success({\n            id: _id3.toNumber(),\n            txHash: _event3.transactionHash,\n            txBlock: _event3.blockNumber,\n            confirmed: undefined,\n            locks: (_c = (_b = (_a = channels[tokenNetwork]) === null || _a === void 0 ? void 0 : _a[partner]) === null || _b === void 0 ? void 0 : _b.partner) === null || _c === void 0 ? void 0 : _c.locks\n          }, action.meta);\n        }\n      }), Object(filter["a" /* filter */])(isntNil), // takeWhile tends to broad input to generic Action. We need to narrow it explicitly\n      Object(takeWhile["a" /* takeWhile */])(negate_default()(channelSettle.success.is), true));\n    }));\n  }));\n};\n/**\n * A channelOpen action requested by user\n * Needs to be called on a previously monitored tokenNetwork. Calls TokenNetwork.openChannel\n * with given parameters. If tx goes through successfuly, stop as ChannelOpened success action\n * will instead be detected and fired by tokenMonitoredEpic. If anything detectable goes wrong,\n * fires a ChannnelOpenActionFailed instead\n *\n * @param action$ - Observable of channelOpen actions\n * @param state$ - Observable of RaidenStates\n * @param getTokenNetworkContract - RaidenEpicDeps members\n * @returns Observable of channelOpen.failure actions\n */\n\nvar epics_channelOpenEpic = function channelOpenEpic(action$, state$, _ref23) {\n  var log = _ref23.log,\n      signer = _ref23.signer,\n      address = _ref23.address,\n      main = _ref23.main,\n      getTokenContract = _ref23.getTokenContract,\n      getTokenNetworkContract = _ref23.getTokenNetworkContract,\n      config$ = _ref23.config$;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(channelOpen.request)), Object(withLatestFrom["a" /* withLatestFrom */])(state$, config$), Object(mergeMap["a" /* mergeMap */])(function (_ref24) {\n    var _ref25 = epics_slicedToArray(_ref24, 3),\n        action = _ref25[0],\n        state = _ref25[1],\n        _ref25$ = _ref25[2],\n        settleTimeout = _ref25$.settleTimeout,\n        configSubkey = _ref25$.subkey;\n\n    var _a, _b, _c;\n\n    var _action$meta2 = action.meta,\n        tokenNetwork = _action$meta2.tokenNetwork,\n        partner = _action$meta2.partner;\n    var channelState = (_b = (_a = state.channels[tokenNetwork]) === null || _a === void 0 ? void 0 : _a[partner]) === null || _b === void 0 ? void 0 : _b.state; // proceed only if channel is in \'opening\' state, set by this action\n\n    if (channelState !== ChannelState.opening) return Object(of["a" /* of */])(channelOpen.failure(new error_RaidenError(ErrorCodes.CNL_INVALID_STATE, {\n      state: channelState\n    }), action.meta));\n\n    var _chooseOnchainAccount = chooseOnchainAccount({\n      signer: signer,\n      address: address,\n      main: main\n    }, (_c = action.payload.subkey) !== null && _c !== void 0 ? _c : configSubkey),\n        onchainSigner = _chooseOnchainAccount.signer;\n\n    var tokenNetworkContract = getContractWithSigner(getTokenNetworkContract(tokenNetwork), onchainSigner); // if also requested deposit\n\n    var deposit = !action.payload.deposit || action.payload.deposit.isZero() ? undefined : action.payload.deposit;\n    var token = findKey_default()(state.tokens, function (tn) {\n      return tn === tokenNetwork;\n    });\n    var tokenContract = getContractWithSigner(getTokenContract(token), onchainSigner);\n    return action$.pipe(Object(filter["a" /* filter */])(channelOpen.success.is), Object(filter["a" /* filter */])(function (a) {\n      return a.meta.tokenNetwork === tokenNetwork && a.meta.partner === partner;\n    }), // opened$ will "cache" matching channelOpen.success, if needed\n    Object(publishReplay["a" /* publishReplay */])(1, undefined, function (opened$) {\n      return (// send openChannel transaction\n        Object(defer["a" /* defer */])(function () {\n          var _a;\n\n          return tokenNetworkContract.functions.openChannel(address, partner, (_a = action.payload.settleTimeout) !== null && _a !== void 0 ? _a : settleTimeout);\n        }).pipe( // Wallet signer depends on fetching the \'pending\' tx count to fill \'nonce\'\n        // therefore we need to send open then approve, instead of doing them parallely\n        Object(mergeMap["a" /* mergeMap */])(function (openTx) {\n          return deposit ? Object(from["a" /* from */])(tokenContract.functions.approve(tokenNetwork, deposit)).pipe(Object(map["a" /* map */])(function (approveTx) {\n            return [openTx, approveTx];\n          })) : Object(of["a" /* of */])([openTx]);\n        }), // can\'t share logic with channelDepositEpic, because parallelism of txs needs to be\n        // strict, nor use assertTx for approve|openChannel parallel txs\n        Object(tap["a" /* tap */])(function (_ref26) {\n          var _ref27 = epics_slicedToArray(_ref26, 1),\n              tx = _ref27[0];\n\n          return log.debug("sent openChannel tx \\"".concat(tx.hash, "\\" to \\"").concat(tokenNetwork, "\\""));\n        }), Object(tap["a" /* tap */])(function (_ref28) {\n          var _ref29 = epics_slicedToArray(_ref28, 2),\n              tx = _ref29[1];\n\n          return tx ? log.debug("sent approve tx \\"".concat(tx.hash, "\\" to \\"").concat(token, "\\"")) : 0;\n        }), Object(mergeMap["a" /* mergeMap */])(function (_ref30) {\n          var _ref31 = epics_slicedToArray(_ref30, 2),\n              openTx = _ref31[0],\n              approveTx = _ref31[1];\n\n          return Object(combineLatest["a" /* combineLatest */])([Object(from["a" /* from */])(openTx.wait()).pipe(Object(map["a" /* map */])(function (receipt) {\n            return {\n              tx: openTx,\n              receipt: receipt\n            };\n          })), approveTx ? Object(from["a" /* from */])(approveTx.wait()).pipe(Object(map["a" /* map */])(function (receipt) {\n            return {\n              tx: approveTx,\n              receipt: receipt\n            };\n          })) : Object(of["a" /* of */])(undefined)]);\n        }), Object(mergeMap["a" /* mergeMap */])(function (_ref32) {\n          var _ref33 = epics_slicedToArray(_ref32, 2),\n              open = _ref33[0],\n              approve = _ref33[1];\n\n          if (!open.receipt.status) throw new error_RaidenError(ErrorCodes.CNL_OPENCHANNEL_FAILED, Object.assign(Object.assign({}, action.meta), {\n            transactionHash: open.tx.hash\n          }));\n          log.debug("openChannel tx \\"".concat(open.tx.hash, "\\" successfuly mined!")); // now that channel is opened, check approve and proceed to setTotalDeposit\n          // if no deposit requested, EMPTY will skip rest of this chain\n\n          return (approve ? Object(of["a" /* of */])(approve) : empty["a" /* EMPTY */]).pipe(Object(mergeMap["a" /* mergeMap */])(function (_ref34) {\n            var tx = _ref34.tx,\n                receipt = _ref34.receipt;\n            if (!receipt.status) throw new error_RaidenError(ErrorCodes.CNL_APPROVE_TRANSACTION_FAILED, {\n              token: token,\n              transactionHash: tx.hash\n            });\n            log.debug("approve tx \\"".concat(tx.hash, "\\" successfuly mined!")); // wait or use cached channelOpen.success, unconfirmed\n\n            return opened$.pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])(function (_ref35) {\n              var id = _ref35.payload.id;\n              return tokenNetworkContract.functions.setTotalDeposit(id, address, deposit, partner);\n            }));\n          }), assertTx(\'setTotalDeposit\', ErrorCodes.CNL_SETTOTALDEPOSIT_FAILED, {\n            log: log\n          }), // ignore success so it\'s picked by channelMonitoredEpic\n          Object(ignoreElements["a" /* ignoreElements */])(), Object(catchError["a" /* catchError */])(function (error) {\n            return Object(of["a" /* of */])(channelDeposit.failure(error, action.meta));\n          }));\n        }), // ignore success so it\'s picked by tokenMonitoredEpic\n        Object(catchError["a" /* catchError */])(function (error) {\n          return Object(of["a" /* of */])(channelOpen.failure(error, action.meta));\n        }))\n      );\n    }));\n  }));\n};\n/**\n * A ChannelDeposit action requested by user\n * Needs to be called on a previously monitored channel. Calls Token.approve for TokenNetwork\n * and then set respective setTotalDeposit. If all tx go through successfuly, stop as\n * ChannelDeposited success action will instead be detected and reacted by\n * channelMonitoredEpic. If anything detectable goes wrong, fires a ChannelDepositActionFailed\n * instead\n *\n * @param action$ - Observable of channelDeposit.request actions\n * @param state$ - Observable of RaidenStates\n * @param address,getTokenContract,getTokenNetworkContract - RaidenEpicDeps members\n * @returns Observable of channelDeposit.failure actions\n */\n\nvar epics_channelDepositEpic = function channelDepositEpic(action$, state$, _ref36) {\n  var log = _ref36.log,\n      signer = _ref36.signer,\n      address = _ref36.address,\n      main = _ref36.main,\n      getTokenContract = _ref36.getTokenContract,\n      getTokenNetworkContract = _ref36.getTokenNetworkContract,\n      config$ = _ref36.config$;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(channelDeposit.request)), Object(withLatestFrom["a" /* withLatestFrom */])(state$, config$), Object(mergeMap["a" /* mergeMap */])(function (_ref37) {\n    var _ref38 = epics_slicedToArray(_ref37, 3),\n        action = _ref38[0],\n        state = _ref38[1],\n        configSubkey = _ref38[2].subkey;\n\n    var _a;\n\n    var _action$meta3 = action.meta,\n        tokenNetwork = _action$meta3.tokenNetwork,\n        partner = _action$meta3.partner;\n    var token = findKey_default()(state.tokens, function (tn) {\n      return tn === tokenNetwork;\n    });\n\n    if (!token) {\n      var error = new error_RaidenError(ErrorCodes.CNL_TOKEN_NOT_FOUND, action.meta);\n      return Object(of["a" /* of */])(channelDeposit.failure(error, action.meta));\n    }\n\n    var _chooseOnchainAccount2 = chooseOnchainAccount({\n      signer: signer,\n      address: address,\n      main: main\n    }, (_a = action.payload.subkey) !== null && _a !== void 0 ? _a : configSubkey),\n        onchainSigner = _chooseOnchainAccount2.signer;\n\n    var tokenContract = getContractWithSigner(getTokenContract(token), onchainSigner);\n    var tokenNetworkContract = getContractWithSigner(getTokenNetworkContract(tokenNetwork), onchainSigner);\n    var channel = state.channels[tokenNetwork][partner];\n\n    if ((channel === null || channel === void 0 ? void 0 : channel.state) !== ChannelState.open) {\n      var _error = new error_RaidenError(ErrorCodes.CNL_NO_OPEN_CHANNEL_FOUND, action.meta);\n\n      return Object(of["a" /* of */])(channelDeposit.failure(_error, action.meta));\n    } // send approve transaction\n\n\n    return Object(from["a" /* from */])(tokenContract.functions.approve(tokenNetwork, action.payload.deposit)).pipe(assertTx(\'approve\', ErrorCodes.CNL_APPROVE_TRANSACTION_FAILED, {\n      log: log\n    }), Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(mergeMap["a" /* mergeMap */])(function (_ref39) {\n      var _ref40 = epics_slicedToArray(_ref39, 2),\n          state = _ref40[1];\n\n      return (// send setTotalDeposit transaction\n        tokenNetworkContract.functions.setTotalDeposit(channel.id, address, state.channels[tokenNetwork][partner].own.deposit.add(action.payload.deposit), partner)\n      );\n    }), assertTx(\'setTotalDeposit\', ErrorCodes.CNL_SETTOTALDEPOSIT_FAILED, {\n      log: log\n    }), // if succeeded, return a empty/completed observable\n    // actual ChannelDepositedAction will be detected and handled by channelMonitoredEpic\n    // if any error happened on tx call/pipeline, mergeMap below won\'t be hit, and catchError\n    // will then emit the channelDeposit.failure action instead\n    Object(ignoreElements["a" /* ignoreElements */])(), Object(catchError["a" /* catchError */])(function (error) {\n      return Object(of["a" /* of */])(channelDeposit.failure(error, action.meta));\n    }));\n  }));\n};\n/**\n * A ChannelClose action requested by user\n * Needs to be called on an opened or closing (for retries) channel.\n * If tx goes through successfuly, stop as ChannelClosed success action will instead be\n * detected and reacted by channelMonitoredEpic. If anything detectable goes wrong, fires a\n * ChannelCloseActionFailed instead\n *\n * @param action$ - Observable of channelClose actions\n * @param state$ - Observable of RaidenStates\n * @param getTokenNetworkContract - RaidenEpicDeps members\n * @returns Observable of channelClose.failure actions\n */\n\nvar epics_channelCloseEpic = function channelCloseEpic(action$, state$, _ref41) {\n  var log = _ref41.log,\n      signer = _ref41.signer,\n      address = _ref41.address,\n      main = _ref41.main,\n      network = _ref41.network,\n      getTokenNetworkContract = _ref41.getTokenNetworkContract,\n      config$ = _ref41.config$;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(channelClose.request)), Object(withLatestFrom["a" /* withLatestFrom */])(state$, config$), Object(mergeMap["a" /* mergeMap */])(function (_ref42) {\n    var _ref43 = epics_slicedToArray(_ref42, 3),\n        action = _ref43[0],\n        state = _ref43[1],\n        configSubkey = _ref43[2].subkey;\n\n    var _a, _b, _c;\n\n    var _action$meta4 = action.meta,\n        tokenNetwork = _action$meta4.tokenNetwork,\n        partner = _action$meta4.partner;\n\n    var _chooseOnchainAccount3 = chooseOnchainAccount({\n      signer: signer,\n      address: address,\n      main: main\n    }, (_b = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.subkey) !== null && _b !== void 0 ? _b : configSubkey),\n        onchainSigner = _chooseOnchainAccount3.signer;\n\n    var tokenNetworkContract = getContractWithSigner(getTokenNetworkContract(tokenNetwork), onchainSigner);\n    var channel = (_c = state.channels[tokenNetwork]) === null || _c === void 0 ? void 0 : _c[partner];\n\n    if ((channel === null || channel === void 0 ? void 0 : channel.state) !== ChannelState.open && (channel === null || channel === void 0 ? void 0 : channel.state) !== ChannelState.closing) {\n      var error = new error_RaidenError(ErrorCodes.CNL_NO_OPEN_OR_CLOSING_CHANNEL_FOUND, action.meta);\n      return Object(of["a" /* of */])(channelClose.failure(error, action.meta));\n    }\n\n    var balanceHash = constants["HashZero"],\n        nonce = constants["Zero"],\n        additionalHash = constants["HashZero"],\n        nonClosingSignature = Object(utils["hexlify"])(SignatureZero);\n\n    if (channel.partner.balanceProof) {\n      balanceHash = createBalanceHash(channel.partner.balanceProof.transferredAmount, channel.partner.balanceProof.lockedAmount, channel.partner.balanceProof.locksroot);\n      nonce = channel.partner.balanceProof.nonce;\n      additionalHash = channel.partner.balanceProof.messageHash;\n      nonClosingSignature = channel.partner.balanceProof.signature;\n    }\n\n    var closingMessage = Object(utils["concat"])([encode(tokenNetwork, 20), encode(network.chainId, 32), encode(1, 32), encode(channel.id, 32), encode(balanceHash, 32), encode(nonce, 32), encode(additionalHash, 32), encode(nonClosingSignature, 65)]); // UInt8Array of 277 bytes\n    // sign counter balance proof, then send closeChannel transaction with our signature\n\n    return Object(from["a" /* from */])(signer.signMessage(closingMessage)).pipe(Object(mergeMap["a" /* mergeMap */])(function (closingSignature) {\n      return tokenNetworkContract.functions.closeChannel(channel.id, partner, address, balanceHash, nonce, additionalHash, nonClosingSignature, closingSignature);\n    }), assertTx(\'closeChannel\', ErrorCodes.CNL_CLOSECHANNEL_FAILED, {\n      log: log\n    }), // if succeeded, return a empty/completed observable\n    // actual ChannelClosedAction will be detected and handled by channelMonitoredEpic\n    // if any error happened on tx call/pipeline, catchError will then emit the\n    // channelClose.failure action instead\n    Object(ignoreElements["a" /* ignoreElements */])(), Object(catchError["a" /* catchError */])(function (error) {\n      return Object(of["a" /* of */])(channelClose.failure(error, action.meta));\n    }));\n  }));\n};\n/**\n * When detecting a ChannelClosed event, calls updateNonClosingBalanceProof with partner\'s balance\n * proof, iff there\'s any\n * TODO: do it only if economically viable (and define what that means)\n *\n * @param action$ - Observable of channelClose.success|newBlock actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps members\n * @returns Empty observable\n */\n\nvar epics_channelUpdateEpic = function channelUpdateEpic(action$, state$, _ref44) {\n  var log = _ref44.log,\n      signer = _ref44.signer,\n      address = _ref44.address,\n      main = _ref44.main,\n      network = _ref44.network,\n      getTokenNetworkContract = _ref44.getTokenNetworkContract,\n      config$ = _ref44.config$;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(channelClose.success)), Object(filter["a" /* filter */])(function (action) {\n    return !!action.payload.confirmed;\n  }), // wait 2 newBlock actions go through after channelClose confirmation, to ensure any pending\n  // channelSettle could have been processed\n  Object(mergeMap["a" /* mergeMap */])(function (action) {\n    return action$.pipe(Object(filter["a" /* filter */])(newBlock.is), Object(skip["a" /* skip */])(1), Object(take["a" /* take */])(1), Object(mapTo["a" /* mapTo */])(action));\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(state$, config$), Object(filter["a" /* filter */])(function (_ref45) {\n    var _ref46 = epics_slicedToArray(_ref45, 2),\n        action = _ref46[0],\n        state = _ref46[1];\n\n    var _a;\n\n    var channel = (_a = state.channels[action.meta.tokenNetwork]) === null || _a === void 0 ? void 0 : _a[action.meta.partner];\n    return (channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.closed && channel.id === action.payload.id && !!channel.partner.balanceProof && // there\'s partners balanceProof (i.e. received transfers)\n    channel.closeParticipant !== address // we\'re not the closing end\n    ;\n  }), Object(mergeMap["a" /* mergeMap */])(function (_ref47) {\n    var _ref48 = epics_slicedToArray(_ref47, 3),\n        action = _ref48[0],\n        state = _ref48[1],\n        subkey = _ref48[2].subkey;\n\n    var _action$meta5 = action.meta,\n        tokenNetwork = _action$meta5.tokenNetwork,\n        partner = _action$meta5.partner;\n\n    var _chooseOnchainAccount4 = chooseOnchainAccount({\n      signer: signer,\n      address: address,\n      main: main\n    }, subkey),\n        onchainSigner = _chooseOnchainAccount4.signer;\n\n    var tokenNetworkContract = getContractWithSigner(getTokenNetworkContract(tokenNetwork), onchainSigner);\n    var channel = state.channels[tokenNetwork][partner]; // should never happen because of filter, just here to narrow union\n\n    assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.closed);\n    assert(channel.partner.balanceProof);\n    var balanceHash = createBalanceHash(channel.partner.balanceProof.transferredAmount, channel.partner.balanceProof.lockedAmount, channel.partner.balanceProof.locksroot);\n    var nonce = channel.partner.balanceProof.nonce;\n    var additionalHash = channel.partner.balanceProof.messageHash;\n    var closingSignature = channel.partner.balanceProof.signature;\n    var nonClosingMessage = Object(utils["concat"])([encode(tokenNetwork, 20), encode(network.chainId, 32), encode(2, 32), encode(channel.id, 32), encode(balanceHash, 32), encode(nonce, 32), encode(additionalHash, 32), encode(closingSignature, 65)]); // UInt8Array of 277 bytes\n    // send updateNonClosingBalanceProof transaction\n\n    return Object(from["a" /* from */])(signer.signMessage(nonClosingMessage)).pipe(Object(mergeMap["a" /* mergeMap */])(function (nonClosingSignature) {\n      return tokenNetworkContract.functions.updateNonClosingBalanceProof(channel.id, partner, address, balanceHash, nonce, additionalHash, closingSignature, nonClosingSignature);\n    }), assertTx(\'updateNonClosingBalanceProof\', ErrorCodes.CNL_UPDATE_NONCLOSING_BP_FAILED, {\n      log: log\n    }), // if succeeded, return a empty/completed observable\n    Object(ignoreElements["a" /* ignoreElements */])(), Object(catchError["a" /* catchError */])(function (error) {\n      log.error(\'Error updating non-closing balance-proof, ignoring\', error);\n      return empty["a" /* EMPTY */];\n    }));\n  }));\n};\n/**\n * A ChannelSettle action requested by user\n * Needs to be called on an settleable or settling (for retries) channel.\n * If tx goes through successfuly, stop as ChannelSettled success action will instead be\n * detected and reacted by channelMonitoredEpic. If anything detectable goes wrong, fires a\n * ChannelSettleActionFailed instead\n *\n * @param action$ - Observable of channelSettle actions\n * @param state$ - Observable of RaidenStates\n * @param address,getTokenNetworkContract - RaidenEpicDeps members\n * @returns Observable of channelSettle.failure actions\n */\n\nvar epics_channelSettleEpic = function channelSettleEpic(action$, state$, _ref49) {\n  var log = _ref49.log,\n      signer = _ref49.signer,\n      address = _ref49.address,\n      main = _ref49.main,\n      getTokenNetworkContract = _ref49.getTokenNetworkContract,\n      config$ = _ref49.config$;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(channelSettle.request)), Object(withLatestFrom["a" /* withLatestFrom */])(state$, config$), Object(mergeMap["a" /* mergeMap */])(function (_ref50) {\n    var _ref51 = epics_slicedToArray(_ref50, 3),\n        action = _ref51[0],\n        state = _ref51[1],\n        configSubkey = _ref51[2].subkey;\n\n    var _a, _b, _c;\n\n    var _action$meta6 = action.meta,\n        tokenNetwork = _action$meta6.tokenNetwork,\n        partner = _action$meta6.partner;\n\n    var _chooseOnchainAccount5 = chooseOnchainAccount({\n      signer: signer,\n      address: address,\n      main: main\n    }, (_b = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.subkey) !== null && _b !== void 0 ? _b : configSubkey),\n        onchainSigner = _chooseOnchainAccount5.signer;\n\n    var tokenNetworkContract = getContractWithSigner(getTokenNetworkContract(tokenNetwork), onchainSigner);\n    var channel = (_c = state.channels[tokenNetwork]) === null || _c === void 0 ? void 0 : _c[partner];\n\n    if ((channel === null || channel === void 0 ? void 0 : channel.state) !== ChannelState.settleable && (channel === null || channel === void 0 ? void 0 : channel.state) !== ChannelState.settling) {\n      var error = new error_RaidenError(ErrorCodes.CNL_NO_SETTLEABLE_OR_SETTLING_CHANNEL_FOUND, action.meta);\n      return Object(of["a" /* of */])(channelSettle.failure(error, action.meta));\n    }\n\n    var zeroBalanceProof = {\n      transferredAmount: constants["Zero"],\n      lockedAmount: constants["Zero"],\n      locksroot: constants["HashZero"]\n    };\n    var part1 = Object.assign({\n      address: partner\n    }, channel.partner.balanceProof || zeroBalanceProof),\n        part2 = Object.assign({\n      address: address\n    }, channel.own.balanceProof || zeroBalanceProof);\n\n    if (channel.isFirstParticipant) {\n      var _ref52 = [part2, part1];\n      part1 = _ref52[0];\n      part2 = _ref52[1];\n    } // send settleChannel transaction\n\n\n    return Object(from["a" /* from */])(tokenNetworkContract.functions.settleChannel(channel.id, part1.address, part1.transferredAmount, part1.lockedAmount, part1.locksroot, part2.address, part2.transferredAmount, part2.lockedAmount, part2.locksroot)).pipe(assertTx(\'settleChannel\', ErrorCodes.CNL_SETTLECHANNEL_FAILED, {\n      log: log\n    }), // if succeeded, return a empty/completed observable\n    // actual ChannelSettledAction will be detected and handled by channelMonitoredEpic\n    // if any error happened on tx call/pipeline, mergeMap below won\'t be hit, and catchError\n    // will then emit the channelSettle.failure action instead\n    Object(ignoreElements["a" /* ignoreElements */])(), Object(catchError["a" /* catchError */])(function (error) {\n      return Object(of["a" /* of */])(channelSettle.failure(error, action.meta));\n    }));\n  }));\n};\n/**\n * Process newBlocks, emits ChannelSettleableAction if any closed channel is now settleable\n *\n * @param action$ - Observable of newBlock actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of channelSettleable actions\n */\n\nvar epics_channelSettleableEpic = function channelSettleableEpic(action$, state$) {\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(newBlock)), Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee2(_ref53) {\n    var _ref54, blockNumber, state, tokenNetwork, partner, channel;\n\n    return regenerator_default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref54 = epics_slicedToArray(_ref53, 2), blockNumber = _ref54[0].payload.blockNumber, state = _ref54[1];\n            _context2.t0 = regenerator_default.a.keys(state.channels);\n\n          case 2:\n            if ((_context2.t1 = _context2.t0()).done) {\n              _context2.next = 15;\n              break;\n            }\n\n            tokenNetwork = _context2.t1.value;\n            _context2.t2 = regenerator_default.a.keys(state.channels[tokenNetwork]);\n\n          case 5:\n            if ((_context2.t3 = _context2.t2()).done) {\n              _context2.next = 13;\n              break;\n            }\n\n            partner = _context2.t3.value;\n            channel = state.channels[tokenNetwork][partner];\n\n            if (!(channel.state === ChannelState.closed && channel.settleTimeout && // closed channels always have settleTimeout & closeBlock set\n            channel.closeBlock && blockNumber > channel.closeBlock + channel.settleTimeout)) {\n              _context2.next = 11;\n              break;\n            }\n\n            _context2.next = 11;\n            return channelSettleable({\n              settleableBlock: blockNumber\n            }, {\n              tokenNetwork: tokenNetwork,\n              partner: partner\n            });\n\n          case 11:\n            _context2.next = 5;\n            break;\n\n          case 13:\n            _context2.next = 2;\n            break;\n\n          case 15:\n          case "end":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  })));\n};\n/**\n * When channel is settled, unlock any pending lock on-chain\n * TODO: check if it\'s worth it to also unlock partner\'s end\n * TODO: do it only if economically viable (and define what that means)\n *\n * @param action$ - Observable of channelSettle.success actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps members\n * @returns Empty observable\n */\n\nvar epics_channelUnlockEpic = function channelUnlockEpic(action$, state$, _ref55) {\n  var log = _ref55.log,\n      signer = _ref55.signer,\n      address = _ref55.address,\n      main = _ref55.main,\n      getTokenNetworkContract = _ref55.getTokenNetworkContract,\n      config$ = _ref55.config$;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(channelSettle.success)), Object(filter["a" /* filter */])(function (action) {\n    var _a;\n\n    return !!(action.payload.confirmed && ((_a = action.payload.locks) === null || _a === void 0 ? void 0 : _a.length));\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(state$, config$), Object(filter["a" /* filter */])(function (_ref56) {\n    var _ref57 = epics_slicedToArray(_ref56, 2),\n        action = _ref57[0],\n        state = _ref57[1];\n\n    var _a;\n\n    var channel = (_a = state.channels[action.meta.tokenNetwork]) === null || _a === void 0 ? void 0 : _a[action.meta.partner];\n    return !channel || !(\'id\' in channel) || channel.id !== action.payload.id;\n  }), Object(mergeMap["a" /* mergeMap */])(function (_ref58) {\n    var _ref59 = epics_slicedToArray(_ref58, 3),\n        action = _ref59[0],\n        subkey = _ref59[2].subkey;\n\n    var _action$meta7 = action.meta,\n        tokenNetwork = _action$meta7.tokenNetwork,\n        partner = _action$meta7.partner;\n    var tokenNetworkContract = getContractWithSigner(getTokenNetworkContract(tokenNetwork), chooseOnchainAccount({\n      signer: signer,\n      address: address,\n      main: main\n    }, subkey).signer);\n    var locks = Object(utils["concat"])(action.payload.locks.reduce(function (acc, lock) {\n      return [].concat(epics_toConsumableArray(acc), [encode(lock.expiration, 32), encode(lock.amount, 32), lock.secrethash]);\n    }, [])); // send unlock transaction\n\n    return Object(from["a" /* from */])(tokenNetworkContract.functions.unlock(action.payload.id, address, partner, locks)).pipe(assertTx(\'unlock\', ErrorCodes.CNL_ONCHAIN_UNLOCK_FAILED, {\n      log: log\n    }), Object(ignoreElements["a" /* ignoreElements */])(), Object(catchError["a" /* catchError */])(function (error) {\n      log.error(\'Error unlocking pending locks on-chain, ignoring\', error);\n      return empty["a" /* EMPTY */];\n    }));\n  }));\n};\n\nfunction checkPendingAction(action, provider, blockNumber, confirmationBlocks) {\n  return retryAsync$(function () {\n    return provider.getTransactionReceipt(action.payload.txHash);\n  }, provider.pollingInterval).pipe(Object(map["a" /* map */])(function (receipt) {\n    if ((receipt === null || receipt === void 0 ? void 0 : receipt.confirmations) !== undefined && receipt.confirmations >= confirmationBlocks) {\n      return Object.assign(Object.assign({}, action), {\n        // beyond setting confirmed, also re-set blockNumber,\n        // which may have changed on a reorg\n        payload: Object.assign(Object.assign({}, action.payload), {\n          txBlock: receipt.blockNumber,\n          confirmed: true\n        })\n      });\n    } else if (action.payload.txBlock + 2 * confirmationBlocks < blockNumber) {\n      // if this txs didn\'t get confirmed for more than 2*confirmationBlocks, it was removed\n      return Object.assign(Object.assign({}, action), {\n        payload: Object.assign(Object.assign({}, action.payload), {\n          confirmed: false\n        })\n      });\n    } // else, it seems removed, but give it twice confirmationBlocks to be picked up again\n\n  }), Object(filter["a" /* filter */])(isntNil));\n}\n/**\n * Process new blocks and re-emit confirmed or removed actions\n *\n * @param action$ - Observable of channelSettle actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps\n * @param deps.config$,deps.provider - RaidenEpicDeps members\n * @returns Observable of confirmed or removed actions\n */\n\n\nvar epics_confirmationEpic = function confirmationEpic(_ref60, state$, _ref61) {\n  epics_objectDestructuringEmpty(_ref60);\n\n  var config$ = _ref61.config$,\n      provider = _ref61.provider;\n  return Object(combineLatest["a" /* combineLatest */])(state$.pipe(pluckDistinct(\'blockNumber\')), state$.pipe(Object(pluck["a" /* pluck */])(\'pendingTxs\')), config$.pipe(pluckDistinct(\'confirmationBlocks\'))).pipe(Object(filter["a" /* filter */])(function (_ref62) {\n    var _ref63 = epics_slicedToArray(_ref62, 2),\n        pendingTxs = _ref63[1];\n\n    return pendingTxs.length > 0;\n  }), // exhaust will ignore blocks while concat$ is busy\n  Object(exhaustMap["a" /* exhaustMap */])(function (_ref64) {\n    var _ref65 = epics_slicedToArray(_ref64, 3),\n        blockNumber = _ref65[0],\n        pendingTxs = _ref65[1],\n        confirmationBlocks = _ref65[2];\n\n    return concat["a" /* concat */].apply(void 0, epics_toConsumableArray(pendingTxs // only txs/confirmable actions which are more than confirmationBlocks in the past\n    .filter(function (a) {\n      return a.payload.txBlock + confirmationBlocks <= blockNumber;\n    }).map(function (action) {\n      return checkPendingAction(action, provider, blockNumber, confirmationBlocks);\n    })));\n  }));\n};\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEvent.js\nvar fromEvent = __webpack_require__("6e77");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/toArray.js + 2 modules\nvar toArray = __webpack_require__("47ea");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/delay.js\nvar delay = __webpack_require__("bee6");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/repeatWhen.js\nvar repeatWhen = __webpack_require__("b4cc1");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeout.js + 2 modules\nvar timeout = __webpack_require__("d337");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js\nvar throwIfEmpty = __webpack_require__("b4d5");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/finalize.js\nvar finalize = __webpack_require__("d96a");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/delayWhen.js\nvar delayWhen = __webpack_require__("59b7");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/distinct.js\nvar distinct = __webpack_require__("a2ef");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/bufferTime.js\nvar bufferTime = __webpack_require__("6fb6");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/endWith.js\nvar endWith = __webpack_require__("de5c");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js\nvar mergeMapTo = __webpack_require__("8f41");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/dom/fetch.js\nvar fetch = __webpack_require__("2527");\n\n// EXTERNAL MODULE: ./node_modules/lodash/find.js\nvar find = __webpack_require__("2769");\nvar find_default = /*#__PURE__*/__webpack_require__.n(find);\n\n// EXTERNAL MODULE: ./node_modules/lodash/minBy.js\nvar minBy = __webpack_require__("80f6");\nvar minBy_default = /*#__PURE__*/__webpack_require__.n(minBy);\n\n// EXTERNAL MODULE: ./node_modules/lodash/curry.js\nvar curry = __webpack_require__("dc46");\nvar curry_default = /*#__PURE__*/__webpack_require__.n(curry);\n\n// EXTERNAL MODULE: ../raiden-ts/node_modules/matrix-js-sdk/lib/utils.js\nvar lib_utils = __webpack_require__("fc5d");\n\n// CONCATENATED MODULE: ../raiden-ts/dist/utils/matrix.js\n\n/**\n * Return server name without schema or path\n *\n * @param server - any URL\n * @returns server URL with domain and port (if present), without schema, paths or query params\n */\n\nfunction getServerName(server) {\n  var match = /^(?:\\w*:?\\/\\/)?([^/#?&]+)/.exec(server);\n  return match && match[1];\n}\n/**\n * MatrixClient doesn\'t expose this API, but it does exist, so we create it here\n *\n * @param matrix - an already setup and started MatrixClient\n * @param userId - to fetch status/presence from\n * @returns Promise to object containing status data\n */\n\nfunction getUserPresence(matrix, userId) {\n  var path = Object(lib_utils["encodeUri"])(\'/presence/$userId/status\', {\n    $userId: userId\n  });\n  return matrix._http.authedRequest(undefined, \'GET\', path);\n}\n// CONCATENATED MODULE: ../raiden-ts/dist/utils/lru.js\nfunction lru_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction lru_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction lru_createClass(Constructor, protoProps, staticProps) { if (protoProps) lru_defineProperties(Constructor.prototype, protoProps); if (staticProps) lru_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Simple Map-based LRU cache\n *\n * @param max - Maximum size of cache\n */\nvar LruCache = /*#__PURE__*/function () {\n  function LruCache(max) {\n    lru_classCallCheck(this, LruCache);\n\n    this.values = new Map();\n    this.max = max;\n  }\n\n  lru_createClass(LruCache, [{\n    key: "get",\n    value: function get(key) {\n      var entry = this.values.get(key);\n\n      if (entry) {\n        // peek the entry, re-insert for LRU strategy\n        this.values.delete(key);\n        this.values.set(key, entry);\n      }\n\n      return entry;\n    }\n  }, {\n    key: "put",\n    value: function put(key, value) {\n      if (this.values.size >= this.max) {\n        // least-recently used cache eviction strategy\n        var keyToDelete = this.values.keys().next().value;\n        this.values.delete(keyToDelete);\n      }\n\n      this.values.set(key, value);\n    }\n  }]);\n\n  return LruCache;\n}();\n// CONCATENATED MODULE: ../raiden-ts/dist/transport/epics.js\n\n\nfunction transport_epics_toConsumableArray(arr) { return transport_epics_arrayWithoutHoles(arr) || transport_epics_iterableToArray(arr) || transport_epics_unsupportedIterableToArray(arr) || transport_epics_nonIterableSpread(); }\n\nfunction transport_epics_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction transport_epics_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction transport_epics_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return transport_epics_arrayLikeToArray(arr); }\n\nfunction transport_epics_objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }\n\nfunction epics_createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = transport_epics_unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction transport_epics_slicedToArray(arr, i) { return transport_epics_arrayWithHoles(arr) || transport_epics_iterableToArrayLimit(arr, i) || transport_epics_unsupportedIterableToArray(arr, i) || transport_epics_nonIterableRest(); }\n\nfunction transport_epics_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction transport_epics_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return transport_epics_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return transport_epics_arrayLikeToArray(o, minLen); }\n\nfunction transport_epics_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction transport_epics_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction transport_epics_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar epics_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/camelcase */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n // unavailable just means the user didn\'t do anything over a certain amount of time, but they\'re\n// still there, so we consider the user as available/online then\n\nvar AVAILABLE = [\'online\', \'unavailable\'];\nvar userRe = /^@(0x[0-9a-f]{40})[.:]/i;\nvar DEVICE_ID = \'RAIDEN\';\n/**\n * Return the array of configured global rooms\n *\n * @param config - object to gather the list from\n * @returns Array of room names\n */\n\nfunction globalRoomNames(config) {\n  return [config.discoveryRoom, config.pfsRoom].filter(isntNil);\n}\n/**\n * Curried function (arity=2) which matches room passed as second argument based on roomId, name or\n * alias passed as first argument\n *\n * @param roomIdOrAlias - Room Id, name, canonical or normal alias for room\n * @param room - Room to test\n * @returns True if room matches term, false otherwise\n */\n\n\nvar roomMatch = curry_default()(function (roomIdOrAlias, room) {\n  return roomIdOrAlias === room.roomId || roomIdOrAlias === room.name || roomIdOrAlias === room.getCanonicalAlias() || room.getAliases().includes(roomIdOrAlias);\n});\n/**\n * Returns an observable to a (possibly pending) room matching roomId or some alias\n * This method doesn\'t try to join the room, just wait for it to show up in MatrixClient.\n *\n * @param matrix - Client instance to fetch room info from\n * @param roomIdOrAlias - room id or alias to look for\n * @returns Observable to populated room instance\n */\n\nfunction getRoom$(matrix, roomIdOrAlias) {\n  var room = matrix.getRoom(roomIdOrAlias);\n  if (!room) room = matrix.getRooms().find(roomMatch(roomIdOrAlias));\n  if (room) return Object(of["a" /* of */])(room);\n  return Object(fromEvent["a" /* fromEvent */])(matrix, \'Room\').pipe(Object(filter["a" /* filter */])(roomMatch(roomIdOrAlias)), Object(take["a" /* take */])(1));\n}\n/**\n * Joins the global broadcast rooms and returns the room ids.\n *\n * @param config - The {@link RaidenConfig} provides the broadcast room aliases for pfs and discovery.\n * @param matrix - The {@link MatrixClient} instance used to create the filter.\n * @returns Observable of the list of room ids for the the broadcast rooms.\n */\n\n\nfunction joinGlobalRooms(config, matrix) {\n  var serverName = getServerName(matrix.getHomeserverUrl());\n  return Object(from["a" /* from */])(globalRoomNames(config)).pipe(Object(map["a" /* map */])(function (globalRoom) {\n    return "#".concat(globalRoom, ":").concat(serverName);\n  }), Object(mergeMap["a" /* mergeMap */])(function (alias) {\n    return matrix.joinRoom(alias).then(function (room) {\n      // set alias in room state directly\n      // this trick is needed because global rooms aren\'t synced\n      room.currentState.setStateEvents([new browser_index["MatrixEvent"]({\n        type: \'m.room.aliases\',\n        state_key: serverName,\n        content: {\n          aliases: [alias]\n        },\n        event_id: "$local_".concat(Date.now()),\n        room_id: room.roomId,\n        sender: matrix.getUserId()\n      })]);\n      matrix.store.storeRoom(room);\n      return room;\n    });\n  }), Object(pluck["a" /* pluck */])(\'roomId\'), Object(toArray["a" /* toArray */])());\n}\n/**\n * Creates and returns a matrix filter. The filter reduces the size of the initial sync by\n * filtering out broadcast rooms, emphemeral messages like receipts etc.\n *\n * @param matrix - The {@link MatrixClient} instance used to create the filter.\n * @param roomIds - The ids of the rooms to filter out during sync.\n * @returns Observable of the {@link Filter} that was created.\n */\n\n\nfunction createFilter(matrix, roomIds) {\n  return Object(defer["a" /* defer */])(function () {\n    var roomFilter = {\n      not_rooms: roomIds,\n      ephemeral: {\n        not_types: [\'m.receipt\', \'m.typing\']\n      },\n      timeline: {\n        limit: 0,\n        not_senders: [matrix.getUserId()]\n      }\n    };\n    var filterDefinition = {\n      room: roomFilter\n    };\n    return matrix.createFilter(filterDefinition);\n  });\n}\n\nfunction startMatrixSync(action$, matrix, matrix$, config$) {\n  return action$.pipe(Object(filter["a" /* filter */])(matrixSetup.is), Object(take["a" /* take */])(1), Object(tap["a" /* tap */])(function () {\n    matrix$.next(matrix);\n    matrix$.complete();\n  }), Object(delay["a" /* delay */])(1e3), // wait 1s before starting matrix, so event listeners can be registered\n  Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(mergeMap["a" /* mergeMap */])(function (_ref) {\n    var _ref2 = transport_epics_slicedToArray(_ref, 2),\n        config = _ref2[1];\n\n    return joinGlobalRooms(config, matrix).pipe(Object(mergeMap["a" /* mergeMap */])(function (roomIds) {\n      return createFilter(matrix, roomIds);\n    }), Object(mergeMap["a" /* mergeMap */])(function (filter) {\n      return matrix.startClient({\n        filter: filter\n      });\n    }));\n  }), Object(ignoreElements["a" /* ignoreElements */])());\n}\n/**\n * Search user directory for valid users matching a given address and return latest\n *\n * @param matrix - Matrix client to search users from\n * @param address - Address of interest\n * @param log - Logger object\n * @returns Observable of user with most recent presence\n */\n\n\nfunction searchAddressPresence$(matrix, address, _ref3) {\n  var log = _ref3.log;\n  return Object(defer["a" /* defer */])(function () {\n    return (// search for any user containing the address of interest in its userId\n      matrix.searchUserDirectory({\n        term: address.toLowerCase()\n      })\n    );\n  }).pipe( // for every result matches, verify displayName signature is address of interest\n  Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee(_ref4) {\n    var results, _iterator, _step, user, match, recovered;\n\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            results = _ref4.results;\n            _iterator = epics_createForOfIteratorHelper(results);\n            _context.prev = 2;\n\n            _iterator.s();\n\n          case 4:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 24;\n              break;\n            }\n\n            user = _step.value;\n\n            if (user.display_name) {\n              _context.next = 8;\n              break;\n            }\n\n            return _context.abrupt("continue", 22);\n\n          case 8:\n            _context.prev = 8;\n            match = userRe.exec(user.user_id);\n\n            if (!(!match || Object(utils["getAddress"])(match[1]) !== address)) {\n              _context.next = 12;\n              break;\n            }\n\n            return _context.abrupt("continue", 22);\n\n          case 12:\n            recovered = Object(utils["verifyMessage"])(user.user_id, user.display_name);\n\n            if (!(!recovered || recovered !== address)) {\n              _context.next = 15;\n              break;\n            }\n\n            return _context.abrupt("continue", 22);\n\n          case 15:\n            _context.next = 20;\n            break;\n\n          case 17:\n            _context.prev = 17;\n            _context.t0 = _context["catch"](8);\n            return _context.abrupt("continue", 22);\n\n          case 20:\n            _context.next = 22;\n            return user;\n\n          case 22:\n            _context.next = 4;\n            break;\n\n          case 24:\n            _context.next = 29;\n            break;\n\n          case 26:\n            _context.prev = 26;\n            _context.t1 = _context["catch"](2);\n\n            _iterator.e(_context.t1);\n\n          case 29:\n            _context.prev = 29;\n\n            _iterator.f();\n\n            return _context.finish(29);\n\n          case 32:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[2, 26, 29, 32], [8, 17]]);\n  })), Object(mergeMap["a" /* mergeMap */])(function (user) {\n    return getUserPresence(matrix, user.user_id).then(function (presence) {\n      return Object.assign(Object.assign({}, presence), user);\n    }).catch(function (err) {\n      return log.info(\'Error fetching user presence, ignoring:\', err), undefined;\n    });\n  }), Object(filter["a" /* filter */])(isntNil), Object(toArray["a" /* toArray */])(), // for all matched/verified users, get its presence through dedicated API\n  // it\'s required because, as the user events could already have been handled\n  // and filtered out by matrixPresenceUpdateEpic because it wasn\'t yet a\n  // user-of-interest, we could have missed presence updates, then we need to\n  // fetch it here directly, and from now on, that other epic will monitor its\n  // updates, and sort by most recently seen user\n  Object(map["a" /* map */])(function (presences) {\n    if (!presences.length) throw new error_RaidenError(ErrorCodes.TRNS_NO_VALID_USER, {\n      address: address\n    });\n    return minBy_default()(presences, \'last_active_ago\');\n  }));\n}\n/**\n * Parse a caps string in the format \'k1,k2=v2,k3="v3"\' to { k1: true, k2: v2, k3: v3 } object\n *\n * @param caps - caps string\n * @returns Caps mapping object\n */\n\n\nfunction parseCaps(caps) {\n  var _a;\n\n  if (!caps) return;\n  var result = {};\n\n  try {\n    // this regex splits by comma, but respecting strings inside double-quotes\n    var _iterator2 = epics_createForOfIteratorHelper(caps.split(/,(?=(?:[^\\"]*\\"[^\\"]*\\")*[^\\"]*$)/g)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var cap = _step2.value;\n        var match = cap.match(/^\\s*([^=]+)(?: ?= ?"?(.*?)"?\\s*)?$/);\n        if (match) result[match[1]] = (_a = match[2]) !== null && _a !== void 0 ? _a : true;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return result;\n  } catch (err) {}\n}\n\nfunction stringifyCaps(caps) {\n  return Object.entries(caps).filter(function (_ref5) {\n    var _ref6 = transport_epics_slicedToArray(_ref5, 2),\n        v = _ref6[1];\n\n    return typeof v !== \'boolean\' || v;\n  }).map(function (_ref7) {\n    var _ref8 = transport_epics_slicedToArray(_ref7, 2),\n        k = _ref8[0],\n        v = _ref8[1];\n\n    return typeof v === \'boolean\' ? k : "".concat(k, "=\\"").concat(v, "\\"");\n  }).join(\',\');\n}\n/**\n * Returns an observable which keeps inviting userId to roomId while user doesn\'t join\n *\n * If user already joined, completes immediatelly.\n *\n * @param matrix - client instance\n * @param roomId - room to invite user to\n * @param userId - user to be invited\n * @param config$ - Observable of config object containing httpTimeout used as iteration delay\n * @returns Cold observable which keep inviting user if needed and then completes.\n */\n\n\nfunction inviteLoop$(matrix, roomId, userId, config$, _ref9) {\n  var log = _ref9.log;\n  return Object(defer["a" /* defer */])(function () {\n    var room = matrix.getRoom(roomId);\n    return room ? // use room already present in matrix instance\n    Object(of["a" /* of */])(room) : // wait for room\n    Object(fromEvent["a" /* fromEvent */])(matrix, \'Room\').pipe(Object(filter["a" /* filter */])(function (room) {\n      return room.roomId === roomId;\n    }), Object(take["a" /* take */])(1));\n  }).pipe( // stop if user already a room member\n  Object(filter["a" /* filter */])(function (room) {\n    var member = room.getMember(userId);\n    return !member || member.membership !== \'join\';\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(mergeMap["a" /* mergeMap */])(function (_ref10) {\n    var _ref11 = transport_epics_slicedToArray(_ref10, 2),\n        httpTimeout = _ref11[1].httpTimeout;\n\n    return (// defer here ensures invite is re-done on repeat (re-subscription)\n      Object(defer["a" /* defer */])(function () {\n        return matrix.invite(roomId, userId).catch(log.warn.bind(log, \'Error inviting\'));\n      }).pipe( // while shouldn\'t stop (by unsubscribe or takeUntil)\n      Object(repeatWhen["a" /* repeatWhen */])(function (completed$) {\n        return completed$.pipe(Object(delay["a" /* delay */])(httpTimeout));\n      }), Object(takeUntil["a" /* takeUntil */])( // stop repeat+defer loop above when user joins\n      Object(fromEvent["a" /* fromEvent */])(matrix, \'RoomMember.membership\', function (_ref12, member) {\n        transport_epics_objectDestructuringEmpty(_ref12);\n\n        return member;\n      }).pipe(Object(filter["a" /* filter */])(function (member) {\n        return member.roomId === roomId && member.userId === userId && member.membership === \'join\';\n      }))))\n    );\n  }));\n}\n/**\n * From a yaml list string, return as Array\n * E.g. yamlListToArray(`\n * # comment\n *   - test1\n *   - test2\n *   - test3\n * `) === [\'test1\', \'test2\', \'test3\']\n *\n * @param yml - String containing only YAML list\n * @returns List of strings inside yml-encoded text\n */\n\n\nfunction yamlListToArray(yml) {\n  // match all strings starting with optional spaces followed by a dash + space\n  // capturing only the content of the list item, trimming spaces\n  var reg = /^\\s*-\\s*(.+?)\\s*$/gm;\n  var results = [];\n  var match;\n\n  while (match = reg.exec(yml)) {\n    results.push(match[1]);\n  }\n\n  return results;\n}\n/**\n * Given a server name (schema defaults to https:// and is prepended if missing), returns HTTP GET\n * round trip time (time to response)\n *\n * @param server - Server name with or without schema\n * @param httpTimeout - Optional timeout for the HTTP request\n * @returns Promise to a { server, rtt } object, where `rtt` may be NaN\n */\n\n\nfunction matrixRTT$(server, httpTimeout) {\n  if (!server.includes(\'://\')) server = \'https://\' + server;\n  return Object(defer["a" /* defer */])(function () {\n    var start = Date.now();\n    return Object(fetch["a" /* fromFetch */])(server + \'/_matrix/client/versions\').pipe(Object(timeout["a" /* timeout */])(httpTimeout), Object(map["a" /* map */])(function (_ref13) {\n      var ok = _ref13.ok;\n      return ok ? Date.now() : NaN;\n    }), Object(catchError["a" /* catchError */])(function () {\n      return Object(of["a" /* of */])(NaN);\n    }), Object(map["a" /* map */])(function (end) {\n      return {\n        server: server,\n        rtt: end - start\n      };\n    }));\n  });\n}\n/**\n * Returns an observable of servers, sorted by response time\n *\n * @param matrixServerLookup - URL containing an YAML list of servers url\n * @param httpTimeout - httpTimeout to limit queries\n * @returns Observable of { server, rtt } objects, emitted in increasing rtt order\n */\n\n\nfunction fetchSortedMatrixServers$(matrixServerLookup, httpTimeout) {\n  var _this = this;\n\n  return Object(fetch["a" /* fromFetch */])(matrixServerLookup).pipe(Object(mergeMap["a" /* mergeMap */])(function (response) {\n    return epics_awaiter(_this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee2() {\n      return regenerator_default.a.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              assert(response.ok, "Could not fetch server list from \\"".concat(matrixServerLookup, "\\" => ").concat(response.status));\n              return _context2.abrupt("return", response.text());\n\n            case 2:\n            case "end":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n  }), Object(timeout["a" /* timeout */])(httpTimeout), Object(mergeMap["a" /* mergeMap */])(function (text) {\n    return yamlListToArray(text);\n  }), Object(mergeMap["a" /* mergeMap */])(function (server) {\n    return matrixRTT$(server, httpTimeout);\n  }), Object(toArray["a" /* toArray */])(), Object(mergeMap["a" /* mergeMap */])(function (rtts) {\n    return sortBy_default()(rtts, [\'rtt\']);\n  }), Object(filter["a" /* filter */])(function (_ref14) {\n    var rtt = _ref14.rtt;\n    return !isNaN(rtt);\n  }), Object(throwIfEmpty["a" /* throwIfEmpty */])(function () {\n    return new error_RaidenError(ErrorCodes.TRNS_NO_MATRIX_SERVERS);\n  }));\n}\n/**\n * Validate and setup a MatrixClient connected to server, possibly using previous \'setup\' data\n * May error if anything goes wrong.\n *\n * @param server - server URL, with schema\n * @param setup - optional previous setup/credentials data\n * @param deps - RaidenEpicDeps-like/partial object\n * @param deps.address - Our address (to compose matrix user)\n * @param deps.signer - Signer to be used to sign password and displayName\n * @param caps - Transport capabilities to set in user\'s avatar_url\n * @returns Observable of one { matrix, server, setup } object\n */\n\n\nfunction setupMatrixClient$(server, setup, _ref15, caps) {\n  var address = _ref15.address,\n      signer = _ref15.signer;\n  var serverName = getServerName(server);\n  if (!serverName) throw new error_RaidenError(ErrorCodes.TRNS_NO_SERVERNAME, {\n    server: server\n  });\n  return Object(defer["a" /* defer */])(function () {\n    if (setup) {\n      // if matrixSetup was already issued before, and credentials are already in state\n      var matrix = Object(browser_index["createClient"])({\n        baseUrl: server,\n        userId: setup.userId,\n        accessToken: setup.accessToken,\n        deviceId: setup.deviceId\n      });\n      return Object(of["a" /* of */])({\n        matrix: matrix,\n        server: server,\n        setup: setup\n      });\n    } else {\n      var _matrix = Object(browser_index["createClient"])({\n        baseUrl: server\n      });\n\n      var userName = address.toLowerCase(),\n          userId = "@".concat(userName, ":").concat(serverName); // create password as signature of serverName, then try login or register\n\n      return Object(from["a" /* from */])(signer.signMessage(serverName)).pipe(Object(mergeMap["a" /* mergeMap */])(function (password) {\n        return Object(from["a" /* from */])(_matrix.login(\'m.login.password\', {\n          user: userName,\n          password: password,\n          device_id: DEVICE_ID\n        })).pipe(Object(catchError["a" /* catchError */])(function () {\n          return _matrix.register(userName, password);\n        }));\n      }), Object(mergeMap["a" /* mergeMap */])(function (_ref16) {\n        var access_token = _ref16.access_token,\n            device_id = _ref16.device_id;\n        // matrix.register implementation doesn\'t set returned credentials\n        // which would require an unnecessary additional login request if we didn\'t\n        // set it here, and login doesn\'t set deviceId, so we set all credential\n        // parameters again here after successful login or register\n        _matrix.deviceId = device_id;\n        _matrix._http.opts.accessToken = access_token;\n        _matrix.credentials = {\n          userId: userId\n        }; // displayName must be signature of full userId for our messages to be accepted\n\n        return Object(from["a" /* from */])(signer.signMessage(userId)).pipe(Object(map["a" /* map */])(function (signedUserId) {\n          return {\n            matrix: _matrix,\n            server: server,\n            setup: {\n              userId: userId,\n              accessToken: access_token,\n              deviceId: device_id,\n              displayName: signedUserId\n            }\n          };\n        }));\n      }));\n    }\n  }).pipe( // the APIs below are authenticated, and therefore also act as validator\n  Object(mergeMap["a" /* mergeMap */])(function (_ref17) {\n    var matrix = _ref17.matrix,\n        server = _ref17.server,\n        setup = _ref17.setup;\n    return (// ensure displayName is set even on restarts\n      Object(merge["a" /* merge */])(Object(from["a" /* from */])(matrix.setDisplayName(setup.displayName)), Object(from["a" /* from */])(matrix.setPresence({\n        presence: \'online\',\n        status_msg: \'\'\n      })), caps ? Object(from["a" /* from */])(matrix.setAvatarUrl(stringifyCaps(caps))) : empty["a" /* EMPTY */]).pipe(Object(mapTo["a" /* mapTo */])({\n        matrix: matrix,\n        server: server,\n        setup: setup\n      }))\n    );\n  }));\n}\n/**\n * Initialize matrix transport\n * The matrix client instance will be outputed to RaidenEpicDeps.matrix$ AsyncSubject\n * The setup info (including credentials, for persistence) will be the matrixSetup output action\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param address,network,signer,matrix$ - RaidenEpicDeps members\n * @returns Observable of matrixSetup generated by initializing matrix client\n */\n\n\nvar epics_initMatrixEpic = function initMatrixEpic(action$, _ref18, _ref19) {\n  transport_epics_objectDestructuringEmpty(_ref18);\n\n  var address = _ref19.address,\n      signer = _ref19.signer,\n      matrix$ = _ref19.matrix$,\n      latest$ = _ref19.latest$,\n      config$ = _ref19.config$;\n  return Object(combineLatest["a" /* combineLatest */])([latest$.pipe(Object(pluck["a" /* pluck */])(\'state\')), config$]).pipe(Object(first["a" /* first */])(), // at startup\n  Object(mergeMap["a" /* mergeMap */])(function (_ref20) {\n    var _ref21 = transport_epics_slicedToArray(_ref20, 2),\n        state = _ref21[0],\n        _ref21$ = _ref21[1],\n        matrixServer = _ref21$.matrixServer,\n        matrixServerLookup = _ref21$.matrixServerLookup,\n        httpTimeout = _ref21$.httpTimeout,\n        caps = _ref21$.caps;\n\n    var _a, _b;\n\n    var server = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.server,\n        setup = (_b = state.transport.matrix) === null || _b === void 0 ? void 0 : _b.setup;\n    var servers$Array = [];\n\n    if (matrixServer) {\n      // if config.matrixServer is set, we must use it (possibly re-using stored credentials,\n      // if matching), not fetch from lookup address\n      if (matrixServer === server) servers$Array.push(Object(of["a" /* of */])({\n        server: server,\n        setup: setup\n      }));else servers$Array.push(Object(of["a" /* of */])({\n        server: matrixServer\n      }));\n    } else {\n      // previously used server\n      if (server) servers$Array.push(Object(of["a" /* of */])({\n        server: server,\n        setup: setup\n      })); // fetched servers list\n      // notice it may include stored server again, but no stored setup, which could be the\n      // cause of the  first failure, so we allow it to try again (not necessarily first)\n\n      servers$Array.push(fetchSortedMatrixServers$(matrixServerLookup, httpTimeout));\n    }\n\n    var lastError;\n\n    var andSuppress = function andSuppress(err) {\n      return lastError = err, empty["a" /* EMPTY */];\n    }; // on [re-]subscription (defer), pops next observable and subscribe to it\n\n\n    return Object(defer["a" /* defer */])(function () {\n      return servers$Array.shift() || empty["a" /* EMPTY */];\n    }).pipe(Object(catchError["a" /* catchError */])(andSuppress), // servers$ may error, so store lastError\n    Object(concatMap["a" /* concatMap */])(function (_ref22) {\n      var server = _ref22.server,\n          setup = _ref22.setup;\n      return (// serially, try setting up client and validate its credential\n        setupMatrixClient$(server, setup, {\n          address: address,\n          signer: signer\n        }, caps).pipe( // store and suppress any \'setupMatrixClient$\' error\n        Object(catchError["a" /* catchError */])(andSuppress))\n      );\n    }), // on first setupMatrixClient$\'s success, emit, complete and unsubscribe\n    Object(first["a" /* first */])(), Object(tap["a" /* tap */])(function (_ref23) {\n      var matrix = _ref23.matrix;\n      return matrix.setMaxListeners(30);\n    }), // with errors suppressed, only possible error here is \'no element in sequence\'\n    Object(retryWhen["a" /* retryWhen */])(function (err$) {\n      return (// if there\'re more servers$ observables in queue, emit once to retry from defer;\n        // else, errors output with lastError to unsubscribe\n        err$.pipe(Object(mergeMap["a" /* mergeMap */])(function () {\n          return servers$Array.length ? Object(of["a" /* of */])(null) : Object(throwError["a" /* throwError */])(lastError);\n        }))\n      );\n    }));\n  }), // on success\n  Object(mergeMap["a" /* mergeMap */])(function (_ref24) {\n    var matrix = _ref24.matrix,\n        server = _ref24.server,\n        setup = _ref24.setup;\n    return Object(merge["a" /* merge */])( // wait for matrixSetup through reducer, then resolves matrix$ with client and starts it\n    startMatrixSync(action$, matrix, matrix$, config$), // emit matrixSetup in parallel to be persisted in state\n    Object(of["a" /* of */])(matrixSetup({\n      server: server,\n      setup: setup\n    })), // monitor config.logger & disable or re-enable matrix\'s logger accordingly\n    config$.pipe(pluckDistinct(\'logger\'), Object(tap["a" /* tap */])(function (logger) {\n      return lib_logger["logger"].setLevel(logger || \'silent\', false);\n    }), Object(ignoreElements["a" /* ignoreElements */])()));\n  }));\n};\n/**\n * Calls matrix.stopClient when raiden is shutting down, i.e. action$ completes\n *\n * @param action$ - Observable of matrixSetup actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Empty observable (whole side-effect on matrix instance)\n */\n\nvar epics_matrixShutdownEpic = function matrixShutdownEpic(action$, _ref25, _ref26) {\n  transport_epics_objectDestructuringEmpty(_ref25);\n\n  var matrix$ = _ref26.matrix$;\n  return matrix$.pipe(Object(mergeMap["a" /* mergeMap */])(function (matrix) {\n    return action$.pipe(Object(finalize["a" /* finalize */])(function () {\n      matrix.setPresence({\n        presence: \'offline\',\n        status_msg: \'\'\n      }).catch(function () {\n        /* stopping, ignore exceptions */\n      });\n      matrix.stopClient();\n    }));\n  }), Object(ignoreElements["a" /* ignoreElements */])());\n};\n/**\n * Handles MatrixRequestMonitorPresenceAction and emits a MatrixPresenceUpdateAction\n * If presence is already known, emits it, else fetch from user profile\n * Even if the presence stays the same, we emit a MatrixPresenceUpdateAction, as this may be a\n * request being waited by a promise or something like that\n * IOW: every request should be followed by a presence update or a failed action, but presence\n * updates may happen later without new requests (e.g. when the user goes offline)\n *\n * @param action$ - Observable of matrixPresence.request actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of presence updates or fail action\n */\n\nvar epics_matrixMonitorPresenceEpic = function matrixMonitorPresenceEpic(action$, _ref27, _ref28) {\n  transport_epics_objectDestructuringEmpty(_ref27);\n\n  var matrix$ = _ref28.matrix$,\n      latest$ = _ref28.latest$,\n      log = _ref28.log;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(matrixPresence.request)), // this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value\n  Object(mergeMap["a" /* mergeMap */])(function (action) {\n    return matrix$.pipe(Object(map["a" /* map */])(function (matrix) {\n      return {\n        action: action,\n        matrix: matrix\n      };\n    }));\n  }), Object(groupBy["a" /* groupBy */])(function (_ref29) {\n    var action = _ref29.action;\n    return action.meta.address;\n  }), Object(mergeMap["a" /* mergeMap */])(function (grouped$) {\n    return grouped$.pipe(Object(withLatestFrom["a" /* withLatestFrom */])(latest$.pipe(pluckDistinct(\'presences\'))), // if we\'re already fetching presence for this address, no need to fetch again\n    Object(exhaustMap["a" /* exhaustMap */])(function (_ref30) {\n      var _ref31 = transport_epics_slicedToArray(_ref30, 2),\n          _ref31$ = _ref31[0],\n          action = _ref31$.action,\n          matrix = _ref31$.matrix,\n          presences = _ref31[1];\n\n      return action.meta.address in presences ? // we already monitored/saw this user\'s presence\n      Object(of["a" /* of */])(presences[action.meta.address]) : searchAddressPresence$(matrix, action.meta.address, {\n        log: log\n      }).pipe(Object(map["a" /* map */])(function (_ref32) {\n        var presence = _ref32.presence,\n            userId = _ref32.user_id,\n            avatar_url = _ref32.avatar_url;\n        return matrixPresence.success({\n          userId: userId,\n          available: AVAILABLE.includes(presence),\n          ts: Date.now(),\n          caps: parseCaps(avatar_url)\n        }, action.meta);\n      }), Object(catchError["a" /* catchError */])(function (err) {\n        return Object(of["a" /* of */])(matrixPresence.failure(err, action.meta));\n      }));\n    }));\n  }));\n};\n/**\n * Monitor peers matrix presence from User.presence events\n * We aggregate all users of interest (i.e. for which a monitor request was emitted at some point)\n * and emit presence updates for any presence change happening to a user validating to this address\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of presence updates\n */\n\nvar epics_matrixPresenceUpdateEpic = function matrixPresenceUpdateEpic(action$, _ref33, _ref34) {\n  transport_epics_objectDestructuringEmpty(_ref33);\n\n  var log = _ref34.log,\n      matrix$ = _ref34.matrix$,\n      latest$ = _ref34.latest$;\n  return matrix$.pipe( // when matrix finishes initialization, register to matrix presence events\n  Object(switchMap["a" /* switchMap */])(function (matrix) {\n    return (// matrix\'s \'User.presence\' sometimes fail to fire, but generic \'event\' is always fired,\n      // and User (retrieved via matrix.getUser) is up-to-date before \'event\' emits\n      Object(fromEvent["a" /* fromEvent */])(matrix, \'event\').pipe(Object(map["a" /* map */])(function (event) {\n        return {\n          event: event,\n          matrix: matrix\n        };\n      }))\n    );\n  }), Object(filter["a" /* filter */])(function (_ref35) {\n    var event = _ref35.event;\n    return event.getType() === \'m.presence\';\n  }), // parse peer address from userId\n  Object(map["a" /* map */])(function (_ref36) {\n    var event = _ref36.event,\n        matrix = _ref36.matrix;\n    // as \'event\' is emitted after user is (created and) updated, getUser always returns it\n    var user = matrix.getUser(event.getSender());\n    if (!user || !user.presence) return;\n    var match = userRe.exec(user.userId),\n        peerAddress = match && match[1];\n    if (!peerAddress) return; // getAddress will convert any valid address into checksummed-format\n\n    var address = Object(utils["getAddress"])(peerAddress);\n    if (!address) return;\n    return {\n      matrix: matrix,\n      user: user,\n      address: address\n    };\n  }), // filter out events without userId in the right format (startWith hex-address)\n  Object(filter["a" /* filter */])(isntNil), Object(withLatestFrom["a" /* withLatestFrom */])( // observable of all addresses whose presence monitoring was requested since init\n  action$.pipe(Object(filter["a" /* filter */])(isActionOf(matrixPresence.request)), Object(scan["a" /* scan */])(function (toMonitor, request) {\n    return toMonitor.add(request.meta.address);\n  }, new Set()), Object(startWith["a" /* startWith */])(new Set())), // known presences as { address: <last seen MatrixPresenceUpdateAction> } mapping\n  latest$.pipe(pluckDistinct(\'presences\'))), // filter out events from users we don\'t care about\n  // i.e.: presence monitoring never requested\n  Object(filter["a" /* filter */])(function (_ref37) {\n    var _ref38 = transport_epics_slicedToArray(_ref37, 2),\n        address = _ref38[0].address,\n        toMonitor = _ref38[1];\n\n    return toMonitor.has(address);\n  }), Object(mergeMap["a" /* mergeMap */])(function (_ref39) {\n    var _ref40 = transport_epics_slicedToArray(_ref39, 3),\n        _ref40$ = _ref40[0],\n        matrix = _ref40$.matrix,\n        user = _ref40$.user,\n        address = _ref40$.address,\n        presences = _ref40[2];\n\n    // first filter can\'t tell typescript this property will always be set!\n    var userId = user.userId,\n        presence = user.presence,\n        available = AVAILABLE.includes(presence);\n    if (address in presences && presences[address].payload.userId === userId && presences[address].payload.available === available) // even if signature verification passes, this wouldn\'t change presence, so return early\n      return empty["a" /* EMPTY */]; // fetch profile info if user have no valid displayName set\n\n    var profile$ = Signature.is(user.displayName) ? Object(of["a" /* of */])({\n      displayname: user.displayName,\n      avatar_url: user.avatarUrl\n    }) : Object(defer["a" /* defer */])(function () {\n      return matrix.getProfileInfo(userId);\n    });\n    return profile$.pipe(Object(map["a" /* map */])(function (profile) {\n      var _a; // errors raised here will be logged and ignored on catchError below\n\n\n      assert(profile === null || profile === void 0 ? void 0 : profile.displayname, \'no displayname\'); // ecrecover address, validating displayName is the signature of the userId\n\n      var recovered = Object(utils["verifyMessage"])(userId, profile.displayname);\n      assert(recovered === address, "invalid displayname signature: ".concat(recovered, " !== ").concat(address));\n      return matrixPresence.success({\n        userId: userId,\n        available: available,\n        ts: (_a = user.lastPresenceTs) !== null && _a !== void 0 ? _a : Date.now(),\n        caps: parseCaps(profile.avatar_url)\n      }, {\n        address: recovered\n      });\n    }), Object(catchError["a" /* catchError */])(function (err) {\n      return log.debug(\'Error validating presence event, ignoring\', err), empty["a" /* EMPTY */];\n    }));\n  })).pipe(Object(withLatestFrom["a" /* withLatestFrom */])(latest$), // filter out if presence update is to offline, and address became online in another user\n  Object(filter["a" /* filter */])(function (_ref41) {\n    var _ref42 = transport_epics_slicedToArray(_ref41, 2),\n        action = _ref42[0],\n        presences = _ref42[1].presences;\n\n    return action.payload.available || !(action.meta.address in presences) || !presences[action.meta.address].payload.available || action.payload.userId === presences[action.meta.address].payload.userId;\n  }), Object(pluck["a" /* pluck */])(0));\n};\n/**\n * Create room (if needed) for a transfer\'s target, channel\'s partner or, as a fallback, for any\n * recipient of a messageSend.request action\n *\n * @param action$ - Observable of transferSigned|channelMonitor|messageSend.request actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of matrixRoom actions\n */\n\nvar epics_matrixCreateRoomEpic = function matrixCreateRoomEpic(action$, _ref43, _ref44) {\n  transport_epics_objectDestructuringEmpty(_ref43);\n\n  var log = _ref44.log,\n      matrix$ = _ref44.matrix$,\n      latest$ = _ref44.latest$;\n  return (// actual output observable, selects addresses of interest from actions\n    action$.pipe( // ensure there\'s a room for address of interest for each of these actions\n    // matrixRoomLeave ensures a new room is created if all we had are forgotten/left\n    Object(filter["a" /* filter */])(isActionOf([transferSigned, channelMonitor, messageSend.request, matrixRoomLeave])), Object(map["a" /* map */])(function (action) {\n      return isActionOf(transferSigned, action) ? action.payload.message.target : isActionOf(channelMonitor, action) ? action.meta.partner : action.meta.address;\n    }), // groupby+mergeMap ensures different addresses are processed in parallel, and also\n    // prevents one stuck address observable (e.g. presence delayed) from holding whole queue\n    Object(groupBy["a" /* groupBy */])(function (address) {\n      return address;\n    }), Object(mergeMap["a" /* mergeMap */])(function (grouped$) {\n      return grouped$.pipe( // this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value\n      Object(mergeMap["a" /* mergeMap */])(function (address) {\n        return matrix$.pipe(Object(map["a" /* map */])(function (matrix) {\n          return {\n            address: address,\n            matrix: matrix\n          };\n        }));\n      }), // exhaustMap is used to prevent bursts of actions for a given address (eg. on startup)\n      // of creating multiple rooms for same address, so we ignore new address items while\n      // previous is being processed. If user roams, matrixInviteEpic will re-invite\n      Object(exhaustMap["a" /* exhaustMap */])(function (_ref45) {\n        var address = _ref45.address,\n            matrix = _ref45.matrix;\n        return (// presencesStateReplay$+take(1) acts like withLatestFrom with cached result\n          latest$.pipe( // wait for user to be monitored\n          Object(filter["a" /* filter */])(function (_ref46) {\n            var presences = _ref46.presences;\n            return address in presences;\n          }), Object(take["a" /* take */])(1), // if there\'s already a room in state for address, skip\n          Object(filter["a" /* filter */])(function (_ref47) {\n            var state = _ref47.state;\n\n            var _a, _b, _c;\n\n            return !((_c = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) === null || _b === void 0 ? void 0 : _b[address]) === null || _c === void 0 ? void 0 : _c[0]);\n          }), // else, create a room, invite known user and persist roomId in state\n          Object(mergeMap["a" /* mergeMap */])(function (_ref48) {\n            var presences = _ref48.presences;\n            return matrix.createRoom({\n              visibility: \'private\',\n              invite: [presences[address].payload.userId]\n            });\n          }), Object(map["a" /* map */])(function (_ref49) {\n            var roomId = _ref49.room_id;\n            return matrixRoom({\n              roomId: roomId\n            }, {\n              address: address\n            });\n          }), Object(catchError["a" /* catchError */])(function (err) {\n            return log.error(\'Error creating room, ignoring\', err), empty["a" /* EMPTY */];\n          }))\n        );\n      }));\n    }))\n  );\n};\n/**\n * Invites users coming online to main room we may have with them\n *\n * This also keeps retrying inviting every config.httpTimeout (default=30s) while user doesn\'t\n * accept our invite or don\'t invite or write to us to/in another room.\n *\n * @param action$ - Observable of matrixPresence.success actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps\n * @param deps.matrix$ - MatrixClient AsyncSubject\n * @param deps.config$ - RaidenConfig BehaviorSubject\n * @returns Empty observable (whole side-effect on matrix instance)\n */\n\nvar epics_matrixInviteEpic = function matrixInviteEpic(action$, _ref50, _ref51) {\n  transport_epics_objectDestructuringEmpty(_ref50);\n\n  var matrix$ = _ref51.matrix$,\n      config$ = _ref51.config$,\n      latest$ = _ref51.latest$,\n      log = _ref51.log;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(matrixPresence.success)), Object(groupBy["a" /* groupBy */])(function (a) {\n    return a.meta.address;\n  }), Object(mergeMap["a" /* mergeMap */])(function (grouped$) {\n    return (// grouped$ is one observable of presence actions per partners address\n      grouped$.pipe( // action comes only after matrix$ is started, so it\'s safe to use withLatestFrom\n      Object(withLatestFrom["a" /* withLatestFrom */])(matrix$), // switchMap on new presence action for address\n      Object(switchMap["a" /* switchMap */])(function (_ref52) {\n        var _ref53 = transport_epics_slicedToArray(_ref52, 2),\n            action = _ref53[0],\n            matrix = _ref53[1];\n\n        return (// if not available, do nothing (and unsubscribe from previous observable)\n          !action.payload.available ? empty["a" /* EMPTY */] : latest$.pipe(Object(map["a" /* map */])(function (_ref54) {\n            var state = _ref54.state;\n\n            var _a, _b, _c;\n\n            return (_c = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) === null || _b === void 0 ? void 0 : _b[action.meta.address]) === null || _c === void 0 ? void 0 : _c[0];\n          }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])(), Object(switchMap["a" /* switchMap */])(function (roomId) {\n            return Object(concat["a" /* concat */])(Object(of["a" /* of */])(roomId), !roomId ? empty["a" /* EMPTY */] : // re-trigger invite loop if user leaves\n            Object(fromEvent["a" /* fromEvent */])(matrix, \'RoomMember.membership\', function (_ref55, member) {\n              transport_epics_objectDestructuringEmpty(_ref55);\n\n              return member;\n            }).pipe(Object(filter["a" /* filter */])(function (member) {\n              return member.roomId === roomId && member.userId === action.payload.userId && member.membership === \'leave\';\n            }), Object(mapTo["a" /* mapTo */])(roomId)));\n          }), // switchMap on main roomId change\n          Object(switchMap["a" /* switchMap */])(function (roomId) {\n            return !roomId ? // if roomId not set, do nothing and unsubscribe\n            empty["a" /* EMPTY */] : // while subscribed and user didn\'t join, invite every httpTimeout=30s\n            inviteLoop$(matrix, roomId, action.payload.userId, config$, {\n              log: log\n            });\n          }))\n        );\n      }))\n    );\n  }), Object(ignoreElements["a" /* ignoreElements */])());\n};\n/**\n * Handle invites sent to us and accepts them iff sent by a monitored user\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of matrixRoom actions\n */\n\nvar epics_matrixHandleInvitesEpic = function matrixHandleInvitesEpic(_ref56, _ref57, _ref58) {\n  transport_epics_objectDestructuringEmpty(_ref56);\n\n  transport_epics_objectDestructuringEmpty(_ref57);\n\n  var log = _ref58.log,\n      matrix$ = _ref58.matrix$,\n      config$ = _ref58.config$,\n      latest$ = _ref58.latest$;\n  return matrix$.pipe( // when matrix finishes initialization, register to matrix invite events\n  Object(switchMap["a" /* switchMap */])(function (matrix) {\n    return Object(fromEvent["a" /* fromEvent */])(matrix, \'RoomMember.membership\', function (event, member) {\n      return {\n        event: event,\n        member: member,\n        matrix: matrix\n      };\n    });\n  }), Object(filter["a" /* filter */])( // filter for invite events to us\n  function (_ref59) {\n    var member = _ref59.member,\n        matrix = _ref59.matrix;\n    return member.userId === matrix.getUserId() && member.membership === \'invite\';\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(mergeMap["a" /* mergeMap */])(function (_ref60) {\n    var _ref61 = transport_epics_slicedToArray(_ref60, 2),\n        _ref61$ = _ref61[0],\n        event = _ref61$.event,\n        member = _ref61$.member,\n        matrix = _ref61$.matrix,\n        httpTimeout = _ref61[1].httpTimeout;\n\n    var sender = event.getSender(),\n        senderPresence$ = latest$.pipe(pluckDistinct(\'presences\'), Object(map["a" /* map */])(function (presences) {\n      return find_default()(presences, function (p) {\n        return p.payload.userId === sender;\n      });\n    }), Object(filter["a" /* filter */])(isntNil), Object(take["a" /* take */])(1), // Don\'t wait more than some arbitrary time for this sender presence update to show\n    // up; completes without emitting anything otherwise, ending this pipeline.\n    // This also works as a filter to continue processing invites only for monitored\n    // users, as it\'ll complete without emitting if no MatrixPresenceUpdateAction is\n    // found for sender in time\n    Object(takeUntil["a" /* takeUntil */])(Object(timer["a" /* timer */])(httpTimeout)));\n    return senderPresence$.pipe(Object(map["a" /* map */])(function (senderPresence) {\n      return {\n        matrix: matrix,\n        member: member,\n        senderPresence: senderPresence\n      };\n    }));\n  }), Object(mergeMap["a" /* mergeMap */])(function (_ref62) {\n    var matrix = _ref62.matrix,\n        member = _ref62.member,\n        senderPresence = _ref62.senderPresence;\n    return (// join room and emit MatrixRoomAction to make it default/first option for sender address\n      Object(from["a" /* from */])(matrix.joinRoom(member.roomId, {\n        syncRoom: true\n      })).pipe(Object(mapTo["a" /* mapTo */])(matrixRoom({\n        roomId: member.roomId\n      }, {\n        address: senderPresence.meta.address\n      })), Object(catchError["a" /* catchError */])(function (err) {\n        return log.error(\'Error joining invited room, ignoring\', err), empty["a" /* EMPTY */];\n      }))\n    );\n  }));\n};\n/**\n * Leave any excess room for a partner when creating or joining a new one.\n * Excess rooms are LRU beyond a given threshold (configurable, default=3) in address\'s rooms\n * queue and are checked (only) when a new one is added to it.\n *\n * @param action$ - Observable of matrixRoom actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of matrixRoomLeave actions\n */\n\nvar epics_matrixLeaveExcessRoomsEpic = function matrixLeaveExcessRoomsEpic(action$, state$, _ref63) {\n  var log = _ref63.log,\n      matrix$ = _ref63.matrix$,\n      config$ = _ref63.config$;\n  return action$.pipe( // act whenever a new room is added to the address queue in state\n  Object(filter["a" /* filter */])(isActionOf(matrixRoom)), // this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value\n  Object(mergeMap["a" /* mergeMap */])(function (action) {\n    return matrix$.pipe(Object(map["a" /* map */])(function (matrix) {\n      return {\n        action: action,\n        matrix: matrix\n      };\n    }));\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(state$, config$), Object(mergeMap["a" /* mergeMap */])(function (_ref64) {\n    var _ref65 = transport_epics_slicedToArray(_ref64, 3),\n        _ref65$ = _ref65[0],\n        action = _ref65$.action,\n        matrix = _ref65$.matrix,\n        state = _ref65[1],\n        matrixExcessRooms = _ref65[2].matrixExcessRooms;\n\n    var _a, _b, _c;\n\n    var rooms = (_c = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) === null || _b === void 0 ? void 0 : _b[action.meta.address]) !== null && _c !== void 0 ? _c : [];\n    return Object(from["a" /* from */])(rooms.filter(function (_ref66, i) {\n      transport_epics_objectDestructuringEmpty(_ref66);\n\n      return i >= matrixExcessRooms;\n    })).pipe(Object(mergeMap["a" /* mergeMap */])(function (roomId) {\n      return matrix.leave(roomId).catch(function (err) {\n        return log.error(\'Error leaving excess room, ignoring\', err);\n      }).then(function () {\n        return roomId;\n      });\n    }), Object(map["a" /* map */])(function (roomId) {\n      return matrixRoomLeave({\n        roomId: roomId\n      }, action.meta);\n    }));\n  }));\n};\n/**\n * Leave any room which is neither global nor known as a room for some user of interest\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Empty observable (whole side-effect on matrix instance)\n */\n\nvar epics_matrixLeaveUnknownRoomsEpic = function matrixLeaveUnknownRoomsEpic(_ref67, state$, _ref68) {\n  transport_epics_objectDestructuringEmpty(_ref67);\n\n  var log = _ref68.log,\n      matrix$ = _ref68.matrix$,\n      config$ = _ref68.config$;\n  return matrix$.pipe( // when matrix finishes initialization, register to matrix Room events\n  Object(switchMap["a" /* switchMap */])(function (matrix) {\n    return Object(fromEvent["a" /* fromEvent */])(matrix, \'Room\').pipe(Object(map["a" /* map */])(function (room) {\n      return {\n        matrix: matrix,\n        roomId: room.roomId\n      };\n    }));\n  }), // this room may become known later for some reason, so wait a little\n  Object(delayWhen["a" /* delayWhen */])(function () {\n    return config$.pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])(function (_ref69) {\n      var httpTimeout = _ref69.httpTimeout;\n      return Object(timer["a" /* timer */])(httpTimeout);\n    }));\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(state$, config$), // filter for leave events to us\n  Object(filter["a" /* filter */])(function (_ref70) {\n    var _ref71 = transport_epics_slicedToArray(_ref70, 3),\n        _ref71$ = _ref71[0],\n        matrix = _ref71$.matrix,\n        roomId = _ref71$.roomId,\n        state = _ref71[1],\n        config = _ref71[2];\n\n    var _a, _b;\n\n    var room = matrix.getRoom(roomId);\n    if (!room) return false; // room already gone while waiting\n\n    var globalRooms = globalRoomNames(config);\n    if (room.name && globalRooms.some(function (g) {\n      return room.name.match("#".concat(g, ":"));\n    })) return false;\n    var rooms = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) !== null && _b !== void 0 ? _b : {};\n\n    for (var address in rooms) {\n      var _iterator3 = epics_createForOfIteratorHelper(rooms[address]),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _roomId = _step3.value;\n          if (_roomId === room.roomId) return false;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n\n    return true;\n  }), Object(mergeMap["a" /* mergeMap */])(function (_ref72) {\n    var _ref73 = transport_epics_slicedToArray(_ref72, 1),\n        _ref73$ = _ref73[0],\n        matrix = _ref73$.matrix,\n        roomId = _ref73$.roomId;\n\n    return epics_awaiter(void 0, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee3() {\n      return regenerator_default.a.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              log.warn(\'Unknown room in matrix, leaving\', roomId);\n              return _context3.abrupt("return", matrix.leave(roomId).catch(function (err) {\n                return log.error(\'Error leaving unknown room, ignoring\', err);\n              }));\n\n            case 2:\n            case "end":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n  }), Object(ignoreElements["a" /* ignoreElements */])());\n};\n/**\n * If we leave a room for any reason (eg. a kick event), purge it from state\n * Notice excess rooms left by matrixLeaveExcessRoomsEpic are cleaned before the matrix event is\n * detected, and then no MatrixRoomLeaveAction is emitted for them by this epic.\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of matrixRoomLeave actions\n */\n\nvar epics_matrixCleanLeftRoomsEpic = function matrixCleanLeftRoomsEpic(_ref74, state$, _ref75) {\n  transport_epics_objectDestructuringEmpty(_ref74);\n\n  var log = _ref75.log,\n      matrix$ = _ref75.matrix$;\n  return matrix$.pipe( // when matrix finishes initialization, register to matrix invite events\n  Object(switchMap["a" /* switchMap */])(function (matrix) {\n    return Object(fromEvent["a" /* fromEvent */])(matrix, \'Room.myMembership\', function (room, membership) {\n      return {\n        room: room,\n        membership: membership,\n        matrix: matrix\n      };\n    });\n  }), // filter for leave events to us\n  Object(filter["a" /* filter */])(function (_ref76) {\n    var membership = _ref76.membership;\n    return membership === \'leave\';\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee4(_ref77) {\n    var _ref78, room, state, _a, _b, rooms, address, _iterator4, _step4, roomId;\n\n    return regenerator_default.a.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _ref78 = transport_epics_slicedToArray(_ref77, 2), room = _ref78[0].room, state = _ref78[1];\n            rooms = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) !== null && _b !== void 0 ? _b : {};\n            _context4.t0 = regenerator_default.a.keys(rooms);\n\n          case 3:\n            if ((_context4.t1 = _context4.t0()).done) {\n              _context4.next = 26;\n              break;\n            }\n\n            address = _context4.t1.value;\n            _iterator4 = epics_createForOfIteratorHelper(rooms[address]);\n            _context4.prev = 6;\n\n            _iterator4.s();\n\n          case 8:\n            if ((_step4 = _iterator4.n()).done) {\n              _context4.next = 16;\n              break;\n            }\n\n            roomId = _step4.value;\n\n            if (!(roomId === room.roomId)) {\n              _context4.next = 14;\n              break;\n            }\n\n            log.warn(\'Left event for peer room detected, forgetting\', address, roomId);\n            _context4.next = 14;\n            return matrixRoomLeave({\n              roomId: roomId\n            }, {\n              address: address\n            });\n\n          case 14:\n            _context4.next = 8;\n            break;\n\n          case 16:\n            _context4.next = 21;\n            break;\n\n          case 18:\n            _context4.prev = 18;\n            _context4.t2 = _context4["catch"](6);\n\n            _iterator4.e(_context4.t2);\n\n          case 21:\n            _context4.prev = 21;\n\n            _iterator4.f();\n\n            return _context4.finish(21);\n\n          case 24:\n            _context4.next = 3;\n            break;\n\n          case 26:\n          case "end":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[6, 18, 21, 24]]);\n  })));\n};\n/**\n * If some room we had with a peer doesn\'t show up in transport, forget it\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps members\n * @returns Observable of matrixRoomLeave actions\n */\n\nvar epics_matrixCleanMissingRoomsEpic = function matrixCleanMissingRoomsEpic(_ref79, state$, _ref80) {\n  transport_epics_objectDestructuringEmpty(_ref79);\n\n  var log = _ref80.log,\n      matrix$ = _ref80.matrix$,\n      config$ = _ref80.config$;\n  return state$.pipe(pluckDistinct(\'transport\', \'matrix\'), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee5(matrix) {\n    var _a, rooms, address, _iterator5, _step5, roomId;\n\n    return regenerator_default.a.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            rooms = (_a = matrix === null || matrix === void 0 ? void 0 : matrix.rooms) !== null && _a !== void 0 ? _a : {};\n            _context5.t0 = regenerator_default.a.keys(rooms);\n\n          case 2:\n            if ((_context5.t1 = _context5.t0()).done) {\n              _context5.next = 23;\n              break;\n            }\n\n            address = _context5.t1.value;\n            _iterator5 = epics_createForOfIteratorHelper(rooms[address]);\n            _context5.prev = 5;\n\n            _iterator5.s();\n\n          case 7:\n            if ((_step5 = _iterator5.n()).done) {\n              _context5.next = 13;\n              break;\n            }\n\n            roomId = _step5.value;\n            _context5.next = 11;\n            return {\n              roomId: roomId,\n              address: address\n            };\n\n          case 11:\n            _context5.next = 7;\n            break;\n\n          case 13:\n            _context5.next = 18;\n            break;\n\n          case 15:\n            _context5.prev = 15;\n            _context5.t2 = _context5["catch"](5);\n\n            _iterator5.e(_context5.t2);\n\n          case 18:\n            _context5.prev = 18;\n\n            _iterator5.f();\n\n            return _context5.finish(18);\n\n          case 21:\n            _context5.next = 2;\n            break;\n\n          case 23:\n          case "end":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[5, 15, 18, 21]]);\n  })), Object(distinct["a" /* distinct */])(function (_ref81) {\n    var roomId = _ref81.roomId;\n    return roomId;\n  }), Object(mergeMap["a" /* mergeMap */])(function (_ref82) {\n    var roomId = _ref82.roomId,\n        address = _ref82.address;\n    return matrix$.pipe(Object(map["a" /* map */])(function (matrix) {\n      return {\n        matrix: matrix,\n        roomId: roomId,\n        address: address\n      };\n    }));\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(mergeMap["a" /* mergeMap */])(function (_ref83) {\n    var _ref84 = transport_epics_slicedToArray(_ref83, 2),\n        _ref84$ = _ref84[0],\n        roomId = _ref84$.roomId,\n        address = _ref84$.address,\n        matrix = _ref84$.matrix,\n        httpTimeout = _ref84[1].httpTimeout;\n\n    return getRoom$(matrix, roomId).pipe( // wait for room to show up in MatrixClient; if it doesn\'t, clean up\n    Object(timeout["a" /* timeout */])(httpTimeout), Object(ignoreElements["a" /* ignoreElements */])(), Object(catchError["a" /* catchError */])(function () {\n      log.warn(\'Peer room in state not found in matrix, forgetting\', address, roomId);\n      return Object(of["a" /* of */])(matrixRoomLeave({\n        roomId: roomId\n      }, {\n        address: address\n      }));\n    }));\n  }));\n};\n\nfunction waitMemberAndSend$(address, matrix, type, content, // eslint-disable-line @typescript-eslint/no-explicit-any\n_ref85) {\n  var log = _ref85.log,\n      latest$ = _ref85.latest$,\n      config$ = _ref85.config$;\n  var allowRtc = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  var RETRY_COUNT = 3; // is this relevant enough to become a constant/setting?\n\n  return latest$.pipe(Object(filter["a" /* filter */])(function (_ref86) {\n    var presences = _ref86.presences;\n    return address in presences;\n  }), Object(take["a" /* take */])(1), Object(mergeMap["a" /* mergeMap */])(function (_ref87) {\n    var rtc = _ref87.rtc;\n\n    var _a; // if available & open, use channel\n\n\n    if (allowRtc && ((_a = rtc === null || rtc === void 0 ? void 0 : rtc[address]) === null || _a === void 0 ? void 0 : _a.readyState) === \'open\') return Object(of["a" /* of */])(rtc[address]); // else, wait for member to join in the first room, and return roomId\n\n    return latest$.pipe(Object(map["a" /* map */])(function (_ref88) {\n      var state = _ref88.state;\n\n      var _a, _b, _c;\n\n      return (_c = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) === null || _b === void 0 ? void 0 : _b[address]) === null || _c === void 0 ? void 0 : _c[0];\n    }), // wait for a room to exist (created or invited) for address\n    Object(filter["a" /* filter */])(isntNil), Object(distinctUntilChanged["a" /* distinctUntilChanged */])(), // this switchMap unsubscribes from previous "wait" if first room for address changes\n    Object(switchMap["a" /* switchMap */])(function (roomId) {\n      return (// get/wait room object for roomId\n        // may wait for the room state to be populated (happens after createRoom resolves)\n        getRoom$(matrix, roomId).pipe(Object(mergeMap["a" /* mergeMap */])(function (room) {\n          return (// wait for address to be monitored & online (after getting Room for address)\n            // latest$ ensures it happens immediatelly if all conditions are satisfied\n            latest$.pipe(Object(pluck["a" /* pluck */])(\'presences\', address), Object(map["a" /* map */])(function (presence) {\n              var _a;\n\n              return ((_a = presence === null || presence === void 0 ? void 0 : presence.payload) === null || _a === void 0 ? void 0 : _a.available) ? presence.payload.userId : undefined;\n            }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])(), Object(map["a" /* map */])(function (userId) {\n              return {\n                room: room,\n                userId: userId\n              };\n            }))\n          );\n        }), // when user is online, get room member for partner\'s userId\n        // this switchMap unsubscribes from previous wait if userId changes or go offline\n        Object(switchMap["a" /* switchMap */])(function (_ref89) {\n          var room = _ref89.room,\n              userId = _ref89.userId;\n          if (!userId) return empty["a" /* EMPTY */]; // user not monitored or not available\n\n          var member = room.getMember(userId); // if it already joined room, return its membership\n\n          if (member && member.membership === \'join\') return Object(of["a" /* of */])(member); // else, wait for the user to join/accept invite\n\n          return Object(fromEvent["a" /* fromEvent */])(matrix, \'RoomMember.membership\', function (_ref90, member) {\n            transport_epics_objectDestructuringEmpty(_ref90);\n\n            return member;\n          }).pipe(Object(filter["a" /* filter */])(function (member) {\n            return member.roomId === room.roomId && member.userId === userId && member.membership === \'join\';\n          }));\n        }), Object(pluck["a" /* pluck */])(\'roomId\'))\n      );\n    }));\n  }), Object(take["a" /* take */])(1), // use first room/user which meets all requirements/filters above\n  Object(mergeMap["a" /* mergeMap */])(function (via) {\n    return Object(defer["a" /* defer */])(function () {\n      return typeof via === \'string\' ? matrix.sendEvent(via, type, content, \'\') // via room\n      : via.send(content.body);\n    }).pipe( // this returned value is just for notification, and shouldn\'t be relayed on\n    // all functionality is provided as side effects of the subscription\n    Object(mapTo["a" /* mapTo */])(typeof via === \'string\' ? via : via.label), Object(retryWhen["a" /* retryWhen */])(function (err$) {\n      return (// if sendEvent throws, omit & retry after httpTimeout / N,\n        // up to RETRY_COUNT times; if it continues to error, throws down\n        err$.pipe(Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(mergeMap["a" /* mergeMap */])(function (_ref91, i) {\n          var _ref92 = transport_epics_slicedToArray(_ref91, 2),\n              err = _ref92[0],\n              httpTimeout = _ref92[1].httpTimeout;\n\n          if (i < RETRY_COUNT - 1) {\n            log.warn("messageSend error, retrying ".concat(i + 1, "/").concat(RETRY_COUNT), err);\n            return Object(timer["a" /* timer */])(httpTimeout / RETRY_COUNT); // give up\n          } else return Object(throwError["a" /* throwError */])(err);\n        }))\n      );\n    }));\n  }));\n}\n/**\n * Handles a [[messageSend.request]] action and send its message to the first room on queue for\n * address\n *\n * @param action$ - Observable of messageSend.request actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of messageSend.success actions\n */\n\n\nvar epics_matrixMessageSendEpic = function matrixMessageSendEpic(action$, _ref93, _ref94) {\n  transport_epics_objectDestructuringEmpty(_ref93);\n\n  var log = _ref94.log,\n      matrix$ = _ref94.matrix$,\n      config$ = _ref94.config$,\n      latest$ = _ref94.latest$;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(messageSend.request)), // this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value\n  Object(mergeMap["a" /* mergeMap */])(function (action) {\n    return matrix$.pipe(Object(map["a" /* map */])(function (matrix) {\n      return {\n        action: action,\n        matrix: matrix\n      };\n    }));\n  }), Object(groupBy["a" /* groupBy */])(function (_ref95) {\n    var action = _ref95.action;\n    return action.meta.address;\n  }), // merge all inner/grouped observables, so different user\'s "queues" can be parallel\n  Object(mergeMap["a" /* mergeMap */])(function (grouped$) {\n    return (// per-user "queue"\n      grouped$.pipe( // each per-user "queue" (observable) are processed serially (because concatMap)\n      // TODO: batch all pending messages in a single send message request, with retry\n      Object(concatMap["a" /* concatMap */])(function (_ref96) {\n        var action = _ref96.action,\n            matrix = _ref96.matrix;\n        var body = typeof action.payload.message === \'string\' ? action.payload.message : encodeJsonMessage(action.payload.message);\n        var content = {\n          body: body,\n          msgtype: \'m.text\'\n        }; // wait for address to be monitored, online & have joined a non-global room with us\n\n        return waitMemberAndSend$(action.meta.address, matrix, \'m.room.message\', content, {\n          log: log,\n          latest$: latest$,\n          config$: config$\n        }, true).pipe(Object(mapTo["a" /* mapTo */])(messageSend.success(undefined, action.meta)), Object(catchError["a" /* catchError */])(function (err) {\n          log.error(\'messageSend error\', err, action.meta);\n          return Object(of["a" /* of */])(messageSend.failure(err, action.meta));\n        }));\n      }))\n    );\n  }));\n};\n/**\n * Handles a [[messageGlobalSend]] action and send one-shot message to a global room\n *\n * @param action$ - Observable of messageGlobalSend actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Empty observable (whole side-effect on matrix instance)\n */\n\nvar epics_matrixMessageGlobalSendEpic = function matrixMessageGlobalSendEpic(action$, _ref97, _ref98) {\n  transport_epics_objectDestructuringEmpty(_ref97);\n\n  var log = _ref98.log,\n      matrix$ = _ref98.matrix$,\n      config$ = _ref98.config$;\n  return (// actual output observable, gets/wait for the user to be in a room, and then sendMessage\n    action$.pipe(Object(filter["a" /* filter */])(isActionOf(messageGlobalSend)), // this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value\n    Object(mergeMap["a" /* mergeMap */])(function (action) {\n      return matrix$.pipe(Object(map["a" /* map */])(function (matrix) {\n        return {\n          action: action,\n          matrix: matrix\n        };\n      }));\n    }), Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(mergeMap["a" /* mergeMap */])(function (_ref99) {\n      var _ref100 = transport_epics_slicedToArray(_ref99, 2),\n          _ref100$ = _ref100[0],\n          action = _ref100$.action,\n          matrix = _ref100$.matrix,\n          config = _ref100[1];\n\n      var globalRooms = globalRoomNames(config);\n\n      if (!globalRooms.includes(action.meta.roomName)) {\n        log.warn(\'messageGlobalSend for unknown global room, ignoring\', action.meta.roomName, globalRooms);\n        return empty["a" /* EMPTY */];\n      }\n\n      var serverName = getServerName(matrix.getHomeserverUrl()),\n          roomAlias = "#".concat(action.meta.roomName, ":").concat(serverName);\n      return getRoom$(matrix, roomAlias).pipe( // send message!\n      Object(mergeMap["a" /* mergeMap */])(function (room) {\n        var body = typeof action.payload.message === \'string\' ? action.payload.message : encodeJsonMessage(action.payload.message);\n        return matrix.sendEvent(room.roomId, \'m.room.message\', {\n          body: body,\n          msgtype: \'m.text\'\n        }, \'\');\n      }), Object(catchError["a" /* catchError */])(function (err) {\n        log.error(\'Error sending message to global room\', action.meta, action.payload.message, err);\n        return empty["a" /* EMPTY */];\n      }));\n    }), Object(ignoreElements["a" /* ignoreElements */])())\n  );\n};\n\nfunction parseMessage(line, // eslint-disable-line @typescript-eslint/no-explicit-any\naddress, _ref101) {\n  var log = _ref101.log;\n  if (typeof line !== \'string\') return;\n\n  try {\n    var message = decodeJsonMessage(line); // if Signed, accept only if signature matches sender address\n\n    if (\'signature\' in message) {\n      var signer = getMessageSigner(message);\n      if (signer !== address) throw new error_RaidenError(ErrorCodes.TRNS_MESSAGE_SIGNATURE_MISMATCH, {\n        sender: address,\n        signer: signer\n      });\n    }\n\n    return message;\n  } catch (err) {\n    log.warn("Could not decode message: ".concat(line, ": ").concat(err));\n  }\n}\n/**\n * Subscribe to matrix messages and emits MessageReceivedAction upon receiving a valid message from\n * an user of interest (one valid signature from an address we monitor) in a room we have for them\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of messageReceived actions\n */\n\n\nvar epics_matrixMessageReceivedEpic = function matrixMessageReceivedEpic(_ref102, _ref103, _ref104) {\n  transport_epics_objectDestructuringEmpty(_ref102);\n\n  transport_epics_objectDestructuringEmpty(_ref103);\n\n  var log = _ref104.log,\n      matrix$ = _ref104.matrix$,\n      config$ = _ref104.config$,\n      latest$ = _ref104.latest$;\n  return (// gets/wait for the user to be in a room, and then sendMessage\n    matrix$.pipe( // when matrix finishes initialization, register to matrix timeline events\n    Object(switchMap["a" /* switchMap */])(function (matrix) {\n      return Object(fromEvent["a" /* fromEvent */])(matrix, \'Room.timeline\', function (event, room) {\n        return {\n          matrix: matrix,\n          event: event,\n          room: room\n        };\n      });\n    }), Object(withLatestFrom["a" /* withLatestFrom */])(config$), // filter for text messages not from us and not from global rooms\n    Object(filter["a" /* filter */])(function (_ref105) {\n      var _ref106 = transport_epics_slicedToArray(_ref105, 2),\n          _ref106$ = _ref106[0],\n          matrix = _ref106$.matrix,\n          event = _ref106$.event,\n          room = _ref106$.room,\n          config = _ref106[1];\n\n      var _a, _b;\n\n      return event.getType() === \'m.room.message\' && ((_b = (_a = event.event) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.msgtype) === \'m.text\' && event.getSender() !== matrix.getUserId() && !globalRoomNames(config).some(function (g) {\n        return (// generate an alias for global room of given name, and check if room matches\n          roomMatch("#".concat(g, ":").concat(getServerName(matrix.getHomeserverUrl())), room)\n        );\n      });\n    }), Object(mergeMap["a" /* mergeMap */])(function (_ref107) {\n      var _ref108 = transport_epics_slicedToArray(_ref107, 2),\n          _ref108$ = _ref108[0],\n          event = _ref108$.event,\n          room = _ref108$.room,\n          httpTimeout = _ref108[1].httpTimeout;\n\n      return latest$.pipe(Object(filter["a" /* filter */])(function (_ref109) {\n        var presences = _ref109.presences,\n            state = _ref109.state;\n\n        var _a, _b, _c;\n\n        var presence = find_default()(presences, [\'payload.userId\', event.getSender()]);\n        if (!presence) return false;\n        var rooms = (_c = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) === null || _b === void 0 ? void 0 : _b[presence.meta.address]) !== null && _c !== void 0 ? _c : [];\n        if (!rooms.includes(room.roomId)) return false;\n        return true;\n      }), Object(take["a" /* take */])(1), // take up to an arbitrary timeout to presence status for the sender\n      // AND the room in which this message was sent to be in sender\'s address room queue\n      Object(takeUntil["a" /* takeUntil */])(Object(timer["a" /* timer */])(httpTimeout)), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee6(_ref110) {\n        var presences, _a, presence, _iterator6, _step6, line, message;\n\n        return regenerator_default.a.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                presences = _ref110.presences;\n                presence = find_default()(presences, [\'payload.userId\', event.getSender()]);\n                _iterator6 = epics_createForOfIteratorHelper((event.event.content.body || \'\').split(\'\\n\'));\n                _context6.prev = 3;\n\n                _iterator6.s();\n\n              case 5:\n                if ((_step6 = _iterator6.n()).done) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                line = _step6.value;\n                message = parseMessage(line, presence.meta.address, {\n                  log: log\n                });\n                _context6.next = 10;\n                return messageReceived({\n                  text: line,\n                  message: message,\n                  ts: (_a = event.event.origin_server_ts) !== null && _a !== void 0 ? _a : Date.now(),\n                  userId: presence.payload.userId,\n                  roomId: room.roomId\n                }, presence.meta);\n\n              case 10:\n                _context6.next = 5;\n                break;\n\n              case 12:\n                _context6.next = 17;\n                break;\n\n              case 14:\n                _context6.prev = 14;\n                _context6.t0 = _context6["catch"](3);\n\n                _iterator6.e(_context6.t0);\n\n              case 17:\n                _context6.prev = 17;\n\n                _iterator6.f();\n\n                return _context6.finish(17);\n\n              case 20:\n              case "end":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[3, 14, 17, 20]]);\n      })));\n    }))\n  );\n};\n/**\n * If matrix received a message from user in a room we have with them, but not the first on queue,\n * update queue so this room goes to the front and will be used as send message room from now on\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of matrixRoom actions\n */\n\nvar epics_matrixMessageReceivedUpdateRoomEpic = function matrixMessageReceivedUpdateRoomEpic(action$, state$) {\n  return action$.pipe(Object(filter["a" /* filter */])(messageReceived.is), Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(filter["a" /* filter */])(function (_ref111) {\n    var _ref112 = transport_epics_slicedToArray(_ref111, 2),\n        action = _ref112[0],\n        state = _ref112[1];\n\n    var _a, _b, _c;\n\n    var rooms = (_c = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) === null || _b === void 0 ? void 0 : _b[action.meta.address]) !== null && _c !== void 0 ? _c : [];\n    return !!action.payload.roomId && rooms.includes(action.payload.roomId) && rooms[0] !== action.payload.roomId;\n  }), Object(map["a" /* map */])(function (_ref113) {\n    var _ref114 = transport_epics_slicedToArray(_ref113, 1),\n        action = _ref114[0];\n\n    return matrixRoom({\n      roomId: action.payload.roomId\n    }, action.meta);\n  }));\n};\n/**\n * Channel monitoring triggers matrix presence monitoring for partner\n *\n * @param action$ - Observable of RaidenActions\n * @returns Observable of matrixPresence.request actions\n */\n\nvar epics_matrixMonitorChannelPresenceEpic = function matrixMonitorChannelPresenceEpic(action$) {\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(channelMonitor)), Object(map["a" /* map */])(function (action) {\n    return matrixPresence.request(undefined, {\n      address: action.meta.partner\n    });\n  }));\n};\n/**\n * Sends Delivered for specific messages\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @param signer - RaidenEpicDeps members\n * @returns Observable of messageSend.request actions\n */\n\nvar epics_deliveredEpic = function deliveredEpic(action$, _ref115, _ref116) {\n  transport_epics_objectDestructuringEmpty(_ref115);\n\n  var log = _ref116.log,\n      signer = _ref116.signer,\n      latest$ = _ref116.latest$;\n  var cache = new LruCache(32);\n  return action$.pipe(Object(filter["a" /* filter */])(isMessageReceivedOfType([Signed(Processed), Signed(SecretRequest), Signed(SecretReveal)])), Object(withLatestFrom["a" /* withLatestFrom */])(latest$), Object(filter["a" /* filter */])(function (_ref117) {\n    var _ref118 = transport_epics_slicedToArray(_ref117, 2),\n        action = _ref118[0],\n        presences = _ref118[1].presences;\n\n    var _a;\n\n    return action.meta.address in presences && // skip if peer supports Capabilities.NO_DELIVERY\n    !((_a = presences[action.meta.address].payload.caps) === null || _a === void 0 ? void 0 : _a[Capabilities.NO_DELIVERY]);\n  }), Object(concatMap["a" /* concatMap */])(function (_ref119) {\n    var _ref120 = transport_epics_slicedToArray(_ref119, 1),\n        action = _ref120[0];\n\n    var message = action.payload.message; // defer causes the cache check to be performed at subscription time\n\n    return Object(defer["a" /* defer */])(function () {\n      var msgId = message.message_identifier;\n      var key = msgId.toString();\n      var cached = cache.get(key);\n      if (cached) return Object(of["a" /* of */])(messageSend.request({\n        message: cached\n      }, {\n        address: action.meta.address,\n        msgId: key\n      }));\n      var delivered = {\n        type: MessageType.DELIVERED,\n        delivered_message_identifier: msgId\n      };\n      log.info("Signing \\"".concat(delivered.type, "\\" for \\"").concat(message.type, "\\" with id=").concat(msgId.toString()));\n      return Object(from["a" /* from */])(signMessage(signer, delivered, {\n        log: log\n      })).pipe(Object(tap["a" /* tap */])(function (signed) {\n        return cache.put(key, signed);\n      }), Object(map["a" /* map */])(function (signed) {\n        return messageSend.request({\n          message: signed\n        }, {\n          address: action.meta.address,\n          msgId: key\n        });\n      }));\n    });\n  }));\n}; // fetches and caches matrix set turnServer\n\nvar _matrixIceServersCache = new WeakMap();\n\nfunction getMatrixIceServers(matrix) {\n  return epics_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee7() {\n    var cached, fetched, expire, servers;\n    return regenerator_default.a.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            cached = _matrixIceServersCache.get(matrix);\n\n            if (!(cached && Date.now() < cached[0])) {\n              _context7.next = 3;\n              break;\n            }\n\n            return _context7.abrupt("return", cached[1]);\n\n          case 3:\n            _context7.next = 5;\n            return matrix.turnServer();\n\n          case 5:\n            fetched = _context7.sent;\n            // if request returns nothing, caches empty list for 1h\n            expire = Date.now() + 36e5;\n            servers = [];\n\n            if (fetched && \'uris\' in fetched) {\n              servers.push({\n                urls: fetched.uris,\n                username: fetched.username,\n                credentialType: \'password\',\n                credential: fetched.password\n              });\n              expire = Date.now() + fetched.ttl * 1e3;\n            }\n\n            _matrixIceServersCache.set(matrix, [expire, servers]);\n\n            return _context7.abrupt("return", servers);\n\n          case 11:\n          case "end":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n} // creates a filter function which filters valid MatrixEvents\n\n\nfunction filterMatrixVoipEvents(type, sender, callId, httpTimeout) {\n  var contentKey = type === \'m.call.invite\' ? \'offer\' : type === \'m.call.answer\' ? \'answer\' : type === \'m.call.candidates\' ? \'candidates\' : undefined;\n  return function ( // FIXME: remove any when MatrixEvent type exposes getAge & getContent methods\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  event) {\n    var _a, _b, _c, _d;\n\n    return event.getType() === type && event.getSender() === sender && ((_a = event.getContent()) === null || _a === void 0 ? void 0 : _a.call_id) === callId && (!httpTimeout || event.getAge() <= ((_c = (_b = event.getContent()) === null || _b === void 0 ? void 0 : _b.lifetime) !== null && _c !== void 0 ? _c : httpTimeout)) && (!contentKey || !!((_d = event.getContent()) === null || _d === void 0 ? void 0 : _d[contentKey]));\n  };\n} // setup candidates$ handlers\n\n\nfunction handleCandidates$(connection, matrix, start$, _ref121, _ref122) {\n  var callId = _ref121.callId,\n      peerId = _ref121.peerId,\n      peerAddress = _ref121.peerAddress;\n  var log = _ref122.log,\n      latest$ = _ref122.latest$,\n      config$ = _ref122.config$;\n  return Object(merge["a" /* merge */])( // when seeing an icecandidate, send it to peer\n  Object(fromEvent["a" /* fromEvent */])(connection, \'icecandidate\').pipe(Object(pluck["a" /* pluck */])(\'candidate\'), Object(delayWhen["a" /* delayWhen */])(function () {\n    return start$;\n  }), Object(takeWhile["a" /* takeWhile */])(isntNil), Object(bufferTime["a" /* bufferTime */])(10), Object(filter["a" /* filter */])(function (candidates) {\n    return candidates.length > 0;\n  }), Object(tap["a" /* tap */])(function (e) {\n    return log.debug(\'RTC: got candidates\', callId, e);\n  }), Object(mergeMap["a" /* mergeMap */])(function (candidates) {\n    return waitMemberAndSend$(peerAddress, matrix, \'m.call.candidates\', {\n      call_id: callId,\n      version: 0,\n      candidates: candidates\n    }, {\n      log: log,\n      latest$: latest$,\n      config$: config$\n    });\n  })), // when receiving candidates from peer, add it locally\n  Object(fromEvent["a" /* fromEvent */])(matrix, \'event\').pipe(Object(filter["a" /* filter */])(filterMatrixVoipEvents(\'m.call.candidates\', peerId, callId)), Object(tap["a" /* tap */])(function (e) {\n    return log.debug(\'RTC: received candidates\', callId, e.getContent().candidates);\n  }), Object(mergeMap["a" /* mergeMap */])(function (event) {\n    var _a;\n\n    return Object(from["a" /* from */])((_a = event.getContent().candidates) !== null && _a !== void 0 ? _a : []);\n  }), Object(mergeMap["a" /* mergeMap */])(function (candidate) {\n    return Object(defer["a" /* defer */])(function () {\n      return connection.addIceCandidate(candidate);\n    }).pipe(Object(catchError["a" /* catchError */])(function (err) {\n      log.error(\'RTC: error setting candidate, ignoring\', err);\n      return empty["a" /* EMPTY */];\n    }));\n  }))).pipe(Object(ignoreElements["a" /* ignoreElements */])());\n} // setup RTC data channel for caller\n\n\nfunction setupCallerDataChannel$(matrix, start$, info, _ref123, deps) {\n  var httpTimeout = _ref123.httpTimeout,\n      fallbackIceServers = _ref123.fallbackIceServers;\n  var callId = info.callId,\n      peerId = info.peerId,\n      peerAddress = info.peerAddress;\n  var log = deps.log,\n      latest$ = deps.latest$,\n      config$ = deps.config$;\n  return Object(from["a" /* from */])(getMatrixIceServers(matrix)).pipe(Object(mergeMap["a" /* mergeMap */])(function (matrixTurnServers) {\n    var connection = new RTCPeerConnection({\n      iceServers: [].concat(transport_epics_toConsumableArray(matrixTurnServers), transport_epics_toConsumableArray(fallbackIceServers))\n    }); // we relay on retries, no need to enforce ordered\n\n    var dataChannel = connection.createDataChannel(callId, {\n      ordered: false\n    });\n    return Object(merge["a" /* merge */])( // despite \'never\' emitting, candidates$ have side-effects while/when subscribed\n    handleCandidates$(connection, matrix, start$, info, deps), Object(defer["a" /* defer */])(function () {\n      return connection.createOffer();\n    }).pipe(Object(mergeMap["a" /* mergeMap */])(function (offer) {\n      connection.setLocalDescription(offer);\n      var content = {\n        call_id: callId,\n        lifetime: httpTimeout,\n        version: 0,\n        offer: offer\n      };\n      return Object(merge["a" /* merge */])( // wait for answer\n      Object(fromEvent["a" /* fromEvent */])(matrix, \'event\').pipe(Object(filter["a" /* filter */])(filterMatrixVoipEvents(\'m.call.answer\', peerId, callId, httpTimeout))), // send invite with offer\n      waitMemberAndSend$(peerAddress, matrix, \'m.call.invite\', content, {\n        log: log,\n        latest$: latest$,\n        config$: config$\n      }).pipe(Object(tap["a" /* tap */])(function (e) {\n        return log.debug(\'RTC: sent invite\', callId, e);\n      }), Object(ignoreElements["a" /* ignoreElements */])()));\n    }), Object(take["a" /* take */])(1), Object(tap["a" /* tap */])(function () {\n      return log.info(\'RTC: got answer\', callId);\n    }), Object(map["a" /* map */])(function (event) {\n      connection.setRemoteDescription(new RTCSessionDescription(event.getContent().answer));\n      start$.next(null);\n      start$.complete();\n    }), Object(ignoreElements["a" /* ignoreElements */])()), Object(of["a" /* of */])(dataChannel));\n  }));\n} // setup RTC data channel for callee\n\n\nfunction setupCalleeDataChannel$(matrix, start$, info, _ref124, deps) {\n  var httpTimeout = _ref124.httpTimeout;\n  var callId = info.callId,\n      peerId = info.peerId,\n      peerAddress = info.peerAddress;\n  var log = deps.log,\n      latest$ = deps.latest$,\n      config$ = deps.config$;\n  return Object(fromEvent["a" /* fromEvent */])(matrix, \'event\').pipe(Object(filter["a" /* filter */])(filterMatrixVoipEvents(\'m.call.invite\', peerId, callId, httpTimeout)), Object(tap["a" /* tap */])(function () {\n    return log.info(\'RTC: got invite\', callId);\n  }), Object(mergeMap["a" /* mergeMap */])(function (event) {\n    return Object(from["a" /* from */])(getMatrixIceServers(matrix)).pipe(Object(map["a" /* map */])(function (serv) {\n      return [event, serv];\n    }));\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(mergeMap["a" /* mergeMap */])(function (_ref125) {\n    var _ref126 = transport_epics_slicedToArray(_ref125, 2),\n        _ref126$ = transport_epics_slicedToArray(_ref126[0], 2),\n        event = _ref126$[0],\n        matrixTurnServers = _ref126$[1],\n        fallbackIceServers = _ref126[1].fallbackIceServers;\n\n    // create connection only upon invite/offer\n    var connection = new RTCPeerConnection({\n      iceServers: [].concat(transport_epics_toConsumableArray(matrixTurnServers), transport_epics_toConsumableArray(fallbackIceServers))\n    });\n    connection.setRemoteDescription(new RTCSessionDescription(event.getContent().offer));\n    return Object(merge["a" /* merge */])( // despite \'never\' emitting, candidates$ have side-effects while/when subscribed\n    handleCandidates$(connection, matrix, start$, info, deps), Object(defer["a" /* defer */])(function () {\n      return connection.createAnswer();\n    }).pipe(Object(mergeMap["a" /* mergeMap */])(function (answer) {\n      connection.setLocalDescription(answer);\n      var content = {\n        call_id: callId,\n        lifetime: httpTimeout,\n        version: 0,\n        answer: answer\n      }; // send answer\n\n      return waitMemberAndSend$(peerAddress, matrix, \'m.call.answer\', content, {\n        log: log,\n        latest$: latest$,\n        config$: config$\n      });\n    }), Object(tap["a" /* tap */])(function (e) {\n      log.debug(\'RTC: sent answer\', callId, e);\n      start$.next(null);\n      start$.complete();\n    }), Object(ignoreElements["a" /* ignoreElements */])()), Object(fromEvent["a" /* fromEvent */])(connection, \'datachannel\').pipe(Object(pluck["a" /* pluck */])(\'channel\')));\n  }), Object(take["a" /* take */])(1));\n} // setup listeners & events for a data channel, when it gets opened, and teardown when closed\n\n\nfunction listenDataChannel$(stop$, _ref127, _ref128, _ref129) {\n  var callId = _ref127.callId,\n      peerId = _ref127.peerId,\n      peerAddress = _ref127.peerAddress;\n  var httpTimeout = _ref128.httpTimeout;\n  var log = _ref129.log;\n  return function (dataChannel$) {\n    return dataChannel$.pipe(Object(mergeMap["a" /* mergeMap */])(function (dataChannel) {\n      return Object(merge["a" /* merge */])(Object(fromEvent["a" /* fromEvent */])(dataChannel, \'close\').pipe(Object(tap["a" /* tap */])(function () {\n        log.info(\'RTC: dataChannel close\', callId);\n        stop$.next(null);\n        stop$.complete();\n      }), Object(ignoreElements["a" /* ignoreElements */])()), Object(fromEvent["a" /* fromEvent */])(dataChannel, \'error\').pipe(Object(mergeMap["a" /* mergeMap */])(function (ev) {\n        return Object(throwError["a" /* throwError */])(ev.error);\n      })), Object(fromEvent["a" /* fromEvent */])(dataChannel, \'open\').pipe(Object(take["a" /* take */])(1), // this timeout ensures the whole dataChannel$ observable throws if it can\'t be set up,\n      // so it can be retried/repeated/restarted.\n      // notice it only starts after dataChannel$ emits, i.e. on subscription for caller (as\n      // it createDataChannel object, then responsible for hanging up call and retrying),\n      // and after \'datachannel\' event for callee (passive listener)\n      Object(timeout["a" /* timeout */])(httpTimeout / 3), Object(tap["a" /* tap */])(function () {\n        return log.info(\'RTC: dataChannel open\', callId);\n      }), // output rtcChannel action with defined channel instance to have it set in latest$\n      Object(mapTo["a" /* mapTo */])(rtcChannel(dataChannel, {\n        address: peerAddress\n      }))), Object(fromEvent["a" /* fromEvent */])(dataChannel, \'message\').pipe(Object(tap["a" /* tap */])(function (e) {\n        return log.debug(\'RTC: dataChannel message\', callId, e);\n      }), Object(pluck["a" /* pluck */])(\'data\'), Object(filter["a" /* filter */])(function (d) {\n        return typeof d === \'string\';\n      }), Object(map["a" /* map */])(function (line) {\n        return messageReceived({\n          text: line,\n          message: parseMessage(line, peerAddress, {\n            log: log\n          }),\n          ts: Date.now(),\n          userId: peerId\n        }, {\n          address: peerAddress\n        });\n      }))).pipe(Object(finalize["a" /* finalize */])(function () {\n        return dataChannel.close();\n      }));\n    }), Object(takeUntil["a" /* takeUntil */])(stop$), Object(catchError["a" /* catchError */])(function (err) {\n      var _a;\n\n      stop$.next(null);\n      stop$.complete();\n      log.info("Couldn\'t set up WebRTC dataChannel, retrying", callId, (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : err);\n      return empty["a" /* EMPTY */];\n    }), // if it ends by takeUntil or catchError, output rtcChannel to reset latest$ mapping\n    Object(endWith["a" /* endWith */])(rtcChannel(undefined, {\n      address: peerAddress\n    })));\n  };\n} // handles presence changes for a single peer address (grouped)\n\n\nfunction handlePresenceChange$(action$, presence$, _ref130) {\n  var log = _ref130.log,\n      address = _ref130.address,\n      latest$ = _ref130.latest$,\n      matrix$ = _ref130.matrix$,\n      config$ = _ref130.config$;\n  return presence$.pipe(Object(distinctUntilChanged["a" /* distinctUntilChanged */])(function (a, b) {\n    return a.payload.userId === b.payload.userId && a.payload.available === b.payload.available;\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(matrix$, config$), Object(filter["a" /* filter */])(function (_ref131) {\n    var _ref132 = transport_epics_slicedToArray(_ref131, 3),\n        action = _ref132[0],\n        caps = _ref132[2].caps;\n\n    var _a;\n\n    return !!((_a = action.payload.caps) === null || _a === void 0 ? void 0 : _a[Capabilities.WEBRTC]) && !!(caps === null || caps === void 0 ? void 0 : caps[Capabilities.WEBRTC]);\n  }), Object(switchMap["a" /* switchMap */])(function (_ref133) {\n    var _ref134 = transport_epics_slicedToArray(_ref133, 3),\n        action = _ref134[0],\n        matrix = _ref134[1],\n        config = _ref134[2];\n\n    // if peer goes offline in Matrix, reset dataChannel & unsubscribe defer to close dataChannel\n    if (!action.payload.available) return Object(of["a" /* of */])(rtcChannel(undefined, action.meta));\n    var deps = {\n      log: log,\n      latest$: latest$,\n      config$: config$\n    };\n    var callId = [address, action.meta.address].map(function (a) {\n      return a.toLowerCase();\n    }).sort(function (a, b) {\n      return a.localeCompare(b);\n    }).join(\'|\');\n    var isCaller = callId.startsWith(address.toLowerCase());\n    return Object(defer["a" /* defer */])(function () {\n      var info = {\n        callId: callId,\n        peerId: action.payload.userId,\n        peerAddress: action.meta.address\n      }; // start$ indicates invite/offer/answer cycle completed, and candidates can be exchanged\n\n      var start$ = new AsyncSubject["a" /* AsyncSubject */](); // stop$ indicates dataChannel closed (maybe by peer), and teardown should take place\n\n      var stop$ = new AsyncSubject["a" /* AsyncSubject */]();\n      var dataChannel$;\n\n      if (isCaller) {\n        // caller\n        dataChannel$ = setupCallerDataChannel$(matrix, start$, info, config, deps);\n      } else {\n        // callee\n        dataChannel$ = setupCalleeDataChannel$(matrix, start$, info, config, deps);\n      }\n\n      stop$.pipe(Object(mergeMap["a" /* mergeMap */])(function () {\n        return waitMemberAndSend$(action.meta.address, matrix, \'m.call.hangup\', {\n          call_id: callId,\n          version: 0\n        }, {\n          log: log,\n          latest$: latest$,\n          config$: config$\n        }).pipe(Object(takeUntil["a" /* takeUntil */])(Object(timer["a" /* timer */])(config.httpTimeout / 10)));\n      }), Object(takeUntil["a" /* takeUntil */])(action$.pipe(Object(filter["a" /* filter */])(raidenShutdown.is)))).subscribe(); // when stopping, if not shutting down, send hangup\n      // listenDataChannel$ needs channel$:Observable<RTCDataChannel>, but we must include/merge\n      // setup and monitoring Observable<never>\'s to get things moving on subscription\n\n      return Object(merge["a" /* merge */])(dataChannel$, // throws nad restart if peer hangs up\n      Object(fromEvent["a" /* fromEvent */])(matrix, \'event\').pipe(Object(filter["a" /* filter */])(filterMatrixVoipEvents(\'m.call.hangup\', info.peerId, callId)), // no need for specific error since this is just logged and ignored in listenDataChannel$\n      Object(mergeMapTo["a" /* mergeMapTo */])(Object(throwError["a" /* throwError */])(new Error(\'RTC: peer hung up\'))))).pipe(listenDataChannel$(stop$, info, config, deps));\n    }).pipe( // if it disconnects for any reason, but partner is still online,\n    // try to reconnect by repeating from \'defer\'\n    Object(repeatWhen["a" /* repeatWhen */])(function (completed$) {\n      return completed$.pipe(Object(withLatestFrom["a" /* withLatestFrom */])(latest$, config$), Object(mergeMap["a" /* mergeMap */])(function (_ref135) {\n        var _ref136 = transport_epics_slicedToArray(_ref135, 3),\n            presences = _ref136[1].presences,\n            httpTimeout = _ref136[2].httpTimeout;\n\n        var _a, _b;\n\n        return !((_b = (_a = presences[action.meta.address]) === null || _a === void 0 ? void 0 : _a.payload) === null || _b === void 0 ? void 0 : _b.available) ? empty["a" /* EMPTY */] : isCaller ? Object(timer["a" /* timer */])(httpTimeout / 10) // caller waits some time to retry\n        : Object(of["a" /* of */])(null);\n      }));\n    }));\n  }));\n}\n\nvar epics_rtcConnectEpic = function rtcConnectEpic(action$, _ref137, deps) {\n  transport_epics_objectDestructuringEmpty(_ref137);\n\n  return action$.pipe(Object(filter["a" /* filter */])(matrixPresence.success.is), Object(groupBy["a" /* groupBy */])(function (action) {\n    return action.meta.address;\n  }), Object(mergeMap["a" /* mergeMap */])(function (grouped$) {\n    return handlePresenceChange$(action$, grouped$, deps);\n  }));\n};\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/epics/close.js\nfunction close_slicedToArray(arr, i) { return close_arrayWithHoles(arr) || close_iterableToArrayLimit(arr, i) || close_unsupportedIterableToArray(arr, i) || close_nonIterableRest(); }\n\nfunction close_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction close_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return close_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return close_arrayLikeToArray(o, minLen); }\n\nfunction close_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction close_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction close_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\n/**\n * Complete or fail any pending transfer for any closing or closed channels\n * Transfer is considered successful if secret was revealed (as it could be claimed on-chain),\n * else it\'s considered as failed as couldn\'t succeed inside expiration timeout\n *\n * @param action$ - Observable of channelClose.{requet,success} actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transfer.{success|failure} actions\n */\n\nvar close_transferChannelClosedEpic = function transferChannelClosedEpic(action$, state$, _ref) {\n  var address = _ref.address;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf([channelClose.request, channelClose.success])), Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(mergeMap["a" /* mergeMap */])(function (_ref2) {\n    var _ref3 = close_slicedToArray(_ref2, 2),\n        action = _ref3[0],\n        state = _ref3[1];\n\n    return Object(from["a" /* from */])(Object.entries(state.sent)).pipe(Object(filter["a" /* filter */])(function (_ref4) {\n      var _ref5 = close_slicedToArray(_ref4, 2),\n          _ref5$1$transfer = close_slicedToArray(_ref5[1].transfer, 2),\n          transf = _ref5$1$transfer[1];\n\n      return transf.token_network_address === action.meta.tokenNetwork && transf.recipient === action.meta.partner && transf.initiator === address;\n    }), Object(map["a" /* map */])(function (_ref6) {\n      var _ref7 = close_slicedToArray(_ref6, 2),\n          secrethash = _ref7[0],\n          sent = _ref7[1];\n\n      var _a, _b, _c, _d; // as we can\'t know for sure if recipient/partner received the secret or unlock,\n      //consider transfer failed iff neither the secret was revealed nor the unlock happened\n\n\n      var meta = {\n        secrethash: secrethash,\n        direction: Direction.SENT\n      };\n      if (sent.lockExpired || sent.unlockProcessed || ((_b = (_a = sent.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) || sent.secretRequest && !sent.secretReveal) // success/failure already emitted\n        return;else if (!((_d = (_c = sent.secret) === null || _c === void 0 ? void 0 : _c[1]) === null || _d === void 0 ? void 0 : _d.registerBlock) && !sent.secretReveal && !sent.unlock) return actions_transfer.failure(new error_RaidenError(ErrorCodes.XFER_CHANNEL_CLOSED_PREMATURELY), meta);else if (sent.unlock) return actions_transfer.success({\n        balanceProof: getBalanceProofFromEnvelopeMessage(sent.unlock[1])\n      }, meta);else return actions_transfer.success({}, meta);\n    }), Object(filter["a" /* filter */])(isntNil));\n  }));\n};\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/epics/utils.js\n\n\n/**\n * Dispatches an actions and waits until a condition is satisfied.\n *\n * @param action$ - Observable of actions that will be monitored\n * @param request - The request/action that will be dispatched\n * @param predicate - The condition that will that was to be satisfied for the observable to\n * complete\n * @returns Observable of the request type.\n */\n\nfunction dispatchAndWait$(action$, request, predicate) {\n  return Object(merge["a" /* merge */])( // wait until respective success/failure action is seen before completing\n  action$.pipe(Object(filter["a" /* filter */])(predicate), Object(take["a" /* take */])(1), // don\'t output success/failure action, just wait for first match to complete\n  Object(ignoreElements["a" /* ignoreElements */])()), // output once\n  Object(of["a" /* of */])(request));\n}\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/epics/expire.js\nfunction expire_slicedToArray(arr, i) { return expire_arrayWithHoles(arr) || expire_iterableToArrayLimit(arr, i) || expire_unsupportedIterableToArray(arr, i) || expire_nonIterableRest(); }\n\nfunction expire_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction expire_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return expire_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return expire_arrayLikeToArray(o, minLen); }\n\nfunction expire_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction expire_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction expire_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n/**\n * Contains the core logic of {@link transferAutoExpireEpic}.\n *\n * @param action$ - Observable of {@link RaidenAction} actions\n * @param state - Contains The current state of the app\n * @param config - Contains the current app config\n * @param blockNumber - The current block number\n * @returns Observable of {@link transferExpire.request} or {@link transfer.failure} actions\n */\n\nfunction autoExpire$(action$, state, _ref, blockNumber) {\n  var confirmationBlocks = _ref.confirmationBlocks;\n  // we can send LockExpired only for SENT transfers\n  return Object(from["a" /* from */])(Object.entries(state.sent)).pipe(Object(filter["a" /* filter */])(function (_ref2) {\n    var _ref3 = expire_slicedToArray(_ref2, 2),\n        sent = _ref3[1];\n\n    var _a, _b;\n\n    return !sent.unlock && !sent.lockExpired && !sent.channelClosed && sent.transfer[1].lock.expiration.add(confirmationBlocks).lte(blockNumber) && // don\'t expire if secret got registered before lock expired\n    !((_b = (_a = sent.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock);\n  }), Object(mergeMap["a" /* mergeMap */])(function (_ref4) {\n    var _ref5 = expire_slicedToArray(_ref4, 2),\n        secrethash = _ref5[0],\n        sent = _ref5[1];\n\n    var meta = {\n      secrethash: secrethash,\n      direction: Direction.SENT\n    }; // this observable acts like a Promise: emits request once, completes on success/failure\n\n    return Object(merge["a" /* merge */])(dispatchAndWait$(action$, transferExpire.request(undefined, meta), isResponseOf(transferExpire, meta)), // notify users that this transfer failed definitely\n    Object(of["a" /* of */])(actions_transfer.failure(new error_RaidenError(ErrorCodes.XFER_EXPIRED, {\n      block: sent.transfer[1].lock.expiration.toString()\n    }), meta)));\n  }));\n}\n/**\n * Process newBlocks, emits transferExpire.request (request to compose&sign LockExpired for a transfer)\n * if pending transfer\'s lock expired and transfer didn\'t unlock (succeed) in time\n * Also, emits transfer.failure, to notify users that a transfer has failed (although it\'ll only be\n * considered as completed with fail once the transferExpireProcessed arrives).\n *\n * @param action$ - Observable of newBlock|transferExpire.success|transferExpire.failure actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferExpire.request|transfer.failure actions\n */\n\n\nvar expire_transferAutoExpireEpic = function transferAutoExpireEpic(action$, state$, _ref6) {\n  var config$ = _ref6.config$;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(newBlock)), Object(withLatestFrom["a" /* withLatestFrom */])(state$, config$), // exhaustMap ignores new blocks while previous request batch is still pending\n  Object(exhaustMap["a" /* exhaustMap */])(function (_ref7) {\n    var _ref8 = expire_slicedToArray(_ref7, 3),\n        blockNumber = _ref8[0].payload.blockNumber,\n        state = _ref8[1],\n        config = _ref8[2];\n\n    return autoExpire$(action$, state, config, blockNumber);\n  }));\n};\n// EXTERNAL MODULE: ./node_modules/lodash/get.js\nvar lodash_get = __webpack_require__("9b02");\nvar lodash_get_default = /*#__PURE__*/__webpack_require__.n(lodash_get);\n\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/epics/locked.js\n\n\nfunction locked_objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }\n\nfunction locked_slicedToArray(arr, i) { return locked_arrayWithHoles(arr) || locked_iterableToArrayLimit(arr, i) || locked_unsupportedIterableToArray(arr, i) || locked_nonIterableRest(); }\n\nfunction locked_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction locked_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction locked_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction locked_toConsumableArray(arr) { return locked_arrayWithoutHoles(arr) || locked_iterableToArray(arr) || locked_unsupportedIterableToArray(arr) || locked_nonIterableSpread(); }\n\nfunction locked_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction locked_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return locked_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return locked_arrayLikeToArray(o, minLen); }\n\nfunction locked_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction locked_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return locked_arrayLikeToArray(arr); }\n\nfunction locked_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/* eslint-disable @typescript-eslint/camelcase */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Return the next nonce for a (possibly missing) balanceProof, or else BigNumber(1)\n *\n * @param balanceProof - Balance proof to increase nonce from\n * @returns Increased nonce, or One if no balance proof provided\n */\n\nfunction nextNonce(balanceProof) {\n  var _a;\n\n  return ((_a = balanceProof === null || balanceProof === void 0 ? void 0 : balanceProof.nonce) !== null && _a !== void 0 ? _a : constants["Zero"]).add(1);\n}\n\nfunction getChannelLocksroot(channel, secrethash) {\n  var _a;\n\n  var locks = ((_a = channel.own.locks) !== null && _a !== void 0 ? _a : []).filter(function (l) {\n    return l.secrethash !== secrethash;\n  });\n  return getLocksroot(locks);\n}\n/**\n * THe core logic of {@link makeAndSignTransfer}.\n *\n * @param state - Contains The current state of the app\n * @param action - transfer request action to be sent.\n * @param revealTimeout - The reveal timeout for the transfer.\n * @param deps - {@link RaidenEpicDeps}\n * @returns Observable of {@link transferSecret} or {@link transferSigned} actions\n */\n\n\nfunction makeAndSignTransfer$(state, action, _ref, _ref2) {\n  var revealTimeout = _ref.revealTimeout;\n  var log = _ref2.log,\n      address = _ref2.address,\n      network = _ref2.network,\n      signer = _ref2.signer;\n\n  var _a, _b, _c, _d, _e, _f;\n\n  if (action.meta.secrethash in state.sent) {\n    // don\'t throw to avoid emitting transfer.failure, to just wait for already pending transfer\n    log.warn(\'transfer already present\', action.meta);\n    return empty["a" /* EMPTY */];\n  } // assume paths are valid and recipient is first hop of first route\n  // compose metadata from it, and use first path fee\n\n\n  var metadata = {\n    routes: action.payload.paths.map(function (_ref3) {\n      var path = _ref3.path;\n      return {\n        route: path\n      };\n    })\n  };\n  var fee = action.payload.paths[0].fee;\n  var recipient = action.payload.paths[0].path[0];\n  var channel = state.channels[action.payload.tokenNetwork][recipient]; // check below shouldn\'t fail because of route validation in pathFindServiceEpic\n  // used here mostly for type narrowing on channel union\n\n  assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.open, \'not open\');\n  assert(!action.payload.expiration || action.payload.expiration >= state.blockNumber + revealTimeout, \'expiration too soon\');\n  var lock = {\n    amount: action.payload.value.add(fee),\n    expiration: Object(utils["bigNumberify"])(action.payload.expiration || state.blockNumber + revealTimeout * 2),\n    secrethash: action.meta.secrethash\n  };\n  var locks = [].concat(locked_toConsumableArray((_a = channel.own.locks) !== null && _a !== void 0 ? _a : []), [lock]);\n  var locksroot = getLocksroot(locks);\n  var token = findKey_default()(state.tokens, function (tn) {\n    return tn === action.payload.tokenNetwork;\n  });\n  log.info(\'Signing transfer of value\', action.payload.value.toString(), \'of token\', token, \', to\', action.payload.target, \', through routes\', action.payload.paths, \', paying\', fee.toString(), \'in fees.\');\n  var message = {\n    type: MessageType.LOCKED_TRANSFER,\n    message_identifier: makeMessageId(),\n    chain_id: Object(utils["bigNumberify"])(network.chainId),\n    token_network_address: action.payload.tokenNetwork,\n    channel_identifier: Object(utils["bigNumberify"])(channel.id),\n    nonce: nextNonce(channel.own.balanceProof),\n    transferred_amount: (_c = (_b = channel.own.balanceProof) === null || _b === void 0 ? void 0 : _b.transferredAmount) !== null && _c !== void 0 ? _c : constants["Zero"],\n    locked_amount: ((_e = (_d = channel.own.balanceProof) === null || _d === void 0 ? void 0 : _d.lockedAmount) !== null && _e !== void 0 ? _e : constants["Zero"]).add(lock.amount),\n    locksroot: locksroot,\n    payment_identifier: action.payload.paymentId,\n    token: token,\n    recipient: recipient,\n    lock: lock,\n    target: action.payload.target,\n    initiator: (_f = action.payload.initiator) !== null && _f !== void 0 ? _f : address,\n    metadata: metadata\n  };\n  return Object(from["a" /* from */])(signMessage(signer, message, {\n    log: log\n  })).pipe(Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee(signed) {\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return transferSigned({\n              message: signed,\n              fee: fee\n            }, action.meta);\n\n          case 2:\n            if (!action.payload.secret) {\n              _context.next = 5;\n              break;\n            }\n\n            _context.next = 5;\n            return transferSecret({\n              secret: action.payload.secret\n            }, action.meta);\n\n          case 5:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })));\n}\n/**\n * Create an observable to compose and sign a LockedTransfer message/transferSigned action\n * As it\'s an async observable which depends on state and may return an action which changes it,\n * the returned observable must be subscribed in a serialized context that ensures non-concurrent\n * write access to the channel\'s balance proof (e.g. concatMap)\n *\n * @param state$ - Observable of current state\n * @param action - transfer request action to be sent\n * @param deps - RaidenEpicDeps\n * @returns Observable of transferSigned|transferSecret|transfer.failure actions\n */\n\n\nfunction makeAndSignTransfer(state$, action, deps) {\n  return Object(combineLatest["a" /* combineLatest */])([state$, deps.config$]).pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])(function (_ref4) {\n    var _ref5 = locked_slicedToArray(_ref4, 2),\n        state = _ref5[0],\n        config = _ref5[1];\n\n    return makeAndSignTransfer$(state, action, config, deps);\n  }), Object(catchError["a" /* catchError */])(function (err) {\n    return Object(of["a" /* of */])(actions_transfer.failure(err, action.meta));\n  }));\n}\n/**\n * Contains the core logic of {@link makeAndSignUnlock}.\n *\n * @param state$ - Observable of the latest app state.\n * @param state - Contains The current state of the app\n * @param action - The transfer unlock action that will generate the transferUnlock.success action.\n * @param signer - The signer that will sign the message\n * @returns Observable of {@link transferUnlock.success} action.\n */\n\n\nfunction makeAndSignUnlock$(state$, state, action, _ref6) {\n  var log = _ref6.log,\n      signer = _ref6.signer;\n\n  var _a, _b;\n\n  var secrethash = action.meta.secrethash;\n  assert(secrethash in state.sent, \'unknown transfer\');\n  var transfer = state.sent[secrethash].transfer[1];\n  var channel = lodash_get_default()(state.channels, [transfer.token_network_address, transfer.recipient]); // shouldn\'t happen, channel close clears transfers, but unlock may already have been queued\n\n  assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.open && channel.own.balanceProof, \'channel gone, not open or no balanceProof\');\n  var signed$;\n\n  if (state.sent[secrethash].unlock) {\n    // unlock already signed, use cached\n    signed$ = Object(of["a" /* of */])(state.sent[secrethash].unlock[1]);\n  } else {\n    // don\'t forget to check after signature too, may have expired by then\n    // allow unlocking past expiration if secret registered\n    assert(((_b = (_a = state.sent[secrethash].secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) || transfer.lock.expiration.gt(state.blockNumber), \'lock expired\');\n    var locksroot = getChannelLocksroot(channel, secrethash);\n    var message = {\n      type: MessageType.UNLOCK,\n      message_identifier: makeMessageId(),\n      chain_id: transfer.chain_id,\n      token_network_address: transfer.token_network_address,\n      channel_identifier: transfer.channel_identifier,\n      nonce: nextNonce(channel.own.balanceProof),\n      transferred_amount: channel.own.balanceProof.transferredAmount.add(transfer.lock.amount),\n      locked_amount: channel.own.balanceProof.lockedAmount.sub(transfer.lock.amount),\n      locksroot: locksroot,\n      payment_identifier: transfer.payment_identifier,\n      secret: state.sent[action.meta.secrethash].secret[1].value\n    };\n    signed$ = Object(from["a" /* from */])(signMessage(signer, message, {\n      log: log\n    }));\n  }\n\n  return signed$.pipe(Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee2(_ref7) {\n    var _ref8, signed, state, _a, _b;\n\n    return regenerator_default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref8 = locked_slicedToArray(_ref7, 2), signed = _ref8[0], state = _ref8[1];\n            assert(((_b = (_a = state.sent[secrethash].secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) || transfer.lock.expiration.gt(state.blockNumber), \'lock expired\');\n            assert(!state.sent[secrethash].channelClosed, \'channel closed!\');\n            _context2.next = 5;\n            return transferUnlock.success({\n              message: signed\n            }, action.meta);\n\n          case 5:\n          case "end":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  })));\n}\n/**\n * Create an observable to compose and sign a Unlock message/transferUnlock.success action\n * As it\'s an async observable which depends on state and may return an action which changes it,\n * the returned observable must be subscribed in a serialized context that ensures non-concurrent\n * write access to the channel\'s balance proof (e.g. concatMap)\n *\n * @param state$ - Observable of current state\n * @param action - transferUnlock.request request action to be sent\n * @param signer - RaidenEpicDeps members\n * @returns Observable of transferUnlock.success actions\n */\n\n\nfunction makeAndSignUnlock(state$, action, _ref9) {\n  var signer = _ref9.signer,\n      log = _ref9.log;\n  return state$.pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])(function (state) {\n    return makeAndSignUnlock$(state$, state, action, {\n      log: log,\n      signer: signer\n    });\n  }), Object(catchError["a" /* catchError */])(function (err) {\n    log.warn(\'Error trying to unlock after SecretReveal\', err);\n    return Object(of["a" /* of */])(transferUnlock.failure(err, action.meta));\n  }));\n}\n/**\n * Contains the core logic of {@link makeAndSignLockExpired}.\n *\n * @param state - Contains The current state of the app\n * @param action - The transfer expire action.\n * @param signer - RaidenEpicDeps members\n * @returns Observable of transferExpire.success actions\n */\n\n\nfunction makeAndSignLockExpired$(state, action, _ref10) {\n  var signer = _ref10.signer,\n      log = _ref10.log;\n  var secrethash = action.meta.secrethash;\n  assert(secrethash in state.sent, \'unknown transfer\');\n  var transfer = state.sent[secrethash].transfer[1];\n  var channel = lodash_get_default()(state.channels, [transfer.token_network_address, transfer.recipient]);\n  assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.open && channel.own.balanceProof, \'channel gone, not open or no balanceProof\');\n  var signed$;\n\n  if (state.sent[secrethash].lockExpired) {\n    // lockExpired already signed, use cached\n    signed$ = Object(of["a" /* of */])(state.sent[secrethash].lockExpired[1]);\n  } else {\n    assert(transfer.lock.expiration.lt(state.blockNumber), \'lock not yet expired\');\n    assert(!state.sent[secrethash].unlock, \'transfer already unlocked\');\n    var locksroot = getChannelLocksroot(channel, secrethash);\n    var message = {\n      type: MessageType.LOCK_EXPIRED,\n      message_identifier: makeMessageId(),\n      chain_id: transfer.chain_id,\n      token_network_address: transfer.token_network_address,\n      channel_identifier: transfer.channel_identifier,\n      nonce: nextNonce(channel.own.balanceProof),\n      transferred_amount: channel.own.balanceProof.transferredAmount,\n      locked_amount: channel.own.balanceProof.lockedAmount.sub(transfer.lock.amount),\n      locksroot: locksroot,\n      recipient: transfer.recipient,\n      secrethash: secrethash\n    };\n    signed$ = Object(from["a" /* from */])(signMessage(signer, message, {\n      log: log\n    }));\n  }\n\n  return signed$.pipe( // messageSend LockExpired handled by transferRetryMessageEpic\n  Object(map["a" /* map */])(function (signed) {\n    return transferExpire.success({\n      message: signed\n    }, action.meta);\n  }));\n}\n/**\n * Create an observable to compose and sign a LockExpired message/transferExpire.success action\n * As it\'s an async observable which depends on state and may return an action which changes it,\n * the returned observable must be subscribed in a serialized context that ensures non-concurrent\n * write access to the channel\'s balance proof (e.g. concatMap)\n *\n * @param state$ - Observable of current state\n * @param action - transfer request action to be sent\n * @param signer - RaidenEpicDeps members\n * @returns Observable of transferExpire.success|transferExpire.failure actions\n */\n\n\nfunction makeAndSignLockExpired(state$, action, _ref11) {\n  var log = _ref11.log,\n      signer = _ref11.signer;\n  return state$.pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])(function (state) {\n    return makeAndSignLockExpired$(state, action, {\n      signer: signer,\n      log: log\n    });\n  }), Object(catchError["a" /* catchError */])(function (err) {\n    return Object(of["a" /* of */])(transferExpire.failure(err, action.meta));\n  }));\n}\n\nfunction makeAndSignWithdrawConfirmation$(state, action, _ref12, cache) {\n  var log = _ref12.log,\n      signer = _ref12.signer;\n\n  var _a, _b;\n\n  var request = action.payload.message;\n  var channel = lodash_get_default()(state.channels, [action.meta.tokenNetwork, action.meta.partner]); // check channel is in valid state and requested total_withdraw is valid\n  // withdrawable amount is: total_withdraw <= partner.deposit + own.transferredAmount\n\n  assert(channel && channel.state === ChannelState.open && request.channel_identifier.eq(channel.id), \'channel gone or not open\');\n  assert(request.expiration.gt(state.blockNumber), \'WithdrawRequest expired\');\n  assert(request.total_withdraw.lte(channel.partner.deposit.add((_b = (_a = channel.own.balanceProof) === null || _a === void 0 ? void 0 : _a.transferredAmount) !== null && _b !== void 0 ? _b : constants["Zero"])), \'invalid total_withdraw, greater than partner.deposit + own.transferredAmount\');\n  var signed$;\n  var key = request.message_identifier.toString(); // compare WithdrawRequest and a possible signed WithdrawConfirmation\n\n  function compareReqConf(req, conf) {\n    if (!conf) return false;\n    var matchSet = pick_default()(conf, [\'token_network_address\', \'participant\', \'chain_id\', \'channel_identifier\', \'total_withdraw\', \'expiration\']);\n    return isMatchWith_default()(req, matchSet, function (objVal, othVal) {\n      return BigNumberC.is(objVal) ? objVal.eq(othVal) : BigNumberC.is(othVal) ? othVal.eq(objVal) : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      undefined;\n    });\n  }\n\n  var cached = cache.get(key); // ensure all parameters are equal the cached one before returning it, or else sign again\n\n  if (compareReqConf(request, cached)) {\n    signed$ = Object(of["a" /* of */])(cached);\n  } else {\n    var confirmation = {\n      type: MessageType.WITHDRAW_CONFIRMATION,\n      message_identifier: request.message_identifier,\n      chain_id: request.chain_id,\n      token_network_address: request.token_network_address,\n      channel_identifier: request.channel_identifier,\n      participant: request.participant,\n      total_withdraw: request.total_withdraw,\n      nonce: nextNonce(channel.own.balanceProof),\n      expiration: request.expiration\n    };\n    signed$ = Object(from["a" /* from */])(signMessage(signer, confirmation, {\n      log: log\n    })).pipe(Object(tap["a" /* tap */])(function (signed) {\n      return cache.put(key, signed);\n    }));\n  }\n\n  return signed$.pipe(Object(map["a" /* map */])(function (signed) {\n    return withdrawReceive.success({\n      message: signed\n    }, action.meta);\n  }));\n}\n/**\n * Create an observable to compose and sign a [[WithdrawConfirmation]] message\n *\n * Validate we\'re inside expiration timeout, channel exists and is open, and that total_withdraw is\n * less than or equal withdrawable amount (while we don\'t receive, partner.deposit +\n * own.transferredAmount).\n * We need it inside [[transferGenerateAndSignEnvelopeMessageEpic]] concatMap/lock because we read\n * and change the \'nonce\', even though WithdrawConfirmation doesn\'t carry a full balanceProof.\n * Also, instead of storing the messages in state and retrying, we just cache it and send cached\n * signed message on each received request.\n *\n * TODO: once we\'re able to receive transfers, instead of considering only own.transferredAmount,\n * we must also listen to ChannelWithdraw events, store it alongside pending withdraw requests and\n * take that into account before accepting a transfer and also total balance/capacity for accepting\n * a total_withdraw from a WithdrawRequest.\n *\n * @param state$ - Observable of current state\n * @param action - Withdraw request which caused this handling\n * @param signer - RaidenEpicDeps members\n * @param cache - A Map to store and reuse previously Signed<WithdrawConfirmation>\n * @returns Observable of transferExpire.success|transferExpire.failure actions\n */\n\n\nfunction makeAndSignWithdrawConfirmation(state$, action, _ref13, cache) {\n  var signer = _ref13.signer,\n      log = _ref13.log;\n  return state$.pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])(function (state) {\n    return makeAndSignWithdrawConfirmation$(state, action, {\n      log: log,\n      signer: signer\n    }, cache);\n  }), Object(catchError["a" /* catchError */])(function (err) {\n    log.warn(\'Error trying to handle WithdrawRequest, ignoring:\', err);\n    return empty["a" /* EMPTY */];\n  }));\n}\n\nfunction receiveTransferSigned(state$, action, _ref14) {\n  var address = _ref14.address,\n      log = _ref14.log,\n      network = _ref14.network,\n      signer = _ref14.signer,\n      config$ = _ref14.config$;\n  var secrethash = action.payload.message.lock.secrethash;\n  var meta = {\n    secrethash: secrethash,\n    direction: Direction.RECEIVED\n  };\n  return Object(combineLatest["a" /* combineLatest */])([state$, config$]).pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])(function (_ref15) {\n    var _ref16 = locked_slicedToArray(_ref15, 2),\n        state = _ref16[0],\n        _ref16$ = _ref16[1],\n        revealTimeout = _ref16$.revealTimeout,\n        caps = _ref16$.caps;\n\n    var _a, _b, _c, _d, _e, _f;\n\n    var transfer = action.payload.message;\n\n    if (secrethash in state.received) {\n      log.warn(\'transfer already present\', action.meta);\n      var msgId = transfer.message_identifier; // if transfer matches the stored one, re-send Processed once\n\n      if (state.received[secrethash].partner === action.meta.address && state.received[secrethash].transfer[1].message_identifier.eq(msgId)) {\n        // transferProcessed again will trigger messageSend.request\n        return Object(of["a" /* of */])(transferProcessed({\n          message: state.received[secrethash].transferProcessed[1]\n        }, meta));\n      } else return empty["a" /* EMPTY */];\n    } // full balance proof validation\n\n\n    var tokenNetwork = transfer.token_network_address;\n    var partner = action.meta.address;\n    var channel = (_a = state.channels[tokenNetwork]) === null || _a === void 0 ? void 0 : _a[partner];\n    assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.open, \'channel not found or not open\');\n    assert(transfer.chain_id.eq(network.chainId), \'chainId mismatch\');\n    assert(transfer.channel_identifier.eq(channel.id), \'channelId mismatch\');\n    assert(transfer.nonce.eq(nextNonce(channel.partner.balanceProof)), \'nonce mismatch\');\n    assert(transfer.transferred_amount.eq((_c = (_b = channel.partner.balanceProof) === null || _b === void 0 ? void 0 : _b.transferredAmount) !== null && _c !== void 0 ? _c : constants["Zero"]), \'transferredAmount mismatch\');\n    assert(transfer.locked_amount.eq(((_e = (_d = channel.partner.balanceProof) === null || _d === void 0 ? void 0 : _d.lockedAmount) !== null && _e !== void 0 ? _e : constants["Zero"]).add(transfer.lock.amount)), \'lockedAmount mismatch\');\n    var partnerCapacity = channelAmounts(channel).partnerCapacity;\n    assert(transfer.lock.amount.lte(partnerCapacity), \'balanceProof total amount bigger than capacity\');\n    assert(transfer.recipient === address, "Received transfer isn\'t for us");\n    assert(transfer.lock.expiration.sub(state.blockNumber).gt(revealTimeout), \'lock expires too soon\');\n    var locks = [].concat(locked_toConsumableArray((_f = channel.partner.locks) !== null && _f !== void 0 ? _f : []), [transfer.lock]);\n    var locksroot = getLocksroot(locks);\n    assert(transfer.locksroot === locksroot, \'locksroot mismatch\');\n    var token = findKey_default()(state.tokens, function (tn) {\n      return tn === tokenNetwork;\n    });\n    log.info(\'Receiving transfer of value\', transfer.lock.amount.toString(), \'of token\', token, \', from\', transfer.initiator, \', through partner\', partner);\n    var request$ = Object(of["a" /* of */])(undefined);\n    if (!(caps === null || caps === void 0 ? void 0 : caps[Capabilities.NO_RECEIVE]) && transfer.target === address) request$ = Object(defer["a" /* defer */])(function () {\n      var request = {\n        type: MessageType.SECRET_REQUEST,\n        payment_identifier: transfer.payment_identifier,\n        secrethash: secrethash,\n        amount: transfer.lock.amount,\n        expiration: transfer.lock.expiration,\n        message_identifier: makeMessageId()\n      };\n      return signMessage(signer, request, {\n        log: log\n      });\n    });\n    var processed$ = Object(defer["a" /* defer */])(function () {\n      var processed = {\n        type: MessageType.PROCESSED,\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        message_identifier: transfer.message_identifier\n      };\n      return signMessage(signer, processed, {\n        log: log\n      });\n    }); // if any of these signature prompts fail, none of these actions will be emitted\n\n    return Object(combineLatest["a" /* combineLatest */])([processed$, request$]).pipe(Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee3(_ref17) {\n      var _ref18, processed, request;\n\n      return regenerator_default.a.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _ref18 = locked_slicedToArray(_ref17, 2), processed = _ref18[0], request = _ref18[1];\n              _context3.next = 3;\n              return transferSigned({\n                message: transfer,\n                fee: constants["Zero"]\n              }, meta);\n\n            case 3:\n              _context3.next = 5;\n              return transferProcessed({\n                message: processed\n              }, meta);\n\n            case 5:\n              if (!request) {\n                _context3.next = 10;\n                break;\n              }\n\n              _context3.next = 8;\n              return matrixPresence.request(undefined, {\n                address: transfer.initiator\n              });\n\n            case 8:\n              _context3.next = 10;\n              return transferSecretRequest({\n                message: request\n              }, meta);\n\n            case 10:\n            case "end":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    })));\n  }), Object(catchError["a" /* catchError */])(function (err) {\n    return Object(of["a" /* of */])(actions_transfer.failure(err, meta));\n  }));\n}\n\nfunction receiveTransferUnlocked(state$, action, _ref19) {\n  var log = _ref19.log,\n      network = _ref19.network,\n      signer = _ref19.signer;\n  var secrethash = getSecrethash(action.payload.message.secret);\n  var meta = {\n    secrethash: secrethash,\n    direction: Direction.RECEIVED\n  };\n  return state$.pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])(function (state) {\n    var _a;\n\n    if (!(secrethash in state.received)) return empty["a" /* EMPTY */];\n    var received = state.received[secrethash];\n    var unlock = action.payload.message;\n    var partner = action.meta.address;\n    assert(partner === received.partner, \'wrong partner\');\n\n    if (received.unlock) {\n      log.warn(\'transfer already unlocked\', action.meta); // if message matches the stored one, re-send Processed once\n\n      if (received.unlockProcessed && received.unlockProcessed[1].message_identifier.eq(unlock.message_identifier)) {\n        // transferProcessed again will trigger messageSend.request\n        return Object(of["a" /* of */])(transferUnlockProcessed({\n          message: received.unlockProcessed[1]\n        }, meta));\n      } else return empty["a" /* EMPTY */];\n    }\n\n    var transf = received.transfer[1]; // unlock validation\n\n    var tokenNetwork = unlock.token_network_address;\n    assert(tokenNetwork === transf.token_network_address, \'wrong tokenNetwork\');\n    var channel = (_a = state.channels[tokenNetwork]) === null || _a === void 0 ? void 0 : _a[partner];\n    assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.open && channel.partner.balanceProof && channel.partner.locks, \'channel not found or not open\');\n    assert(unlock.chain_id.eq(network.chainId), \'chainId mismatch\');\n    assert(unlock.channel_identifier.eq(channel.id), \'channelId mismatch\');\n    assert(unlock.nonce.eq(nextNonce(channel.partner.balanceProof)), \'nonce mismatch\');\n    var lock = transf.lock;\n    var amount = lock.amount;\n    assert(unlock.transferred_amount.eq(channel.partner.balanceProof.transferredAmount.add(amount)), \'transferredAmount mismatch\');\n    assert(unlock.locked_amount.eq(channel.partner.balanceProof.lockedAmount.sub(amount)), \'lockedAmount mismatch\');\n    var locks = channel.partner.locks.filter(function (lock) {\n      return lock.secrethash !== secrethash;\n    });\n    var locksroot = getLocksroot(locks);\n    assert(unlock.locksroot === locksroot, \'locksroot mismatch\');\n    var processed = {\n      type: MessageType.PROCESSED,\n      // eslint-disable-next-line @typescript-eslint/camelcase\n      message_identifier: unlock.message_identifier\n    }; // if any of these signature prompts fail, none of these actions will be emitted\n\n    return Object(from["a" /* from */])(signMessage(signer, processed, {\n      log: log\n    })).pipe(Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee4(processed) {\n      return regenerator_default.a.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return transferUnlock.success({\n                message: unlock\n              }, meta);\n\n            case 2:\n              _context4.next = 4;\n              return transferUnlockProcessed({\n                message: processed\n              }, meta);\n\n            case 4:\n              _context4.next = 6;\n              return actions_transfer.success({\n                balanceProof: getBalanceProofFromEnvelopeMessage(unlock)\n              }, meta);\n\n            case 6:\n            case "end":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    })));\n  }), Object(catchError["a" /* catchError */])(function (err) {\n    log.warn(\'Error trying to process received Unlock\', err);\n    return Object(of["a" /* of */])(transferUnlock.failure(err, meta));\n  }));\n}\n\nfunction receiveTransferExpired(state$, action, _ref20) {\n  var log = _ref20.log,\n      network = _ref20.network,\n      signer = _ref20.signer,\n      config$ = _ref20.config$;\n  var secrethash = action.payload.message.secrethash;\n  var meta = {\n    secrethash: secrethash,\n    direction: Direction.RECEIVED\n  };\n  return Object(combineLatest["a" /* combineLatest */])([state$, config$]).pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])(function (_ref21) {\n    var _ref22 = locked_slicedToArray(_ref21, 2),\n        state = _ref22[0],\n        confirmationBlocks = _ref22[1].confirmationBlocks;\n\n    var _a, _b, _c;\n\n    if (!(secrethash in state.received)) return empty["a" /* EMPTY */];\n    var received = state.received[secrethash];\n    var expired = action.payload.message;\n    var partner = action.meta.address;\n    assert(partner === received.partner, \'wrong partner\');\n\n    if (received.lockExpired) {\n      log.warn(\'transfer already expired\', action.meta); // if message matches the stored one, re-send Processed once\n\n      if (received.lockExpiredProcessed && received.lockExpiredProcessed[1].message_identifier.eq(expired.message_identifier)) {\n        // transferProcessed again will trigger messageSend.request\n        return Object(of["a" /* of */])(transferExpireProcessed({\n          message: received.lockExpiredProcessed[1]\n        }, meta));\n      } else return empty["a" /* EMPTY */];\n    }\n\n    var transf = received.transfer[1]; // lockExpired validation\n\n    assert(transf.lock.expiration.add(confirmationBlocks).lte(state.blockNumber), \'expiration block not confirmed yet\');\n    assert(!received.unlock, \'transfer unlocked\');\n    assert(!((_b = (_a = received.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock), \'secret registered\');\n    var tokenNetwork = expired.token_network_address;\n    assert(tokenNetwork === transf.token_network_address, \'wrong tokenNetwork\');\n    var channel = (_c = state.channels[tokenNetwork]) === null || _c === void 0 ? void 0 : _c[partner];\n    assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.open && channel.partner.balanceProof && channel.partner.locks, \'channel not found or not open\');\n    assert(expired.chain_id.eq(network.chainId), \'chainId mismatch\');\n    assert(expired.channel_identifier.eq(channel.id), \'channelId mismatch\');\n    assert(expired.nonce.eq(nextNonce(channel.partner.balanceProof)), \'nonce mismatch\');\n    var lock = transf.lock;\n    var amount = lock.amount;\n    assert(expired.transferred_amount.eq(channel.partner.balanceProof.transferredAmount), \'transferredAmount mismatch\');\n    assert(expired.locked_amount.eq(channel.partner.balanceProof.lockedAmount.sub(amount)), \'lockedAmount mismatch\');\n    var locks = channel.partner.locks.filter(function (lock) {\n      return lock.secrethash !== secrethash;\n    });\n    var locksroot = getLocksroot(locks);\n    assert(expired.locksroot === locksroot, \'locksroot mismatch\');\n    var processed = {\n      type: MessageType.PROCESSED,\n      // eslint-disable-next-line @typescript-eslint/camelcase\n      message_identifier: expired.message_identifier\n    }; // if any of these signature prompts fail, none of these actions will be emitted\n\n    return Object(from["a" /* from */])(signMessage(signer, processed, {\n      log: log\n    })).pipe(Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee5(processed) {\n      return regenerator_default.a.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return transferExpire.success({\n                message: expired\n              }, meta);\n\n            case 2:\n              _context5.next = 4;\n              return transferExpireProcessed({\n                message: processed\n              }, meta);\n\n            case 4:\n              _context5.next = 6;\n              return actions_transfer.failure(new error_RaidenError(ErrorCodes.XFER_EXPIRED, {\n                block: transf.lock.expiration.toString()\n              }), meta);\n\n            case 6:\n            case "end":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    })));\n  }), Object(catchError["a" /* catchError */])(function (err) {\n    log.warn(\'Error trying to process received LockExpired\', err);\n    return Object(of["a" /* of */])(transferExpire.failure(err, meta));\n  }));\n}\n/**\n * Serialize creation and signing of BalanceProof-changing messages or actions\n * Actions which change any data in any channel balance proof must only ever be created reading\n * state inside the serialization flow provided by the concatMap, and also be composed and produced\n * inside it (inner, subscribed observable)\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps\n * @returns Observable of output actions for this epic\n */\n\n\nvar locked_transferGenerateAndSignEnvelopeMessageEpic = function transferGenerateAndSignEnvelopeMessageEpic(action$, _ref23, deps) {\n  locked_objectDestructuringEmpty(_ref23);\n\n  var withdrawCache = new LruCache(32);\n  var state$ = deps.latest$.pipe(pluckDistinct(\'state\')); // replayed(1)\' state$\n\n  return Object(merge["a" /* merge */])(action$.pipe(Object(filter["a" /* filter */])(isActionOf([actions_transfer.request, transferUnlock.request, transferExpire.request, withdrawReceive.request]))), // merge separatedly, to filter per message type before concat\n  action$.pipe(Object(filter["a" /* filter */])(isMessageReceivedOfType([Signed(LockedTransfer), Signed(Unlock), Signed(LockExpired)])))).pipe(Object(concatMap["a" /* concatMap */])(function (action) {\n    return actions_transfer.request.is(action) ? makeAndSignTransfer(state$, action, deps) : transferUnlock.request.is(action) ? makeAndSignUnlock(state$, action, deps) : transferExpire.request.is(action) ? makeAndSignLockExpired(state$, action, deps) : withdrawReceive.request.is(action) ? makeAndSignWithdrawConfirmation(state$, action, deps, withdrawCache) : action.payload.message.type === MessageType.LOCKED_TRANSFER ? receiveTransferSigned(state$, action, deps) : action.payload.message.type === MessageType.UNLOCK ? receiveTransferUnlocked(state$, action, deps) : receiveTransferExpired(state$, action, deps);\n  }));\n};\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/epics/init.js\n\n\nfunction init_slicedToArray(arr, i) { return init_arrayWithHoles(arr) || init_iterableToArrayLimit(arr, i) || init_unsupportedIterableToArray(arr, i) || init_nonIterableRest(); }\n\nfunction init_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction init_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return init_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return init_arrayLikeToArray(o, minLen); }\n\nfunction init_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction init_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction init_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction init_objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }\n\n\n\n\n\n\n\n/**\n * Re-queue pending transfer\'s BalanceProof/Envelope messages for retry on init\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferSigned|transferUnlock.success actions\n */\n\nvar init_initQueuePendingEnvelopeMessagesEpic = function initQueuePendingEnvelopeMessagesEpic(_ref, state$) {\n  init_objectDestructuringEmpty(_ref);\n\n  return state$.pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee(state) {\n    var _a, _b, _i, _Object$entries, _Object$entries$_i, key, sent, secrethash, meta;\n\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _i = 0, _Object$entries = Object.entries(state.sent);\n\n          case 1:\n            if (!(_i < _Object$entries.length)) {\n              _context.next = 21;\n              break;\n            }\n\n            _Object$entries$_i = init_slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], sent = _Object$entries$_i[1];\n            secrethash = key; // transfer already completed or channelClosed\n\n            if (!(sent.unlockProcessed || sent.lockExpiredProcessed || ((_b = (_a = sent.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) || sent.channelClosed)) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt("continue", 18);\n\n          case 6:\n            meta = {\n              secrethash: secrethash,\n              direction: Direction.SENT\n            }; // on init, request monitor presence of any pending transfer target\n\n            _context.next = 9;\n            return matrixPresence.request(undefined, {\n              address: sent.transfer[1].target\n            });\n\n          case 9:\n            if (sent.transferProcessed) {\n              _context.next = 12;\n              break;\n            }\n\n            _context.next = 12;\n            return transferSigned({\n              message: sent.transfer[1],\n              fee: sent.fee\n            }, meta);\n\n          case 12:\n            if (!sent.unlock) {\n              _context.next = 15;\n              break;\n            }\n\n            _context.next = 15;\n            return transferUnlock.success({\n              message: sent.unlock[1]\n            }, meta);\n\n          case 15:\n            if (!sent.lockExpired) {\n              _context.next = 18;\n              break;\n            }\n\n            _context.next = 18;\n            return transferExpire.success({\n              message: sent.lockExpired[1]\n            }, meta);\n\n          case 18:\n            _i++;\n            _context.next = 1;\n            break;\n\n          case 21:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })));\n};\n/**\n * Re-queue pending Received transfer\'s\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferSigned|transferUnlock.success actions\n */\n\nvar init_initQueuePendingReceivedEpic = function initQueuePendingReceivedEpic(_ref2, state$, _ref3) {\n  init_objectDestructuringEmpty(_ref2);\n\n  var config$ = _ref3.config$;\n  return state$.pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])(function (state) {\n    return Object(from["a" /* from */])(Object.entries(state.received));\n  }), Object(filter["a" /* filter */])(function (_ref4) {\n    var _ref5 = init_slicedToArray(_ref4, 2),\n        received = _ref5[1];\n\n    var _a, _b;\n\n    return !received.unlock && !received.lockExpired && !((_b = (_a = received.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) && !received.channelClosed;\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee2(_ref6) {\n    var _ref7, _ref7$, secrethash, received, caps, meta;\n\n    return regenerator_default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref7 = init_slicedToArray(_ref6, 2), _ref7$ = init_slicedToArray(_ref7[0], 2), secrethash = _ref7$[0], received = _ref7$[1], caps = _ref7[1].caps;\n            // loop over all pending transfers\n            meta = {\n              secrethash: secrethash,\n              direction: Direction.RECEIVED\n            }; // on init, request monitor presence of any pending transfer initiator\n\n            _context2.next = 4;\n            return transferSigned({\n              message: received.transfer[1],\n              fee: received.fee\n            }, meta);\n\n          case 4:\n            if (!(received.secret && !received.secretReveal)) {\n              _context2.next = 7;\n              break;\n            }\n\n            _context2.next = 7;\n            return transferSecret({\n              secret: received.secret[1].value\n            }, meta);\n\n          case 7:\n            if (!received.secretReveal) {\n              _context2.next = 10;\n              break;\n            }\n\n            _context2.next = 10;\n            return transferSecretReveal({\n              message: received.secretReveal[1]\n            }, meta);\n\n          case 10:\n            if (!(!(caps === null || caps === void 0 ? void 0 : caps[Capabilities.NO_RECEIVE]) && !received.secret && received.secretRequest)) {\n              _context2.next = 15;\n              break;\n            }\n\n            _context2.next = 13;\n            return matrixPresence.request(undefined, {\n              address: received.transfer[1].initiator\n            });\n\n          case 13:\n            _context2.next = 15;\n            return transferSecretRequest({\n              message: received.secretRequest[1]\n            }, meta);\n\n          case 15:\n          case "end":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  })));\n};\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/epics/mediate.js\nfunction mediate_slicedToArray(arr, i) { return mediate_arrayWithHoles(arr) || mediate_iterableToArrayLimit(arr, i) || mediate_unsupportedIterableToArray(arr, i) || mediate_nonIterableRest(); }\n\nfunction mediate_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction mediate_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return mediate_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return mediate_arrayLikeToArray(o, minLen); }\n\nfunction mediate_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction mediate_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction mediate_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n/**\n * When receiving a transfer not targeting us, create an outgoing transfer to target\n * Mediated transfers are handled the same way as unrelated received & sent pairs. The difference\n * is that we don\'t request the secret (as initiator would only reveal to target), and instead,\n * wait for SecretReveal to cascade back from outbound partner, then we unlock it and reveal back\n * to inbound partner, to get its Unlock.\n * If it doesn\'t succeed, if we didn\'t get reveal, we\'ll accept LockExpired, if we did and know\n * the secret but partner didn\'t unlock, we register on-chain as usual.\n *\n * @param action$ - Observable of incoming transferSigned transfers\n * @param state$ - Observable of RaidenStates\n * @param deps - Raiden epic deps\n * @returns Observable of outbound transfer.request actions\n */\n\nvar mediate_transferMediateEpic = function transferMediateEpic(action$, state$, _ref) {\n  var address = _ref.address,\n      config$ = _ref.config$;\n  return action$.pipe(Object(filter["a" /* filter */])(transferSigned.is), // filter for received transfers not to us\n  Object(filter["a" /* filter */])(function (action) {\n    return action.meta.direction === Direction.RECEIVED && action.payload.message.target !== address;\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(state$, config$), // filter when mediating is enabled and outgoing transfer isn\'t set\n  Object(filter["a" /* filter */])(function (_ref2) {\n    var _ref3 = mediate_slicedToArray(_ref2, 3),\n        action = _ref3[0],\n        sent = _ref3[1].sent,\n        caps = _ref3[2].caps;\n\n    return !(caps === null || caps === void 0 ? void 0 : caps[Capabilities.NO_MEDIATE]) && !(action.meta.secrethash in sent);\n  }), Object(map["a" /* map */])(function (_ref4) {\n    var _ref5 = mediate_slicedToArray(_ref4, 1),\n        _ref5$ = _ref5[0],\n        transf = _ref5$.payload.message,\n        secrethash = _ref5$.meta.secrethash;\n\n    return (// request an outbound transfer to target\n      actions_transfer.request({\n        tokenNetwork: transf.token_network_address,\n        target: transf.target,\n        value: transf.lock.amount,\n        paymentId: transf.payment_identifier,\n        paths: transf.metadata.routes.map(function (_ref6) {\n          var route = _ref6.route;\n          return {\n            path: route.slice(1),\n            fee: constants["Zero"]\n          };\n        }),\n        expiration: transf.lock.expiration.toNumber(),\n        initiator: transf.initiator\n      }, {\n        secrethash: secrethash,\n        direction: Direction.SENT\n      })\n    );\n  }));\n};\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/epics/processed.js\n\n\nfunction processed_objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }\n\nfunction processed_slicedToArray(arr, i) { return processed_arrayWithHoles(arr) || processed_iterableToArrayLimit(arr, i) || processed_unsupportedIterableToArray(arr, i) || processed_nonIterableRest(); }\n\nfunction processed_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction processed_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return processed_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return processed_arrayLikeToArray(o, minLen); }\n\nfunction processed_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction processed_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction processed_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Handles receiving a signed Processed for some sent LockedTransfer\n * This will persist the Processed reply in transfer state and stop message retry\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferProcessed actions\n */\n\nvar processed_transferProcessedReceivedEpic = function transferProcessedReceivedEpic(action$, state$) {\n  return action$.pipe(Object(filter["a" /* filter */])(isMessageReceivedOfType(Signed(Processed))), Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee(_ref) {\n    var _ref2, action, state, message, secrethash, _i2, _Object$entries, _Object$entries$_i, key, sent;\n\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref2 = processed_slicedToArray(_ref, 2), action = _ref2[0], state = _ref2[1];\n            message = action.payload.message;\n            secrethash = undefined;\n            _i2 = 0, _Object$entries = Object.entries(state.sent);\n\n          case 4:\n            if (!(_i2 < _Object$entries.length)) {\n              _context.next = 12;\n              break;\n            }\n\n            _Object$entries$_i = processed_slicedToArray(_Object$entries[_i2], 2), key = _Object$entries$_i[0], sent = _Object$entries$_i[1];\n\n            if (!(sent.transfer[1].message_identifier.eq(message.message_identifier) && sent.transfer[1].recipient === action.meta.address)) {\n              _context.next = 9;\n              break;\n            }\n\n            secrethash = key;\n            return _context.abrupt("break", 12);\n\n          case 9:\n            _i2++;\n            _context.next = 4;\n            break;\n\n          case 12:\n            if (secrethash) {\n              _context.next = 14;\n              break;\n            }\n\n            return _context.abrupt("return");\n\n          case 14:\n            _context.next = 16;\n            return transferProcessed({\n              message: message\n            }, {\n              secrethash: secrethash,\n              direction: Direction.SENT\n            });\n\n          case 16:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })));\n};\n/**\n * Handles sending Processed for a received EnvelopeMessages\n *\n * @param action$ - Observable of transferProcessed actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of messageSend.request actions\n */\n\nvar processed_transferProcessedSendEpic = function transferProcessedSendEpic(action$, state$) {\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf([transferProcessed, transferUnlockProcessed, transferExpireProcessed])), // transfer direction is RECEIVED, not message direction (which is outbound)\n  Object(filter["a" /* filter */])(function (action) {\n    return action.meta.direction === Direction.RECEIVED;\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(map["a" /* map */])(function (_ref3) {\n    var _ref4 = processed_slicedToArray(_ref3, 2),\n        action = _ref4[0],\n        received = _ref4[1].received;\n\n    return messageSend.request({\n      message: action.payload.message\n    }, {\n      address: received[action.meta.secrethash].partner,\n      msgId: action.payload.message.message_identifier.toString()\n    });\n  }));\n};\n/**\n * Handles receiving a signed Processed for some sent Unlock\n * It sends the success action for transfer (which resolves any pending Promise), marking it as\n * completed successfuly by setting sent.unlockProcessed\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transfer.success|transferUnlockProcessed actions\n */\n\nvar processed_transferUnlockProcessedReceivedEpic = function transferUnlockProcessedReceivedEpic(action$, state$) {\n  return action$.pipe(Object(filter["a" /* filter */])(isMessageReceivedOfType(Signed(Processed))), Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee2(_ref5) {\n    var _ref6, action, state, message, secrethash, meta;\n\n    return regenerator_default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref6 = processed_slicedToArray(_ref5, 2), action = _ref6[0], state = _ref6[1];\n            message = action.payload.message;\n            secrethash = findKey_default()(state.sent, function (sent) {\n              return sent.unlock && sent.unlock[1].message_identifier.eq(message.message_identifier) && sent.partner === action.meta.address;\n            });\n\n            if (secrethash) {\n              _context2.next = 5;\n              break;\n            }\n\n            return _context2.abrupt("return");\n\n          case 5:\n            meta = {\n              secrethash: secrethash,\n              direction: Direction.SENT\n            };\n            _context2.next = 8;\n            return actions_transfer.success({\n              balanceProof: getBalanceProofFromEnvelopeMessage(state.sent[secrethash].unlock[1])\n            }, meta);\n\n          case 8:\n            _context2.next = 10;\n            return transferUnlockProcessed({\n              message: message\n            }, meta);\n\n          case 10:\n          case "end":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  })));\n};\n/**\n * Handles receiving a signed Processed for some sent LockExpired\n * It marks the end of the unhappy case, by setting sent.lockExpiredProcessed\n * transfer.failure was already sent at newBlock handling/transferExpire.request time\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of output actions for this epic\n */\n\nvar processed_transferExpireProcessedEpic = function transferExpireProcessedEpic(action$, state$) {\n  return action$.pipe(Object(filter["a" /* filter */])(isMessageReceivedOfType(Signed(Processed))), Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee3(_ref7) {\n    var _ref8, action, state, message, secrethash;\n\n    return regenerator_default.a.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _ref8 = processed_slicedToArray(_ref7, 2), action = _ref8[0], state = _ref8[1];\n            message = action.payload.message;\n            secrethash = findKey_default()(state.sent, function (sent) {\n              return sent.lockExpired && sent.lockExpired[1].message_identifier.eq(message.message_identifier) && sent.partner === action.meta.address;\n            });\n\n            if (secrethash) {\n              _context3.next = 5;\n              break;\n            }\n\n            return _context3.abrupt("return");\n\n          case 5:\n            _context3.next = 7;\n            return transferExpireProcessed({\n              message: message\n            }, {\n              secrethash: secrethash,\n              direction: Direction.SENT\n            });\n\n          case 7:\n          case "end":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  })));\n};\n/**\n * Sends Processed for unhandled nonce\'d messages\n *\n * We don\'t yet support receiving nor mediating transfers (LockedTransfer, RefundTransfer), but\n * also don\'t want the partner to keep retrying any messages intended for us indefinitely.\n * That\'s why we decided to just answer them with Processed, to clear their queue. Of course, we\n * still don\'t validate, store state for these messages nor handle them in any way (e.g. requesting\n * secret from initiator), so any transfer is going to expire, and then we also reply Processed for\n * the respective LockExpired.\n * Additionally, we hook in sending Processed for other messages which contain nonces (and require\n * Processed reply to stop being retried) but are safe to be ignored, like WithdrawExpired.\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @param signer - RaidenEpicDeps members\n * @returns Observable of messageSend.request actions\n */\n\nvar processed_transferReceivedReplyProcessedEpic = function transferReceivedReplyProcessedEpic(action$, _ref9, _ref10) {\n  processed_objectDestructuringEmpty(_ref9);\n\n  var log = _ref10.log,\n      signer = _ref10.signer;\n  var cache = new LruCache(32);\n  return action$.pipe(Object(filter["a" /* filter */])(isMessageReceivedOfType([Signed(RefundTransfer), Signed(WithdrawExpired)])), Object(concatMap["a" /* concatMap */])(function (action) {\n    var message = action.payload.message; // defer causes the cache check to be performed at subscription time\n\n    return Object(defer["a" /* defer */])(function () {\n      var msgId = message.message_identifier;\n      var key = msgId.toString();\n      var cached = cache.get(key);\n      if (cached) return Object(of["a" /* of */])(messageSend.request({\n        message: cached\n      }, {\n        address: action.meta.address,\n        msgId: key\n      }));\n      var processed = {\n        type: MessageType.PROCESSED,\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        message_identifier: msgId\n      };\n      return Object(from["a" /* from */])(signMessage(signer, processed, {\n        log: log\n      })).pipe(Object(tap["a" /* tap */])(function (signed) {\n        return cache.put(key, signed);\n      }), Object(map["a" /* map */])(function (signed) {\n        return messageSend.request({\n          message: signed\n        }, {\n          address: action.meta.address,\n          msgId: key\n        });\n      }));\n    });\n  }));\n};\n// EXTERNAL MODULE: ./node_modules/lodash/isEqualWith.js\nvar isEqualWith = __webpack_require__("b6ad");\nvar isEqualWith_default = /*#__PURE__*/__webpack_require__.n(isEqualWith);\n\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/epics/refund.js\n\n\nfunction refund_slicedToArray(arr, i) { return refund_arrayWithHoles(arr) || refund_iterableToArrayLimit(arr, i) || refund_unsupportedIterableToArray(arr, i) || refund_nonIterableRest(); }\n\nfunction refund_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction refund_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return refund_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return refund_arrayLikeToArray(o, minLen); }\n\nfunction refund_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction refund_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction refund_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n // Compare two objects, using .eq for BigNumber properties\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nfunction bnIsEqual(obj, other) {\n  return isEqualWith_default()(obj, other, function (objVal, othVal) {\n    return BigNumberC.is(objVal) ? objVal.eq(othVal) : BigNumberC.is(othVal) ? othVal.eq(objVal) : undefined;\n  });\n}\n/**\n * Receiving RefundTransfer for pending transfer fails it\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transfer.failure|transferRefunded actions\n */\n\n\nvar refund_transferRefundedEpic = function transferRefundedEpic(action$, state$) {\n  return action$.pipe(Object(filter["a" /* filter */])(isMessageReceivedOfType(Signed(RefundTransfer))), Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee(_ref) {\n    var _ref2, action, state, message, secrethash, sent, transf, meta;\n\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref2 = refund_slicedToArray(_ref, 2), action = _ref2[0], state = _ref2[1];\n            message = action.payload.message;\n            secrethash = message.lock.secrethash;\n\n            if (secrethash in state.sent) {\n              _context.next = 5;\n              break;\n            }\n\n            return _context.abrupt("return");\n\n          case 5:\n            sent = state.sent[secrethash], transf = sent.transfer[1];\n\n            if (!(message.initiator !== transf.recipient || !message.payment_identifier.eq(transf.payment_identifier) || !bnIsEqual(message.lock, transf.lock))) {\n              _context.next = 8;\n              break;\n            }\n\n            return _context.abrupt("return");\n\n          case 8:\n            if (!(sent.unlock || // already unlocked\n            sent.lockExpired || // already expired\n            sent.channelClosed || // channel closed\n            transf.lock.expiration.lte(state.blockNumber) // lock expired but transfer didn\'t yet\n            )) {\n              _context.next = 10;\n              break;\n            }\n\n            return _context.abrupt("return");\n\n          case 10:\n            meta = {\n              secrethash: secrethash,\n              direction: Direction.SENT\n            };\n            _context.next = 13;\n            return transferRefunded({\n              message: message\n            }, meta);\n\n          case 13:\n            _context.next = 15;\n            return actions_transfer.failure(new error_RaidenError(ErrorCodes.XFER_REFUNDED), meta);\n\n          case 15:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })));\n};\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/epics/retry.js\nfunction retry_objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }\n\nfunction retry_slicedToArray(arr, i) { return retry_arrayWithHoles(arr) || retry_iterableToArrayLimit(arr, i) || retry_unsupportedIterableToArray(arr, i) || retry_nonIterableRest(); }\n\nfunction retry_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction retry_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return retry_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return retry_arrayLikeToArray(o, minLen); }\n\nfunction retry_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction retry_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction retry_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n\n\n\n\n\n\n\n\nfunction repeatUntil(notifier) {\n  var delayMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30e3;\n  // Resubscribe/retry every 30s after messageSend succeeds\n  // Notice first (or any) messageSend.request can wait for a long time before succeeding, as it\n  // waits for address\'s user in transport to be online and joined room before actually\n  // sending the message. That\'s why repeatWhen emits/resubscribe only some time after\n  // sendOnceAndWaitSent$ completes, instead of a plain \'interval\'\n  return function (input$) {\n    return input$.pipe(Object(repeatWhen["a" /* repeatWhen */])(function (completed$) {\n      return completed$.pipe(Object(delay["a" /* delay */])(delayMs));\n    }), Object(takeUntil["a" /* takeUntil */])(notifier));\n  };\n}\n\nfunction retrySendUntil$(send, action$, notifier) {\n  var delayMs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30e3;\n  return dispatchAndWait$(action$, send, isResponseOf(messageSend, send.meta)).pipe(repeatUntil(notifier, delayMs));\n}\n/**\n * Handles a transferSigned action and retry messageSend.request until transfer is gone (completed\n * with success or error) OR Processed message for LockedTransfer received.\n * transferSigned for pending LockedTransfer\'s may be re-emitted on startup for pending transfer,\n * to start retrying sending the message again until stop condition is met.\n *\n * @param action$ - Observable of transferSigned actions\n * @param state$ - Observable of latest RaidenStates\n * @param config$ - Observable of latest RaidenConfig\n * @param action - The {@link transferSigned} action\n * @returns - Observable of {@link messageSend.request} actions\n */\n\n\nvar retry_signedRetryMessage$ = function signedRetryMessage$(action$, state$, config$, action) {\n  if (action.meta.direction !== Direction.SENT) return empty["a" /* EMPTY */];\n  return config$.pipe(Object(first["a" /* first */])(), Object(switchMap["a" /* switchMap */])(function (_ref) {\n    var httpTimeout = _ref.httpTimeout;\n    var secrethash = action.meta.secrethash;\n    var signed = action.payload.message;\n    var send = messageSend.request({\n      message: signed\n    }, {\n      address: signed.recipient,\n      msgId: signed.message_identifier.toString()\n    });\n    var notifier = state$.pipe(pluckDistinct(\'sent\', secrethash), Object(filter["a" /* filter */])(function (sent) {\n      return !!(sent.transferProcessed || sent.unlockProcessed || sent.lockExpiredProcessed || sent.channelClosed);\n    })); // emit request once immediatelly, then wait until success, then retry every 30s\n\n    return retrySendUntil$(send, action$, notifier, httpTimeout);\n  }));\n};\n/**\n * Handles a transferUnlock.success action and retry messageSend until confirmed.\n * transferUnlock.success for pending Unlock\'s may be re-emitted on startup for pending transfer, to\n * start retrying sending the message again until stop condition is met.\n *\n * @param action$ - Observable of transferUnlock.success actions\n * @param state$ - Observable of the latest RaidenStates\n * @param config$ - Observable of latest RaidenConfig\n * @param action - the transferUnlock.success action\n * @returns Observable of {@link messageSend.request} actions\n */\n\n\nvar retry_unlockedRetryMessage$ = function unlockedRetryMessage$(action$, state$, config$, action) {\n  if (action.meta.direction !== Direction.SENT) return empty["a" /* EMPTY */];\n  return state$.pipe(Object(first["a" /* first */])(), Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(switchMap["a" /* switchMap */])(function (_ref2) {\n    var _ref3 = retry_slicedToArray(_ref2, 2),\n        state = _ref3[0],\n        httpTimeout = _ref3[1].httpTimeout;\n\n    var secrethash = action.meta.secrethash;\n    var unlock = action.payload.message;\n    var transfer = state.sent[secrethash].transfer[1];\n    var send = messageSend.request({\n      message: unlock\n    }, {\n      address: transfer.recipient,\n      msgId: unlock.message_identifier.toString()\n    });\n    var notifier = state$.pipe(pluckDistinct(\'sent\', secrethash), Object(filter["a" /* filter */])(function (sent) {\n      return !!(sent.unlockProcessed || sent.channelClosed);\n    })); // emit request once immediatelly, then wait until respective success,\n    // then repeats until confirmed\n\n    return retrySendUntil$(send, action$, notifier, httpTimeout);\n  }));\n};\n/**\n * Handles a transferExpire.success action and retry messageSend.request until transfer is gone (completed\n * with success or error).\n * transferExpire.success for pending LockExpired\'s may be re-emitted on startup for pending transfer, to\n * start retrying sending the message again until stop condition is met.\n *\n * @param action$ - Observable of transferUnlock.success actions\n * @param state$ - Observable of latest RaidenState\n * @param config$ - Observable of latest RaidenConfig\n * @param action - transferExpire.success action\n * @returns Observable of {@link messageSend.request} actions\n */\n\n\nvar retry_expiredRetryMessages$ = function expiredRetryMessages$(action$, state$, config$, action) {\n  if (action.meta.direction !== Direction.SENT) return empty["a" /* EMPTY */];\n  return state$.pipe(Object(first["a" /* first */])(), Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(switchMap["a" /* switchMap */])(function (_ref4) {\n    var _ref5 = retry_slicedToArray(_ref4, 2),\n        state = _ref5[0],\n        httpTimeout = _ref5[1].httpTimeout;\n\n    var secrethash = action.meta.secrethash;\n    var lockExpired = action.payload.message;\n    var send = messageSend.request({\n      message: lockExpired\n    }, {\n      address: state.sent[secrethash].transfer[1].recipient,\n      msgId: lockExpired.message_identifier.toString()\n    });\n    var notifier = state$.pipe(pluckDistinct(\'sent\', secrethash), Object(filter["a" /* filter */])(function (sent) {\n      return !!(sent.lockExpiredProcessed || sent.channelClosed);\n    })); // emit request once immediatelly, then wait until respective success,\n    // then retries until confirmed\n\n    return retrySendUntil$(send, action$, notifier, httpTimeout);\n  }));\n};\n\nvar retry_secretRequestRetryMessage$ = function secretRequestRetryMessage$(action$, state$, config$, action) {\n  if (action.meta.direction !== Direction.RECEIVED) return empty["a" /* EMPTY */];\n  return state$.pipe(Object(first["a" /* first */])(), Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(switchMap["a" /* switchMap */])(function (_ref6) {\n    var _ref7 = retry_slicedToArray(_ref6, 2),\n        state = _ref7[0],\n        httpTimeout = _ref7[1].httpTimeout;\n\n    var secrethash = action.meta.secrethash;\n    var request = action.payload.message;\n    var send = messageSend.request({\n      message: request\n    }, {\n      address: state.received[secrethash].transfer[1].initiator,\n      msgId: request.message_identifier.toString()\n    });\n    var notifier = state$.pipe(pluckDistinct(\'received\', secrethash), // stop retrying when we\'ve signed secretReveal, lock expired or channel closed\n    // we could stop as soon as we know received.secret, but we use it to retry SecretReveal\n    // signature, if it failed for any reason\n    Object(filter["a" /* filter */])(function (received) {\n      return !!(received.secretReveal || received.lockExpired || received.channelClosed);\n    })); // emit request once immediatelly, then wait until respective success,\n    // then retries until confirmed\n\n    return retrySendUntil$(send, action$, notifier, httpTimeout);\n  }));\n};\n\nvar retry_secretRevealRetryMessage$ = function secretRevealRetryMessage$(action$, state$, config$, action) {\n  if (action.meta.direction !== Direction.RECEIVED) return empty["a" /* EMPTY */];\n  return state$.pipe(Object(first["a" /* first */])(), Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(switchMap["a" /* switchMap */])(function (_ref8) {\n    var _ref9 = retry_slicedToArray(_ref8, 2),\n        state = _ref9[0],\n        httpTimeout = _ref9[1].httpTimeout;\n\n    var secrethash = action.meta.secrethash;\n    var reveal = action.payload.message;\n    var send = messageSend.request({\n      message: reveal\n    }, {\n      address: state.received[secrethash].partner,\n      msgId: reveal.message_identifier.toString()\n    });\n    var notifier = state$.pipe(pluckDistinct(\'received\', secrethash), // stop retrying when we were unlocked, secret registered or channel closed\n    // we don\'t test for lockExpired, as we know the secret and must not accept LockExpired\n    Object(filter["a" /* filter */])(function (received) {\n      var _a, _b;\n\n      return !!(received.unlock || ((_b = (_a = received.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) || received.channelClosed);\n    })); // emit request once immediatelly, then wait until respective success,\n    // then retries until confirmed\n\n    return retrySendUntil$(send, action$, notifier, httpTimeout);\n  }));\n};\n/**\n * Retry sending balance proof messages until their respective Processed\n *\n * @param action$ - Observable of transferExpire.success actions\n * @param state$ - Observable of RaidenStates\n * @param latest$ - RaidenEpicDeps latest\n * @returns Observable of messageSend.request actions\n */\n\n\nvar retry_transferRetryMessageEpic = function transferRetryMessageEpic(action$, _ref10, _ref11) {\n  retry_objectDestructuringEmpty(_ref10);\n\n  var latest$ = _ref11.latest$,\n      config$ = _ref11.config$;\n  var state$ = latest$.pipe(pluckDistinct(\'state\'));\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf([transferSigned, transferUnlock.success, transferExpire.success, transferSecretRequest, transferSecretReveal])), Object(mergeMap["a" /* mergeMap */])(function (action) {\n    return transferSigned.is(action) ? retry_signedRetryMessage$(action$, state$, config$, action) : transferUnlock.success.is(action) ? retry_unlockedRetryMessage$(action$, state$, config$, action) : transferExpire.success.is(action) ? retry_expiredRetryMessages$(action$, state$, config$, action) : transferSecretRequest.is(action) ? retry_secretRequestRetryMessage$(action$, state$, config$, action) : retry_secretRevealRetryMessage$(action$, state$, config$, action);\n  }));\n};\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/epics/secret.js\n\n\nfunction secret_objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }\n\nfunction secret_slicedToArray(arr, i) { return secret_arrayWithHoles(arr) || secret_iterableToArrayLimit(arr, i) || secret_unsupportedIterableToArray(arr, i) || secret_nonIterableRest(); }\n\nfunction secret_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction secret_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return secret_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return secret_arrayLikeToArray(o, minLen); }\n\nfunction secret_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction secret_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction secret_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Handles receiving a signed SecretRequest from target for some sent LockedTransfer\n * Emits a transferSecretRequest action only if all conditions are met\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferSecretRequest actions\n */\n\nvar secret_transferSecretRequestedEpic = function transferSecretRequestedEpic(action$, state$, _ref) {\n  var address = _ref.address,\n      log = _ref.log;\n  return action$.pipe(Object(filter["a" /* filter */])(isMessageReceivedOfType(Signed(SecretRequest))), Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee(_ref2) {\n    var _ref3, action, state, message, transfer;\n\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref3 = secret_slicedToArray(_ref2, 2), action = _ref3[0], state = _ref3[1];\n            message = action.payload.message; // proceed only if we know the secret and the SENT transfer\n\n            if (message.secrethash in state.sent) {\n              _context.next = 4;\n              break;\n            }\n\n            return _context.abrupt("return");\n\n          case 4:\n            transfer = state.sent[message.secrethash].transfer[1]; // we do only some basic verification here, as most of it is done upon SecretReveal,\n            // to persist the request in most cases in TransferState.secretRequest\n\n            if (!(transfer.initiator !== address || // only the initiator may reply a SecretRequest\n            transfer.target !== action.meta.address || // reveal only to target\n            !transfer.payment_identifier.eq(message.payment_identifier))) {\n              _context.next = 8;\n              break;\n            }\n\n            log.warn(\'Invalid SecretRequest for transfer\', message, transfer);\n            return _context.abrupt("return");\n\n          case 8:\n            _context.next = 10;\n            return transferSecretRequest({\n              message: message\n            }, {\n              secrethash: message.secrethash,\n              direction: Direction.SENT\n            });\n\n          case 10:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })));\n};\n/**\n * Contains the core logic of {@link transferSecretRevealEpic}.\n *\n * @param state - Contains the current state of the app\n * @param action - The {@link transferSecretRequest} action that\n * @param signer - The singer that will sign the message\n * @returns Observable of {@link transfer.failure}, {@link transferSecretReveal} or\n *      {@link messageSend.request} actions\n */\n\nvar secret_secretReveal$ = function secretReveal$(state, action, _ref4) {\n  var signer = _ref4.signer,\n      log = _ref4.log;\n\n  var _a;\n\n  var request = action.payload.message;\n  var secrethash = action.meta.secrethash;\n\n  if (!((_a = state.sent[secrethash]) === null || _a === void 0 ? void 0 : _a.secret)) {\n    // shouldn\'t happen, as we\'re the initiator (for now), and always know the secret\n    log.warn(\'SecretRequest for unknown secret\', request, secrethash);\n    return empty["a" /* EMPTY */];\n  }\n\n  var transf = state.sent[secrethash].transfer[1];\n  var target = transf.target;\n  var fee = state.sent[secrethash].fee;\n  var value = transf.lock.amount.sub(fee);\n\n  if (!request.expiration.lte(transf.lock.expiration) || !request.expiration.gt(state.blockNumber)) {\n    log.error(\'SecretRequest for expired transfer\', request, transf);\n    return empty["a" /* EMPTY */];\n  } else if (request.amount.lt(value)) {\n    log.error(\'SecretRequest for amount too small!\', request, transf);\n    return Object(of["a" /* of */])(actions_transfer.failure(new error_RaidenError(ErrorCodes.XFER_INVALID_SECRETREQUEST), action.meta));\n  } else if (!request.amount.eq(value)) {\n    // accept request\n    log.info(\'Accepted SecretRequest for amount different than sent\', request, transf);\n  }\n\n  var reveal$;\n  if (state.sent[action.meta.secrethash].secretReveal) reveal$ = Object(of["a" /* of */])(state.sent[action.meta.secrethash].secretReveal[1]);else {\n    var message = {\n      type: MessageType.SECRET_REVEAL,\n      // eslint-disable-next-line @typescript-eslint/camelcase\n      message_identifier: makeMessageId(),\n      secret: state.sent[action.meta.secrethash].secret[1].value\n    };\n    reveal$ = Object(from["a" /* from */])(signMessage(signer, message, {\n      log: log\n    }));\n  }\n  return reveal$.pipe(Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee2(message) {\n    return regenerator_default.a.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return transferSecretReveal({\n              message: message\n            }, action.meta);\n\n          case 2:\n            _context2.next = 4;\n            return messageSend.request({\n              message: message\n            }, {\n              address: target,\n              msgId: message.message_identifier.toString()\n            });\n\n          case 4:\n          case "end":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  })));\n};\n/**\n * Handles a transferSecretRequest action to send the respective secret to target\n * It both emits transferSecretReveal (to persist sent SecretReveal in state and indicate that\n * the secret was revealed and thus the transfer should be assumed as succeeded) as well as\n * triggers sending the message once. New SecretRequests will cause a new transferSecretRequest,\n * which will re-send the cached SecretReveal.\n * transfer.failure is emitted in case invalid secretRequest comes, as no valid one will come as\n * per current implementation, so we fail early to notify users about it.\n *\n * @param action$ - Observable of transferSecretRequest actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps\n * @param deps.signer - RaidenEpicDeps signer\n * @param deps.latest$ - RaidenEpicDeps latest$\n * @returns Observable of transfer.failure|transferSecretReveal|messageSend.request actions\n */\n\n\nvar secret_transferSecretRevealEpic = function transferSecretRevealEpic(action$, _ref5, _ref6) {\n  secret_objectDestructuringEmpty(_ref5);\n\n  var log = _ref6.log,\n      signer = _ref6.signer,\n      latest$ = _ref6.latest$;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(transferSecretRequest)), Object(filter["a" /* filter */])(function (action) {\n    return action.meta.direction === Direction.SENT;\n  }), Object(concatMap["a" /* concatMap */])(function (action) {\n    return latest$.pipe(pluckDistinct(\'state\')).pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])(function (state) {\n      return secret_secretReveal$(state, action, {\n        log: log,\n        signer: signer\n      });\n    }));\n  }));\n};\n/**\n * Handles receiving a valid SecretReveal from recipient (neighbor/partner)\n * This indicates that the partner knowws the secret, and we should Unlock to avoid going on-chain.\n * The transferUnlock.request action is a request for the unlocking to be generated and sent.\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of output actions for this epic\n */\n\nvar secret_transferSecretRevealedEpic = function transferSecretRevealedEpic(action$, state$) {\n  return action$.pipe( // we don\'t require Signed SecretReveal, nor even check sender for persisting the secret\n  Object(filter["a" /* filter */])(isMessageReceivedOfType(SecretReveal)), Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee3(_ref7) {\n    var _ref8, action, state, message, secrethash, meta;\n\n    return regenerator_default.a.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _ref8 = secret_slicedToArray(_ref7, 2), action = _ref8[0], state = _ref8[1];\n            message = action.payload.message;\n            secrethash = getSecrethash(message.secret);\n\n            if (!(secrethash in state.sent)) {\n              _context3.next = 10;\n              break;\n            }\n\n            meta = {\n              secrethash: secrethash,\n              direction: Direction.SENT\n            }; // if secrethash matches, we\'re good for persisting\n\n            _context3.next = 7;\n            return transferSecret({\n              secret: message.secret\n            }, meta);\n\n          case 7:\n            if (!(action.meta.address === state.sent[secrethash].partner && // don\'t unlock if channel closed\n            !state.sent[secrethash].channelClosed && // don\'t unlock again if already unlocked, retry handled by transferRetryMessageEpic\n            // in the future, we may avoid retry until Processed, and [re]send once per SecretReveal\n            !state.sent[secrethash].unlock // accepts secretReveal/unlock request even if registered on-chain\n            )) {\n              _context3.next = 10;\n              break;\n            }\n\n            _context3.next = 10;\n            return transferUnlock.request(undefined, meta);\n\n          case 10:\n            if (!(secrethash in state.received)) {\n              _context3.next = 13;\n              break;\n            }\n\n            _context3.next = 13;\n            return transferSecret({\n              secret: message.secret\n            }, {\n              secrethash: secrethash,\n              direction: Direction.RECEIVED\n            });\n\n          case 13:\n          case "end":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  })));\n};\n/**\n * For a received transfer, when we know the secret, sign & send a SecretReveal to previous hop\n *\n * @param action$ - Observable of transferSecret|transferSecretReveal actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps\n * @returns Observable of transferSecretReveal actions\n */\n\nvar secret_transferRequestUnlockEpic = function transferRequestUnlockEpic(action$, _ref9, _ref10) {\n  secret_objectDestructuringEmpty(_ref9);\n\n  var log = _ref10.log,\n      signer = _ref10.signer,\n      latest$ = _ref10.latest$;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf([transferSecret, transferSecretRegister.success])), Object(filter["a" /* filter */])(function (action) {\n    return action.meta.direction === Direction.RECEIVED;\n  }), Object(concatMap["a" /* concatMap */])(function (action) {\n    return latest$.pipe(pluckDistinct(\'state\'), Object(first["a" /* first */])(), Object(filter["a" /* filter */])(function (_ref11) {\n      var received = _ref11.received;\n\n      var _a;\n\n      return !((_a = received[action.meta.secrethash]) === null || _a === void 0 ? void 0 : _a.secretReveal);\n    }), Object(mergeMap["a" /* mergeMap */])(function () {\n      var message = {\n        type: MessageType.SECRET_REVEAL,\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        message_identifier: makeMessageId(),\n        secret: action.payload.secret\n      };\n      return signMessage(signer, message, {\n        log: log\n      });\n    }), Object(map["a" /* map */])(function (message) {\n      return transferSecretReveal({\n        message: message\n      }, action.meta);\n    }), Object(catchError["a" /* catchError */])(function (err) {\n      log.warn(\'Error trying to sign SecretReveal - ignoring\', err, action.meta);\n      return empty["a" /* EMPTY */];\n    }));\n  }));\n};\n/**\n * Monitors SecretRegistry and emits when a relevant secret gets registered\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferSecretRegister.success actions\n */\n\nvar secret_monitorSecretRegistryEpic = function monitorSecretRegistryEpic(_ref12, state$, _ref13) {\n  secret_objectDestructuringEmpty(_ref12);\n\n  var secretRegistryContract = _ref13.secretRegistryContract;\n  return getEventsStream(secretRegistryContract, [secretRegistryContract.filters.SecretRevealed(null, null)]).pipe(Object(withLatestFrom["a" /* withLatestFrom */])(state$), Object(filter["a" /* filter */])(function (_ref14) {\n    var _ref15 = secret_slicedToArray(_ref14, 2),\n        _ref15$ = secret_slicedToArray(_ref15[0], 3),\n        secrethash = _ref15$[0],\n        blockNumber = _ref15$[2].blockNumber,\n        _ref15$2 = _ref15[1],\n        sent = _ref15$2.sent,\n        received = _ref15$2.received;\n\n    return (// emits only if lock didn\'t expire yet\n      secrethash in sent && sent[secrethash].transfer[1].lock.expiration.gte(blockNumber) || secrethash in received && received[secrethash].transfer[1].lock.expiration.gte(blockNumber)\n    );\n  }), Object(mergeMap["a" /* mergeMap */])( /*#__PURE__*/regenerator_default.a.mark(function _callee4(_ref16) {\n    var _ref17, _ref17$, secrethash, secret, event, _ref17$2, sent, received;\n\n    return regenerator_default.a.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _ref17 = secret_slicedToArray(_ref16, 2), _ref17$ = secret_slicedToArray(_ref17[0], 3), secrethash = _ref17$[0], secret = _ref17$[1], event = _ref17$[2], _ref17$2 = _ref17[1], sent = _ref17$2.sent, received = _ref17$2.received;\n\n            if (!(secrethash in sent && sent[secrethash].transfer[1].lock.expiration.gte(event.blockNumber))) {\n              _context4.next = 4;\n              break;\n            }\n\n            _context4.next = 4;\n            return transferSecretRegister.success({\n              secret: secret,\n              txHash: event.transactionHash,\n              txBlock: event.blockNumber,\n              confirmed: undefined\n            }, {\n              secrethash: secrethash,\n              direction: Direction.SENT\n            });\n\n          case 4:\n            if (!(secrethash in received && received[secrethash].transfer[1].lock.expiration.gte(event.blockNumber))) {\n              _context4.next = 7;\n              break;\n            }\n\n            _context4.next = 7;\n            return transferSecretRegister.success({\n              secret: secret,\n              txHash: event.transactionHash,\n              txBlock: event.blockNumber,\n              confirmed: undefined\n            }, {\n              secrethash: secrethash,\n              direction: Direction.RECEIVED\n            });\n\n          case 7:\n          case "end":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  })));\n};\n/**\n * A simple epic to emit transfer.success when secret register is confirmed\n *\n * @param action$ - Observable of transferSecretRegister.success actions\n * @returns Observable of transfer.success actions\n */\n\nvar secret_transferSuccessOnSecretRegisteredEpic = function transferSuccessOnSecretRegisteredEpic(action$) {\n  return action$.pipe(Object(filter["a" /* filter */])(transferSecretRegister.success.is), Object(filter["a" /* filter */])(function (action) {\n    return !!action.payload.confirmed;\n  }), Object(map["a" /* map */])(function (action) {\n    return actions_transfer.success({}, action.meta);\n  }));\n};\n/**\n * Process newBlocks and pending received transfers. If we know the secret, and transfer doesn\'t\n * get unlocked before revealTimeout blocks are left to lock expiration, request to register secret\n * TODO: check economic viability (and define what that means) of registering lock on-chain\n *\n * @param action$ - Observable of newBlock actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferSecretRegister.request actions\n */\n\nvar secret_transferAutoRegisterEpic = function transferAutoRegisterEpic(action$, state$, _ref18) {\n  var config$ = _ref18.config$,\n      latest$ = _ref18.latest$;\n  return state$.pipe(pluckDistinct(Direction.RECEIVED), Object(mergeMap["a" /* mergeMap */])(function (received) {\n    return Object(from["a" /* from */])(Object.keys(received));\n  }), Object(distinct["a" /* distinct */])(), Object(mergeMap["a" /* mergeMap */])(function (secrethash) {\n    return action$.pipe(Object(filter["a" /* filter */])(newBlock.is), Object(withLatestFrom["a" /* withLatestFrom */])(latest$.pipe(Object(pluck["a" /* pluck */])(\'state\', Direction.RECEIVED, secrethash)), config$), Object(filter["a" /* filter */])(function (_ref19) {\n      var _ref20 = secret_slicedToArray(_ref19, 3),\n          action = _ref20[0],\n          received = _ref20[1],\n          _ref20$ = _ref20[2],\n          caps = _ref20$.caps,\n          revealTimeout = _ref20$.revealTimeout;\n\n      var _a, _b;\n\n      return !(caps === null || caps === void 0 ? void 0 : caps[Capabilities.NO_RECEIVE]) && // ignore if receiving is disabled\n      !!received.secret && // register only if we know the secret\n      received.transfer[1].lock.expiration.sub(revealTimeout).lt(action.payload.blockNumber) && // and after <revealTimeout left to expiration\n      !((_b = (_a = received.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) && // and not yet registered nor unlocked\n      !received.unlock;\n    }), Object(exhaustMap["a" /* exhaustMap */])(function (_ref21) {\n      var _ref22 = secret_slicedToArray(_ref21, 2),\n          received = _ref22[1];\n\n      var meta = {\n        secrethash: secrethash,\n        direction: Direction.RECEIVED\n      };\n      return dispatchAndWait$(action$, transferSecretRegister.request({\n        secret: received.secret[1].value\n      }, meta), isConfirmationResponseOf(transferSecretRegister, meta));\n    }), Object(takeUntil["a" /* takeUntil */])(latest$.pipe(pluckDistinct(\'state\'), Object(filter["a" /* filter */])(function (state) {\n      var _a, _b;\n\n      var blockNumber = state.blockNumber;\n      var received = state.received[secrethash];\n      var expiration = received.transfer[1].lock.expiration;\n      return !!(expiration.lt(blockNumber) || // give up if lock already expired\n      received.unlock || ((_b = (_a = // stop if secret got registered or unlocked\n      received.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock)); // even if channelClosed, while inside lock expiration, continue to try to register\n    }))));\n  }));\n};\n/**\n * Registers secret on-chain. Success is detected by monitorSecretRegistryEpic\n *\n * @param action$ - Observable of transferSecretRegister.request actions\n * @param state$ - Observable of RaidenStates\n * @param deps - Dependencies\n * @returns Observable of transferSecretRegister.failure actions\n */\n\nvar secret_transferSecretRegisterEpic = function transferSecretRegisterEpic(action$, _ref23, _ref24) {\n  secret_objectDestructuringEmpty(_ref23);\n\n  var log = _ref24.log,\n      signer = _ref24.signer,\n      address = _ref24.address,\n      main = _ref24.main,\n      secretRegistryContract = _ref24.secretRegistryContract,\n      config$ = _ref24.config$;\n  return action$.pipe(Object(filter["a" /* filter */])(transferSecretRegister.request.is), Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(mergeMap["a" /* mergeMap */])(function (_ref25) {\n    var _ref26 = secret_slicedToArray(_ref25, 2),\n        action = _ref26[0],\n        configSubkey = _ref26[1].subkey;\n\n    var _a;\n\n    var _chooseOnchainAccount = chooseOnchainAccount({\n      signer: signer,\n      address: address,\n      main: main\n    }, (_a = action.payload.subkey) !== null && _a !== void 0 ? _a : configSubkey),\n        onchainSigner = _chooseOnchainAccount.signer;\n\n    var contract = getContractWithSigner(secretRegistryContract, onchainSigner);\n    return Object(from["a" /* from */])(contract.functions.registerSecret(action.payload.secret)).pipe(assertTx(\'registerSecret\', ErrorCodes.XFER_REGISTERSECRET_TX_FAILED, {\n      log: log\n    }), // transferSecretRegister.success handled by monitorSecretRegistryEpic\n    Object(ignoreElements["a" /* ignoreElements */])(), Object(catchError["a" /* catchError */])(function (err) {\n      return Object(of["a" /* of */])(transferSecretRegister.failure(err, action.meta));\n    }));\n  }));\n};\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/epics/withdraw.js\n\n\n\n\n\n\n\n/**\n * When receiving a [[WithdrawRequest]] message, create the respective [[withdrawReceive.request]]\n * action\n *\n * @param action$ - Observable of messageReceived actions\n * @returns Observable of withdrawReceive.request actions\n */\n\nvar withdraw_withdrawRequestReceivedEpic = function withdrawRequestReceivedEpic(action$) {\n  return action$.pipe(Object(filter["a" /* filter */])(isMessageReceivedOfType(Signed(WithdrawRequest))), Object(filter["a" /* filter */])(function (action) {\n    return action.payload.message.participant === action.meta.address;\n  }), Object(map["a" /* map */])(function (action) {\n    var message = action.payload.message;\n    return withdrawReceive.request({\n      message: message\n    }, {\n      tokenNetwork: message.token_network_address,\n      partner: message.participant,\n      totalWithdraw: message.total_withdraw,\n      expiration: message.expiration.toNumber()\n    });\n  }));\n};\n/**\n * sendMessage when a [[withdrawReceive.success]] action is fired\n *\n * @param action$ - Observable of withdrawReceive.success actions\n * @returns Observable of messageSend.request actions\n */\n\nvar withdraw_withdrawSendConfirmationEpic = function withdrawSendConfirmationEpic(action$) {\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(withdrawReceive.success)), Object(map["a" /* map */])(function (action) {\n    return messageSend.request({\n      message: action.payload.message\n    }, {\n      address: action.meta.partner,\n      msgId: action.payload.message.message_identifier.toString()\n    });\n  }));\n};\n// CONCATENATED MODULE: ../raiden-ts/dist/transfers/epics/index.js\n\n\n\n\n\n\n\n\n\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/debounceTime.js\nvar debounceTime = __webpack_require__("1a2de");\n\n// CONCATENATED MODULE: ../raiden-ts/dist/path/utils.js\n\n\nfunction path_utils_slicedToArray(arr, i) { return path_utils_arrayWithHoles(arr) || path_utils_iterableToArrayLimit(arr, i) || path_utils_unsupportedIterableToArray(arr, i) || path_utils_nonIterableRest(); }\n\nfunction path_utils_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction path_utils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return path_utils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return path_utils_arrayLikeToArray(o, minLen); }\n\nfunction path_utils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction path_utils_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction path_utils_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar path_utils_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/camelcase */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Either returns true if given channel can route a payment, or a reason as string if not\n *\n * @param state - current RaidenState\n * @param presences - latest Presences mapping\n * @param tokenNetwork - tokenNetwork where the channel is\n * @param partner - possibly a partner on given tokenNetwork\n * @param target - transfer target\n * @param value - amount of tokens to check if channel can route\n * @returns true if channel can route, string containing reason if not\n */\n\nfunction channelCanRoute(state, presences, tokenNetwork, partner, target, value) {\n  var _a;\n\n  if (!(partner in presences) || !presences[partner].payload.available) return "path: partner \\"".concat(partner, "\\" not available in transport");\n  if (target !== partner && ((_a = presences[partner].payload.caps) === null || _a === void 0 ? void 0 : _a[Capabilities.NO_MEDIATE])) return "path: partner \\"".concat(partner, "\\" doesn\'t mediate transfers");\n  if (!(partner in state.channels[tokenNetwork])) return "path: there\'s no direct channel with partner \\"".concat(partner, "\\"");\n  var channel = state.channels[tokenNetwork][partner];\n  if (channel.state !== ChannelState.open) return "path: channel with \\"".concat(partner, "\\" in state \\"").concat(channel.state, "\\" instead of \\"").concat(ChannelState.open, "\\"");\n\n  var _channelAmounts = channelAmounts(channel),\n      capacity = _channelAmounts.ownCapacity;\n\n  if (capacity.lt(value)) return "path: channel with \\"".concat(partner, "\\" doesn\'t have enough capacity=").concat(capacity.toString());\n  return true;\n}\nvar serviceRegistryToken = memoize_default()(function (serviceRegistryContract) {\n  return path_utils_awaiter(void 0, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt("return", serviceRegistryContract.functions.token());\n\n          case 1:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n});\n/**\n * Returns a cold observable which fetch PFS info & validate for a given server address or URL\n *\n * @param pfsAddrOrUrl - PFS account/address or URL\n * @param deps - RaidenEpicDeps needed for various parameters\n * @returns Observable containing PFS server info\n */\n\nfunction pfsInfo(pfsAddrOrUrl, _ref) {\n  var _this = this;\n\n  var serviceRegistryContract = _ref.serviceRegistryContract,\n      network = _ref.network,\n      contractsInfo = _ref.contractsInfo,\n      config$ = _ref.config$;\n\n  /**\n   * Codec for PFS /api/v1/info result schema\n   */\n  var PathInfo = es6["t" /* type */]({\n    message: es6["q" /* string */],\n    network_info: es6["t" /* type */]({\n      // literals will fail if trying to decode anything different from these constants\n      chain_id: es6["j" /* literal */](network.chainId),\n      token_network_registry_address: es6["j" /* literal */](contractsInfo.TokenNetworkRegistry.address)\n    }),\n    operator: es6["q" /* string */],\n    payment_address: Address,\n    price_info: UInt(32),\n    version: es6["q" /* string */]\n  }); // if it\'s an address, fetch url from ServiceRegistry, else it\'s already the URL\n\n  var url$ = Address.is(pfsAddrOrUrl) ? Object(from["a" /* from */])(serviceRegistryContract.functions.urls(pfsAddrOrUrl)) : Object(of["a" /* of */])(pfsAddrOrUrl);\n  return url$.pipe(Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(mergeMap["a" /* mergeMap */])(function (_ref2) {\n    var _ref3 = path_utils_slicedToArray(_ref2, 2),\n        url = _ref3[0],\n        httpTimeout = _ref3[1].httpTimeout;\n\n    if (!url) throw new error_RaidenError(ErrorCodes.PFS_EMPTY_URL);else if (!isValidUrl(url)) throw new error_RaidenError(ErrorCodes.PFS_INVALID_URL, {\n      url: url\n    }); // default to https for domain-only urls\n    else if (!url.startsWith(\'https://\') && !url.startsWith(\'http://\')) url = "https://".concat(url);\n    var start = Date.now();\n    return Object(fetch["a" /* fromFetch */])(url + \'/api/v1/info\').pipe(Object(timeout["a" /* timeout */])(httpTimeout), Object(mergeMap["a" /* mergeMap */])(function (res) {\n      return path_utils_awaiter(_this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee2() {\n        return regenerator_default.a.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.t0 = decode;\n                _context2.t1 = PathInfo;\n                _context2.t2 = losslessParse;\n                _context2.next = 5;\n                return res.text();\n\n              case 5:\n                _context2.t3 = _context2.sent;\n                _context2.t4 = (0, _context2.t2)(_context2.t3);\n                _context2.t5 = (0, _context2.t0)(_context2.t1, _context2.t4);\n                _context2.next = 10;\n                return serviceRegistryToken(serviceRegistryContract);\n\n              case 10:\n                _context2.t6 = _context2.sent;\n                return _context2.abrupt("return", [_context2.t5, _context2.t6]);\n\n              case 12:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n    }), Object(map["a" /* map */])(function (_ref4) {\n      var _ref5 = path_utils_slicedToArray(_ref4, 2),\n          info = _ref5[0],\n          token = _ref5[1];\n\n      return {\n        address: info.payment_address,\n        url: url,\n        rtt: Date.now() - start,\n        price: info.price_info,\n        token: token\n      };\n    }));\n  }));\n}\n/**\n * Retrieve pfsInfo for these servers & return sorted PFS info\n *\n * Sort order is price then response time (rtt).\n * Throws if no server can be validated, meaning either there\'s none in the current network or\n * we\'re out-of-sync (outdated or ahead of PFS\'s deployment network version).\n *\n * @param pfsList - Array of PFS addresses or URLs\n * @param deps - RaidenEpicDeps array\n * @returns Observable of online, validated & sorted PFS info array\n */\n\nfunction pfsListInfo(pfsList, deps) {\n  var log = deps.log;\n  return Object(from["a" /* from */])(pfsList).pipe(Object(mergeMap["a" /* mergeMap */])(function (addrOrUrl) {\n    return pfsInfo(addrOrUrl, deps).pipe(Object(catchError["a" /* catchError */])(function (err) {\n      log.warn("Error trying to fetch PFS info for \\"".concat(addrOrUrl, "\\" - ignoring:"), err);\n      return empty["a" /* EMPTY */];\n    }));\n  }, 5), Object(toArray["a" /* toArray */])(), Object(map["a" /* map */])(function (list) {\n    if (!list.length) throw new error_RaidenError(ErrorCodes.PFS_INVALID_INFO);\n    return list.sort(function (a, b) {\n      var dif = a.price.sub(b.price); // first, sort by price\n\n      if (dif.lt(0)) return -1;else if (dif.gt(0)) return 1; // if it\'s equal, tiebreak on rtt\n      else return a.rtt - b.rtt;\n    });\n  }));\n}\n// CONCATENATED MODULE: ../raiden-ts/dist/path/epics.js\n\n\nfunction epics_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction path_epics_toConsumableArray(arr) { return path_epics_arrayWithoutHoles(arr) || path_epics_iterableToArray(arr) || path_epics_unsupportedIterableToArray(arr) || path_epics_nonIterableSpread(); }\n\nfunction path_epics_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction path_epics_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction path_epics_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return path_epics_arrayLikeToArray(arr); }\n\nfunction path_epics_createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = path_epics_unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction path_epics_objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure undefined"); }\n\nfunction path_epics_slicedToArray(arr, i) { return path_epics_arrayWithHoles(arr) || path_epics_iterableToArrayLimit(arr, i) || path_epics_unsupportedIterableToArray(arr, i) || path_epics_nonIterableRest(); }\n\nfunction path_epics_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction path_epics_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return path_epics_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return path_epics_arrayLikeToArray(o, minLen); }\n\nfunction path_epics_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction path_epics_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction path_epics_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar path_epics_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/camelcase */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar epics_oneToNAddress = memoize_default()(function (userDepositContract) {\n  return path_epics_awaiter(void 0, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n    return regenerator_default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt("return", userDepositContract.functions.one_to_n_address());\n\n          case 1:\n          case "end":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n});\n/**\n * Codec for PFS API returned error\n *\n * May contain other fields like error_details, but we don\'t care about them (for now)\n */\n\nvar PathError = es6["n" /* readonly */](es6["t" /* type */]({\n  /* eslint-disable-next-line @typescript-eslint/camelcase */\n  error_code: es6["l" /* number */],\n  errors: es6["q" /* string */]\n})); // returns a ISO string truncated at the integer second resolution\n\nfunction makeTimestamp(time) {\n  return (time !== null && time !== void 0 ? time : new Date()).toISOString().substr(0, 19);\n}\n\nvar epics_makeIOU = function makeIOU(sender, receiver, chainId, oneToNAddress, blockNumber) {\n  return {\n    sender: sender,\n    receiver: receiver,\n    chain_id: Object(utils["bigNumberify"])(chainId),\n    amount: constants["Zero"],\n    one_to_n_address: oneToNAddress,\n    expiration_block: Object(utils["bigNumberify"])(blockNumber).add(2 * Math.pow(10, 5))\n  };\n};\n\nvar updateIOU = function updateIOU(iou, price) {\n  return Object.assign(Object.assign({}, iou), {\n    amount: iou.amount.add(price)\n  });\n};\n\nvar epics_packIOU = function packIOU(iou) {\n  return Object(utils["concat"])([encode(iou.one_to_n_address, 20), encode(iou.chain_id, 32), encode(MessageTypeId.IOU, 32), encode(iou.sender, 20), encode(iou.receiver, 20), encode(iou.amount, 32), encode(iou.expiration_block, 32)]);\n};\n\nvar epics_signIOU$ = function signIOU$(iou, signer) {\n  return Object(from["a" /* from */])(signer.signMessage(epics_packIOU(iou))).pipe(Object(map["a" /* map */])(function (signature) {\n    return Object.assign(Object.assign({}, iou), {\n      signature: signature\n    });\n  }));\n};\n\nvar epics_makeAndSignLastIOURequest$ = function makeAndSignLastIOURequest$(sender, receiver, signer) {\n  return Object(defer["a" /* defer */])(function () {\n    var timestamp = makeTimestamp(),\n        message = Object(utils["concat"])([sender, receiver, Object(utils["toUtf8Bytes"])(timestamp)]);\n    return Object(from["a" /* from */])(signer.signMessage(message)).pipe(Object(map["a" /* map */])(function (signature) {\n      return {\n        sender: sender,\n        receiver: receiver,\n        timestamp: timestamp,\n        signature: signature\n      };\n    }));\n  });\n};\n\nvar epics_prepareNextIOU$ = function prepareNextIOU$(pfs, tokenNetwork, _ref) {\n  var address = _ref.address,\n      signer = _ref.signer,\n      network = _ref.network,\n      userDepositContract = _ref.userDepositContract,\n      latest$ = _ref.latest$;\n  return latest$.pipe(Object(first["a" /* first */])(), Object(switchMap["a" /* switchMap */])(function (_ref2) {\n    var state = _ref2.state,\n        httpTimeout = _ref2.config.httpTimeout;\n\n    var _a;\n\n    var cachedIOU = (_a = state.path.iou[tokenNetwork]) === null || _a === void 0 ? void 0 : _a[pfs.address];\n    return (cachedIOU ? Object(of["a" /* of */])(cachedIOU) : epics_makeAndSignLastIOURequest$(address, pfs.address, signer).pipe(Object(mergeMap["a" /* mergeMap */])(function (payload) {\n      return Object(fetch["a" /* fromFetch */])("".concat(pfs.url, "/api/v1/").concat(tokenNetwork, "/payment/iou?").concat(new URLSearchParams(payload).toString()), {\n        method: \'GET\',\n        headers: {\n          \'Content-Type\': \'application/json\'\n        }\n      }).pipe(Object(timeout["a" /* timeout */])(httpTimeout));\n    }), Object(withLatestFrom["a" /* withLatestFrom */])(latest$.pipe(Object(pluck["a" /* pluck */])(\'state\'))), Object(mergeMap["a" /* mergeMap */])(function (_ref3) {\n      var _ref4 = path_epics_slicedToArray(_ref3, 2),\n          response = _ref4[0],\n          blockNumber = _ref4[1].blockNumber;\n\n      return path_epics_awaiter(void 0, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee2() {\n        var text, _decode, lastIou, signer;\n\n        return regenerator_default.a.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(response.status === 404)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                _context2.t0 = epics_makeIOU;\n                _context2.t1 = address;\n                _context2.t2 = pfs.address;\n                _context2.t3 = network.chainId;\n                _context2.next = 7;\n                return epics_oneToNAddress(userDepositContract);\n\n              case 7:\n                _context2.t4 = _context2.sent;\n                _context2.t5 = blockNumber;\n                return _context2.abrupt("return", (0, _context2.t0)(_context2.t1, _context2.t2, _context2.t3, _context2.t4, _context2.t5));\n\n              case 10:\n                _context2.next = 12;\n                return response.text();\n\n              case 12:\n                text = _context2.sent;\n\n                if (response.ok) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                throw new error_RaidenError(ErrorCodes.PFS_LAST_IOU_REQUEST_FAILED, {\n                  responseStatus: response.status,\n                  responseText: text\n                });\n\n              case 15:\n                _decode = decode(LastIOUResults, losslessParse(text)), lastIou = _decode.last_iou;\n                signer = Object(utils["verifyMessage"])(epics_packIOU(lastIou), lastIou.signature);\n\n                if (!(signer !== address)) {\n                  _context2.next = 19;\n                  break;\n                }\n\n                throw new error_RaidenError(ErrorCodes.PFS_IOU_SIGNATURE_MISMATCH, {\n                  signer: signer,\n                  address: address\n                });\n\n              case 19:\n                return _context2.abrupt("return", lastIou);\n\n              case 20:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n    }))).pipe(Object(map["a" /* map */])(function (iou) {\n      return updateIOU(iou, pfs.price);\n    }), Object(mergeMap["a" /* mergeMap */])(function (iou) {\n      return epics_signIOU$(iou, signer);\n    }));\n  }));\n};\n/**\n * Check if a transfer can be made and return a set of paths for it.\n *\n * @param action$ - Observable of pathFind.request actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps object\n * @returns Observable of pathFind.{success|failure} actions\n */\n\n\nvar epics_pathFindServiceEpic = function pathFindServiceEpic(action$, _ref5, deps) {\n  path_epics_objectDestructuringEmpty(_ref5);\n\n  var log = deps.log,\n      latest$ = deps.latest$;\n  return action$.pipe(Object(filter["a" /* filter */])(isActionOf(pathFind.request)), Object(concatMap["a" /* concatMap */])(function (action) {\n    return latest$.pipe(Object(first["a" /* first */])(), Object(mergeMap["a" /* mergeMap */])(function (_ref6) {\n      var state = _ref6.state,\n          presences = _ref6.presences,\n          _ref6$config = _ref6.config,\n          configPfs = _ref6$config.pfs,\n          httpTimeout = _ref6$config.httpTimeout,\n          pfsSafetyMargin = _ref6$config.pfsSafetyMargin;\n\n      var _a;\n\n      var _action$meta = action.meta,\n          tokenNetwork = _action$meta.tokenNetwork,\n          target = _action$meta.target;\n      if (!(tokenNetwork in state.channels)) throw new error_RaidenError(ErrorCodes.PFS_UNKNOWN_TOKEN_NETWORK, {\n        tokenNetwork: tokenNetwork\n      });\n      if (!(target in presences) || !presences[target].payload.available) throw new error_RaidenError(ErrorCodes.PFS_TARGET_OFFLINE, {\n        target: target\n      });\n      if ((_a = presences[target].payload.caps) === null || _a === void 0 ? void 0 : _a[Capabilities.NO_RECEIVE]) throw new error_RaidenError(ErrorCodes.PFS_TARGET_NO_RECEIVE, {\n        target: target\n      }); // if pathFind received a set of paths, pass it through to validation/cleanup\n\n      if (action.payload.paths) return Object(of["a" /* of */])({\n        paths: action.payload.paths,\n        iou: undefined\n      }); // else, if possible, use a direct transfer\n      else if (channelCanRoute(state, presences, tokenNetwork, target, target, action.meta.value) === true) {\n          return Object(of["a" /* of */])({\n            paths: [{\n              path: [deps.address, target],\n              fee: constants["Zero"]\n            }],\n            iou: undefined\n          });\n        } else if (action.payload.pfs === null || // explicitly disabled in action\n        !action.payload.pfs && configPfs === null // undefined in action and disabled in config\n        ) {\n            // pfs not specified in action and disabled (null) in config\n            throw new error_RaidenError(ErrorCodes.PFS_DISABLED);\n          } else {\n          // else, request a route from PFS.\n          // pfs$ - Observable which emits one PFS info and then completes\n          var pfs$ = action.payload.pfs ? // first, use action.payload.pfs as is, if present\n          Object(of["a" /* of */])(action.payload.pfs) : configPfs ? // or if config.pfs isn\'t disabled (null) nor auto (\'\'), fetch & use it\n          pfsInfo(configPfs, deps) : // else (action unset, config.pfs=\'\'=auto mode)\n          latest$.pipe(Object(pluck["a" /* pluck */])(\'pfsList\'), // get cached pfsList\n          // if needed, wait for list to be populated\n          Object(first["a" /* first */])(function (pfsList) {\n            return pfsList.length > 0;\n          }), // fetch pfsInfo from whole list & sort it\n          Object(mergeMap["a" /* mergeMap */])(function (pfsList) {\n            return pfsListInfo(pfsList, deps);\n          }), Object(tap["a" /* tap */])(function (pfss) {\n            return log.info(\'Auto-selecting best PFS from:\', pfss);\n          }), // pop best ranked\n          Object(pluck["a" /* pluck */])(0));\n          return pfs$.pipe(Object(mergeMap["a" /* mergeMap */])(function (pfs) {\n            return pfs.price.isZero() ? Object(of["a" /* of */])({\n              pfs: pfs,\n              iou: undefined\n            }) : epics_prepareNextIOU$(pfs, tokenNetwork, deps).pipe(Object(map["a" /* map */])(function (iou) {\n              return {\n                pfs: pfs,\n                iou: iou\n              };\n            }));\n          }), Object(mergeMap["a" /* mergeMap */])(function (_ref7) {\n            var pfs = _ref7.pfs,\n                iou = _ref7.iou;\n            return Object(fetch["a" /* fromFetch */])("".concat(pfs.url, "/api/v1/").concat(tokenNetwork, "/paths"), {\n              method: \'POST\',\n              headers: {\n                \'Content-Type\': \'application/json\'\n              },\n              body: losslessStringify({\n                from: deps.address,\n                to: target,\n                value: UInt(32).encode(action.meta.value),\n                max_paths: 10,\n                iou: iou ? Object.assign(Object.assign({}, iou), {\n                  amount: UInt(32).encode(iou.amount),\n                  expiration_block: UInt(32).encode(iou.expiration_block),\n                  chain_id: UInt(32).encode(iou.chain_id)\n                }) : undefined\n              })\n            }).pipe(Object(timeout["a" /* timeout */])(httpTimeout), Object(map["a" /* map */])(function (response) {\n              return {\n                response: response,\n                iou: iou\n              };\n            }));\n          }), Object(mergeMap["a" /* mergeMap */])(function (_ref8) {\n            var response = _ref8.response,\n                iou = _ref8.iou;\n            return path_epics_awaiter(void 0, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee3() {\n              return regenerator_default.a.wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      _context3.t0 = response;\n                      _context3.next = 3;\n                      return response.text();\n\n                    case 3:\n                      _context3.t1 = _context3.sent;\n                      _context3.t2 = iou;\n                      return _context3.abrupt("return", {\n                        response: _context3.t0,\n                        text: _context3.t1,\n                        iou: _context3.t2\n                      });\n\n                    case 6:\n                    case "end":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3);\n            }));\n          }), Object(map["a" /* map */])(function (_ref9) {\n            var response = _ref9.response,\n                text = _ref9.text,\n                iou = _ref9.iou;\n            // any decode error here will throw early and end up in catchError\n            var data = losslessParse(text);\n\n            if (!response.ok) {\n              return {\n                error: decode(PathError, data),\n                iou: iou\n              };\n            }\n\n            return {\n              paths: decode(PathResults, data).result.map(function (r) {\n                return {\n                  path: r.path,\n                  // Add PFS safety margin to estimated fees\n                  fee: r.estimated_fee.mul(Math.round(pfsSafetyMargin * 1e6)).div(1e6)\n                };\n              }),\n              iou: iou\n            };\n          }));\n        }\n    }), Object(withLatestFrom["a" /* withLatestFrom */])(latest$), // validate/cleanup received routes/paths/results\n    Object(mergeMap["a" /* mergeMap */])(function (_ref10) {\n      var _ref11 = path_epics_slicedToArray(_ref10, 2),\n          data = _ref11[0],\n          _ref11$ = _ref11[1],\n          state = _ref11$.state,\n          presences = _ref11$.presences;\n\n      return (// looks like mergeMap with generator doesn\'t handle exceptions correctly\n        // use from+iterator from iife generator instead\n        Object(from["a" /* from */])( /*#__PURE__*/regenerator_default.a.mark(function _callee4() {\n          var iou, filteredPaths, invalidatedRecipients, _iterator, _step, _step$value, path, fee, recipient, canTransferOrReason;\n\n          return regenerator_default.a.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  iou = data.iou;\n\n                  if (!iou) {\n                    _context4.next = 9;\n                    break;\n                  }\n\n                  if (!(data.paths || data.error.error_code === 2201)) {\n                    _context4.next = 7;\n                    break;\n                  }\n\n                  _context4.next = 5;\n                  return iouPersist({\n                    iou: iou\n                  }, {\n                    tokenNetwork: action.meta.tokenNetwork,\n                    serviceAddress: iou.receiver\n                  });\n\n                case 5:\n                  _context4.next = 9;\n                  break;\n\n                case 7:\n                  _context4.next = 9;\n                  return iouClear(undefined, {\n                    tokenNetwork: action.meta.tokenNetwork,\n                    serviceAddress: iou.receiver\n                  });\n\n                case 9:\n                  if (data.paths) {\n                    _context4.next = 11;\n                    break;\n                  }\n\n                  throw new error_RaidenError(ErrorCodes.PFS_ERROR_RESPONSE, {\n                    errorCode: data.error.error_code,\n                    errors: data.error.errors\n                  });\n\n                case 11:\n                  filteredPaths = [], invalidatedRecipients = new Set(); // eslint-disable-next-line prefer-const\n\n                  _iterator = path_epics_createForOfIteratorHelper(data.paths);\n                  _context4.prev = 13;\n\n                  _iterator.s();\n\n                case 15:\n                  if ((_step = _iterator.n()).done) {\n                    _context4.next = 29;\n                    break;\n                  }\n\n                  _step$value = _step.value, path = _step$value.path, fee = _step$value.fee;\n                  // if route has us as first hop, cleanup/shift\n                  if (path[0] === deps.address) path = path.slice(1);\n                  recipient = path[0]; // if this recipient was already invalidated in a previous iteration, skip\n\n                  if (!invalidatedRecipients.has(recipient)) {\n                    _context4.next = 21;\n                    break;\n                  }\n\n                  return _context4.abrupt("continue", 27);\n\n                case 21:\n                  // if we already found some valid route, allow only new routes through this peer\n                  canTransferOrReason = !filteredPaths.length ? channelCanRoute(state, presences, action.meta.tokenNetwork, recipient, action.meta.target, action.meta.value.add(fee)) : recipient !== filteredPaths[0].path[0] ? \'path: already selected another recipient\' : fee.gt(filteredPaths[0].fee) ? \'path: already selected a smaller fee\' : true;\n\n                  if (!(canTransferOrReason !== true)) {\n                    _context4.next = 26;\n                    break;\n                  }\n\n                  log.warn(\'Invalidated received route. Reason:\', canTransferOrReason, \'Route:\', path);\n                  invalidatedRecipients.add(recipient);\n                  return _context4.abrupt("continue", 27);\n\n                case 26:\n                  filteredPaths.push({\n                    path: path,\n                    fee: fee\n                  });\n\n                case 27:\n                  _context4.next = 15;\n                  break;\n\n                case 29:\n                  _context4.next = 34;\n                  break;\n\n                case 31:\n                  _context4.prev = 31;\n                  _context4.t0 = _context4["catch"](13);\n\n                  _iterator.e(_context4.t0);\n\n                case 34:\n                  _context4.prev = 34;\n\n                  _iterator.f();\n\n                  return _context4.finish(34);\n\n                case 37:\n                  if (filteredPaths.length) {\n                    _context4.next = 39;\n                    break;\n                  }\n\n                  throw new error_RaidenError(ErrorCodes.PFS_NO_ROUTES_FOUND);\n\n                case 39:\n                  _context4.next = 41;\n                  return pathFind.success({\n                    paths: filteredPaths\n                  }, action.meta);\n\n                case 41:\n                case "end":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, null, [[13, 31, 34, 37]]);\n        })())\n      );\n    }), Object(catchError["a" /* catchError */])(function (err) {\n      return Object(of["a" /* of */])(pathFind.failure(err, action.meta));\n    }));\n  }));\n};\n\nfunction channelEntries(channels) {\n  return Object.entries(channels).map(function (_ref12) {\n    var _ref13 = path_epics_slicedToArray(_ref12, 2),\n        tokenNetwork = _ref13[0],\n        partnerChannels = _ref13[1];\n\n    return Object.entries(partnerChannels).map(function (_ref14) {\n      var _ref15 = path_epics_slicedToArray(_ref14, 2),\n          partner = _ref15[0],\n          channel = _ref15[1];\n\n      return ["".concat(partner, "@").concat(tokenNetwork), channel];\n    });\n  }).reduce(function (acc, val) {\n    return [].concat(path_epics_toConsumableArray(acc), path_epics_toConsumableArray(val));\n  }, []);\n}\n\nfunction keyToTNP(key) {\n  var _key$split = key.split(\'@\'),\n      _key$split2 = path_epics_slicedToArray(_key$split, 2),\n      partner = _key$split2[0],\n      tokenNetwork = _key$split2[1];\n\n  return {\n    key: key,\n    tokenNetwork: tokenNetwork,\n    partnerAddr: partner\n  };\n}\n/**\n * Sends a [[PFSCapacityUpdate]] to PFS global room on new deposit on our side of channels\n *\n * @param action$ - Observable of channelDeposit.success actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of messageGlobalSend actions\n */\n\n\nvar epics_pfsCapacityUpdateEpic = function pfsCapacityUpdateEpic(_ref16, _ref17, _ref18) {\n  path_epics_objectDestructuringEmpty(_ref16);\n\n  path_epics_objectDestructuringEmpty(_ref17);\n\n  var log = _ref18.log,\n      address = _ref18.address,\n      network = _ref18.network,\n      signer = _ref18.signer,\n      config$ = _ref18.config$,\n      latest$ = _ref18.latest$;\n  return latest$.pipe(pluckDistinct(\'state\', \'channels\'), Object(concatMap["a" /* concatMap */])(function (channels) {\n    return Object(from["a" /* from */])(channelEntries(channels));\n  }),\n  /* this scan stores a reference to each [key,value] in \'acc\', and emit as \'changed\' iff it\n   * changes from last time seen. It relies on value references changing only if needed */\n  Object(scan["a" /* scan */])(function (_ref19, _ref20) {\n    var acc = _ref19.acc;\n\n    var _ref21 = path_epics_slicedToArray(_ref20, 2),\n        key = _ref21[0],\n        channel = _ref21[1];\n\n    return (// if ref didn\'t change, emit previous accumulator, without \'changed\' value\n      acc[key] === channel ? {\n        acc: acc\n      } : // else, update ref in \'acc\' and emit value in \'changed\' prop\n      {\n        acc: Object.assign(Object.assign({}, acc), epics_defineProperty({}, key, channel)),\n        changed: Object.assign(Object.assign({}, channel), keyToTNP(key))\n      }\n    );\n  }, {\n    acc: {}\n  }), Object(pluck["a" /* pluck */])(\'changed\'), Object(filter["a" /* filter */])(isntNil), // filter out if reference didn\'t change from last emit\n  Object(groupBy["a" /* groupBy */])(function (_ref22) {\n    var key = _ref22.key;\n    return key;\n  }), Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(mergeMap["a" /* mergeMap */])(function (_ref23) {\n    var _ref24 = path_epics_slicedToArray(_ref23, 2),\n        grouped$ = _ref24[0],\n        httpTimeout = _ref24[1].httpTimeout;\n\n    return grouped$.pipe(Object(withLatestFrom["a" /* withLatestFrom */])(config$), Object(filter["a" /* filter */])(function (_ref25) {\n      var _ref26 = path_epics_slicedToArray(_ref25, 2),\n          pfsRoom = _ref26[1].pfsRoom;\n\n      return !!pfsRoom;\n    }), // ignore actions while/if config.pfsRoom isn\'t set\n    Object(debounceTime["a" /* debounceTime */])(httpTimeout / 2), // default: 15s\n    Object(concatMap["a" /* concatMap */])(function (_ref27) {\n      var _ref28 = path_epics_slicedToArray(_ref27, 2),\n          channel = _ref28[0],\n          _ref28$ = _ref28[1],\n          revealTimeout = _ref28$.revealTimeout,\n          pfsRoom = _ref28$.pfsRoom;\n\n      var _a, _b, _c, _d;\n\n      var tokenNetwork = channel.tokenNetwork,\n          partner = channel.partnerAddr;\n      if (channel.state !== ChannelState.open) return empty["a" /* EMPTY */];\n\n      var _channelAmounts = channelAmounts(channel),\n          ownCapacity = _channelAmounts.ownCapacity,\n          partnerCapacity = _channelAmounts.partnerCapacity;\n\n      var message = {\n        type: MessageType.PFS_CAPACITY_UPDATE,\n        canonical_identifier: {\n          chain_identifier: Object(utils["bigNumberify"])(network.chainId),\n          token_network_address: tokenNetwork,\n          channel_identifier: Object(utils["bigNumberify"])(channel.id)\n        },\n        updating_participant: address,\n        other_participant: partner,\n        updating_nonce: (_b = (_a = channel.own.balanceProof) === null || _a === void 0 ? void 0 : _a.nonce) !== null && _b !== void 0 ? _b : constants["Zero"],\n        other_nonce: (_d = (_c = channel.partner.balanceProof) === null || _c === void 0 ? void 0 : _c.nonce) !== null && _d !== void 0 ? _d : constants["Zero"],\n        updating_capacity: ownCapacity,\n        other_capacity: partnerCapacity,\n        reveal_timeout: Object(utils["bigNumberify"])(revealTimeout)\n      };\n      return Object(defer["a" /* defer */])(function () {\n        return signMessage(signer, message, {\n          log: log\n        });\n      }).pipe(Object(map["a" /* map */])(function (signed) {\n        return messageGlobalSend({\n          message: signed\n        }, {\n          roomName: pfsRoom\n        });\n      }), Object(catchError["a" /* catchError */])(function (err) {\n        log.error(\'Error trying to generate & sign PFSCapacityUpdate\', err);\n        return empty["a" /* EMPTY */];\n      }));\n    }));\n  }));\n};\n/**\n * When monitoring a channel (either a new channel or a previously monitored one), send a matching\n * PFSFeeUpdate to path_finding global room, so PFSs can pick us for mediation\n * TODO: Currently, we always send Zero fees; we should send correct fee data from config\n *\n * @param action$ - Observable of channelMonitor actions\n * @param state$ - Observable of RaidenStates\n * @param deps - Raiden epic dependencies\n * @returns Observable of messageGlobalSend actions\n */\n\nvar epics_pfsFeeUpdateEpic = function pfsFeeUpdateEpic(action$, state$, _ref29) {\n  var log = _ref29.log,\n      address = _ref29.address,\n      network = _ref29.network,\n      signer = _ref29.signer,\n      config$ = _ref29.config$;\n  return action$.pipe(Object(filter["a" /* filter */])(channelMonitor.is), Object(withLatestFrom["a" /* withLatestFrom */])(state$, config$), // ignore actions while/if mediating not enabled\n  Object(filter["a" /* filter */])(function (_ref30) {\n    var _ref31 = path_epics_slicedToArray(_ref30, 3),\n        _ref31$ = _ref31[2],\n        pfsRoom = _ref31$.pfsRoom,\n        caps = _ref31$.caps;\n\n    return !!pfsRoom && !(caps === null || caps === void 0 ? void 0 : caps[Capabilities.NO_MEDIATE]);\n  }), Object(mergeMap["a" /* mergeMap */])(function (_ref32) {\n    var _ref33 = path_epics_slicedToArray(_ref32, 3),\n        action = _ref33[0],\n        state = _ref33[1],\n        pfsRoom = _ref33[2].pfsRoom;\n\n    var _a;\n\n    var channel = (_a = state.channels[action.meta.tokenNetwork]) === null || _a === void 0 ? void 0 : _a[action.meta.partner];\n    if ((channel === null || channel === void 0 ? void 0 : channel.state) !== ChannelState.open) return empty["a" /* EMPTY */];\n    var message = {\n      type: MessageType.PFS_FEE_UPDATE,\n      canonical_identifier: {\n        chain_identifier: Object(utils["bigNumberify"])(network.chainId),\n        token_network_address: action.meta.tokenNetwork,\n        channel_identifier: Object(utils["bigNumberify"])(channel.id)\n      },\n      updating_participant: address,\n      timestamp: makeTimestamp(),\n      fee_schedule: {\n        cap_fees: true,\n        imbalance_penalty: null,\n        proportional: constants["Zero"],\n        flat: constants["Zero"]\n      }\n    };\n    return Object(from["a" /* from */])(signMessage(signer, message, {\n      log: log\n    })).pipe(Object(map["a" /* map */])(function (signed) {\n      return messageGlobalSend({\n        message: signed\n      }, {\n        roomName: pfsRoom\n      });\n    }), Object(catchError["a" /* catchError */])(function (err) {\n      log.error(\'Error trying to generate & sign PFSFeeUpdate\', err);\n      return empty["a" /* EMPTY */];\n    }));\n  }));\n};\n/**\n * Fetch & monitors ServiceRegistry\'s RegisteredService events, keep track of valid_till expiration\n * and aggregate list of valid service addresses\n *\n * Notice this epic only deals with the events & addresses, and don\'t fetch URLs, which need to be\n * fetched on-demand through [[pfsInfo]] & [[pfsListInfo]].\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps object\n * @returns Observable of pfsListUpdated actions\n */\n\nvar epics_pfsServiceRegistryMonitorEpic = function pfsServiceRegistryMonitorEpic(_ref34, _ref35, _ref36) {\n  path_epics_objectDestructuringEmpty(_ref34);\n\n  path_epics_objectDestructuringEmpty(_ref35);\n\n  var serviceRegistryContract = _ref36.serviceRegistryContract,\n      contractsInfo = _ref36.contractsInfo,\n      config$ = _ref36.config$;\n  return config$.pipe( // monitors config.pfs, and only monitors contract if it\'s empty\n  pluckDistinct(\'pfs\'), Object(switchMap["a" /* switchMap */])(function (pfs) {\n    return pfs !== \'\' ? // disable ServiceRegistry monitoring if/while pfs is null=disabled or truty\n    empty["a" /* EMPTY */] : // type of elements emitted by getEventsStream (past and new events coming from contract):\n    // [service, valid_till, deposit_amount, deposit_contract, Event]\n    getEventsStream(serviceRegistryContract, [serviceRegistryContract.filters.RegisteredService(null, null, null, null)], Object(of["a" /* of */])(contractsInfo.ServiceRegistry.block_number)).pipe(Object(groupBy["a" /* groupBy */])(function (_ref37) {\n      var _ref38 = path_epics_slicedToArray(_ref37, 1),\n          service = _ref38[0];\n\n      return service;\n    }), Object(mergeMap["a" /* mergeMap */])(function (grouped$) {\n      return grouped$.pipe( // switchMap ensures new events for each server (grouped$) picks latest event\n      Object(switchMap["a" /* switchMap */])(function (_ref39) {\n        var _ref40 = path_epics_slicedToArray(_ref39, 2),\n            service = _ref40[0],\n            valid_till = _ref40[1];\n\n        var now = Date.now(),\n            validTill = valid_till.mul(1000); // milliseconds valid_till\n\n        if (validTill.lt(now)) return empty["a" /* EMPTY */]; // this event already expired\n        // end$ will emit valid=false iff <2^31 ms in the future (setTimeout limit)\n\n        var end$ = validTill.sub(now).lt(constants["Two"].pow(31)) ? Object(of["a" /* of */])({\n          service: service,\n          valid: false\n        }).pipe(Object(delay["a" /* delay */])(new Date(validTill.toNumber()))) : empty["a" /* EMPTY */];\n        return Object(merge["a" /* merge */])(Object(of["a" /* of */])({\n          service: service,\n          valid: true\n        }), end$);\n      }));\n    }), Object(scan["a" /* scan */])(function (acc, _ref41) {\n      var service = _ref41.service,\n          valid = _ref41.valid;\n      return !valid && acc.includes(service) ? acc.filter(function (s) {\n        return s !== service;\n      }) : valid && !acc.includes(service) ? [].concat(path_epics_toConsumableArray(acc), [service]) : acc;\n    }, []), Object(distinctUntilChanged["a" /* distinctUntilChanged */])(), Object(debounceTime["a" /* debounceTime */])(1e3), // debounce burst of updates on initial fetch\n    Object(map["a" /* map */])(function (pfsList) {\n      return pfsListUpdated({\n        pfsList: pfsList\n      });\n    }));\n  }));\n};\n// CONCATENATED MODULE: ../raiden-ts/dist/epics.js\nfunction dist_epics_slicedToArray(arr, i) { return dist_epics_arrayWithHoles(arr) || dist_epics_iterableToArrayLimit(arr, i) || dist_epics_unsupportedIterableToArray(arr, i) || dist_epics_nonIterableRest(); }\n\nfunction dist_epics_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction dist_epics_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dist_epics_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dist_epics_arrayLikeToArray(o, minLen); }\n\nfunction dist_epics_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction dist_epics_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction dist_epics_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction dist_epics_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This function maps cached/latest relevant values from action$ & state$\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns latest$ observable\n */\n\nfunction getLatest$(action$, state$, _ref) {\n  var defaultConfig = _ref.defaultConfig;\n  return Object(combineLatest["a" /* combineLatest */])([action$, state$, state$.pipe(pluckDistinct(\'config\'), Object(map["a" /* map */])(function (c) {\n    return Object.assign(Object.assign({}, defaultConfig), c);\n  })), getPresences$(action$), action$.pipe(Object(filter["a" /* filter */])(isActionOf(pfsListUpdated)), Object(pluck["a" /* pluck */])(\'payload\', \'pfsList\'), Object(startWith["a" /* startWith */])([])), action$.pipe(Object(filter["a" /* filter */])(rtcChannel.is), // scan: if v.payload is defined, set it; else, unset\n  Object(scan["a" /* scan */])(function (acc, v) {\n    return v.payload ? Object.assign(Object.assign({}, acc), dist_epics_defineProperty({}, v.meta.address, v.payload)) : unset_default()(v.meta.address, acc);\n  }, {}), Object(startWith["a" /* startWith */])({}))]).pipe(Object(map["a" /* map */])(function (_ref2) {\n    var _ref3 = dist_epics_slicedToArray(_ref2, 6),\n        action = _ref3[0],\n        state = _ref3[1],\n        config = _ref3[2],\n        presences = _ref3[3],\n        pfsList = _ref3[4],\n        rtc = _ref3[5];\n\n    return {\n      action: action,\n      state: state,\n      config: config,\n      presences: presences,\n      pfsList: pfsList,\n      rtc: rtc\n    };\n  }));\n}\nvar RaidenEpics = Object.assign(Object.assign(Object.assign(Object.assign({}, epics_namespaceObject), transport_epics_namespaceObject), transfers_epics_namespaceObject), path_epics_namespaceObject);\nvar epics_raidenRootEpic = function raidenRootEpic(action$, state$, deps) {\n  // observable which emits once when a raidenShutdown action goes through actions pipeline\n  var shutdownNotification = action$.pipe(Object(filter["a" /* filter */])(isActionOf(raidenShutdown))),\n      // actions pipeline, but ends with (including) a raidenShutdown action\n  limitedAction$ = action$.pipe(Object(takeWhile["a" /* takeWhile */])(negate_default()(isActionOf(raidenShutdown)), true)),\n      // states pipeline, but ends when shutdownNotification emits\n  limitedState$ = state$.pipe(Object(takeUntil["a" /* takeUntil */])(shutdownNotification)); // wire deps.latest$\n\n  getLatest$(limitedAction$, limitedState$, deps).subscribe(deps.latest$); // like combineEpics, but completes action$, state$ & output$ when a raidenShutdown goes through\n\n  return Object(from["a" /* from */])(Object.values(RaidenEpics)).pipe(Object(mergeMap["a" /* mergeMap */])(function (epic) {\n    return epic(limitedAction$, limitedState$, deps);\n  }), Object(catchError["a" /* catchError */])(function (err) {\n    return Object(of["a" /* of */])(raidenShutdown({\n      reason: err\n    }));\n  }), Object(takeUntil["a" /* takeUntil */])(shutdownNotification));\n};\n// CONCATENATED MODULE: ../raiden-ts/dist/raiden.js\n\n\nfunction raiden_toConsumableArray(arr) { return raiden_arrayWithoutHoles(arr) || raiden_iterableToArray(arr) || raiden_unsupportedIterableToArray(arr) || raiden_nonIterableSpread(); }\n\nfunction raiden_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction raiden_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction raiden_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return raiden_arrayLikeToArray(arr); }\n\nfunction raiden_slicedToArray(arr, i) { return raiden_arrayWithHoles(arr) || raiden_iterableToArrayLimit(arr, i) || raiden_unsupportedIterableToArray(arr, i) || raiden_nonIterableRest(); }\n\nfunction raiden_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction raiden_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return raiden_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return raiden_arrayLikeToArray(o, minLen); }\n\nfunction raiden_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction raiden_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction raiden_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction raiden_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction raiden_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction raiden_createClass(Constructor, protoProps, staticProps) { if (protoProps) raiden_defineProperties(Constructor.prototype, protoProps); if (staticProps) raiden_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar raiden_awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar raiden_Raiden = /*#__PURE__*/function () {\n  function Raiden(provider, network, signer, contractsInfo, state, defaultConfig, main) {\n    var _this = this;\n\n    raiden_classCallCheck(this, Raiden);\n\n    var _a, _b, _c, _d;\n\n    this.resolveName = provider.resolveName.bind(provider);\n    var address = state.address;\n    this.log = loglevel_default.a.getLogger("raiden:".concat(address)); // use next from latest known blockNumber as start block when polling\n\n    provider.resetEventsBlock(state.blockNumber + 1);\n    var latest$ = new ReplaySubject["a" /* ReplaySubject */](1); // pipe cached state\n\n    this.state$ = latest$.pipe(pluckDistinct(\'state\')); // pipe action, skipping cached\n\n    this.action$ = latest$.pipe(pluckDistinct(\'action\'), Object(skip["a" /* skip */])(1));\n    this.channels$ = this.state$.pipe(Object(map["a" /* map */])(function (state) {\n      return helpers_mapTokenToPartner(state);\n    }));\n    this.transfers$ = helpers_initTransfers$(this.state$);\n    this.events$ = this.action$.pipe(Object(filter["a" /* filter */])(isActionOf(RaidenEvents)));\n    this.getTokenInfo = memoize_default()(function (token) {\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee() {\n        var tokenContract, _yield$Promise$all, _yield$Promise$all2, totalSupply, decimals, name, symbol;\n\n        return regenerator_default.a.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                assert(Address.is(token), \'Invalid address\');\n                tokenContract = this.deps.getTokenContract(token);\n                _context.next = 4;\n                return Promise.all([tokenContract.functions.totalSupply(), tokenContract.functions.decimals(), tokenContract.functions.name().catch(constant_default()(undefined)), tokenContract.functions.symbol().catch(constant_default()(undefined))]);\n\n              case 4:\n                _yield$Promise$all = _context.sent;\n                _yield$Promise$all2 = raiden_slicedToArray(_yield$Promise$all, 4);\n                totalSupply = _yield$Promise$all2[0];\n                decimals = _yield$Promise$all2[1];\n                name = _yield$Promise$all2[2];\n                symbol = _yield$Promise$all2[3];\n                // workaround for https://github.com/microsoft/TypeScript/issues/33752\n                assert(totalSupply && decimals != null, \'Not a token contract\');\n                return _context.abrupt("return", {\n                  totalSupply: totalSupply,\n                  decimals: decimals,\n                  name: name,\n                  symbol: symbol\n                });\n\n              case 12:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    });\n    this.deps = {\n      latest$: latest$,\n      config$: latest$.pipe(pluckDistinct(\'config\')),\n      matrix$: new AsyncSubject["a" /* AsyncSubject */](),\n      provider: provider,\n      network: network,\n      signer: signer,\n      address: address,\n      log: this.log,\n      defaultConfig: defaultConfig,\n      contractsInfo: contractsInfo,\n      registryContract: TokenNetworkRegistryFactory_TokenNetworkRegistryFactory.connect(contractsInfo.TokenNetworkRegistry.address, (_a = main === null || main === void 0 ? void 0 : main.signer) !== null && _a !== void 0 ? _a : signer),\n      getTokenNetworkContract: memoize_default()(function (address) {\n        var _a;\n\n        return TokenNetworkFactory_TokenNetworkFactory.connect(address, (_a = main === null || main === void 0 ? void 0 : main.signer) !== null && _a !== void 0 ? _a : signer);\n      }),\n      getTokenContract: memoize_default()(function (address) {\n        var _a;\n\n        return HumanStandardTokenFactory_HumanStandardTokenFactory.connect(address, (_a = main === null || main === void 0 ? void 0 : main.signer) !== null && _a !== void 0 ? _a : signer);\n      }),\n      serviceRegistryContract: ServiceRegistryFactory_ServiceRegistryFactory.connect(contractsInfo.ServiceRegistry.address, (_b = main === null || main === void 0 ? void 0 : main.signer) !== null && _b !== void 0 ? _b : signer),\n      userDepositContract: UserDepositFactory_UserDepositFactory.connect(contractsInfo.UserDeposit.address, (_c = main === null || main === void 0 ? void 0 : main.signer) !== null && _c !== void 0 ? _c : signer),\n      secretRegistryContract: SecretRegistryFactory_SecretRegistryFactory.connect(contractsInfo.SecretRegistry.address, (_d = main === null || main === void 0 ? void 0 : main.signer) !== null && _d !== void 0 ? _d : signer),\n      main: main\n    };\n    this.userDepositTokenAddress = memoize_default()(function () {\n      return raiden_awaiter(_this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee2() {\n        return regenerator_default.a.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.deps.userDepositContract.functions.token();\n\n              case 2:\n                return _context2.abrupt("return", _context2.sent);\n\n              case 3:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    });\n    var loggerMiddleware = Object(redux_logger["createLogger"])({\n      predicate: function predicate() {\n        return _this.log.getLevel() <= loglevel_default.a.levels.INFO;\n      },\n      logger: this.log,\n      level: {\n        prevState: \'debug\',\n        action: \'info\',\n        error: \'error\',\n        nextState: \'debug\'\n      }\n    });\n    this.deps.config$.pipe(pluckDistinct(\'logger\')).subscribe(function (logger) {\n      return _this.log.setLevel(logger || \'silent\', false);\n    }); // minimum blockNumber of contracts deployment as start scan block\n\n    this.epicMiddleware = Object(createEpicMiddleware["a" /* createEpicMiddleware */])({\n      dependencies: this.deps\n    });\n    this.store = Object(redux["b" /* createStore */])(reducer_raidenReducer, // workaround for redux\'s PreloadedState issues with branded values\n    state, // eslint-disable-line @typescript-eslint/no-explicit-any\n    Object(redux["a" /* applyMiddleware */])(loggerMiddleware, this.epicMiddleware));\n  }\n  /**\n   * Async helper factory to make a Raiden instance from more common parameters.\n   *\n   * An async factory is needed so we can do the needed async requests to construct the required\n   * parameters ahead of construction time, and avoid partial initialization then\n   *\n   * @param connection - A URL or provider to connect to, one of:\n   *     <ul>\n   *       <li>JsonRpcProvider instance,</li>\n   *       <li>a Metamask\'s web3.currentProvider object or,</li>\n   *       <li>a hostname or remote json-rpc connection string</li>\n   *     </ul>\n   * @param account - An account to use as main account, one of:\n   *     <ul>\n   *       <li>Signer instance (e.g. Wallet) loadded with account/private key or</li>\n   *       <li>hex-encoded string address of a remote account in provider or</li>\n   *       <li>hex-encoded string local private key or</li>\n   *       <li>number index of a remote account loaded in provider\n   *            (e.g. 0 for Metamask\'s loaded account)</li>\n   *     </ul>\n   * @param storageOrState - Storage/localStorage-like object from where to load and store current\n   *     state, initial RaidenState-like object, or a { storage; state? } object containing both.\n   *     If a storage isn\'t provided, user must listen state$ changes on ensure it\'s persisted.\n   * @param contracts - Contracts deployment info\n   * @param config - Raiden configuration\n   * @param subkey - Whether to use a derived subkey or not\n   * @returns Promise to Raiden SDK client instance\n   **/\n\n\n  raiden_createClass(Raiden, [{\n    key: "start",\n\n    /**\n     * Starts redux/observables by subscribing to all epics and emitting initial state and action\n     *\n     * No event should be emitted before start is called\n     */\n    value: function start() {\n      var _this2 = this;\n\n      assert(this.epicMiddleware, \'Already started or stopped!\'); // on complete, sets epicMiddleware to null, so this.started === false\n\n      this.deps.latest$.subscribe(undefined, undefined, function () {\n        return _this2.epicMiddleware = null;\n      });\n      this.epicMiddleware.run(epics_raidenRootEpic); // prevent start from being called again, turns this.started to true\n\n      this.epicMiddleware = undefined; // dispatch a first, noop action, to next first state$ as current/initial state\n\n      this.store.dispatch(raidenConfigUpdate({}));\n    }\n    /**\n     * Gets the running state of the instance\n     *\n     * @returns undefined if not yet started, true if running, false if already stopped\n     */\n\n  }, {\n    key: "stop",\n\n    /**\n     * Triggers all epics to be unsubscribed\n     */\n    value: function stop() {\n      // start still can\'t be called again, but turns this.started to false\n      // this.epicMiddleware is set to null by latest$\'s complete callback\n      this.store.dispatch(raidenShutdown({\n        reason: ShutdownReason.STOP\n      }));\n    }\n    /**\n     * Get current RaidenState object. Can be serialized safely with [[encodeRaidenState]]\n     *\n     * @returns Current Raiden state\n     */\n\n  }, {\n    key: "getBlockNumber",\n\n    /**\n     * Returns a promise to current block number, as seen in provider and state\n     *\n     * @returns Promise to current block number\n     */\n    value: function getBlockNumber() {\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee3() {\n        return regenerator_default.a.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.t0 = this.deps.provider.blockNumber;\n\n                if (_context3.t0) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                _context3.next = 4;\n                return this.deps.provider.getBlockNumber();\n\n              case 4:\n                _context3.t0 = _context3.sent;\n\n              case 5:\n                return _context3.abrupt("return", _context3.t0);\n\n              case 6:\n              case "end":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Getter for current Raiden Config\n     *\n     * @returns Current Raiden config\n     */\n\n  }, {\n    key: "updateConfig",\n\n    /**\n     * Update Raiden Config with a partial (shallow) object\n     *\n     * @param config - Partial object containing keys and values to update in config\n     */\n    value: function updateConfig(config) {\n      this.store.dispatch(raidenConfigUpdate(decode(PartialRaidenConfig, config)));\n    }\n    /**\n     * Get ETH balance for given address or self\n     *\n     * @param address - Optional target address. If omitted, gets own balance\n     * @returns BigNumber of ETH balance\n     */\n\n  }, {\n    key: "getBalance",\n    value: function getBalance(address) {\n      address = address !== null && address !== void 0 ? address : chooseOnchainAccount(this.deps, this.config.subkey).address;\n      assert(Address.is(address), \'Invalid address\');\n      return this.deps.provider.getBalance(address);\n    }\n    /**\n     * Get token balance and token decimals for given address or self\n     *\n     * @param token - Token address to fetch balance. Must be one of the monitored tokens.\n     * @param address - Optional target address. If omitted, gets own balance\n     * @returns BigNumber containing address\'s token balance\n     */\n\n  }, {\n    key: "getTokenBalance",\n    value: function getTokenBalance(token, address) {\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee4() {\n        var tokenContract;\n        return regenerator_default.a.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                address = address !== null && address !== void 0 ? address : chooseOnchainAccount(this.deps, this.config.subkey).address;\n                assert(Address.is(address) && Address.is(token), \'Invalid address\');\n                tokenContract = this.deps.getTokenContract(token);\n                return _context4.abrupt("return", tokenContract.functions.balanceOf(address));\n\n              case 4:\n              case "end":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Returns a list of all token addresses registered as token networks in registry\n     *\n     * @returns Promise to list of token addresses\n     */\n\n  }, {\n    key: "getTokenList",\n    value: function getTokenList() {\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee5() {\n        var _this3 = this;\n\n        return regenerator_default.a.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt("return", this.deps.provider.getLogs(Object.assign(Object.assign({}, this.deps.registryContract.filters.TokenNetworkCreated(null, null)), {\n                  fromBlock: this.deps.contractsInfo.TokenNetworkRegistry.block_number,\n                  toBlock: \'latest\'\n                })).then(function (logs) {\n                  return logs.map(function (log) {\n                    return _this3.deps.registryContract.interface.parseLog(log);\n                  }).filter(function (parsed) {\n                    var _a;\n\n                    return !!((_a = parsed.values) === null || _a === void 0 ? void 0 : _a.token_address);\n                  }).map(function (parsed) {\n                    return parsed.values.token_address;\n                  });\n                }));\n\n              case 1:\n              case "end":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\n     * Scans initially and start monitoring a token for channels with us, returning its Tokennetwork\n     * address\n     *\n     * Throws an exception if token isn\'t registered in current registry\n     *\n     * @param token - token address to monitor, must be registered in current token network registry\n     * @returns Address of TokenNetwork contract\n     */\n\n  }, {\n    key: "monitorToken",\n    value: function monitorToken(token) {\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee6() {\n        var alreadyMonitoredTokens, tokenNetwork;\n        return regenerator_default.a.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                assert(Address.is(token), \'Invalid address\');\n                alreadyMonitoredTokens = this.state.tokens;\n\n                if (!(token in alreadyMonitoredTokens)) {\n                  _context6.next = 4;\n                  break;\n                }\n\n                return _context6.abrupt("return", alreadyMonitoredTokens[token]);\n\n              case 4:\n                _context6.next = 6;\n                return this.deps.registryContract.token_to_token_networks(token);\n\n              case 6:\n                tokenNetwork = _context6.sent;\n                assert(tokenNetwork && tokenNetwork !== constants["AddressZero"], \'Unknown token network\');\n                this.store.dispatch(tokenMonitored({\n                  token: token,\n                  tokenNetwork: tokenNetwork,\n                  fromBlock: this.deps.contractsInfo.TokenNetworkRegistry.block_number\n                }));\n                return _context6.abrupt("return", tokenNetwork);\n\n              case 10:\n              case "end":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n    /**\n     * Open a channel on the tokenNetwork for given token address with partner\n     *\n     * If token isn\'t yet monitored, starts monitoring it\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param partner - Partner address\n     * @param options - (optional) option parameter\n     * @param options.settleTimeout - Custom, one-time settle timeout\n     * @param options.subkey - Whether to use the subkey for on-chain tx or main account (default)\n     * @param onChange - Optional callback for status change notification\n     * @returns txHash of channelOpen call, iff it succeeded\n     */\n\n  }, {\n    key: "openChannel",\n    value: function openChannel(token, partner) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var onChange = arguments.length > 3 ? arguments[3] : undefined;\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee7() {\n        var tokenNetwork, deposit, meta, openPromise, openTxHash, depositTx;\n        return regenerator_default.a.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                assert(Address.is(token) && Address.is(partner), \'Invalid address\');\n                _context7.next = 3;\n                return this.monitorToken(token);\n\n              case 3:\n                tokenNetwork = _context7.sent;\n                assert(!options.subkey || this.deps.main, "Can\'t send tx from subkey if not set");\n                deposit = options.deposit === undefined ? undefined : decode(UInt(32), options.deposit);\n                meta = {\n                  tokenNetwork: tokenNetwork,\n                  partner: partner\n                }; // wait for confirmation\n\n                openPromise = asyncActionToPromise(channelOpen, meta, this.action$, false).then(function (_ref) {\n                  var txHash = _ref.txHash;\n                  return txHash;\n                });\n                this.store.dispatch(channelOpen.request(Object.assign(Object.assign({}, options), {\n                  deposit: deposit\n                }), meta));\n                _context7.next = 11;\n                return openPromise;\n\n              case 11:\n                openTxHash = _context7.sent;\n                onChange === null || onChange === void 0 ? void 0 : onChange({\n                  type: EventTypes.OPENED,\n                  payload: {\n                    txHash: openTxHash\n                  }\n                });\n                _context7.next = 15;\n                return this.state$.pipe(pluckDistinct(\'channels\', tokenNetwork, partner, \'state\'), Object(first["a" /* first */])(function (state) {\n                  return state === ChannelState.open;\n                })).toPromise();\n\n              case 15:\n                onChange === null || onChange === void 0 ? void 0 : onChange({\n                  type: EventTypes.CONFIRMED,\n                  payload: {\n                    txHash: openTxHash\n                  }\n                });\n\n                if (!deposit) {\n                  _context7.next = 21;\n                  break;\n                }\n\n                _context7.next = 19;\n                return asyncActionToPromise(channelDeposit, meta, this.action$, true).then(function (_ref2) {\n                  var txHash = _ref2.txHash;\n                  return txHash;\n                });\n\n              case 19:\n                depositTx = _context7.sent;\n                onChange === null || onChange === void 0 ? void 0 : onChange({\n                  type: EventTypes.DEPOSITED,\n                  payload: {\n                    txHash: depositTx\n                  }\n                });\n\n              case 21:\n                return _context7.abrupt("return", openTxHash);\n\n              case 22:\n              case "end":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n    /**\n     * Deposit tokens on channel between us and partner on tokenNetwork for token\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param partner - Partner address\n     * @param amount - Number of tokens to deposit on channel\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    (and is also the account used as source of the deposit tokens).\n     *    Set this to true if one wants to force sending the transaction with the subkey, and using\n     *    tokens held in the subkey.\n     * @returns txHash of setTotalDeposit call, iff it succeeded\n     */\n\n  }, {\n    key: "depositChannel",\n    value: function depositChannel(token, partner, amount) {\n      var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n          subkey = _ref3.subkey;\n\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee8() {\n        var state, tokenNetwork, deposit, meta, promise;\n        return regenerator_default.a.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                assert(Address.is(token) && Address.is(partner), \'Invalid address\');\n                state = this.state;\n                tokenNetwork = state.tokens[token];\n                assert(tokenNetwork, \'Unknown token network\');\n                assert(!subkey || this.deps.main, "Can\'t send tx from subkey if not set");\n                deposit = decode(UInt(32), amount);\n                meta = {\n                  tokenNetwork: tokenNetwork,\n                  partner: partner\n                };\n                promise = asyncActionToPromise(channelDeposit, meta, this.action$, true).then(function (_ref4) {\n                  var txHash = _ref4.txHash;\n                  return txHash;\n                });\n                this.store.dispatch(channelDeposit.request({\n                  deposit: deposit,\n                  subkey: subkey\n                }, meta));\n                return _context8.abrupt("return", promise);\n\n              case 10:\n              case "end":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\n     * Close channel between us and partner on tokenNetwork for token\n     * This method will fail if called on a channel not in \'opened\' or \'closing\' state.\n     * When calling this method on an \'opened\' channel, its state becomes \'closing\', and from there\n     * on, no payments can be performed on the channel. If for any reason the closeChannel\n     * transaction fails, channel\'s state stays as \'closing\', and this method can be called again\n     * to retry sending \'closeChannel\' transaction. After it\'s successful, channel becomes \'closed\',\n     * and can be settled after \'settleTimeout\' blocks (when it then becomes \'settleable\').\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param partner - Partner address\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    Set this to true if one wants to force sending the transaction with the subkey\n     * @returns txHash of closeChannel call, iff it succeeded\n     */\n\n  }, {\n    key: "closeChannel",\n    value: function closeChannel(token, partner) {\n      var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          subkey = _ref5.subkey;\n\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee9() {\n        var state, tokenNetwork, meta, promise;\n        return regenerator_default.a.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                assert(Address.is(token) && Address.is(partner), \'Invalid address\');\n                state = this.state;\n                tokenNetwork = state.tokens[token];\n                assert(tokenNetwork, \'Unknown token network\');\n                assert(!subkey || this.deps.main, "Can\'t send tx from subkey if not set");\n                meta = {\n                  tokenNetwork: tokenNetwork,\n                  partner: partner\n                };\n                promise = asyncActionToPromise(channelClose, meta, this.action$, true).then(function (_ref6) {\n                  var txHash = _ref6.txHash;\n                  return txHash;\n                });\n                this.store.dispatch(channelClose.request(subkey ? {\n                  subkey: subkey\n                } : undefined, meta));\n                return _context9.abrupt("return", promise);\n\n              case 9:\n              case "end":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n    /**\n     * Settle channel between us and partner on tokenNetwork for token\n     * This method will fail if called on a channel not in \'settleable\' or \'settling\' state.\n     * Channel becomes \'settleable\' settleTimeout blocks after closed (detected automatically\n     * while Raiden Light Client is running or later on restart). When calling it, channel state\n     * becomes \'settling\'. If for any reason transaction fails, it\'ll stay on this state, and this\n     * method can be called again to re-send a settleChannel transaction.\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param partner - Partner address\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    Set this to true if one wants to force sending the transaction with the subkey\n     * @returns txHash of settleChannel call, iff it succeeded\n     */\n\n  }, {\n    key: "settleChannel",\n    value: function settleChannel(token, partner) {\n      var _ref7 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          subkey = _ref7.subkey;\n\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee10() {\n        var state, tokenNetwork, meta, promise;\n        return regenerator_default.a.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                assert(Address.is(token) && Address.is(partner), \'Invalid address\');\n                state = this.state;\n                tokenNetwork = state.tokens[token];\n                assert(tokenNetwork, \'Unknown token network\');\n                assert(!subkey || this.deps.main, "Can\'t send tx from subkey if not set"); // wait for the corresponding success or error action\n\n                meta = {\n                  tokenNetwork: tokenNetwork,\n                  partner: partner\n                };\n                promise = asyncActionToPromise(channelSettle, meta, this.action$, true).then(function (_ref8) {\n                  var txHash = _ref8.txHash;\n                  return txHash;\n                });\n                this.store.dispatch(channelSettle.request(subkey ? {\n                  subkey: subkey\n                } : undefined, meta));\n                return _context10.abrupt("return", promise);\n\n              case 9:\n              case "end":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n    /**\n     * Returns object describing address\'s users availability on transport\n     * After calling this method, any further presence update to valid transport peers of this\n     * address will trigger a corresponding MatrixPresenceUpdateAction on events$\n     *\n     * @param address - checksummed address to be monitored\n     * @returns Promise to object describing availability and last event timestamp\n     */\n\n  }, {\n    key: "getAvailability",\n    value: function getAvailability(address) {\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee11() {\n        var meta, promise;\n        return regenerator_default.a.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                assert(Address.is(address), \'Invalid address\');\n                meta = {\n                  address: address\n                };\n                promise = asyncActionToPromise(matrixPresence, meta, this.action$);\n                this.store.dispatch(matrixPresence.request(undefined, meta));\n                return _context11.abrupt("return", promise);\n\n              case 5:\n              case "end":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n    }\n    /**\n     * Send a Locked Transfer!\n     * This will reject if LockedTransfer signature prompt is canceled/signature fails, or be\n     * resolved to the transfer unique identifier (secrethash) otherwise, and transfer status can be\n     * queried with this id on this.transfers$ observable, which will just have emitted the \'pending\'\n     * transfer. Any following transfer state change will be notified through this observable.\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param target - Target address (must be getAvailability before)\n     * @param value - Amount to try to transfer\n     * @param options - Optional parameters for transfer:\n     *    <ul>\n     *      <li>paymentId - payment identifier, a random one will be generated if missing</li>\n     *      <li>secret - Secret to register, a random one will be generated if missing</li>\n     *      <li>secrethash - Must match secret, if both provided, or else, secret must be\n     *          informed to target by other means, and reveal can\'t be performed</li>\n     *      <li>paths - Used to specify possible routes & fees instead of querying PFS.</li>\n     *      <li>pfs - Use this PFS instead of configured or automatically choosen ones.\n     *          Is ignored if paths were already provided. If neither are set and config.pfs is not\n     *          disabled (null), use it if set or if undefined (auto mode), fetches the best\n     *          PFS from ServiceRegistry and automatically fetch routes from it.</li>\n     *    </ul>\n     * @returns A promise to transfer\'s secrethash (unique id) when it\'s accepted\n     */\n\n  }, {\n    key: "transfer",\n    value: function transfer(token, target, value) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee12() {\n        var _this4 = this;\n\n        var tokenNetwork, decodedValue, paymentId, paths, pfs, secret, secrethash, pathFindMeta;\n        return regenerator_default.a.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                assert(Address.is(token) && Address.is(target), \'Invalid address\');\n                tokenNetwork = this.state.tokens[token];\n                assert(tokenNetwork, \'Unknown token network\');\n                decodedValue = decode(UInt(32), value);\n                paymentId = options.paymentId ? decode(UInt(8), options.paymentId) : makePaymentId();\n                paths = options.paths ? decode(Paths, options.paths) : undefined;\n                pfs = options.pfs ? decode(PFS, options.pfs) : undefined;\n                assert(options.secret === undefined || Secret.is(options.secret), \'Invalid options.secret\');\n                assert(options.secrethash === undefined || Hash.is(options.secrethash), \'Invalid options.secrethash\'); // use provided secret or create one if no secrethash was provided\n\n                secret = options.secret ? options.secret : !options.secrethash ? makeSecret() : undefined;\n                secrethash = options.secrethash || getSecrethash(secret);\n                assert(!secret || getSecrethash(secret) === secrethash, \'Provided secrethash must match the sha256 hash of provided secret\');\n                pathFindMeta = {\n                  tokenNetwork: tokenNetwork,\n                  target: target,\n                  value: decodedValue\n                };\n                return _context12.abrupt("return", Object(merge["a" /* merge */])( // wait for pathFind response\n                this.action$.pipe(Object(first["a" /* first */])(isResponseOf(pathFind, pathFindMeta)), Object(map["a" /* map */])(function (action) {\n                  if (pathFind.failure.is(action)) throw action.payload;\n                  return action.payload.paths;\n                })), // request pathFind; even if paths were provided, send it again for validation\n                // this is done at \'merge\' subscription time (i.e. when above action filter is subscribed)\n                Object(defer["a" /* defer */])(function () {\n                  _this4.store.dispatch(pathFind.request({\n                    paths: paths,\n                    pfs: pfs\n                  }, pathFindMeta));\n\n                  return empty["a" /* EMPTY */];\n                })).pipe(Object(mergeMap["a" /* mergeMap */])(function (paths) {\n                  return Object(merge["a" /* merge */])( // wait for transfer response\n                  _this4.action$.pipe(Object(filter["a" /* filter */])(isActionOf([transferSigned, actions_transfer.failure])), Object(first["a" /* first */])(function (action) {\n                    return action.meta.secrethash === secrethash;\n                  }), Object(map["a" /* map */])(function (action) {\n                    if (actions_transfer.failure.is(action)) throw action.payload;\n                    return secrethash;\n                  })), // request transfer with returned/validated paths at \'merge\' subscription time\n                  Object(defer["a" /* defer */])(function () {\n                    _this4.store.dispatch(actions_transfer.request({\n                      tokenNetwork: tokenNetwork,\n                      target: target,\n                      value: decodedValue,\n                      paths: paths,\n                      paymentId: paymentId,\n                      secret: secret\n                    }, {\n                      secrethash: secrethash,\n                      direction: Direction.SENT\n                    }));\n\n                    return empty["a" /* EMPTY */];\n                  }));\n                })).toPromise());\n\n              case 14:\n              case "end":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n    }\n    /**\n     * Waits for the transfer identified by a secrethash to fail or complete\n     *\n     * The returned promise will resolve with the final amount received by the target\n     *\n     * @param secrethash - Transfer identifier\n     * @returns Amount received by target, as informed by them on SecretRequest\n     */\n\n  }, {\n    key: "waitTransfer",\n    value: function waitTransfer(secrethash) {\n      var _a, _b, _c, _d;\n\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee13() {\n        var state, sent;\n        return regenerator_default.a.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                assert(Hash.is(secrethash), \'Invalid secrethash for transfer\');\n                state = this.state;\n                assert(secrethash in state.sent, \'Unknown secrethash\');\n                sent = raidenSentTransfer(state.sent[secrethash]); // already completed/past transfer\n\n                if (!sent.completed) {\n                  _context13.next = 10;\n                  break;\n                }\n\n                if (!sent.success) {\n                  _context13.next = 9;\n                  break;\n                }\n\n                return _context13.abrupt("return", (_b = (_a = this.state.sent[secrethash].secretRequest) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.amount);\n\n              case 9:\n                throw new error_RaidenError(ErrorCodes.XFER_ALREADY_COMPLETED, {\n                  status: sent.status\n                });\n\n              case 10:\n                _context13.next = 12;\n                return asyncActionToPromise(actions_transfer, {\n                  secrethash: secrethash,\n                  direction: Direction.SENT\n                }, this.action$);\n\n              case 12:\n                state = this.state;\n                return _context13.abrupt("return", (_d = (_c = state.sent[secrethash].secretRequest) === null || _c === void 0 ? void 0 : _c[1]) === null || _d === void 0 ? void 0 : _d.amount);\n\n              case 14:\n              case "end":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n    }\n    /**\n     * Request a path from PFS\n     *\n     * If a direct route is possible, it\'ll be returned. Else if PFS is set up, a request will be\n     * performed and the cleaned/validated path results will be resolved.\n     * Else, if no route can be found, promise is rejected with respective error.\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param target - Target address (must be getAvailability before)\n     * @param value - Minimum capacity required on routes\n     * @param options - Optional parameters\n     * @param options.pfs - Use this PFS instead of configured or automatically choosen ones\n     * @returns A promise to returned routes/paths result\n     */\n\n  }, {\n    key: "findRoutes",\n    value: function findRoutes(token, target, value) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee14() {\n        var tokenNetwork, decodedValue, pfs, meta, promise;\n        return regenerator_default.a.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                assert(Address.is(token) && Address.is(target), \'Invalid address\');\n                tokenNetwork = this.state.tokens[token];\n                assert(tokenNetwork, \'Unknown token network\');\n                decodedValue = decode(UInt(32), value);\n                pfs = options.pfs ? decode(PFS, options.pfs) : undefined;\n                meta = {\n                  tokenNetwork: tokenNetwork,\n                  target: target,\n                  value: decodedValue\n                };\n                promise = asyncActionToPromise(pathFind, meta, this.action$).then(function (_ref9) {\n                  var paths = _ref9.paths;\n                  return paths;\n                });\n                this.store.dispatch(pathFind.request({\n                  pfs: pfs\n                }, meta));\n                return _context14.abrupt("return", promise);\n\n              case 9:\n              case "end":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n    }\n    /**\n     * Checks if a direct transfer of token to target could be performed and returns it on a\n     * single-element array of Paths\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param target - Target address (must be getAvailability before)\n     * @param value - Minimum capacity required on route\n     * @returns Promise to a [Raiden]Paths array containing the single, direct route, or undefined\n     */\n\n  }, {\n    key: "directRoute",\n    value: function directRoute(token, target, value) {\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee15() {\n        var tokenNetwork, decodedValue, meta, promise;\n        return regenerator_default.a.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                assert(Address.is(token) && Address.is(target), \'Invalid address\');\n                tokenNetwork = this.state.tokens[token];\n                assert(tokenNetwork, \'Unknown token network\');\n                decodedValue = decode(UInt(32), value);\n                meta = {\n                  tokenNetwork: tokenNetwork,\n                  target: target,\n                  value: decodedValue\n                };\n                promise = asyncActionToPromise(pathFind, meta, this.action$).then(function (_ref10) {\n                  var paths = _ref10.paths;\n                  return paths;\n                }, // pluck paths\n                function () {\n                  return undefined;\n                }); // dispatch a pathFind with pfs disabled, to force checking for a direct route\n\n                this.store.dispatch(pathFind.request({\n                  pfs: null\n                }, meta));\n                return _context15.abrupt("return", promise);\n\n              case 8:\n              case "end":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n    }\n    /**\n     * Returns a sorted array of info of available PFS\n     *\n     * It uses data polled from ServiceRegistry, which is available only when config.pfs is\n     * undefined, instead of set or disabled (null), and will reject if not.\n     * It can reject if the validated list is empty, meaning we can be out-of-sync (we\'re outdated or\n     * they are) with PFSs deployment, or no PFS is available on this TokenNetwork/blockchain.\n     *\n     * @returns Promise to array of PFS, which is the interface which describes a PFS\n     */\n\n  }, {\n    key: "findPFS",\n    value: function findPFS() {\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee16() {\n        var _this5 = this;\n\n        return regenerator_default.a.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                assert(this.config.pfs !== null, \'PFS disabled in config\');\n                return _context16.abrupt("return", (this.config.pfs ? Object(of["a" /* of */])([this.config.pfs]) : this.deps.latest$.pipe(pluckDistinct(\'pfsList\'), Object(first["a" /* first */])(function (v) {\n                  return v.length > 0;\n                }))).pipe(Object(mergeMap["a" /* mergeMap */])(function (pfsList) {\n                  return pfsListInfo(pfsList, _this5.deps);\n                })).toPromise());\n\n              case 2:\n              case "end":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n    }\n    /**\n     * Mints the amount of tokens of the provided token address.\n     * Throws an error, if\n     * <ol>\n     *  <li>Executed on main net</li>\n     *  <li>`token` is not a valid address</li>\n     *  <li>Token could not be minted</li>\n     * </ol>\n     *\n     * @param token - Address of the token to be minted\n     * @param amount - Amount to be minted\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    Notice the beneficiary here is always the account that sends the transaction, as this is\n     *    expectedly also the account that will pay for e.g. future deposits.\n     *    Set this to true if one wants to force sending the transaction with the subkey\n     * @returns transaction\n     */\n\n  }, {\n    key: "mint",\n    value: function mint(token, amount) {\n      var _ref11 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          subkey = _ref11.subkey;\n\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee17() {\n        var _chooseOnchainAccount, signer, customTokenContract, receipt;\n\n        return regenerator_default.a.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                // Check whether address is valid\n                assert(Address.is(token), \'Invalid address\');\n                assert(!subkey || this.deps.main, "Can\'t send tx from subkey if not set"); // Check whether we are on a test network\n\n                assert(this.deps.network.name !== \'homestead\', \'Minting is only allowed on test networks.\');\n                _chooseOnchainAccount = chooseOnchainAccount(this.deps, subkey !== null && subkey !== void 0 ? subkey : this.config.subkey), signer = _chooseOnchainAccount.signer; // Mint token\n\n                customTokenContract = CustomTokenFactory_CustomTokenFactory.connect(token, signer);\n                _context17.next = 7;\n                return callAndWaitMined(customTokenContract, \'mint\', [decode(UInt(32), amount)], ErrorCodes.RDN_MINT_FAILED, {\n                  log: this.log\n                });\n\n              case 7:\n                receipt = _context17.sent;\n                _context17.next = 10;\n                return waitConfirmation(receipt, this.deps, 1);\n\n              case 10:\n                return _context17.abrupt("return", receipt.transactionHash);\n\n              case 11:\n              case "end":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n    }\n    /**\n     * Fetches balance of UserDeposit Contract for SDK\'s account minus cached spent IOUs\n     *\n     * @returns Promise to UDC remaining capacity\n     */\n\n  }, {\n    key: "getUDCCapacity",\n    value: function getUDCCapacity() {\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee18() {\n        var balance, blockNumber, owedAmount;\n        return regenerator_default.a.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.next = 2;\n                return this.deps.userDepositContract.functions.balances(this.deps.address);\n\n              case 2:\n                balance = _context18.sent;\n                blockNumber = this.state.blockNumber;\n                owedAmount = Object.values(this.state.path.iou).reduce(function (acc, value) {\n                  var nonExpiredIOUs = Object.values(value).filter(function (value) {\n                    return value.expiration_block.gte(blockNumber);\n                  });\n                  acc.push.apply(acc, raiden_toConsumableArray(nonExpiredIOUs));\n                  return acc;\n                }, new Array()).reduce(function (acc, iou) {\n                  return acc.add(iou.amount);\n                }, constants["Zero"]);\n                return _context18.abrupt("return", balance.sub(owedAmount));\n\n              case 6:\n              case "end":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n    }\n    /**\n     * Deposits the amount to the UserDeposit contract with the target/signer as a beneficiary.\n     * The deposited amount can be used as a collateral in order to sign valid IOUs that will\n     * be accepted by the Services.\n     *\n     * Throws an error, in the following cases:\n     * <ol>\n     *  <li>The amount specified equals to zero</li>\n     *  <li>The target has an insufficient token balance</li>\n     *  <li>The "approve" transaction fails with an error</li>\n     *  <li>The "deposit" transaction fails with an error</li>\n     * </ol>\n     *\n     * @param amount - The amount to deposit on behalf of the target/beneficiary.\n     * @param onChange - callback providing notifications about state changes\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    Set this to true if one wants to force sending the transaction with the subkey\n     * @returns transaction hash\n     */\n\n  }, {\n    key: "depositToUDC",\n    value: function depositToUDC(amount, onChange) {\n      var _ref12 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          subkey = _ref12.subkey;\n\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee19() {\n        var depositAmount, _chooseOnchainAccount2, signer, address, userDepositContract, serviceTokenContract, balance, approveReceipt, currentUDCBalance, depositReceipt;\n\n        return regenerator_default.a.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                assert(!subkey || this.deps.main, "Can\'t send tx from subkey if not set", this.log.debug);\n                depositAmount = Object(utils["bigNumberify"])(amount);\n                assert(depositAmount.gt(constants["Zero"]), \'Please deposit a positive amount.\', this.log.debug);\n                _chooseOnchainAccount2 = chooseOnchainAccount(this.deps, subkey !== null && subkey !== void 0 ? subkey : this.config.subkey), signer = _chooseOnchainAccount2.signer, address = _chooseOnchainAccount2.address;\n                userDepositContract = getContractWithSigner(this.deps.userDepositContract, signer);\n                _context19.t0 = getContractWithSigner;\n                _context19.t1 = this.deps;\n                _context19.next = 9;\n                return this.userDepositTokenAddress();\n\n              case 9:\n                _context19.t2 = _context19.sent;\n                _context19.t3 = _context19.t1.getTokenContract.call(_context19.t1, _context19.t2);\n                _context19.t4 = signer;\n                serviceTokenContract = (0, _context19.t0)(_context19.t3, _context19.t4);\n                _context19.next = 15;\n                return serviceTokenContract.functions.balanceOf(address);\n\n              case 15:\n                balance = _context19.sent;\n                assert(balance.gte(amount), "Insufficient token balance (".concat(balance, ")."), this.log.debug);\n                _context19.next = 19;\n                return callAndWaitMined(serviceTokenContract, \'approve\', [userDepositContract.address, depositAmount], ErrorCodes.RDN_APPROVE_TRANSACTION_FAILED, {\n                  log: this.log\n                });\n\n              case 19:\n                approveReceipt = _context19.sent;\n                onChange === null || onChange === void 0 ? void 0 : onChange({\n                  type: EventTypes.APPROVED,\n                  payload: {\n                    txHash: approveReceipt.transactionHash\n                  }\n                });\n                _context19.next = 23;\n                return userDepositContract.functions.balances(this.address);\n\n              case 23:\n                currentUDCBalance = _context19.sent;\n                _context19.next = 26;\n                return callAndWaitMined(userDepositContract, \'deposit\', [this.address, currentUDCBalance.add(depositAmount)], ErrorCodes.RDN_DEPOSIT_TRANSACTION_FAILED, {\n                  log: this.log\n                });\n\n              case 26:\n                depositReceipt = _context19.sent;\n                onChange === null || onChange === void 0 ? void 0 : onChange({\n                  type: EventTypes.DEPOSITED,\n                  payload: {\n                    txHash: depositReceipt.transactionHash\n                  }\n                });\n                _context19.next = 30;\n                return waitConfirmation(depositReceipt, this.deps);\n\n              case 30:\n                this.log.debug("deposit tx \\"".concat(depositReceipt.transactionHash, "\\" confirmed"));\n                onChange === null || onChange === void 0 ? void 0 : onChange({\n                  type: EventTypes.CONFIRMED,\n                  payload: {\n                    txHash: depositReceipt.transactionHash\n                  }\n                });\n                return _context19.abrupt("return", depositReceipt.transactionHash);\n\n              case 33:\n              case "end":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n    }\n    /**\n     * Transfer value ETH on-chain to address.\n     * If subkey is being used, use main account by default, or subkey account if \'subkey\' is true\n     * Example:\n     *   // transfer 0.1 ETH from main account to subkey account, when subkey is used\n     *   await raiden.transferOnchainBalance(raiden.address, parseEther(\'0.1\'));\n     *   // transfer 0.1 ETH back from subkey account to main account\n     *   await raiden.transferOnchainBalance(raiden.mainAddress, parseEther(\'0.1\'), true);\n     * TODO: expose a nice way to transfer ALL, considering gas price & limit\n     *\n     * @param to - Recipient address\n     * @param value - Amount of ETH (in Wei) to transfer. Use ethers/utils::parseEther if needed\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    Set this to true if one wants to force sending the transaction with the subkey\n     * @returns transaction hash\n     */\n\n  }, {\n    key: "transferOnchainBalance",\n    value: function transferOnchainBalance(to, value) {\n      var _ref13 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          subkey = _ref13.subkey;\n\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee20() {\n        var _chooseOnchainAccount3, signer, tx, receipt;\n\n        return regenerator_default.a.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                assert(Address.is(to), \'Invalid address\', this.log.debug);\n                assert(!subkey || this.deps.main, "Can\'t send tx from subkey if not set", this.log.debug);\n                _chooseOnchainAccount3 = chooseOnchainAccount(this.deps, subkey !== null && subkey !== void 0 ? subkey : this.config.subkey), signer = _chooseOnchainAccount3.signer;\n                _context20.next = 5;\n                return signer.sendTransaction({\n                  to: to,\n                  value: Object(utils["bigNumberify"])(value)\n                });\n\n              case 5:\n                tx = _context20.sent;\n                _context20.next = 8;\n                return tx.wait();\n\n              case 8:\n                receipt = _context20.sent;\n\n                if (receipt.status) {\n                  _context20.next = 11;\n                  break;\n                }\n\n                throw new error_RaidenError(ErrorCodes.RDN_TRANSFER_ONCHAIN_BALANCE_FAILED);\n\n              case 11:\n                return _context20.abrupt("return", tx.hash);\n\n              case 12:\n              case "end":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n    }\n    /**\n     * Transfer value tokens on-chain to address.\n     * If subkey is being used, use main account by default, or subkey account if \'subkey\' is true\n     * TODO: expose a nice way to transfer ALL tokens\n     *\n     * @param token - Token address\n     * @param to - Recipient address\n     * @param value - Amount of tokens (in Wei) to transfer. Use ethers/utils::parseUnits if needed\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    Set this to true if one wants to force sending the transaction with the subkey\n     * @returns transaction hash\n     */\n\n  }, {\n    key: "transferOnchainTokens",\n    value: function transferOnchainTokens(token, to, value) {\n      var _ref14 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n          subkey = _ref14.subkey;\n\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee21() {\n        var _chooseOnchainAccount4, signer, tokenContract, receipt;\n\n        return regenerator_default.a.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                assert(Address.is(token) && Address.is(to), \'Invalid address\', this.log.debug);\n                assert(!subkey || this.deps.main, "Can\'t send tx from subkey if not set", this.log.debug);\n                _chooseOnchainAccount4 = chooseOnchainAccount(this.deps, subkey !== null && subkey !== void 0 ? subkey : this.config.subkey), signer = _chooseOnchainAccount4.signer;\n                tokenContract = getContractWithSigner(this.deps.getTokenContract(token), signer);\n                _context21.next = 6;\n                return callAndWaitMined(tokenContract, \'transfer\', [to, Object(utils["bigNumberify"])(value)], ErrorCodes.RDN_TRANSFER_ONCHAIN_TOKENS_FAILED, {\n                  log: this.log\n                });\n\n              case 6:\n                receipt = _context21.sent;\n                return _context21.abrupt("return", receipt.transactionHash);\n\n              case 8:\n              case "end":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n    }\n  }, {\n    key: "started",\n    get: function get() {\n      // !epicMiddleware -> undefined | null -> undefined ? true/started : null/stopped;\n      if (!this.epicMiddleware) return this.epicMiddleware === undefined; // else -> !!epicMiddleware -> not yet started -> returns undefined\n    }\n  }, {\n    key: "state",\n    get: function get() {\n      return this.store.getState();\n    }\n    /**\n     * Get current account address (subkey\'s address, if subkey is being used)\n     *\n     * @returns Instance address\n     */\n\n  }, {\n    key: "address",\n    get: function get() {\n      return this.deps.address;\n    }\n    /**\n     * Get main account address (if subkey is being used, undefined otherwise)\n     *\n     * @returns Main account address\n     */\n\n  }, {\n    key: "mainAddress",\n    get: function get() {\n      var _a;\n\n      return (_a = this.deps.main) === null || _a === void 0 ? void 0 : _a.address;\n    }\n    /**\n     * Get current network from provider\n     *\n     * @returns Network object containing blockchain\'s name & chainId\n     */\n\n  }, {\n    key: "network",\n    get: function get() {\n      return this.deps.network;\n    }\n  }, {\n    key: "config",\n    get: function get() {\n      var config;\n      this.deps.config$.pipe(Object(first["a" /* first */])()).subscribe(function (c) {\n        return config = c;\n      });\n      return config;\n    }\n    /**\n     * Returns the currently used SDK version.\n     *\n     * @returns SDK version\n     */\n\n  }], [{\n    key: "create",\n    value: function create(connection, account, storageOrState, contracts, config, subkey) {\n      return raiden_awaiter(this, void 0, void 0, /*#__PURE__*/regenerator_default.a.mark(function _callee22() {\n        var provider, network, _yield$getSigner, signer, address, main, _yield$getState, state, onState, onStateComplete, defaultConfig, raiden;\n\n        return regenerator_default.a.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                if (typeof connection === \'string\') {\n                  provider = new providers["JsonRpcProvider"](connection);\n                } else if (connection instanceof providers["JsonRpcProvider"]) {\n                  provider = connection;\n                } else {\n                  provider = new providers["Web3Provider"](connection);\n                } // Patch provider\'s sign method (https://github.com/raiden-network/light-client/issues/223)\n\n\n                patchSignSend(provider);\n                _context22.next = 4;\n                return provider.getNetwork();\n\n              case 4:\n                network = _context22.sent;\n\n                // if no ContractsInfo, try to populate from defaults\n                if (!contracts) {\n                  contracts = helpers_getContracts(network);\n                }\n\n                _context22.next = 8;\n                return helpers_getSigner(account, provider, subkey);\n\n              case 8:\n                _yield$getSigner = _context22.sent;\n                signer = _yield$getSigner.signer;\n                address = _yield$getSigner.address;\n                main = _yield$getSigner.main;\n                _context22.next = 14;\n                return state_getState(network, contracts, address, storageOrState, config && decode(PartialRaidenConfig, config));\n\n              case 14:\n                _yield$getState = _context22.sent;\n                state = _yield$getState.state;\n                onState = _yield$getState.onState;\n                onStateComplete = _yield$getState.onStateComplete;\n                defaultConfig = _yield$getState.defaultConfig;\n                assert(address === state.address, "Mismatch between provided account and loaded state: \\"".concat(address, "\\" !== \\"").concat(state.address, "\\""));\n                assert(network.chainId === state.chainId && contracts.TokenNetworkRegistry.address === state.registry, "Mismatch between network or registry address and loaded state");\n                raiden = new Raiden(provider, network, signer, contracts, state, defaultConfig, main);\n                if (onState) raiden.state$.subscribe(onState, onStateComplete, onStateComplete);\n                return _context22.abrupt("return", raiden);\n\n              case 24:\n              case "end":\n                return _context22.stop();\n            }\n          }\n        }, _callee22);\n      }));\n    }\n  }, {\n    key: "version",\n    get: function get() {\n      return versions.sdk;\n    }\n    /**\n     * Returns the version of the used Smart Contracts.\n     *\n     * @returns Smart Contract version\n     */\n\n  }, {\n    key: "contractVersion",\n    get: function get() {\n      return versions.contracts;\n    }\n  }]);\n\n  return Raiden;\n}();\n/* harmony default export */ var dist_raiden = (raiden_Raiden);\n// CONCATENATED MODULE: ../raiden-ts/dist/index.js\n/* istanbul ignore file */\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3BvbHlmaWxscy50cz8yYWE4Iiwid2VicGFjazovLy8uLi9yYWlkZW4tdHMvZGlzdC9jb250cmFjdHMvVG9rZW5OZXR3b3JrUmVnaXN0cnlGYWN0b3J5LnRzP2FkOGQiLCJ3ZWJwYWNrOi8vLy4uL3JhaWRlbi10cy9kaXN0L2NvbnRyYWN0cy9Ub2tlbk5ldHdvcmtGYWN0b3J5LnRzPzQ3ZmYiLCJ3ZWJwYWNrOi8vLy4uL3JhaWRlbi10cy9kaXN0L2NvbnRyYWN0cy9IdW1hblN0YW5kYXJkVG9rZW5GYWN0b3J5LnRzP2U3MWMiLCJ3ZWJwYWNrOi8vLy4uL3JhaWRlbi10cy9kaXN0L2NvbnRyYWN0cy9TZXJ2aWNlUmVnaXN0cnlGYWN0b3J5LnRzPzQ3ZWYiLCJ3ZWJwYWNrOi8vLy4uL3JhaWRlbi10cy9kaXN0L2NvbnRyYWN0cy9DdXN0b21Ub2tlbkZhY3RvcnkudHM/NWM0YSIsIndlYnBhY2s6Ly8vLi4vcmFpZGVuLXRzL2Rpc3QvY29udHJhY3RzL1VzZXJEZXBvc2l0RmFjdG9yeS50cz8xZjk3Iiwid2VicGFjazovLy8uLi9yYWlkZW4tdHMvZGlzdC9jb250cmFjdHMvU2VjcmV0UmVnaXN0cnlGYWN0b3J5LnRzP2MzYjMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy90eXBlcy50cz84Y2UxIiwid2VicGFjazovLy8uLi9zcmMvY29uc3RhbnRzLnRzPzM1YjAiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy90eXBlcy50cz9kNjRlIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvZXRoZXJzLnRzPzJhYmQiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb25maWcudHM/ODcxMiIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL2Vycm9yLnRzPzMxNDAiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9hY3Rpb25zLnRzPzZjY2EiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9jaGFubmVscy90eXBlcy50cz82MTZmIiwid2VicGFjazovLy8uLi8uLi9zcmMvY2hhbm5lbHMvYWN0aW9ucy50cz9hY2RjIiwid2VicGFjazovLy8uLi8uLi9zcmMvdHJhbnNwb3J0L3N0YXRlLnRzPzZjOGMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy90cmFuc3BvcnQvYWN0aW9ucy50cz83NjhiIiwid2VicGFjazovLy8uLi8uLi9zcmMvbWVzc2FnZXMvdHlwZXMudHM/MjlhNSIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL21lc3NhZ2VzL2FjdGlvbnMudHM/OWU0MCIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3BhdGgvdHlwZXMudHM/OGZhMCIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3RyYW5zZmVycy9hY3Rpb25zLnRzPzRjZmQiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9wYXRoL2FjdGlvbnMudHM/MDgxNiIsIndlYnBhY2s6Ly8vLi4vc3JjL2FjdGlvbnMudHM/ODk1ZSIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL21pZ3JhdGlvbi8wLnRzPzBmZmUiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9taWdyYXRpb24vMS50cz8wYmY1Iiwid2VicGFjazovLy8uLi8uLi9zcmMvbWlncmF0aW9uLzIudHM/ZTFkZiIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL21pZ3JhdGlvbi9pbmRleC50cz8xMzlhIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvZGF0YS50cz81ODcxIiwid2VicGFjazovLy8uLi8uLi9zcmMvY2hhbm5lbHMvc3RhdGUudHM/Mjk3MyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3RyYW5zZmVycy9zdGF0ZS50cz84Zjg0Iiwid2VicGFjazovLy8uLi9zcmMvc3RhdGUudHM/NmJjMSIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3V0aWxzL3JlZHV4LnRzPzdjZjQiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9jaGFubmVscy9yZWR1Y2VyLnRzPzMzNzgiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9wYXRoL3JlZHVjZXIudHM/ODE4OCIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3RyYW5zcG9ydC9yZWR1Y2VyLnRzPzQyNDQiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9tZXNzYWdlcy91dGlscy50cz9hY2VmIiwid2VicGFjazovLy8uLi8uLi9zcmMvdHJhbnNmZXJzL3V0aWxzLnRzPzQzZDAiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy90cmFuc2ZlcnMvcmVkdWNlci50cz9jMjZkIiwid2VicGFjazovLy8uLi9zcmMvcmVkdWNlci50cz8yOGFkIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvcngudHM/ZGMwNCIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3RyYW5zcG9ydC91dGlscy50cz9kNDgyIiwid2VicGFjazovLy8uLi8uLi9zcmMvY2hhbm5lbHMvaW5kZXgudHM/OTg2MiIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL2NoYW5uZWxzL3V0aWxzLnRzPzkxNGMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9oZWxwZXJzLnRzPzVhMTYiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy9jaGFubmVscy9lcGljcy50cz81OGJkIiwid2VicGFjazovLy8uLi8uLi9zcmMvdXRpbHMvbWF0cml4LnRzP2IyYjMiLCJ3ZWJwYWNrOi8vLy4uLy4uL3NyYy91dGlscy9scnUudHM/NTZjYyIsIndlYnBhY2s6Ly8vLi4vLi4vc3JjL3RyYW5zcG9ydC9lcGljcy50cz81NjcwIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvdHJhbnNmZXJzL2VwaWNzL2Nsb3NlLnRzP2Y1OWYiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy90cmFuc2ZlcnMvZXBpY3MvdXRpbHMudHM/NDhlMSIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL3RyYW5zZmVycy9lcGljcy9leHBpcmUudHM/YWUzMyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL3RyYW5zZmVycy9lcGljcy9sb2NrZWQudHM/MWM3OCIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL3RyYW5zZmVycy9lcGljcy9pbml0LnRzPzIwN2YiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy90cmFuc2ZlcnMvZXBpY3MvbWVkaWF0ZS50cz85OGE3Iiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvdHJhbnNmZXJzL2VwaWNzL3Byb2Nlc3NlZC50cz8xMjlmIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvdHJhbnNmZXJzL2VwaWNzL3JlZnVuZC50cz9mNDFjIiwid2VicGFjazovLy8uLi8uLi8uLi9zcmMvdHJhbnNmZXJzL2VwaWNzL3JldHJ5LnRzPzJjZTYiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy90cmFuc2ZlcnMvZXBpY3Mvc2VjcmV0LnRzP2YyMjMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL3NyYy90cmFuc2ZlcnMvZXBpY3Mvd2l0aGRyYXcudHM/OWMyNyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vc3JjL3RyYW5zZmVycy9lcGljcy9pbmRleC50cz80M2UyIiwid2VicGFjazovLy8uLi8uLi9zcmMvcGF0aC91dGlscy50cz8yMTc2Iiwid2VicGFjazovLy8uLi8uLi9zcmMvcGF0aC9lcGljcy50cz85OGZhIiwid2VicGFjazovLy8uLi9zcmMvZXBpY3MudHM/NmQ3MCIsIndlYnBhY2s6Ly8vLi4vc3JjL3JhaWRlbi50cz8yMDljIiwid2VicGFjazovLy8uLi9zcmMvaW5kZXgudHM/NmYzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7Q0FHQTs7QUFDQTtBQUNBLElBQU0sYUFBYSxHQUFHLGtCQUFPLENBQUMsYUFBOUI7QUFDQTtBQUNBLE1BQU0sQ0FBQyxNQUFQLENBQWMsa0JBQWQsRUFBdUI7QUFBRSxlQUFhLEVBQWI7QUFBRixDQUF2QixFLENBQTJDOztB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LGFBQU8sUUFBUSxDQUFDLFNBQWhCO0FBQ0Q7QUF6WEg7O0FBQUE7QUFBQTtBQStqQ2UsNkRBQWYsRTs7QUNyb0NBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiJmNDU1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdzeW1ib2wtb2JzZXJ2YWJsZSc7XG5pbXBvcnQgJ2lzb21vcnBoaWMtZmV0Y2gnO1xuaW1wb3J0ICdhYm9ydC1jb250cm9sbGVyL3BvbHlmaWxsJztcbi8vIG1hdHJpeC1qcy1zZGsgbW9ua2V5LXBhdGNoIHJvb3QgbWV0aG9kRmFjdG9yeVxuaW1wb3J0IGxvZ2dpbmcgZnJvbSAnbG9nbGV2ZWwnO1xuY29uc3QgbWV0aG9kRmFjdG9yeSA9IGxvZ2dpbmcubWV0aG9kRmFjdG9yeTtcbmltcG9ydCB7IGxvZ2dlciBhcyBtYXRyaXhMb2dnZXIgfSBmcm9tICdtYXRyaXgtanMtc2RrL2xpYi9sb2dnZXInO1xuT2JqZWN0LmFzc2lnbihsb2dnaW5nLCB7IG1ldGhvZEZhY3RvcnkgfSk7IC8vIHJldmVydFxubWF0cml4TG9nZ2VyLnNldExldmVsKGxvZ2dpbmcubGV2ZWxzLkRFQlVHKTsgLy8gYXBwbHlcbi8vIHJlcXVlc3QuYWJvcnQoKSBpcyBjYWxsZWQgd2hlbiBzaHV0dGluZyBkb3duIG1hdHJpeDsgdGhpcyBwYXRjaCBjbGVhcnMgc29tZSB0aW1lb3V0cyBsZWZ0IGJlaGluZFxuaW1wb3J0IHsgZ2V0UmVxdWVzdCwgcmVxdWVzdCB9IGZyb20gJ21hdHJpeC1qcy1zZGsnO1xuY29uc3Qgb3JpZ1JlcXVlc3QgPSBnZXRSZXF1ZXN0KCk7XG4vLyAncmVxdWVzdCcgcmVwbGFjZXMgbWF0cml4J3MgcmVxdWVzdFxucmVxdWVzdCgob3B0cywgY2IpID0+IHtcbiAgICBjb25zdCByZXEgPSBvcmlnUmVxdWVzdChvcHRzLCBjYik7XG4gICAgY29uc3Qgb3JpZ0Fib3J0ID0gcmVxLmFib3J0LmJpbmQocmVxKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZXEsIHtcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9yaWdBYm9ydCgpO1xuICAgICAgICAgICAgY2IobmV3IEVycm9yKCdhYm9ydGVkIScpKTsgLy8gYWxzbyBjYWxsIGNhbGxiYWNrIHdoZW4gYWJvcnRpbmcsIHRvIGNsZWFyIHBlbmRpbmcgdGltZW91dHNcbiAgICAgICAgfSxcbiAgICB9KTtcbn0pO1xuaW1wb3J0IHdydGMgZnJvbSAnd3J0Yyc7XG5pZiAoISgnUlRDUGVlckNvbm5lY3Rpb24nIGluIGdsb2JhbFRoaXMpKSB7XG4gICAgT2JqZWN0LmFzc2lnbihnbG9iYWxUaGlzLCB3cnRjKTtcbn1cbi8vIHBhdGNoIGNyZWF0ZU5ld01hdHJpeENhbGwgdG8gcHJldmVudCBtYXRyaXgtanMtc2RrIGZyb20gaG9va2luZyBXZWJSVEMgZXZlbnRzIGluIGJyb3dzZXI7XG4vLyB1Z2x5LCBidXQgdGhlcmUncyBubyBvcHRpb24gdG8gcHJldmVudCBNYXRyaXhDbGllbnQgdG8gaGFuZGxlIG0uY2FsbC4qIGV2ZW50c1xuaW1wb3J0ICogYXMgY2FsbCBmcm9tICdtYXRyaXgtanMtc2RrL2xpYi93ZWJydGMvY2FsbCc7XG5PYmplY3QuYXNzaWduKGNhbGwsIHsgY3JlYXRlTmV3TWF0cml4Q2FsbDogKCkgPT4gbnVsbCB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlmaWxscy5qcy5tYXAiLCIvKiBHZW5lcmF0ZWQgYnkgdHMtZ2VuZXJhdG9yIHZlci4gMC4wLjggKi9cbi8qIHRzbGludDpkaXNhYmxlICovXG5cbmltcG9ydCB7IENvbnRyYWN0LCBTaWduZXIgfSBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJldGhlcnMvcHJvdmlkZXJzXCI7XG5cbmltcG9ydCB7IFRva2VuTmV0d29ya1JlZ2lzdHJ5IH0gZnJvbSBcIi4vVG9rZW5OZXR3b3JrUmVnaXN0cnlcIjtcblxuZXhwb3J0IGNsYXNzIFRva2VuTmV0d29ya1JlZ2lzdHJ5RmFjdG9yeSB7XG4gIHN0YXRpYyBjb25uZWN0KFxuICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICBzaWduZXJPclByb3ZpZGVyOiBTaWduZXIgfCBQcm92aWRlclxuICApOiBUb2tlbk5ldHdvcmtSZWdpc3RyeSB7XG4gICAgcmV0dXJuIG5ldyBDb250cmFjdChcbiAgICAgIGFkZHJlc3MsXG4gICAgICBfYWJpLFxuICAgICAgc2lnbmVyT3JQcm92aWRlclxuICAgICkgYXMgVG9rZW5OZXR3b3JrUmVnaXN0cnk7XG4gIH1cbn1cblxuY29uc3QgX2FiaSA9IFtcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl9zZWNyZXRfcmVnaXN0cnlfYWRkcmVzc1wiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfY2hhaW5faWRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX3NldHRsZW1lbnRfdGltZW91dF9taW5cIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX3NldHRsZW1lbnRfdGltZW91dF9tYXhcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX21heF90b2tlbl9uZXR3b3Jrc1wiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCJcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwidG9rZW5fYWRkcmVzc1wiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJ0b2tlbl9uZXR3b3JrX2FkZHJlc3NcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiVG9rZW5OZXR3b3JrQ3JlYXRlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcImNoYWluX2lkXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcImNvbnRyYWN0X2FkZHJlc3NcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiY29udHJhY3RFeGlzdHNcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX3Rva2VuX2FkZHJlc3NcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX2NoYW5uZWxfcGFydGljaXBhbnRfZGVwb3NpdF9saW1pdFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfdG9rZW5fbmV0d29ya19kZXBvc2l0X2xpbWl0XCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcImNyZWF0ZUVSQzIwVG9rZW5OZXR3b3JrXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcInRva2VuX25ldHdvcmtfYWRkcmVzc1wiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJkZXByZWNhdGlvbl9leGVjdXRvclwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwibWF4X3Rva2VuX25ldHdvcmtzXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJzZWNyZXRfcmVnaXN0cnlfYWRkcmVzc1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwic2V0dGxlbWVudF90aW1lb3V0X21heFwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwic2V0dGxlbWVudF90aW1lb3V0X21pblwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwidG9rZW5fbmV0d29ya19jcmVhdGVkXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJ0b2tlbl90b190b2tlbl9uZXR3b3Jrc1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH1cbl07XG4iLCIvKiBHZW5lcmF0ZWQgYnkgdHMtZ2VuZXJhdG9yIHZlci4gMC4wLjggKi9cbi8qIHRzbGludDpkaXNhYmxlICovXG5cbmltcG9ydCB7IENvbnRyYWN0LCBTaWduZXIgfSBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJldGhlcnMvcHJvdmlkZXJzXCI7XG5cbmltcG9ydCB7IFRva2VuTmV0d29yayB9IGZyb20gXCIuL1Rva2VuTmV0d29ya1wiO1xuXG5leHBvcnQgY2xhc3MgVG9rZW5OZXR3b3JrRmFjdG9yeSB7XG4gIHN0YXRpYyBjb25uZWN0KFxuICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICBzaWduZXJPclByb3ZpZGVyOiBTaWduZXIgfCBQcm92aWRlclxuICApOiBUb2tlbk5ldHdvcmsge1xuICAgIHJldHVybiBuZXcgQ29udHJhY3QoYWRkcmVzcywgX2FiaSwgc2lnbmVyT3JQcm92aWRlcikgYXMgVG9rZW5OZXR3b3JrO1xuICB9XG59XG5cbmNvbnN0IF9hYmkgPSBbXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJfdG9rZW5fYWRkcmVzc1wiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJfc2VjcmV0X3JlZ2lzdHJ5XCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl9jaGFpbl9pZFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfc2V0dGxlbWVudF90aW1lb3V0X21pblwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfc2V0dGxlbWVudF90aW1lb3V0X21heFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJfZGVwcmVjYXRpb25fZXhlY3V0b3JcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX2NoYW5uZWxfcGFydGljaXBhbnRfZGVwb3NpdF9saW1pdFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfdG9rZW5fbmV0d29ya19kZXBvc2l0X2xpbWl0XCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIlxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJjaGFubmVsX2lkZW50aWZpZXJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiY2xvc2luZ19wYXJ0aWNpcGFudFwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJub25jZVwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgIG5hbWU6IFwiYmFsYW5jZV9oYXNoXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIkNoYW5uZWxDbG9zZWRcIixcbiAgICB0eXBlOiBcImV2ZW50XCJcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiY2hhbm5lbF9pZGVudGlmaWVyXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcInBhcnRpY2lwYW50XCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJ0b3RhbF9kZXBvc2l0XCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIkNoYW5uZWxOZXdEZXBvc2l0XCIsXG4gICAgdHlwZTogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcImNoYW5uZWxfaWRlbnRpZmllclwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudDFcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnQyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJzZXR0bGVfdGltZW91dFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJDaGFubmVsT3BlbmVkXCIsXG4gICAgdHlwZTogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcImNoYW5uZWxfaWRlbnRpZmllclwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnQxX2Ftb3VudFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnQxX2xvY2tzcm9vdFwiLFxuICAgICAgICB0eXBlOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnQyX2Ftb3VudFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnQyX2xvY2tzcm9vdFwiLFxuICAgICAgICB0eXBlOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJDaGFubmVsU2V0dGxlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJjaGFubmVsX2lkZW50aWZpZXJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwicmVjZWl2ZXJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwic2VuZGVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgbmFtZTogXCJsb2Nrc3Jvb3RcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcInVubG9ja2VkX2Ftb3VudFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwicmV0dXJuZWRfdG9rZW5zXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIkNoYW5uZWxVbmxvY2tlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJjaGFubmVsX2lkZW50aWZpZXJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnRcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcInRvdGFsX3dpdGhkcmF3XCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIkNoYW5uZWxXaXRoZHJhd1wiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwibmV3X3ZhbHVlXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIkRlcHJlY2F0aW9uU3dpdGNoXCIsXG4gICAgdHlwZTogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcImNoYW5uZWxfaWRlbnRpZmllclwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJjbG9zaW5nX3BhcnRpY2lwYW50XCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIm5vbmNlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgbmFtZTogXCJiYWxhbmNlX2hhc2hcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiTm9uQ2xvc2luZ0JhbGFuY2VQcm9vZlVwZGF0ZWRcIixcbiAgICB0eXBlOiBcImV2ZW50XCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJNQVhfU0FGRV9VSU5UMjU2XCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJjaGFpbl9pZFwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwiY2hhbm5lbF9jb3VudGVyXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJjaGFubmVsX3BhcnRpY2lwYW50X2RlcG9zaXRfbGltaXRcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcImNoYW5uZWxzXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcInNldHRsZV9ibG9ja19udW1iZXJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJlbnVtIFRva2VuTmV0d29yay5DaGFubmVsU3RhdGVcIixcbiAgICAgICAgbmFtZTogXCJzdGF0ZVwiLFxuICAgICAgICB0eXBlOiBcInVpbnQ4XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJjaGFubmVsX2lkZW50aWZpZXJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwibm9uX2Nsb3NpbmdfcGFydGljaXBhbnRcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiY2xvc2luZ19wYXJ0aWNpcGFudFwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgbmFtZTogXCJiYWxhbmNlX2hhc2hcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwibm9uY2VcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgIG5hbWU6IFwiYWRkaXRpb25hbF9oYXNoXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgbmFtZTogXCJub25fY2xvc2luZ19zaWduYXR1cmVcIixcbiAgICAgICAgdHlwZTogXCJieXRlc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgbmFtZTogXCJjbG9zaW5nX3NpZ25hdHVyZVwiLFxuICAgICAgICB0eXBlOiBcImJ5dGVzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiY2xvc2VDaGFubmVsXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcImNvbnRyYWN0X2FkZHJlc3NcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiY29udHJhY3RFeGlzdHNcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcImRlcHJlY2F0ZVwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwiZGVwcmVjYXRpb25fZXhlY3V0b3JcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnRcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwicGFydG5lclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJnZXRDaGFubmVsSWRlbnRpZmllclwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJjaGFubmVsX2lkZW50aWZpZXJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnQxXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcInBhcnRpY2lwYW50MlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJnZXRDaGFubmVsSW5mb1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJlbnVtIFRva2VuTmV0d29yay5DaGFubmVsU3RhdGVcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50OFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiY2hhbm5lbF9pZGVudGlmaWVyXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcInBhcnRpY2lwYW50XCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcInBhcnRuZXJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiZ2V0Q2hhbm5lbFBhcnRpY2lwYW50SW5mb1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudFwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJwYXJ0bmVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcImdldFBhcnRpY2lwYW50c0hhc2hcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwicHVyZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiY2hhbm5lbF9pZGVudGlmaWVyXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcInNlbmRlclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJyZWNlaXZlclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJnZXRVbmxvY2tJZGVudGlmaWVyXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInB1cmVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcInBhcnRpY2lwYW50MVwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudDJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwic2V0dGxlX3RpbWVvdXRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwib3BlbkNoYW5uZWxcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcInBhcnRpY2lwYW50c19oYXNoX3RvX2NoYW5uZWxfaWRlbnRpZmllclwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwic2FmZXR5X2RlcHJlY2F0aW9uX3N3aXRjaFwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJib29sXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwic2VjcmV0X3JlZ2lzdHJ5XCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiY29udHJhY3QgU2VjcmV0UmVnaXN0cnlcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJjaGFubmVsX2lkZW50aWZpZXJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnRcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwidG90YWxfZGVwb3NpdFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJwYXJ0bmVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcInNldFRvdGFsRGVwb3NpdFwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJjaGFubmVsX2lkZW50aWZpZXJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnRcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwidG90YWxfd2l0aGRyYXdcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiZXhwaXJhdGlvbl9ibG9ja1wiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnRfc2lnbmF0dXJlXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXNcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsXG4gICAgICAgIG5hbWU6IFwicGFydG5lcl9zaWduYXR1cmVcIixcbiAgICAgICAgdHlwZTogXCJieXRlc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcInNldFRvdGFsV2l0aGRyYXdcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiY2hhbm5lbF9pZGVudGlmaWVyXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcInBhcnRpY2lwYW50MVwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJwYXJ0aWNpcGFudDFfdHJhbnNmZXJyZWRfYW1vdW50XCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcInBhcnRpY2lwYW50MV9sb2NrZWRfYW1vdW50XCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICBuYW1lOiBcInBhcnRpY2lwYW50MV9sb2Nrc3Jvb3RcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnQyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcInBhcnRpY2lwYW50Ml90cmFuc2ZlcnJlZF9hbW91bnRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnQyX2xvY2tlZF9hbW91bnRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgIG5hbWU6IFwicGFydGljaXBhbnQyX2xvY2tzcm9vdFwiLFxuICAgICAgICB0eXBlOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJzZXR0bGVDaGFubmVsXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJzZXR0bGVtZW50X3RpbWVvdXRfbWF4XCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJzZXR0bGVtZW50X3RpbWVvdXRfbWluXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJzaWduYXR1cmVfcHJlZml4XCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwidG9rZW5cIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJjb250cmFjdCBUb2tlblwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJ0b2tlbl9uZXR3b3JrX2RlcG9zaXRfbGltaXRcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiY2hhbm5lbF9pZGVudGlmaWVyXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcInJlY2VpdmVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcInNlbmRlclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzXCIsXG4gICAgICAgIG5hbWU6IFwibG9ja3NcIixcbiAgICAgICAgdHlwZTogXCJieXRlc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcInVubG9ja1wiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJjaGFubmVsX2lkZW50aWZpZXJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiY2xvc2luZ19wYXJ0aWNpcGFudFwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJub25fY2xvc2luZ19wYXJ0aWNpcGFudFwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgbmFtZTogXCJiYWxhbmNlX2hhc2hcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwibm9uY2VcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgIG5hbWU6IFwiYWRkaXRpb25hbF9oYXNoXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgbmFtZTogXCJjbG9zaW5nX3NpZ25hdHVyZVwiLFxuICAgICAgICB0eXBlOiBcImJ5dGVzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlc1wiLFxuICAgICAgICBuYW1lOiBcIm5vbl9jbG9zaW5nX3NpZ25hdHVyZVwiLFxuICAgICAgICB0eXBlOiBcImJ5dGVzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwidXBkYXRlTm9uQ2xvc2luZ0JhbGFuY2VQcm9vZlwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH1cbl07XG4iLCIvKiBHZW5lcmF0ZWQgYnkgdHMtZ2VuZXJhdG9yIHZlci4gMC4wLjggKi9cbi8qIHRzbGludDpkaXNhYmxlICovXG5cbmltcG9ydCB7IENvbnRyYWN0LCBTaWduZXIgfSBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJldGhlcnMvcHJvdmlkZXJzXCI7XG5cbmltcG9ydCB7IEh1bWFuU3RhbmRhcmRUb2tlbiB9IGZyb20gXCIuL0h1bWFuU3RhbmRhcmRUb2tlblwiO1xuXG5leHBvcnQgY2xhc3MgSHVtYW5TdGFuZGFyZFRva2VuRmFjdG9yeSB7XG4gIHN0YXRpYyBjb25uZWN0KFxuICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICBzaWduZXJPclByb3ZpZGVyOiBTaWduZXIgfCBQcm92aWRlclxuICApOiBIdW1hblN0YW5kYXJkVG9rZW4ge1xuICAgIHJldHVybiBuZXcgQ29udHJhY3QoYWRkcmVzcywgX2FiaSwgc2lnbmVyT3JQcm92aWRlcikgYXMgSHVtYW5TdGFuZGFyZFRva2VuO1xuICB9XG59XG5cbmNvbnN0IF9hYmkgPSBbXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfaW5pdGlhbEFtb3VudFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQ4XCIsXG4gICAgICAgIG5hbWU6IFwiX2RlY2ltYWxVbml0c1wiLFxuICAgICAgICB0eXBlOiBcInVpbnQ4XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgbmFtZTogXCJfdG9rZW5OYW1lXCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgbmFtZTogXCJfdG9rZW5TeW1ib2xcIixcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCJcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX293bmVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl9zcGVuZGVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfdmFsdWVcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiQXBwcm92YWxcIixcbiAgICB0eXBlOiBcImV2ZW50XCJcbiAgfSxcbiAge1xuICAgIGFub255bW91czogZmFsc2UsXG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX2Zyb21cIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX3RvXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfdmFsdWVcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiVHJhbnNmZXJcIixcbiAgICB0eXBlOiBcImV2ZW50XCJcbiAgfSxcbiAge1xuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmYWxsYmFja1wiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwiX2RlY2ltYWxzXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDhcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50OFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX293bmVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl9zcGVuZGVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcImFsbG93YW5jZVwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJyZW1haW5pbmdcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJfc3BlbmRlclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfdmFsdWVcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiYXBwcm92ZVwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX3NwZW5kZXJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX3ZhbHVlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgbmFtZTogXCJfZXh0cmFEYXRhXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXNcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJhcHByb3ZlQW5kQ2FsbFwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX293bmVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcImJhbGFuY2VPZlwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJiYWxhbmNlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcImJhbGFuY2VzXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJkZWNpbWFsc1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQ4XCIsXG4gICAgICAgIG5hbWU6IFwiZGVjaW1hbHNcIixcbiAgICAgICAgdHlwZTogXCJ1aW50OFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcIm5hbWVcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJzeW1ib2xcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJ0b3RhbFN1cHBseVwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJzdXBwbHlcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJfdG9cIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX3ZhbHVlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcInRyYW5zZmVyXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLFxuICAgICAgICBuYW1lOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgdHlwZTogXCJib29sXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJfZnJvbVwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJfdG9cIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX3ZhbHVlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcInRyYW5zZmVyRnJvbVwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcInZlcnNpb25cIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfVxuXTtcbiIsIi8qIEdlbmVyYXRlZCBieSB0cy1nZW5lcmF0b3IgdmVyLiAwLjAuOCAqL1xuLyogdHNsaW50OmRpc2FibGUgKi9cblxuaW1wb3J0IHsgQ29udHJhY3QsIFNpZ25lciB9IGZyb20gXCJldGhlcnNcIjtcbmltcG9ydCB7IFByb3ZpZGVyIH0gZnJvbSBcImV0aGVycy9wcm92aWRlcnNcIjtcblxuaW1wb3J0IHsgU2VydmljZVJlZ2lzdHJ5IH0gZnJvbSBcIi4vU2VydmljZVJlZ2lzdHJ5XCI7XG5cbmV4cG9ydCBjbGFzcyBTZXJ2aWNlUmVnaXN0cnlGYWN0b3J5IHtcbiAgc3RhdGljIGNvbm5lY3QoXG4gICAgYWRkcmVzczogc3RyaW5nLFxuICAgIHNpZ25lck9yUHJvdmlkZXI6IFNpZ25lciB8IFByb3ZpZGVyXG4gICk6IFNlcnZpY2VSZWdpc3RyeSB7XG4gICAgcmV0dXJuIG5ldyBDb250cmFjdChhZGRyZXNzLCBfYWJpLCBzaWduZXJPclByb3ZpZGVyKSBhcyBTZXJ2aWNlUmVnaXN0cnk7XG4gIH1cbn1cblxuY29uc3QgX2FiaSA9IFtcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl90b2tlbl9mb3JfcmVnaXN0cmF0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl9jb250cm9sbGVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl9pbml0aWFsX3ByaWNlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl9wcmljZV9idW1wX251bWVyYXRvclwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfcHJpY2VfYnVtcF9kZW5vbWluYXRvclwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfZGVjYXlfY29uc3RhbnRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX21pbl9wcmljZVwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfcmVnaXN0cmF0aW9uX2R1cmF0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIlxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJzZXJ2aWNlXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJ2YWxpZF90aWxsXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJkZXBvc2l0X2Ftb3VudFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJjb250cmFjdCBEZXBvc2l0XCIsXG4gICAgICAgIG5hbWU6IFwiZGVwb3NpdF9jb250cmFjdFwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJSZWdpc3RlcmVkU2VydmljZVwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX3ByaWNlX2J1bXBfbnVtZXJhdG9yXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl9wcmljZV9idW1wX2Rlbm9taW5hdG9yXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl9kZWNheV9jb25zdGFudFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfbWluX3ByaWNlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl9yZWdpc3RyYXRpb25fZHVyYXRpb25cIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiY2hhbmdlUGFyYW1ldGVyc1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJfc3VjY2Vzc1wiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcImNvbnRyYWN0X2FkZHJlc3NcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiY29udHJhY3RFeGlzdHNcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcImNvbnRyb2xsZXJcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcImN1cnJlbnRQcmljZVwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwiZGVjYXlfY29uc3RhbnRcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX3NldF9wcmljZVwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfc2Vjb25kc19wYXNzZWRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiZGVjYXllZFByaWNlXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl9saW1pdF9hbW91bnRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiZGVwb3NpdFwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJfc3VjY2Vzc1wiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJkZXByZWNhdGVkXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJldmVyTWFkZURlcG9zaXRzTGVuXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl9sZW5cIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiZXZlcl9tYWRlX2RlcG9zaXRzXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl9hZGRyZXNzXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcImhhc1ZhbGlkUmVnaXN0cmF0aW9uXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLFxuICAgICAgICBuYW1lOiBcIl9oYXNfcmVnaXN0cmF0aW9uXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcIm1pbl9wcmljZVwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwicHJpY2VfYnVtcF9kZW5vbWluYXRvclwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwicHJpY2VfYnVtcF9udW1lcmF0b3JcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcInJlZ2lzdHJhdGlvbl9kdXJhdGlvblwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwic2VydmljZV92YWxpZF90aWxsXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJzZXREZXByZWNhdGlvblN3aXRjaFwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJfc3VjY2Vzc1wiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIG5hbWU6IFwibmV3X3VybFwiLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcInNldFVSTFwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJfc3VjY2Vzc1wiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJzZXRfcHJpY2VcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcInNldF9wcmljZV9hdFwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwidG9rZW5cIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJjb250cmFjdCBUb2tlblwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJ1cmxzXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH1cbl07XG4iLCIvKiBHZW5lcmF0ZWQgYnkgdHMtZ2VuZXJhdG9yIHZlci4gMC4wLjggKi9cbi8qIHRzbGludDpkaXNhYmxlICovXG5cbmltcG9ydCB7IENvbnRyYWN0LCBTaWduZXIgfSBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJldGhlcnMvcHJvdmlkZXJzXCI7XG5cbmltcG9ydCB7IEN1c3RvbVRva2VuIH0gZnJvbSBcIi4vQ3VzdG9tVG9rZW5cIjtcblxuZXhwb3J0IGNsYXNzIEN1c3RvbVRva2VuRmFjdG9yeSB7XG4gIHN0YXRpYyBjb25uZWN0KFxuICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICBzaWduZXJPclByb3ZpZGVyOiBTaWduZXIgfCBQcm92aWRlclxuICApOiBDdXN0b21Ub2tlbiB7XG4gICAgcmV0dXJuIG5ldyBDb250cmFjdChhZGRyZXNzLCBfYWJpLCBzaWduZXJPclByb3ZpZGVyKSBhcyBDdXN0b21Ub2tlbjtcbiAgfVxufVxuXG5jb25zdCBfYWJpID0gW1xuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiaW5pdGlhbF9zdXBwbHlcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50OFwiLFxuICAgICAgICBuYW1lOiBcImRlY2ltYWxfdW5pdHNcIixcbiAgICAgICAgdHlwZTogXCJ1aW50OFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIG5hbWU6IFwidG9rZW5fbmFtZVwiLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIG5hbWU6IFwidG9rZW5fc3ltYm9sXCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl9vd25lclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJfc3BlbmRlclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX3ZhbHVlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIkFwcHJvdmFsXCIsXG4gICAgdHlwZTogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl90b1wiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJfbnVtXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIk1pbnRlZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJfZnJvbVwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJfdG9cIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl92YWx1ZVwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJUcmFuc2ZlclwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcIl9kZWNpbWFsc1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQ4XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDhcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl9vd25lclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJfc3BlbmRlclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJhbGxvd2FuY2VcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwicmVtYWluaW5nXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX3NwZW5kZXJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX3ZhbHVlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcImFwcHJvdmVcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwic3VjY2Vzc1wiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl9vd25lclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJiYWxhbmNlT2ZcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiYmFsYW5jZVwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJiYWxhbmNlc1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwiZGVjaW1hbHNcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50OFwiLFxuICAgICAgICBuYW1lOiBcImRlY2ltYWxzXCIsXG4gICAgICAgIHR5cGU6IFwidWludDhcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIm51bVwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJtaW50XCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIm51bVwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJ0YXJnZXRcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwibWludEZvclwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwibXVsdGlwbGllclwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwibmFtZVwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcIm93bmVyX2FkZHJlc3NcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzIHBheWFibGVcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwic3ltYm9sXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwidG90YWxTdXBwbHlcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwic3VwcGx5XCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX3RvXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl92YWx1ZVwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJ0cmFuc2ZlclwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJvb2xcIixcbiAgICAgICAgbmFtZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX2Zyb21cIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX3RvXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIl92YWx1ZVwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJ0cmFuc2ZlckZyb21cIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwic3VjY2Vzc1wiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJ0cmFuc2ZlckZ1bmRzXCIsXG4gICAgb3V0cHV0czogW10sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH1cbl07XG4iLCIvKiBHZW5lcmF0ZWQgYnkgdHMtZ2VuZXJhdG9yIHZlci4gMC4wLjggKi9cbi8qIHRzbGludDpkaXNhYmxlICovXG5cbmltcG9ydCB7IENvbnRyYWN0LCBTaWduZXIgfSBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJldGhlcnMvcHJvdmlkZXJzXCI7XG5cbmltcG9ydCB7IFVzZXJEZXBvc2l0IH0gZnJvbSBcIi4vVXNlckRlcG9zaXRcIjtcblxuZXhwb3J0IGNsYXNzIFVzZXJEZXBvc2l0RmFjdG9yeSB7XG4gIHN0YXRpYyBjb25uZWN0KFxuICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICBzaWduZXJPclByb3ZpZGVyOiBTaWduZXIgfCBQcm92aWRlclxuICApOiBVc2VyRGVwb3NpdCB7XG4gICAgcmV0dXJuIG5ldyBDb250cmFjdChhZGRyZXNzLCBfYWJpLCBzaWduZXJPclByb3ZpZGVyKSBhcyBVc2VyRGVwb3NpdDtcbiAgfVxufVxuXG5jb25zdCBfYWJpID0gW1xuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX3Rva2VuX2FkZHJlc3NcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiX3dob2xlX2JhbGFuY2VfbGltaXRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIm93bmVyXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJuZXdCYWxhbmNlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIkJhbGFuY2VSZWR1Y2VkXCIsXG4gICAgdHlwZTogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBhbm9ueW1vdXM6IGZhbHNlLFxuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbmRleGVkOiB0cnVlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIndpdGhkcmF3ZXJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGluZGV4ZWQ6IGZhbHNlLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcInBsYW5uZWRCYWxhbmNlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcIldpdGhkcmF3UGxhbm5lZFwiLFxuICAgIHR5cGU6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcImJhbGFuY2VzXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcImNvbnRyYWN0X2FkZHJlc3NcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiY29udHJhY3RFeGlzdHNcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiYmVuZWZpY2lhcnlcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwibmV3X3RvdGFsX2RlcG9zaXRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiZGVwb3NpdFwiLFxuICAgIG91dHB1dHM6IFtdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJvd25lclwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJlZmZlY3RpdmVCYWxhbmNlXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcInJlbWFpbmluZ19iYWxhbmNlXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwiX21zY19hZGRyZXNzXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIl9vbmVfdG9fbl9hZGRyZXNzXCIsXG4gICAgICAgIHR5cGU6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcImluaXRcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcIm1zY19hZGRyZXNzXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW10sXG4gICAgbmFtZTogXCJvbmVfdG9fbl9hZGRyZXNzXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcImFtb3VudFwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJwbGFuV2l0aGRyYXdcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcInRva2VuXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiY29udHJhY3QgVG9rZW5cIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwidG90YWxfZGVwb3NpdFwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImFkZHJlc3NcIixcbiAgICAgICAgbmFtZTogXCJzZW5kZXJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJhZGRyZXNzXCIsXG4gICAgICAgIG5hbWU6IFwicmVjZWl2ZXJcIixcbiAgICAgICAgdHlwZTogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiYW1vdW50XCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcInRyYW5zZmVyXCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLFxuICAgICAgICBuYW1lOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgdHlwZTogXCJib29sXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJub25wYXlhYmxlXCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwid2hvbGVfYmFsYW5jZVwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtdLFxuICAgIG5hbWU6IFwid2hvbGVfYmFsYW5jZV9saW1pdFwiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJhbW91bnRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwid2l0aGRyYXdcIixcbiAgICBvdXRwdXRzOiBbXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXSxcbiAgICBuYW1lOiBcIndpdGhkcmF3X2RlbGF5XCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwidWludDI1NlwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcInZpZXdcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYWRkcmVzc1wiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgbmFtZTogXCJ3aXRoZHJhd19wbGFuc1wiLFxuICAgIG91dHB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcInVpbnQyNTZcIixcbiAgICAgICAgbmFtZTogXCJhbW91bnRcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwid2l0aGRyYXdfYmxvY2tcIixcbiAgICAgICAgdHlwZTogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIHN0YXRlTXV0YWJpbGl0eTogXCJ2aWV3XCIsXG4gICAgdHlwZTogXCJmdW5jdGlvblwiXG4gIH1cbl07XG4iLCIvKiBHZW5lcmF0ZWQgYnkgdHMtZ2VuZXJhdG9yIHZlci4gMC4wLjggKi9cbi8qIHRzbGludDpkaXNhYmxlICovXG5cbmltcG9ydCB7IENvbnRyYWN0LCBTaWduZXIgfSBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJldGhlcnMvcHJvdmlkZXJzXCI7XG5cbmltcG9ydCB7IFNlY3JldFJlZ2lzdHJ5IH0gZnJvbSBcIi4vU2VjcmV0UmVnaXN0cnlcIjtcblxuZXhwb3J0IGNsYXNzIFNlY3JldFJlZ2lzdHJ5RmFjdG9yeSB7XG4gIHN0YXRpYyBjb25uZWN0KFxuICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICBzaWduZXJPclByb3ZpZGVyOiBTaWduZXIgfCBQcm92aWRlclxuICApOiBTZWNyZXRSZWdpc3RyeSB7XG4gICAgcmV0dXJuIG5ldyBDb250cmFjdChhZGRyZXNzLCBfYWJpLCBzaWduZXJPclByb3ZpZGVyKSBhcyBTZWNyZXRSZWdpc3RyeTtcbiAgfVxufVxuXG5jb25zdCBfYWJpID0gW1xuICB7XG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgaW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgbmFtZTogXCJzZWNyZXRoYXNoXCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBcImJ5dGVzMzJcIixcbiAgICAgICAgbmFtZTogXCJzZWNyZXRcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiU2VjcmV0UmV2ZWFsZWRcIixcbiAgICB0eXBlOiBcImV2ZW50XCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMlwiLFxuICAgICAgICBuYW1lOiBcInNlY3JldGhhc2hcIixcbiAgICAgICAgdHlwZTogXCJieXRlczMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIG5hbWU6IFwiZ2V0U2VjcmV0UmV2ZWFsQmxvY2tIZWlnaHRcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJ1aW50MjU2XCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwidmlld1wiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgaW5wdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJieXRlczMyXCIsXG4gICAgICAgIG5hbWU6IFwic2VjcmV0XCIsXG4gICAgICAgIHR5cGU6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcInJlZ2lzdGVyU2VjcmV0XCIsXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYm9vbFwiLFxuICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICB0eXBlOiBcImJvb2xcIlxuICAgICAgfVxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiBcIm5vbnBheWFibGVcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIGlucHV0czogW1xuICAgICAge1xuICAgICAgICBpbnRlcm5hbFR5cGU6IFwiYnl0ZXMzMltdXCIsXG4gICAgICAgIG5hbWU6IFwic2VjcmV0c1wiLFxuICAgICAgICB0eXBlOiBcImJ5dGVzMzJbXVwiXG4gICAgICB9XG4gICAgXSxcbiAgICBuYW1lOiBcInJlZ2lzdGVyU2VjcmV0QmF0Y2hcIixcbiAgICBvdXRwdXRzOiBbXG4gICAgICB7XG4gICAgICAgIGludGVybmFsVHlwZTogXCJib29sXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHR5cGU6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6IFwibm9ucGF5YWJsZVwiLFxuICAgIHR5cGU6IFwiZnVuY3Rpb25cIlxuICB9XG5dO1xuIiwiZXhwb3J0IHZhciBFdmVudFR5cGVzO1xuKGZ1bmN0aW9uIChFdmVudFR5cGVzKSB7XG4gICAgRXZlbnRUeXBlc1tcIk9QRU5FRFwiXSA9IFwiT1BFTkVEXCI7XG4gICAgRXZlbnRUeXBlc1tcIkFQUFJPVkVEXCJdID0gXCJBUFBST1ZFRFwiO1xuICAgIEV2ZW50VHlwZXNbXCJERVBPU0lURURcIl0gPSBcIkRFUE9TSVRFRFwiO1xuICAgIEV2ZW50VHlwZXNbXCJDT05GSVJNRURcIl0gPSBcIkNPTkZJUk1FRFwiO1xufSkoRXZlbnRUeXBlcyB8fCAoRXZlbnRUeXBlcyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJpbXBvcnQgeyBwYWRaZXJvcyB9IGZyb20gJ2V0aGVycy91dGlscyc7XG5leHBvcnQgY29uc3QgU2lnbmF0dXJlWmVybyA9IHBhZFplcm9zKFtdLCA2NSk7XG5leHBvcnQgdmFyIFNodXRkb3duUmVhc29uO1xuKGZ1bmN0aW9uIChTaHV0ZG93blJlYXNvbikge1xuICAgIFNodXRkb3duUmVhc29uW1wiU1RPUFwiXSA9IFwicmFpZGVuU3RvcHBlZFwiO1xuICAgIFNodXRkb3duUmVhc29uW1wiQUNDT1VOVF9DSEFOR0VEXCJdID0gXCJwcm92aWRlckFjY291bnRDaGFuZ2VkXCI7XG4gICAgU2h1dGRvd25SZWFzb25bXCJORVRXT1JLX0NIQU5HRURcIl0gPSBcInByb3ZpZGVyTmV0d29ya0NoYW5nZWRcIjtcbn0pKFNodXRkb3duUmVhc29uIHx8IChTaHV0ZG93blJlYXNvbiA9IHt9KSk7XG5leHBvcnQgdmFyIENhcGFiaWxpdGllcztcbihmdW5jdGlvbiAoQ2FwYWJpbGl0aWVzKSB7XG4gICAgLy8gb3B0LW91dCBjYXBhYmlsaXRpZXMsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIENhcGFiaWxpdGllc1tcIk5PX1JFQ0VJVkVcIl0gPSBcIm5vUmVjZWl2ZVwiO1xuICAgIENhcGFiaWxpdGllc1tcIk5PX01FRElBVEVcIl0gPSBcIm5vTWVkaWF0ZVwiO1xuICAgIENhcGFiaWxpdGllc1tcIk5PX0RFTElWRVJZXCJdID0gXCJub0RlbGl2ZXJ5XCI7XG4gICAgQ2FwYWJpbGl0aWVzW1wiV0VCUlRDXCJdID0gXCJ3ZWJSVENcIjtcbn0pKENhcGFiaWxpdGllcyB8fCAoQ2FwYWJpbGl0aWVzID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5pbXBvcnQgKiBhcyB0IGZyb20gJ2lvLXRzJztcbmltcG9ydCB7IEJpZ051bWJlciwgYmlnTnVtYmVyaWZ5LCBnZXRBZGRyZXNzLCBpc0hleFN0cmluZywgaGV4RGF0YUxlbmd0aCB9IGZyb20gJ2V0aGVycy91dGlscyc7XG5pbXBvcnQgeyBUd28sIFplcm8gfSBmcm9tICdldGhlcnMvY29uc3RhbnRzJztcbmltcG9ydCB7IFRocm93UmVwb3J0ZXIgfSBmcm9tICdpby10cy9saWIvVGhyb3dSZXBvcnRlcic7XG5pbXBvcnQgbWVtb2l6ZSBmcm9tICdsb2Rhc2gvbWVtb2l6ZSc7XG4vKipcbiAqIEVycm9yIGZvciBhc3NlcnRpb24gZnVuY3Rpb25zL3R5cGUgZ3VhcmRzXG4gKi9cbmV4cG9ydCBjbGFzcyBBc3NlcnRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbi8qKlxuICogVHlwZS1zYWZlIGFzc2VydGlvbiBmdW5jdGlvbiAoVFMzLjcpXG4gKlxuICogQHBhcmFtIGNvbmRpdGlvbiAtIENvbmRpdGlvbiB0byB2YWxpZGF0ZSBhcyB0cnV0aHlcbiAqIEBwYXJhbSBtc2cgLSBNZXNzYWdlIHRvIHRocm93IGlmIGNvbmRpdGlvbiBpcyBmYWxzeVxuICogQHBhcmFtIGxvZyAtIExvZ2dlciB0byBsb2cgZXJyb3IgdG9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1zZywgbG9nKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgbG9nID09PSBudWxsIHx8IGxvZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9nKCdBc3NlcnRpb25FcnJvcicsIGNvbmRpdGlvbiwgbXNnKTtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1zZyAhPT0gbnVsbCAmJiBtc2cgIT09IHZvaWQgMCA/IG1zZyA6ICdBc3NlcnRpb25FcnJvcicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcG9ydGVyQXNzZXJ0KHZhbHVlKSB7XG4gICAgVGhyb3dSZXBvcnRlci5yZXBvcnQodmFsdWUpO1xufVxuLyoqXG4gKiBEZWNvZGUvdmFsaWRhdGUgbGlrZSBjb2RlYy5kZWNvZGUsIGJ1dCB0aHJvdyBvciByZXR1cm4gcmlnaHQgaW5zdGVhZCBvZiBFaXRoZXJcbiAqXG4gKiBAcGFyYW0gY29kZWMgLSBpby10cyBjb2RlYyB0byBiZSB1c2VkIGZvciBkZWNvZGluZy92YWxpZGF0aW9uXG4gKiBAcGFyYW0gZGF0YSAtIGRhdGEgdG8gZGVjb2RlL3ZhbGlkYXRlXG4gKiBAcmV0dXJucyBEZWNvZGVkIHZhbHVlIG9mIGNvZGVjIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShjb2RlYywgZGF0YSkge1xuICAgIGNvbnN0IGRlY29kZWQgPSBjb2RlYy5kZWNvZGUoZGF0YSk7XG4gICAgcmVwb3J0ZXJBc3NlcnQoZGVjb2RlZCk7XG4gICAgcmV0dXJuIGRlY29kZWQucmlnaHQ7XG59XG4vKipcbiAqIFRlc3QgZm9yIHZhbHVlJ3Mgbm9uLW51bGxpbmVzc1xuICogTGlrZSBsb2Rhc2gncyBuZWdhdGUoaXNOaWwpLCBidXQgYWxzbyB3b3JrcyBhcyB0eXBlIGd1YXJkIChlLmcuIHVzZWZ1bCBmb3IgZmlsdGVycylcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB0byBiZSB0ZXN0ZWRcbiAqIEByZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbm90IG51bGwgbm9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNudE5pbCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsO1xufVxuLyoqXG4gKiBDb2RlYyBvZiBldGhlcnMudXRpbHMuQmlnTnVtYmVyIG9iamVjdHNcbiAqXG4gKiBJbnB1dCBjYW4gYmUgYW55dGhpbmcgYmlnTnVtYmVyaWZ5LWFibGU6IG51bWJlciwgc3RyaW5nLCBMb3NzbGVzc051bWJlciBvciBCaWdOdW1iZXJcbiAqIE91dHB1dCBpcyBzdHJpbmcsIHNvIHdlIGNhbiBKU09OLXNlcmlhbGl6ZSB3aXRoICdudW1iZXIncyB0eXBlcyBiaWdnZXIgdGhhbiBKUyBWTSBsaW1pdHNcbiAqIG9mIMKxMl41MywgYXMgUmFpZGVuIHB5dGhvbiBjbGllbnQgc3RkbGliIGpzb24gZW5jb2RlIGxvbmdzIGFzIHN0cmluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IEJpZ051bWJlckMgPSBuZXcgdC5UeXBlKCdCaWdOdW1iZXInLCBCaWdOdW1iZXIuaXNCaWdOdW1iZXIsICh1LCBjKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoQmlnTnVtYmVyLmlzQmlnTnVtYmVyKHUpKVxuICAgICAgICByZXR1cm4gdC5zdWNjZXNzKHUpO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGRlY29kZSBieSB0cnlpbmcgdG8gYmlnTnVtYmVyaWZ5IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbnl0aGluZ1xuICAgICAgICByZXR1cm4gdC5zdWNjZXNzKGJpZ051bWJlcmlmeSgoKF9iID0gKF9hID0gdSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9oZXgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHUpLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gdC5mYWlsdXJlKHUsIGMpO1xuICAgIH1cbn0sIChhKSA9PiBhLnRvU3RyaW5nKCkpO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGNvZGVjcyB0byB2YWxpZGF0ZSBhbiBhcmJpdHJhcnkgb3IgdmFyaWFibGUtc2l6ZWQgaGV4IGJ5dGVzdHJpbmdcbiAqIEEgYnJhbmRlZCBjb2RlYyB0byBpbmRpY2F0ZSB2YWxpZGF0ZWQgaGV4LXN0cmluZ3NcbiAqXG4gKiBAcGFyYW0gc2l6ZSAtIFJlcXVpcmVkIG51bWJlciBvZiBieXRlcy4gUGFzcyB1bmRlZmluZWQgb3IgemVybyB0byBoYXZlIGEgdmFyaWFibGUtc2l6ZWQgdHlwZVxuICogQHJldHVybnMgYnJhbmRlZCBjb2RlYyBmb3IgaGV4LWVuY29kZWQgYnl0ZXN0cmluZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IEhleFN0cmluZyA9IG1lbW9pemUoZnVuY3Rpb24gKHNpemUpIHtcbiAgICByZXR1cm4gdC5icmFuZCh0LnN0cmluZywgKG4pID0+IHR5cGVvZiBuID09PSAnc3RyaW5nJyAmJiAoc2l6ZSA/IGhleERhdGFMZW5ndGgobikgPT09IHNpemUgOiBpc0hleFN0cmluZyhuKSksICdIZXhTdHJpbmcnKTtcbn0pO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGNvZGVjcyB0byB2YWxpZGF0ZSBhbiBhcmJpdHJhcnkgb3IgdmFyaWFibGUtc2l6ZWQgQmlnTnVtYmVyc1xuICogQSBicmFuZGVkIGNvZGVjL3R5cGUgdG8gaW5kaWNhdGUgc2l6ZS12YWxpZGF0ZWQgQmlnTnVtYmVyc1xuICpcbiAqIEBwYXJhbSBzaXplIC0gUmVxdWlyZWQgbnVtYmVyIG9mIGJ5dGVzLiBQYXNzIHVuZGVmaW5lZCB0byBoYXZlIGEgdmFyaWFibGUtc2l6ZWQgdHlwZVxuICogQHJldHVybnMgYnJhbmRlZCBjb2RlYyBmb3IgaGV4LWVuY29kZWQgYnl0ZXN0cmluZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IEludCA9IG1lbW9pemUoZnVuY3Rpb24gKHNpemUpIHtcbiAgICBjb25zdCBtaW4gPSBzaXplID8gWmVyby5zdWIoVHdvLnBvdyhzaXplICogOCAtIDEpKSA6IHVuZGVmaW5lZCwgbWF4ID0gc2l6ZSA/IFR3by5wb3coc2l6ZSAqIDggLSAxKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdC5icmFuZChCaWdOdW1iZXJDLCAobikgPT4gQmlnTnVtYmVyQy5pcyhuKSAmJiAoIW1pbiB8fCAhbWF4IHx8IChuLmd0ZShtaW4pICYmIG4ubHQobWF4KSkpLCAnSW50Jyk7XG59KTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBjb2RlY3MgdG8gdmFsaWRhdGUgYW4gYXJiaXRyYXJ5IG9yIHZhcmlhYmxlLXNpemVkIEJpZ051bWJlcnNcbiAqIEEgYnJhbmRlZCBjb2RlYy90eXBlIHRvIGluZGljYXRlIHNpemUtdmFsaWRhdGVkIEJpZ051bWJlcnNcbiAqXG4gKiBAcGFyYW0gc2l6ZSAtIFJlcXVpcmVkIG51bWJlciBvZiBieXRlcy4gUGFzcyB1bmRlZmluZWQgdG8gaGF2ZSBhIHZhcmlhYmxlLXNpemVkIHR5cGVcbiAqIEByZXR1cm5zIGJyYW5kZWQgY29kZWMgZm9yIGhleC1lbmNvZGVkIGJ5dGVzdHJpbmdzXG4gKi9cbmV4cG9ydCBjb25zdCBVSW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoc2l6ZSkge1xuICAgIGNvbnN0IG1pbiA9IHNpemUgPyBaZXJvIDogdW5kZWZpbmVkLCBtYXggPSBzaXplID8gVHdvLnBvdyhzaXplICogOCkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHQuYnJhbmQoQmlnTnVtYmVyQywgKG4pID0+IEJpZ051bWJlckMuaXMobikgJiYgKCFtaW4gfHwgIW1heCB8fCAobi5ndGUobWluKSAmJiBuLmx0KG1heCkpKSwgJ1VJbnQnKTtcbn0pO1xuLy8gc3BlY2lmaWMgdHlwZXNcbi8vIHN0cmlnIGJyYW5kOiBFQ0RTQSBzaWduYXR1cmUgYXMgYW4gaGV4LXN0cmluZ1xuZXhwb3J0IGNvbnN0IFNpZ25hdHVyZSA9IEhleFN0cmluZyg2NSk7XG4vLyBzdHJpbmcgYnJhbmQ6IDI1Ni1iaXQgaGFzaCwgdXN1YWxseSBrZWNjYWsyNTYgb3Igc2hhMjU2XG5leHBvcnQgY29uc3QgSGFzaCA9IEhleFN0cmluZygzMik7XG4vLyBzdHJpbmcgYnJhbmQ6IGEgc2VjcmV0IGJ5dGVhcnJheSwgMzIgYnl0ZXNcbmV4cG9ydCBjb25zdCBTZWNyZXQgPSBIZXhTdHJpbmcoMzIpO1xuLy8gc3RyaW5nIGJyYW5kOiBFQ0RTQSBwcml2YXRlIGtleSwgMzIgYnl0ZXNcbmV4cG9ydCBjb25zdCBQcml2YXRlS2V5ID0gSGV4U3RyaW5nKDMyKTtcbmV4cG9ydCBjb25zdCBBZGRyZXNzID0gbmV3IHQuVHlwZSgnQWRkcmVzcycsICh1KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEhleFN0cmluZygyMCkuaXModSkgJiYgZ2V0QWRkcmVzcyh1KSA9PT0gdTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0sICh1LCBjKSA9PiB7XG4gICAgaWYgKCFIZXhTdHJpbmcoMjApLmlzKHUpKVxuICAgICAgICByZXR1cm4gdC5mYWlsdXJlKHUsIGMpO1xuICAgIGxldCBhZGRyO1xuICAgIHRyeSB7XG4gICAgICAgIGFkZHIgPSBnZXRBZGRyZXNzKHUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdC5mYWlsdXJlKHUsIGMpO1xuICAgIH1cbiAgICBpZiAoIWFkZHIpXG4gICAgICAgIHJldHVybiB0LmZhaWx1cmUodSwgYyk7XG4gICAgcmV0dXJuIHQuc3VjY2VzcyhhZGRyKTtcbn0sIHQuaWRlbnRpdHkpO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGNvZGVjcyB0byB2YWxpZGF0ZSBbdGltZXN0YW1wLCB2YWx1ZV0gdHVwbGVzXG4gKlxuICogQHBhcmFtIGNvZGVjIC0gQ29kZWMgdG8gY29tcG9zZSB3aXRoIGEgdGltZXN0YW1wIGluIGEgdHVwbGVcbiAqIEByZXR1cm5zIENvZGVjIG9mIGEgdHVwbGUgb2YgdGltZXN0YW1wIGFuZCBjb2RlYyB0eXBlXG4gKi9cbmV4cG9ydCBjb25zdCBUaW1lZCA9IG1lbW9pemUoKGNvZGVjKSA9PiB0LnR1cGxlKFt0Lm51bWJlciwgY29kZWNdKSk7XG4vKipcbiAqIEdpdmVuIGEgdmFsdWUgb2YgdHlwZSBULCByZXR1cm5zIGEgVGltZWQ8VD4gdHVwbGUgd2l0aCBjdXJyZW50IHRpbWUgYXMgZmlyc3QgdmFsdWVcbiAqXG4gKiBAcGFyYW0gdiAtIFZhbHVlIHRvIHJldHVybiB3aXRoIHRpbWVcbiAqIEByZXR1cm5zIFR1cGxlIG9mIGNhbGwgdGltZXN0YW1wIGFzIGZpcnN0IGVsZW10biBhbmQgdmFsdWUgcGFzc2VkIGFzIHBhcmFtZXRlciBhcyBzZWNvbmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVkKHYpIHtcbiAgICByZXR1cm4gW0RhdGUubm93KCksIHZdO1xufVxuLy8gZ2VuZXJpYyB0eXBlIGNvZGVjIGZvciBtZXNzYWdlcyB0aGF0IG11c3QgYmUgc2lnbmVkXG4vLyB1c2UgaXQgbGlrZTogQ29kZWMgPSBTaWduZWQoTWVzc2FnZSlcbi8vIFRoZSB0LlR5cGVPZjx0eXBlb2YgY29kZWM+IHdpbGwgYmUgU2lnbmVkPE1lc3NhZ2U+LCBkZWZpbmVkIGxhdGVyXG5leHBvcnQgY29uc3QgU2lnbmVkID0gbWVtb2l6ZSgoY29kZWMpID0+IHQuaW50ZXJzZWN0aW9uKFtjb2RlYywgdC5yZWFkb25seSh0LnR5cGUoeyBzaWduYXR1cmU6IFNpZ25hdHVyZSB9KSldKSk7XG4vKipcbiAqIE1lbW9pemVkIGZhY3RvcnkgdG8gY3JlYXRlIGNvZGVjcyB2YWxpZGF0aW5nIGFuIGFyYml0cmFyeSBjbGFzcyBDXG4gKlxuICogQHBhcmFtIEMgLSBDbGFzcyB0byBjcmVhdGUgYSBjb2RlYyBmb3JcbiAqIEByZXR1cm5zIENvZGVjIHZhbGlkYXRpbmcgY2xhc3MgQ1xuICovXG5leHBvcnQgY29uc3QgaW5zdGFuY2VPZiA9IG1lbW9pemUoKEMpID0+IG5ldyB0LlR5cGUoYGluc3RhbmNlT2YoJHtDLm5hbWV9KWAsICh2KSA9PiB2IGluc3RhbmNlb2YgQywgKGksIGMpID0+IChpIGluc3RhbmNlb2YgQyA/IHQuc3VjY2VzcyhpKSA6IHQuZmFpbHVyZShpLCBjKSksIHQuaWRlbnRpdHkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgZ2V0TmV0d29yayBhcyBwYXJzZU5ldHdvcmsgfSBmcm9tICdldGhlcnMvdXRpbHMvbmV0d29ya3MnO1xuaW1wb3J0IHsgZnJvbUV2ZW50UGF0dGVybiwgbWVyZ2UsIGZyb20sIG9mLCBFTVBUWSwgY29tYmluZUxhdGVzdCwgZGVmZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgZmlyc3QsIG1hcCwgc3dpdGNoTWFwLCBtZXJnZU1hcCwgc2hhcmUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgZmxhdHRlbiBmcm9tICdsb2Rhc2gvZmxhdHRlbic7XG5pbXBvcnQgc29ydEJ5IGZyb20gJ2xvZGFzaC9zb3J0QnknO1xuaW1wb3J0IHsgaXNudE5pbCB9IGZyb20gJy4vdHlwZXMnO1xuLyoqXG4gKiBMaWtlIHJ4anMnIGZyb21FdmVudCwgYnV0IGV2ZW50IGNhbiBiZSBhbiBFdmVudEZpbHRlclxuICpcbiAqIEBwYXJhbSB0YXJnZXQgLSBPYmplY3QgdG8gaG9vayBldmVudCBsaXN0ZW5lciwgbWF5YmUgYSBQcm92aWRlciBvciBDb250cmFjdFxuICogQHBhcmFtIGV2ZW50IC0gRXZlbnRGaWx0ZXIgb3Igc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvXG4gKiBAcGFyYW0gcmVzdWx0U2VsZWN0b3IgLSBBIG1hcCBvZiBldmVudHMgYXJndW1lbnRzIHRvIG91dHB1dCBwYXJhbWV0ZXJzXG4gKiAgICAgIERlZmF1bHQgaXMgdG8gcGFzcyBvbmx5IGZpcnN0IHBhcmFtZXRlclxuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB0YXJnZXQub24oZXZlbnQpIGV2ZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV0aGVyc0V2ZW50KHRhcmdldCwgZXZlbnQsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIGZyb21FdmVudFBhdHRlcm4oKGhhbmRsZXIpID0+IHRhcmdldC5vbihldmVudCwgaGFuZGxlciksIChoYW5kbGVyKSA9PiB0YXJnZXQucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpLCByZXN1bHRTZWxlY3Rvcik7XG59XG4vKipcbiAqIGdldEV2ZW50c1N0cmVhbSByZXR1cm5zIGEgc3RyZWFtIG9mIFQtdHlwZSB0dXBsZXMgKGFycmF5cykgZnJvbSBDb250cmFjdCdzXG4gKiBldmVudHMgZnJvbSBmaWx0ZXJzLiBUaGVzZSBldmVudHMgYXJlIHBvbGxlZCBzaW5jZSBwcm92aWRlcidzIFtyZV1zZXRFdmVudHNCbG9jayB0byBuZXdlc3RcbiAqIHBvbGxlZCBibG9jay4gSWYgYm90aCAnZnJvbUJsb2NrJCcgYW5kICdsYXN0U2VlbkJsb2NrJCcgYXJlIHNwZWNpZmllZCwgYWxzbyBmZXRjaCBwYXN0IGV2ZW50c1xuICogc2luY2UgZnJvbUJsb2NrIHVwIHRvIGxhc3RTZWVuQmxvY2skID09PSBwcm92aWRlci5yZXNldEV2ZW50c0Jsb2NrIC0gMVxuICogVCBtdXN0IGJlIGEgdHVwbGUtbGlrZSB0eXBlIHJlY2VpdmluZyBhbGwgZmlsdGVycyBhcmd1bWVudHMgcGx1cyB0aGUgcmVzcGVjdGl2ZSBFdmVudCBpbiB0aGUgZW5kXG4gKlxuICogQHBhcmFtIGNvbnRyYWN0IC0gQ29udHJhY3Qgc291cmNlIGluc3RhbmNlIGZvciBmaWx0ZXJzLCBjb25uZWN0ZWQgdG8gYSBwcm92aWRlclxuICogQHBhcmFtIGZpbHRlcnMgLSBhcnJheSBvZiBPUiBmaWx0ZXJzIGZyb20gdG9rZW5OZXR3b3JrXG4gKiBAcGFyYW0gZnJvbUJsb2NrJCAtIE9ic2VydmFibGUgb2YgYSBwYXN0IGJsb2NrTnVtYmVyIHNpbmNlIHdoZW4gdG8gZmV0Y2ggcGFzdCBldmVudHNcbiAqICAgICAgICAgICAgICAgICAgICAgSWYgbm90IHByb3ZpZGVkLCBsYXN0IHJlc2V0RXZlbnRzQmxvY2sgaXMgYXV0b21hdGljYWxseSB1c2VkLlxuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBjb250cmFjdCdzIGV2ZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRzU3RyZWFtKGNvbnRyYWN0LCBmaWx0ZXJzLCBmcm9tQmxvY2skKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBjb250cmFjdC5wcm92aWRlcjtcbiAgICBjb25zdCBsb2dUb0V2ZW50ID0gKGxvZykgPT4ge1xuICAgICAgICAvLyBwYXJzZSBsb2cgaW50byBbLi4uYXJncywgZXZlbnQ6IEV2ZW50XSBhcnJheSxcbiAgICAgICAgLy8gdGhlIHNhbWUgdGhhdCBjb250cmFjdC5vbiBldmVudHMvY2FsbGJhY2tzXG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IGNvbnRyYWN0LmludGVyZmFjZS5wYXJzZUxvZyhsb2cpO1xuICAgICAgICAvLyBpZ25vcmUgcmVtb3ZlZCAocmVvcmcnZCkgZXZlbnRzIChyZW9yZ3MgYXJlIGhhbmRsZWQgYnkgQ29uZmlybWFibGVBY3Rpb25zIGxvZ2ljKVxuICAgICAgICAvLyBhbmQgcGFyc2UgZXJyb3JzIChzaG91bGRuJ3QgaGFwcGVuKVxuICAgICAgICBpZiAobG9nLnJlbW92ZWQgPT09IHRydWUgfHwgIXBhcnNlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHBhcnNlZC52YWx1ZXMpO1xuICAgICAgICAvLyBub3QgYWxsIHBhcmFtZXRlcnMgcXVpdGUgbmVlZGVkIHJpZ2h0IG5vdywgYnV0IGxldCdzIGNvbXBseSB3aXRoIHRoZSBpbnRlcmZhY2VcbiAgICAgICAgY29uc3QgZXZlbnQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9nKSwgcGFyc2VkKSwgeyBhcmdzLCByZW1vdmVMaXN0ZW5lcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8qIGdldExvZ3MgZG9uJ3QgaW5zdGFsbCBmaWx0ZXIgKi9cbiAgICAgICAgICAgIH0sIGdldEJsb2NrOiAoKSA9PiBwcm92aWRlci5nZXRCbG9jayhsb2cuYmxvY2tIYXNoKSwgZ2V0VHJhbnNhY3Rpb246ICgpID0+IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGxvZy50cmFuc2FjdGlvbkhhc2gpLCBnZXRUcmFuc2FjdGlvblJlY2VpcHQ6ICgpID0+IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdChsb2cudHJhbnNhY3Rpb25IYXNoKSwgZGVjb2RlOiAoZGF0YSwgdG9waWNzKSA9PiBwYXJzZWQuZGVjb2RlKGRhdGEsIHRvcGljcyB8fCBsb2cudG9waWNzKSB9KTtcbiAgICAgICAgcmV0dXJuIFsuLi5hcmdzLCBldmVudF07XG4gICAgfTtcbiAgICAvLyBwYXN0IGV2ZW50cyAoaW4gdGhlIGNsb3NlZC1pbnRlcnZhbD1bZnJvbUJsb2NrLCBsYXN0U2VlbkJsb2NrXSksXG4gICAgLy8gZmV0Y2ggb25jZSwgc29ydCBieSBibG9ja051bWJlciwgZW1pdCBhbGwsIGNvbXBsZXRlXG4gICAgbGV0IHBhc3RFdmVudHMkID0gRU1QVFksIFxuICAgIC8vIG9mKGNvbnN0YW50KSBlbnN1cmVzIG5ld0V2ZW50cyQgaXMgcmVnaXN0ZXJlZCBpbW1lZGlhdGVseSBpZiBmcm9tQmxvY2skIG5vdCBwcm92aWRlZFxuICAgIG5leHRCbG9jayQgPSBvZigtMSk7XG4gICAgaWYgKGZyb21CbG9jayQpIHtcbiAgICAgICAgLy8gaWYgZmV0Y2hpbmcgcGFzdEV2ZW50cyQsIG5leHRCbG9jayQgaXMgdXNlZCB0byBzeW5jL2F2b2lkIGludGVyc2VjdGlvbiBiZXR3ZWVuIEV2ZW50cyRcbiAgICAgICAgLy8gcGFzdEV2ZW50cyQgPT4gW2Zyb21CbG9jayQsIG5leHRCbG9jayRdLCBuZXdFdmVudHMkID0+IF1uZXh0QmxvY2skLCAuLi5sYXRlc3RdXG4gICAgICAgIG5leHRCbG9jayQgPSBkZWZlcigoKSA9PiBwcm92aWRlci5ibG9ja051bWJlclxuICAgICAgICAgICAgPyBvZihwcm92aWRlci5ibG9ja051bWJlcilcbiAgICAgICAgICAgIDogZnJvbUV0aGVyc0V2ZW50KHByb3ZpZGVyLCAnYmxvY2snKS5waXBlKGZpcnN0KCksIG1hcCgoYikgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBwcm92aWRlci5ibG9ja051bWJlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYjsgfSkpKS5waXBlKHNoYXJlKCkpO1xuICAgICAgICBwYXN0RXZlbnRzJCA9IGNvbWJpbmVMYXRlc3QoZnJvbUJsb2NrJCwgbmV4dEJsb2NrJCkucGlwZShmaXJzdCgpLCBzd2l0Y2hNYXAoKFtmcm9tQmxvY2ssIHRvQmxvY2tdKSA9PiBQcm9taXNlLmFsbChmaWx0ZXJzLm1hcCgoZmlsdGVyKSA9PiBwcm92aWRlci5nZXRMb2dzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmlsdGVyKSwgeyBmcm9tQmxvY2ssIHRvQmxvY2sgfSkpKSkpLCBcbiAgICAgICAgLy8gZmxhdHRlbiBhcnJheSBvZiBlYWNoIGdldExvZ3MgcXVlcnkgcmVzcG9uc2UgYW5kIHNvcnQgdGhlbVxuICAgICAgICAvLyBlbWl0IGxvZyBhcnJheSBlbGVtZW50cyBhcyBzZXBhcmF0ZSBsb2dzIGludG8gc3RyZWFtICh1bndpbmQpXG4gICAgICAgIG1lcmdlTWFwKChsb2dzKSA9PiBmcm9tKHNvcnRCeShmbGF0dGVuKGxvZ3MpLCBbJ2Jsb2NrTnVtYmVyJ10pKSksIG1hcChsb2dUb0V2ZW50KSwgZmlsdGVyKGlzbnROaWwpKTtcbiAgICB9XG4gICAgLy8gbmV3IGV2ZW50cyAoaW4gb3Blbi1pbnRlcnZhbD1dbGFzdFNlZW5CbG9jaywgbGF0ZXN0XSlcbiAgICAvLyB3aGVyZSBsYXN0U2VlbkJsb2NrIGlzIHRoZSBjdXJyZW50QmxvY2sgYXQgY2FsbCB0aW1lXG4gICAgLy8gZG9lc24ndCBjb21wbGV0ZSwga2VlcCBlbWl0dGluZyBldmVudHMgZm9yIGVhY2ggbmV3IGJsb2NrIChpZiBhbnkpIHVudGlsIHVuc3Vic2NyaXB0aW9uXG4gICAgY29uc3QgbmV3RXZlbnRzJCA9IG5leHRCbG9jayQucGlwZShzd2l0Y2hNYXAoKCkgPT4gZnJvbShmaWx0ZXJzKSksIG1lcmdlTWFwKChmaWx0ZXIpID0+IGZyb21FdGhlcnNFdmVudChwcm92aWRlciwgZmlsdGVyKSksIG1hcChsb2dUb0V2ZW50KSwgZmlsdGVyKGlzbnROaWwpKTtcbiAgICByZXR1cm4gbWVyZ2UocGFzdEV2ZW50cyQsIG5ld0V2ZW50cyQpO1xufVxuLyoqXG4gKiBMaWtlIFByb3ZpZGVyLmdldE5ldHdvcmssIGJ1dCBmZXRjaGVzIGV2ZXJ5IHRpbWUgaW5zdGVhZCBvZiB1c2luZyBjYWNoZWQgcHJvcGVydHlcbiAqXG4gKiBAcGFyYW0gcHJvdmlkZXIgLSBQcm92aWRlciB0byBmZXRjaCBkYXRhIGZyb21cbiAqIEByZXR1cm5zIFByb21pc2Ugb2YgTmV0d29yayBpbmZvXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXR3b3JrKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTmV0d29yayhwYXJzZUludCh5aWVsZCBwcm92aWRlci5zZW5kKCduZXRfdmVyc2lvbicsIFtdKSkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBQYXRjaCBKc29uUnBjUHJvdmlkZXIuc2VuZCB0byB0cnkgcGVyc29uYWxfc2lnbiBmaXJzdCwgYW5kIGZhbGxiYWNrIHRvIGV0aF9zaWduIGlmIGl0IGZhaWxzXG4gKiBDYWxsIGl0IG9uY2Ugb24gdGhlIHByb3ZpZGVyIGluc3RhbmNlXG4gKlxuICogQHBhcmFtIHByb3ZpZGVyIC0gQSBKc29uUnBjUHJvdmlkZXIgaW5zdGFuY2UgdG8gcGF0Y2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGNoU2lnblNlbmQocHJvdmlkZXIpIHtcbiAgICBjb25zdCBvcmlnU2VuZCA9IHByb3ZpZGVyLnNlbmQ7XG4gICAgcHJvdmlkZXIuc2VuZCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ2V0aF9zaWduJykge1xuICAgICAgICAgICAgICAgIC8vIHRyeSAncGVyc29uYWxfc2lnbicgYnkgZGVmYXVsdCBpbnN0ZWFkIG9mICdldGhfc2lnbidcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ1NlbmQuYXBwbHkodGhpcywgWydwZXJzb25hbF9zaWduJywgW3BhcmFtc1sxXSwgcGFyYW1zWzBdXV0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gZmlyc3QgZXJyb3IsIGlmIHBlcnNvbmFsX3NpZ24gaXNuJ3QgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGVyci5tZXNzYWdlLmluY2x1ZGVzKCdUaGUgbWV0aG9kIHBlcnNvbmFsX3NpZ24gZG9lcyBub3QgZXhpc3QnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdNZXRob2QgcGVyc29uYWxfc2lnbiBub3Qgc3VwcG9ydGVkJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5zZW5kID0gb3JpZ1NlbmQ7IC8vIHVuLXBhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuc2VuZChtZXRob2QsIHBhcmFtcyk7IC8vIGFuZCByZXRyeSB3aXRoIGV0aF9zaWduXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyOyAvLyBlbHNlLCByZS1yYWlzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdTZW5kLmFwcGx5KHRoaXMsIFttZXRob2QsIHBhcmFtc10pO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm4gYSBuZXR3b3JrIG5hbWUsIGlmIGtub3duLCBvciBzdHJpbmdpZmllZCBjaGFpbklkIG90aGVyd2lzZVxuICpcbiAqIEBwYXJhbSBuZXR3b3JrIC0gTmV0d29yayB0byBnZXQgbmFtZSBmcm9tXG4gKiBAcmV0dXJucyBuYW1lIG9yIGNoYWluSWQgYXMgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXR3b3JrTmFtZShuZXR3b3JrKSB7XG4gICAgcmV0dXJuIG5ldHdvcmsubmFtZSAhPT0gJ3Vua25vd24nID8gbmV0d29yay5uYW1lIDogbmV0d29yay5jaGFpbklkLnRvU3RyaW5nKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldGhlcnMuanMubWFwIiwiaW1wb3J0ICogYXMgdCBmcm9tICdpby10cyc7XG5pbXBvcnQgeyBDYXBhYmlsaXRpZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnLi91dGlscy90eXBlcyc7XG5pbXBvcnQgeyBnZXROZXR3b3JrTmFtZSB9IGZyb20gJy4vdXRpbHMvZXRoZXJzJztcbmNvbnN0IFJUQ0ljZVNlcnZlciA9IHQudHlwZSh7IHVybHM6IHQudW5pb24oW3Quc3RyaW5nLCB0LmFycmF5KHQuc3RyaW5nKV0pIH0pO1xuLyoqXG4gKiBBIFJhaWRlbiBjb25maWd1cmF0aW9uIG9iamVjdCB3aXRoIHJlcXVpcmVkIGFuZCBvcHRpb25hbCBwYXJhbXMgZnJvbSBbW1BhcnRpYWxSYWlkZW5Db25maWddXS5cbiAqXG4gKiBOb3RpY2UgcGFydGlhbC91bmRlZmluZWQgdmFsdWVzIGFyZSBzcGVjaWFsOiB3aGVuIGEgcmFpZGVuQ29uZmlnVXBkYXRlIGlzIGNhbGxlZCB3aXRoIGFuXG4gKiB1bmRlZmluZWQgdmFsdWUsIGl0IHdvbid0IGJlIHNldCwgYXMgdGhleSBjYW4ndCBiZSBbcmVdc3RvcmVkIGluIHRoZSBKU09OIHN0YXRlLCBidXQgaW5zdGVhZFxuICogbWVhbnMgaXQnbGwgYmUgKnJlc2V0KiB0byB0aGUgZGVmYXVsdCB2YWx1ZTsgdGhlcmVmb3JlLCBpZiBhIHBhcnRpYWwgdmFsdWUgaGFzIGEgZGVmaW5lZFxuICogZGVmYXVsdCwgaXQgY2FuJ3QgYmUgdW5zZXQ7IGlmIHlvdSB3YW50IHRvIHN1cHBvcnQgXCJlbXB0eVwiIHZhbHVlcywgdXNlIG51bGwsIGVtcHR5IHN0cmluZyBvclxuICogb3RoZXIgZmFsc3kgc2VyaWFsaXphYmxlIHR5cGVzLCBhbmQvb3IgZW5zdXJlIGl0IG5ldmVyIGdldHMgYSBkZWZhdWx0XG4gKlxuICogLSBtYXRyaXhTZXJ2ZXJMb29rdXAgLSBNYXRyaXggc2VydmVyIFVSTCB0byBmZXRjaCBleGlzdGluZyBtYXRyaXggc2VydmVycyBmcm9tLlxuICogICAgICBBZnRlciBpbnRpYWxpemluZyBhIFtbUmFpZGVuXV0gaW5zdGFuY2UsIHRoZSBtYXRyaXggc2VydmVyIGNhbid0IGJlIGNoYW5nZWQgbGF0ZXIgb24uXG4gKiAtIHJldmVhbFRpbWVvdXQgLSBUaW1lb3V0IGZvciBzZWNyZXRzIHRvIGJlIHJldmVhbGVkXG4gKiAtIHNldHRsZVRpbWVvdXQgLSBUaW1lb3V0IGZvciBjaGFubmVscyB0byBiZSBzZXR0bGVkXG4gKiAtIGh0dHBUaW1lb3V0IC0gVXNlZCBpbiBodHRwIGZldGNoIHJlcXVlc3RzXG4gKiAtIGRpc2NvdmVyeVJvb20gLSBEaXNjb3ZlcnkgUm9vbSB0byBhdXRvLWpvaW4sIHVzZSBudWxsIHRvIGRpc2FibGVcbiAqIC0gcGZzUm9vbSAtIFBGUyBSb29tIHRvIGF1dG8tam9pbiBhbmQgc2VuZCBQRlNDYXBhY2l0eVVwZGF0ZSB0bywgdXNlIG51bGwgdG8gZGlzYWJsZVxuICogLSBwZnMgLSBQYXRoIEZpbmRpbmcgU2VydmljZSBVUkwgb3IgQWRkcmVzcy4gU2V0IHRvIG51bGwgdG8gZGlzYWJsZSwgb3IgZW1wdHkgc3RyaW5nIHRvIGVuYWJsZVxuICogICAgICAgICBhdXRvbWF0aWMgZmV0Y2hpbmcgZnJvbSBTZXJ2aWNlUmVnaXN0cnkuXG4gKiAtIHBmc1NhZmV0eU1hcmdpbiAtIFNhZmV0eSBtYXJnaW4gdG8gYmUgYWRkZWQgdG8gZmVlcyByZWNlaXZlZCBmcm9tIFBGUy4gVXNlIGAxLjFgIHRvIGFkZCBhIDEwJVxuICogICAgICAgICAgICAgICAgICAgICBzYWZldHkgbWFyZ2luLlxuICogLSBtYXRyaXhFeGNlc3NSb29tcyAtIEtlZXAgdGhpcyBtdWNoIHJvb21zIGZvciBhIHNpbmdsZSB1c2VyIG9mIGludGVyZXN0IChwYXJ0bmVyLCB0YXJnZXQpLlxuICogICAgICAgICAgICAgICAgICAgICAgIExlYXZlIExSVSBiZXlvbmQgdGhpcyB0aHJlc2hvbGQuXG4gKiAtIGNvbmZpcm1hdGlvbkJsb2NrcyAtIEhvdyBtYW55IGJsb2NrcyB0byB3YWl0IGJlZm9yZSBjb25zaWRlcmluZyBhIHRyYW5zYWN0aW9uIGFzIGNvbmZpcm1lZFxuICogLSBsb2dnZXIgLSBTdHJpbmcgc3BlY2lmeWluZyB0aGUgY29uc29sZSBsb2cgbGV2ZWwgb2YgcmVkdXgtbG9nZ2VyLiBVc2UgJycgdG8gc2lsZW5jZS5cbiAqIC0gY2FwcyAtIE93biB0cmFuc3BvcnQgY2FwYWJpbGl0aWVzXG4gKiAtIG1hdHJpeFNlcnZlcj8gLSBTcGVjaWZ5IGEgbWF0cml4IHNlcnZlciB0byB1c2UuXG4gKiAtIHN1YmtleT8gLSBXaGVuIHVzaW5nIHN1YmtleSwgdGhpcyBzZXRzIHRoZSBiZWhhdmlvciB3aGVuIHsgc3Via2V5IH0gb3B0aW9uIGlzbid0IGV4cGxpY2l0bHlcbiAqICAgICAgICAgICAgIHNldCBpbiBvbi1jaGFpbiBtZXRob2QgY2FsbHMuIGZhbHNlIChkZWZhdWx0KSA9IHVzZSBtYWluIGtleTsgdHJ1ZSA9IHVzZSBzdWJrZXlcbiAqL1xuZXhwb3J0IGNvbnN0IFJhaWRlbkNvbmZpZyA9IHQucmVhZG9ubHkodC5pbnRlcnNlY3Rpb24oW1xuICAgIHQudHlwZSh7XG4gICAgICAgIG1hdHJpeFNlcnZlckxvb2t1cDogdC5zdHJpbmcsXG4gICAgICAgIHJldmVhbFRpbWVvdXQ6IHQubnVtYmVyLFxuICAgICAgICBzZXR0bGVUaW1lb3V0OiB0Lm51bWJlcixcbiAgICAgICAgaHR0cFRpbWVvdXQ6IHQubnVtYmVyLFxuICAgICAgICBkaXNjb3ZlcnlSb29tOiB0LnVuaW9uKFt0LnN0cmluZywgdC5udWxsXSksXG4gICAgICAgIHBmc1Jvb206IHQudW5pb24oW3Quc3RyaW5nLCB0Lm51bGxdKSxcbiAgICAgICAgcGZzOiB0LnVuaW9uKFtBZGRyZXNzLCB0LnN0cmluZywgdC5udWxsXSksXG4gICAgICAgIHBmc1NhZmV0eU1hcmdpbjogdC5udW1iZXIsXG4gICAgICAgIG1hdHJpeEV4Y2Vzc1Jvb21zOiB0Lm51bWJlcixcbiAgICAgICAgY29uZmlybWF0aW9uQmxvY2tzOiB0Lm51bWJlcixcbiAgICAgICAgbG9nZ2VyOiB0LmtleW9mKHtcbiAgICAgICAgICAgIFsnJ106IG51bGwsXG4gICAgICAgICAgICB0cmFjZTogbnVsbCxcbiAgICAgICAgICAgIGRlYnVnOiBudWxsLFxuICAgICAgICAgICAgaW5mbzogbnVsbCxcbiAgICAgICAgICAgIHdhcm46IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfSksXG4gICAgICAgIGNhcHM6IHQucmVhZG9ubHkodC5yZWNvcmQodC5zdHJpbmcgLyogQ2FwYWJpbGl0aWVzICovLCB0LmFueSkpLFxuICAgICAgICBmYWxsYmFja0ljZVNlcnZlcnM6IHQuYXJyYXkoUlRDSWNlU2VydmVyKSxcbiAgICB9KSxcbiAgICB0LnBhcnRpYWwoe1xuICAgICAgICBtYXRyaXhTZXJ2ZXI6IHQuc3RyaW5nLFxuICAgICAgICBzdWJrZXk6IHQuYm9vbGVhbixcbiAgICB9KSxcbl0pKTtcbmV4cG9ydCBjb25zdCBQYXJ0aWFsUmFpZGVuQ29uZmlnID0gdC5yZWFkb25seSh0LnBhcnRpYWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBSYWlkZW5Db25maWcudHlwZS50eXBlc1snMCddLnByb3BzKSwgUmFpZGVuQ29uZmlnLnR5cGUudHlwZXNbJzEnXS5wcm9wcykpKTtcbi8qKlxuICogQ3JlYXRlIGEgUmFpZGVuQ29uZmlnIGZyb20gc29tZSBjb21tb24gb3B0aW9uc1xuICpcbiAqIEBwYXJhbSBvYmogLSBPYmplY3QgY29udGFpbmluZyBjb21tb24gcGFyYW1ldGVycyBmb3IgY29uZmlnXG4gKiBAcGFyYW0gb2JqLm5ldHdvcmsgLSBldGhlcidzIE5ldHdvcmsgb2JqZWN0IGZvciB0aGUgY3VycmVudCBibG9ja2NoYWluXG4gKiBAcGFyYW0gb3ZlcndyaXRlcyAtIE92ZXJ3cml0ZXMgdmFsdWVzIGZyb20gZGVmYXVsdCBjb25maWdcbiAqIEByZXR1cm5zIEEgZnVsbCBjb25maWcgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlRGVmYXVsdENvbmZpZyh7IG5ldHdvcmsgfSwgb3ZlcndyaXRlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgbWF0cml4U2VydmVyTG9va3VwOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3JhaWRlbi1uZXR3b3JrL3JhaWRlbi10cmFuc3BvcnQvbWFzdGVyL2tub3duX3NlcnZlcnMudGVzdC55YW1sJywgc2V0dGxlVGltZW91dDogNTAwLCByZXZlYWxUaW1lb3V0OiA1MCwgaHR0cFRpbWVvdXQ6IDMwZTMsIGRpc2NvdmVyeVJvb206IGByYWlkZW5fJHtnZXROZXR3b3JrTmFtZShuZXR3b3JrKX1fZGlzY292ZXJ5YCwgcGZzUm9vbTogYHJhaWRlbl8ke2dldE5ldHdvcmtOYW1lKG5ldHdvcmspfV9wYXRoX2ZpbmRpbmdgLCBwZnM6ICcnLCBtYXRyaXhFeGNlc3NSb29tczogMywgcGZzU2FmZXR5TWFyZ2luOiAxLjAsIGNvbmZpcm1hdGlvbkJsb2NrczogNSwgbG9nZ2VyOiAnaW5mbycsIGNhcHM6IHtcbiAgICAgICAgICAgIFtDYXBhYmlsaXRpZXMuTk9fREVMSVZFUlldOiB0cnVlLFxuICAgICAgICAgICAgW0NhcGFiaWxpdGllcy5OT19SRUNFSVZFXTogdHJ1ZSxcbiAgICAgICAgICAgIFtDYXBhYmlsaXRpZXMuTk9fTUVESUFURV06IHRydWUsXG4gICAgICAgICAgICBbQ2FwYWJpbGl0aWVzLldFQlJUQ106IHRydWUsXG4gICAgICAgIH0sIGZhbGxiYWNrSWNlU2VydmVyczogW3sgdXJsczogJ3N0dW46c3R1bi5sLmdvb2dsZS5jb206MTkzMDInIH1dIH0sIG92ZXJ3cml0ZXMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlnLmpzLm1hcCIsImltcG9ydCAqIGFzIHQgZnJvbSAnaW8tdHMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnZnAtdHMvbGliL0VpdGhlcic7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAnZnAtdHMvbGliL3BpcGVhYmxlJztcbmltcG9ydCBmaW5kS2V5IGZyb20gJ2xvZGFzaC9maW5kS2V5JztcbmV4cG9ydCB2YXIgRXJyb3JDb2RlcztcbihmdW5jdGlvbiAoRXJyb3JDb2Rlcykge1xuICAgIC8vIFBhdGggZXJyb3JzXG4gICAgRXJyb3JDb2Rlc1tcIlBGU19FTVBUWV9VUkxcIl0gPSBcIkEgcmVnaXN0ZXJlZCBQYXRoZmluZGluZyBTZXJ2aWNlIHJldHVybmVkIGFuIGVtcHR5IHNlcnZpY2UgVVJMLlwiO1xuICAgIEVycm9yQ29kZXNbXCJQRlNfSU5WQUxJRF9VUkxcIl0gPSBcIkEgcmVnaXN0ZXJlZCBQYXRoZmluZGluZyBTZXJ2aWNlIHJldHVybmVkIGFuIGludmFsaWQgc2VydmljZSBVUkwuXCI7XG4gICAgRXJyb3JDb2Rlc1tcIlBGU19JTlZBTElEX0lORk9cIl0gPSBcIkNvdWxkIG5vdCBmaW5kIGFueSB2YWxpZCBQYXRoZmluZGluZyBzZXJ2aWNlLiBDbGllbnQgYW5kIFBGUyB2ZXJzaW9ucyBhcmUgcG9zc2libHkgb3V0LW9mLXN5bmMuXCI7XG4gICAgRXJyb3JDb2Rlc1tcIlBGU19OT19ST1VURVNfRk9VTkRcIl0gPSBcIk5vIHZhbGlkIHJvdXRlcyBmb3VuZC5cIjtcbiAgICBFcnJvckNvZGVzW1wiUEZTX0VSUk9SX1JFU1BPTlNFXCJdID0gXCJQYXRoZmluZGluZyBTZXJ2aWNlIHJlcXVlc3QgcmV0dXJuZWQgYW4gZXJyb3JcIjtcbiAgICBFcnJvckNvZGVzW1wiUEZTX0RJU0FCTEVEXCJdID0gXCJQYXRoZmluZGluZyBTZXJ2aWNlIGlzIGRpc2FibGVkIGFuZCBubyBkaXJlY3Qgcm91dGUgaXMgYXZhaWxhYmxlLlwiO1xuICAgIEVycm9yQ29kZXNbXCJQRlNfVU5LTk9XTl9UT0tFTl9ORVRXT1JLXCJdID0gXCJObyBvcGVuIGNoYW5uZWxzIG9uIHRoaXMgdG9rZW4gbmV0d29yay5cIjtcbiAgICBFcnJvckNvZGVzW1wiUEZTX1RBUkdFVF9PRkZMSU5FXCJdID0gXCJUaGUgcmVxdWVzdGVkIHRhcmdldCBpcyBvZmZsaW5lLlwiO1xuICAgIEVycm9yQ29kZXNbXCJQRlNfVEFSR0VUX05PX1JFQ0VJVkVcIl0gPSBcIlRoZSByZXF1ZXN0ZWQgdGFyZ2V0IGRvZXNuJ3QgcmVjZWl2ZSB0cmFuc2ZlcnMuXCI7XG4gICAgRXJyb3JDb2Rlc1tcIlBGU19MQVNUX0lPVV9SRVFVRVNUX0ZBSUxFRFwiXSA9IFwiVGhlIHJlcXVlc3QgZm9yIHRoZSBsYXN0IElPVSBoYXMgZmFpbGVkLlwiO1xuICAgIEVycm9yQ29kZXNbXCJQRlNfSU9VX1NJR05BVFVSRV9NSVNNQVRDSFwiXSA9IFwiVGhlIHNpZ25hdHVyZSBvZiB0aGUgbGFzdCBJT1UgZGlkIG5vdCBtYXRjaC5cIjtcbiAgICAvLyBDaGFubmVsIGVycm9yc1xuICAgIEVycm9yQ29kZXNbXCJDTkxfSU5WQUxJRF9TVEFURVwiXSA9IFwiSW52YWxpZCBjaGFubmVsIHN0YXRlLlwiO1xuICAgIEVycm9yQ29kZXNbXCJDTkxfVE9LRU5fTk9UX0ZPVU5EXCJdID0gXCJDb3VsZCBub3QgZmluZCB0b2tlbiBmb3IgdG9rZW4gbmV0d29yay5cIjtcbiAgICBFcnJvckNvZGVzW1wiQ05MX05PX09QRU5fQ0hBTk5FTF9GT1VORFwiXSA9IFwiTm8gb3BlbiBjaGFubmVsIGhhcyBiZWVuIGZvdW5kLlwiO1xuICAgIEVycm9yQ29kZXNbXCJDTkxfTk9fT1BFTl9PUl9DTE9TSU5HX0NIQU5ORUxfRk9VTkRcIl0gPSBcIk5vIG9wZW4gb3IgY2xvc2luZyBjaGFubmVsIGhhcyBiZWVuIGZvdW5kLlwiO1xuICAgIEVycm9yQ29kZXNbXCJDTkxfTk9fU0VUVExFQUJMRV9PUl9TRVRUTElOR19DSEFOTkVMX0ZPVU5EXCJdID0gXCJObyBzZXR0bGVhYmxlIG9yIHNldHRsaW5nIGNoYW5uZWwgaGFzIGJlZW4gZm91bmQuXCI7XG4gICAgRXJyb3JDb2Rlc1tcIkNOTF9BUFBST1ZFX1RSQU5TQUNUSU9OX0ZBSUxFRFwiXSA9IFwiVG9rZW4gYXBwcm92ZSB0cmFuc2FjdGlvbiBmYWlsZWQuXCI7XG4gICAgRXJyb3JDb2Rlc1tcIkNOTF9PUEVOQ0hBTk5FTF9GQUlMRURcIl0gPSBcIlRva2VuIG5ldHdvcmtzIG9wZW5DaGFubmVsIHRyYW5zYWN0aW9uIGZhaWxlZC5cIjtcbiAgICBFcnJvckNvZGVzW1wiQ05MX1NFVFRPVEFMREVQT1NJVF9GQUlMRURcIl0gPSBcIlRva2VuIG5ldHdvcmtzIHNldFRvdGFsRGVwb3NpdCB0cmFuc2FjdGlvbiBmYWlsZWQuXCI7XG4gICAgRXJyb3JDb2Rlc1tcIkNOTF9DTE9TRUNIQU5ORUxfRkFJTEVEXCJdID0gXCJUb2tlbiBuZXR3b3JrcyBjbG9zZUNoYW5uZWwgdHJhbnNhY3Rpb24gZmFpbGVkLlwiO1xuICAgIEVycm9yQ29kZXNbXCJDTkxfU0VUVExFQ0hBTk5FTF9GQUlMRURcIl0gPSBcIlRva2VuIG5ldHdvcmtzIHNldHRsZUNoYW5uZWwgdHJhbnNhY3Rpb24gZmFpbGVkLlwiO1xuICAgIEVycm9yQ29kZXNbXCJDTkxfVVBEQVRFX05PTkNMT1NJTkdfQlBfRkFJTEVEXCJdID0gXCJ1cGRhdGVOb25DbG9zaW5nQmFsYW5jZVByb29mIHRyYW5zYWN0aW9uIGZhaWxlZC5cIjtcbiAgICBFcnJvckNvZGVzW1wiQ05MX09OQ0hBSU5fVU5MT0NLX0ZBSUxFRFwiXSA9IFwib24tY2hhaW4gdW5sb2NrIHRyYW5zYWN0aW9uIGZhaWxlZC5cIjtcbiAgICAvLyBUcmFuc2ZlciBlcnJvcnNcbiAgICBFcnJvckNvZGVzW1wiWEZFUl9FWFBJUkVEXCJdID0gXCJUcmFuc2ZlciBleHBpcmVkLlwiO1xuICAgIEVycm9yQ29kZXNbXCJYRkVSX0NIQU5ORUxfQ0xPU0VEX1BSRU1BVFVSRUxZXCJdID0gXCJDaGFubmVsIHdhcyBjbG9zZWQgYmVmb3JlIHNlY3JldCBnb3QgcmV2ZWlsZWQgb3IgdHJhbnNmZXIgdW5sb2NrZWQuXCI7XG4gICAgRXJyb3JDb2Rlc1tcIlhGRVJfUkVGVU5ERURcIl0gPSBcIlRyYW5zZmVyIGhhcyBiZWVuIHJlZnVuZGVkLlwiO1xuICAgIEVycm9yQ29kZXNbXCJYRkVSX0lOVkFMSURfU0VDUkVUUkVRVUVTVFwiXSA9IFwiSW52YWxpZCBTZWNyZXRSZXF1ZXN0IHJlY2VpdmVkXCI7XG4gICAgRXJyb3JDb2Rlc1tcIlhGRVJfQUxSRUFEWV9DT01QTEVURURcIl0gPSBcIk5vdCB3YWl0aW5nIGZvciB0cmFuc2ZlciwgaXQncyBhbHJlYWR5IGNvbXBsZXRlZC5cIjtcbiAgICBFcnJvckNvZGVzW1wiWEZFUl9SRUdJU1RFUlNFQ1JFVF9UWF9GQUlMRURcIl0gPSBcIlNlY3JldFJlZ2lzdHJ5LnJlZ2lzdGVyU2VjcmV0IHRyYW5zYWN0aW9uIGZhaWxlZFwiO1xuICAgIC8vIFRyYW5zcG9ydCBlcnJvcnNcbiAgICBFcnJvckNvZGVzW1wiVFJOU19OT19NQVRSSVhfU0VSVkVSU1wiXSA9IFwiQ291bGQgbm90IGNvbnRhY3QgYW55IE1hdHJpeCBzZXJ2ZXJzLlwiO1xuICAgIEVycm9yQ29kZXNbXCJUUk5TX05PX1ZBTElEX1VTRVJcIl0gPSBcIkNvdWxkIG5vdCBmaW5kIGEgdXNlciB3aXRoIGEgdmFsaWQgc2lnbmF0dXJlLlwiO1xuICAgIEVycm9yQ29kZXNbXCJUUk5TX05PX1NFUlZFUk5BTUVcIl0gPSBcIkNvdWxkIG5vdCBnZXQgc2VydmVyIG5hbWUgZnJvbSBNYXRyaXggc2VydmVyLlwiO1xuICAgIEVycm9yQ29kZXNbXCJUUk5TX01FU1NBR0VfU0lHTkFUVVJFX01JU01BVENIXCJdID0gXCJVbmFibGUgdG8gZGVjb2RlIG1lc3NhZ2UgZHVlIHRvIHNpZ25hdHVyZSBtaXNtYXRjaC5cIjtcbiAgICAvLyBSYWlkZW4gbWFpbiBjbGFzcyBlcnJvcnNcbiAgICBFcnJvckNvZGVzW1wiUkROX0dFTkVSQUxfRVJST1JcIl0gPSBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJlZC5cIjtcbiAgICBFcnJvckNvZGVzW1wiUkROX01JTlRfRkFJTEVEXCJdID0gXCJGYWlsZWQgdG8gbWludCB0b2tlbnMuXCI7XG4gICAgRXJyb3JDb2Rlc1tcIlJETl9BUFBST1ZFX1RSQU5TQUNUSU9OX0ZBSUxFRFwiXSA9IFwiQXBwcm92ZSB0cmFuc2FjdGlvbiBoYXMgZmFpbGVkLlwiO1xuICAgIEVycm9yQ29kZXNbXCJSRE5fREVQT1NJVF9UUkFOU0FDVElPTl9GQUlMRURcIl0gPSBcIkRlcG9zaXQgdHJhbnNhY3Rpb24gaGFzIGZhaWxlZC5cIjtcbiAgICBFcnJvckNvZGVzW1wiUkROX1RSQU5TRkVSX09OQ0hBSU5fQkFMQU5DRV9GQUlMRURcIl0gPSBcIkZhaWxlZCB0byB0cmFuc2ZlciBvbi1jaGFpbiBiYWxhbmNlLlwiO1xuICAgIEVycm9yQ29kZXNbXCJSRE5fVFJBTlNGRVJfT05DSEFJTl9UT0tFTlNfRkFJTEVEXCJdID0gXCJGYWlsZWQgdG8gdHJhbnNmZXIgb24tY2hhaW4gdG9rZW5zLlwiO1xuICAgIEVycm9yQ29kZXNbXCJSRE5fVU5SRUNPR05JWkVEX05FVFdPUktcIl0gPSBcIk5vIGRlcGxveSBpbmZvIHByb3ZpZGVkIG5vciByZWNvZ25pemVkIG5ldHdvcmsuXCI7XG4gICAgRXJyb3JDb2Rlc1tcIlJETl9TSUdORVJfTk9UX0NPTk5FQ1RFRFwiXSA9IFwiVGhlIHNpZ25pbmcgYWNjb3VudCBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSBwcm92aWRlci5cIjtcbiAgICBFcnJvckNvZGVzW1wiUkROX0FDQ09VTlRfTk9UX0ZPVU5EXCJdID0gXCJBY2NvdW50IG5vdCBmb3VuZCBpbiBwcm92aWRlci5cIjtcbiAgICBFcnJvckNvZGVzW1wiUkROX1NUUklOR19BQ0NPVU5UX0lOVkFMSURcIl0gPSBcIlN0cmluZyBhY2NvdW50IG11c3QgYmUgZWl0aGVyIGEgMHgtZW5jb2RlZCBhZGRyZXNzIG9yIHByaXZhdGUga2V5LlwiO1xuICAgIEVycm9yQ29kZXNbXCJSRE5fVFJBTlNBQ1RJT05fUkVPUkdcIl0gPSBcIlRyYW5zYWN0aW9uIGhhcyBiZWVuIG1pbmVkIGJ1dCBnb3QgcmVtb3ZlZCBieSBhIHJlb3JnLlwiO1xuICAgIEVycm9yQ29kZXNbXCJSRE5fU1RBVEVfTUlHUkFUSU9OXCJdID0gXCJDb3VsZCBub3QgcmVwbGFjZSBzdG9yZWQgc3RhdGUgd2l0aCBvbGRlciwgcHJvdmlkZWQgc3RhdGUuXCI7XG4gICAgLy8gRGF0YSBlcnJvcnNcbiAgICBFcnJvckNvZGVzW1wiRFRBX05FR0FUSVZFX05VTUJFUlwiXSA9IFwiRW5jb3VudGVyZWQgbmVnYXRpdmUgbnVtYmVyIHdoaWxlIGVuY29kaW5nIHRvIEhFWCBzdHJpbmcuXCI7XG4gICAgRXJyb3JDb2Rlc1tcIkRUQV9OVU1CRVJfVE9PX0xBUkdFXCJdID0gXCJFbmNvdW50ZXJlZCBhIG51bWJlciB0aGF0IGlzIHRvbyBsYXJnZSB0byBiZSBlbmNvZGVkLlwiO1xuICAgIEVycm9yQ29kZXNbXCJEVEFfQVJSQVlfTEVOR1RIX0RJRkZSRU5DRVwiXSA9IFwiRXhwZWN0ZWQgbGVuZ3RoIG9mIEhFWCBzdHJpbmcgZGlmZmVycyBmcm9tIGludGVnZXIgYXJyYXkgaW5wdXQuXCI7XG4gICAgRXJyb3JDb2Rlc1tcIkRUQV9VTkVOQ09EQUJMRV9EQVRBXCJdID0gXCJQYXNzZWQgZGF0YSBpcyBub3QgYSBIRVggc3RyaW5nIG5vciBpbnRlZ2VyIGFycmF5LlwiO1xufSkoRXJyb3JDb2RlcyB8fCAoRXJyb3JDb2RlcyA9IHt9KSk7XG5leHBvcnQgY29uc3QgRXJyb3JEZXRhaWxzID0gdC5yZWNvcmQodC5zdHJpbmcsIHQudW5pb24oW3Quc3RyaW5nLCB0Lm51bWJlciwgdC5ib29sZWFuLCB0Lm51bGxdKSk7XG5leHBvcnQgY2xhc3MgUmFpZGVuRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IEVycm9yQ29kZXMuUkROX0dFTkVSQUxfRVJST1IpO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUmFpZGVuRXJyb3InO1xuICAgICAgICB0aGlzLl9jb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUmFpZGVuRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG4gICAgZ2V0IGNvZGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gdG8gbmVlZCB0byBzZWFyY2ggZm9yIF9jb2RlIGJlZm9yZSBmaXJzdCBhY2Nlc3NcbiAgICAgICAgaWYgKHRoaXMuX2NvZGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuX2NvZGUgPSAoX2EgPSBmaW5kS2V5KEVycm9yQ29kZXMsIChtZXNzYWdlKSA9PiBtZXNzYWdlID09PSB0aGlzLm1lc3NhZ2UpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnUkROX0dFTkVSQUxfRVJST1InO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29kZTtcbiAgICB9XG59XG5jb25zdCBzZXJpYWxpemVkRXJyID0gdC5pbnRlcnNlY3Rpb24oW1xuICAgIHQudHlwZSh7IG5hbWU6IHQuc3RyaW5nIH0pLFxuICAgIHQucGFydGlhbCh7IG1lc3NhZ2U6IHQuc3RyaW5nLCBzdGFjazogdC5zdHJpbmcsIGRldGFpbHM6IEVycm9yRGV0YWlscyB9KSxcbl0pO1xuLyoqXG4gKiBTaW1wbGUgRXJyb3IgY29kZWNcbiAqXG4gKiBUaGlzIGNvZGVjIGRvZXNuJ3QgZGVjb2RlIHRvIGFuIGluc3RhbmNlIG9mIHRoZSBleGFjdCBzYW1lIGVycm9yIGNsYXNzIG9iamVjdCwgYnV0IGluc3RlYWQgdG9cbiAqIGEgZ2VuZXJpYyBFcnJvciwgYnV0IGFzc2lnbmluZyAnbmFtZScsICdzdGFjaycgJiAnbWVzc2FnZScgcHJvcGVydGllcywgbW9yZSBhcyBhbiBpbmZvcm1hdGl2ZVxuICogb2JqZWN0LlxuICovXG5leHBvcnQgY29uc3QgRXJyb3JDb2RlYyA9IG5ldyB0LlR5cGUoJ0Vycm9yJywgXG4vLyBpZiBpdCBxdWFja3MgbGlrZSBhIGR1Y2suLi4gd2l0aG91dCByZWx5aW5nIG9uIGluc3RhbmNlb2Zcbih1KSA9PiB0eXBlb2YgdSA9PT0gJ29iamVjdCcgJiYgISF1ICYmICduYW1lJyBpbiB1ICYmICdtZXNzYWdlJyBpbiB1LCAodSkgPT4gcGlwZShzZXJpYWxpemVkRXJyLmRlY29kZSh1KSwgbWFwKChlcnJvcikgPT4ge1xuICAgIGlmICgnZGV0YWlscycgaW4gZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFJhaWRlbkVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yLmRldGFpbHMpLCB7XG4gICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lLFxuICAgICAgICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKSwgeyBuYW1lOiBlcnJvci5uYW1lLCBzdGFjazogZXJyb3Iuc3RhY2sgfSk7XG4gICAgfVxufSkpLCAoZXJyb3IpID0+IChPYmplY3QuYXNzaWduKHsgbmFtZTogZXJyb3IubmFtZSwgbWVzc2FnZTogZXJyb3IubWVzc2FnZSwgc3RhY2s6IGVycm9yLnN0YWNrIH0sICgnZGV0YWlscycgaW4gZXJyb3IgPyB7IGRldGFpbHM6IGVycm9yLmRldGFpbHMgfSA6IHt9KSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmpzLm1hcCIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2NsYXNzLW5hbWUtY2FzaW5nICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5pbXBvcnQgKiBhcyB0IGZyb20gJ2lvLXRzJztcbmltcG9ydCBpc01hdGNoV2l0aCBmcm9tICdsb2Rhc2gvaXNNYXRjaFdpdGgnO1xuaW1wb3J0IHsgZmlyc3QsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFJhaWRlbkVycm9yLCBFcnJvckNvZGVzLCBFcnJvckNvZGVjIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3InO1xuaW1wb3J0IHsgQmlnTnVtYmVyQywgYXNzZXJ0IH0gZnJvbSAnLi90eXBlcyc7XG4vKipcbiAqIEN1cnJpZWQgdHlwZWd1YXJkIGZ1bmN0aW9uIChhcml0eT0yKSB3aGljaCB2YWxpZGF0ZXMgMm5kIHBhcmFtIGlzIG9mIHR5cGUgb2Ygc29tZSBBY3Rpb25DcmVhdG9yc1xuICpcbiAqIEBwYXJhbSBhYyAtIFNpbmdsZSBvciBhcnJheSBvZiBBY3Rpb25DcmVhdG9yc1xuICogQHBhcmFtIGFyZ3MgLSBpZiBhbiBvYmplY3QgaXMgcGFzc2VkLCB2ZXJpZnkgaXQsIGVsc2UgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGRvZXNcbiAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyBvYmplY3QgaXMgb2YgdHlwZSBvZiBhY3Rpb24sIGlmIHBhc3NpbmcgMm5kIGFyZ3VtZW50LFxuICogICAgICBvciB0eXBlZ3VhcmQgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWN0aW9uT2YoYWMsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBhcnIgPSBBcnJheS5pc0FycmF5KGFjKSA/IGFjIDogW2FjXTtcbiAgICBmdW5jdGlvbiBfaXNBY3Rpb25PZihhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbiAhPSBudWxsICYmIGFyci5zb21lKChhKSA9PiBhLmlzKGFjdGlvbikpO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgICByZXR1cm4gX2lzQWN0aW9uT2YoYXJnc1swXSk7XG4gICAgcmV0dXJuIF9pc0FjdGlvbk9mO1xufVxuLyoqXG4gKiBDcmVhdGUgYSB0eXBlc2FmZSwgc2VyaWFsaXphYmxlIEFjdGlvbkNyZWF0b3IgZnJvbSB0eXBlLCBwYXlsb2FkIGNvZGVjLCBtZXRhIGNvZGVjICYgZXJyb3IgZmxhZ1xuICpcbiAqIFBhc3MgdW5kZWZpbmVkIGZvciBpbmRlcm1lZGlhcnkgYXJndW1lbnRzIGlmIHRoZXkgYXJlbid0IG5lZWRlZFxuICogZS5nLiBhY3Rpb24gd2l0aCBtZXRhIGFuZCB3aXRob3V0IHBheWxvYWQ6XG4gKiAgIGNvbnN0IGFkZFRvZG8gPSBjcmVhdGVBY3Rpb24oJ0FERF9UT0RPJywgdW5kZWZpbmVkLCB0LnR5cGUoeyBmb2xkZXI6IHQuc3RyaW5nIH0pKTtcbiAqXG4gKiBAcGFyYW0gYXJncyAtIHR5cGVzYWZlIGFyZ3MgdHVwbGVcbiAqIEBwYXJhbSBhcmdzLjAgLSB0eXBlIGxpdGVyYWwgc3RyaW5nIHRhZyBmb3IgYWN0aW9uXG4gKiBAcGFyYW0gYXJncy4xIC0gcGF5bG9hZCBjb2RlYywgb3B0aW9uYWxcbiAqIEBwYXJhbSBhcmdzLjIgLSBtZXRhIGNvZGVjLCBvcHRpb25hbFxuICogQHBhcmFtIGFyZ3MuMyAtIGVycm9yIGZsYWcsIHdpbGwgb25seSBiZSBwcmVzZW50IGlmIGRlZmluZWQgKGVpdGhlciBmYWxzZSBvciB0cnVlKVxuICogQHJldHVybnMgQWN0aW9uQ3JlYXRvciBmYWN0b3J5IGZ1bmN0aW9uIHdpdGggdXNlZnVsIHByb3BlcnRpZXMuIFNlZSBbW0FjdGlvbkNyZWF0b3JNZW1iZXJzXV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFjdGlvbiguLi5hcmdzKSB7XG4gICAgY29uc3QgW3R5cGUsIHBheWxvYWRDLCBtZXRhQywgZXJyb3JdID0gYXJncztcbiAgICAvLyBhY3Rpb24gY29kZWNcbiAgICBjb25zdCBjb2RlYyA9IHQudHlwZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHR5cGU6IHQubGl0ZXJhbCh0eXBlKSB9LCAocGF5bG9hZEMgPyB7IHBheWxvYWQ6IHBheWxvYWRDIH0gOiBudWxsKSksIChtZXRhQyA/IHsgbWV0YTogbWV0YUMgfSA6IG51bGwpKSwgKGVycm9yID8geyBlcnJvcjogdC5saXRlcmFsKGVycm9yKSB9IDogbnVsbCkpKTtcbiAgICAvLyBtZW1iZXIgdHlwZWd1YXJkXG4gICAgLy8gbGlrZSBjb2RlYy5pcywgYnV0IG9uIHByb2R1Y3Rpb24sIHN3aXRjaGVzIHRvIG1vcmUgcGVyZm9ybWFudCBjaGVjayBvZiAndHlwZScgdGFnIG9ubHlcbiAgICBjb25zdCBpcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnXG4gICAgICAgID8gKGFjdGlvbikgPT4gY29kZWMuaXMoYWN0aW9uKVxuICAgICAgICA6IChhY3Rpb24pID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGFjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWyd0eXBlJ10pID09PSB0eXBlOyB9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKChwYXlsb2FkLCBtZXRhKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB0eXBlIH0sIChwYXlsb2FkQyA/IHsgcGF5bG9hZCB9IDogbnVsbCkpLCAobWV0YUMgPyB7IG1ldGEgfSA6IG51bGwpKSwgKGVycm9yICE9PSB1bmRlZmluZWQgPyB7IGVycm9yIH0gOiBudWxsKSkpLCB7IGNvZGVjLCB0eXBlLCBpcyB9LCBlcnJvciAhPT0gdW5kZWZpbmVkID8geyBlcnJvciB9IDogbnVsbCk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHNldCBvZiBhc3luYyBhY3Rpb25zXG4gKlxuICogSGVyZSwgbWV0YSBpcyBmaXJzdCBjbGFzcyBjaXRpemVuLCBhcyBpdCdzIHJlcXVpcmVkIGFuZCB3aGF0IGxpbmtzIGEgcmVxdWVzdCB3aXRoIGl0cyByZXNwb25zZXNcbiAqIChzdWNjZXNzIG9yIGZhaWx1cmUpLlxuICogQW4gJ2lzUmVzcG9uc2VPZicgbWVtYmVyIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHdoaWNoIGFjY2VwdHMgJ21ldGEnIChlLmcuIGZyb20gcmVxdWVzdCkgYW5kXG4gKiByZXR1cm5zIGEgdHlwZSBndWFyZCBmdW5jdGlvbi9maWx0ZXIgd2hpY2ggcmV0dXJucyB0cnVlIG9ubHkgaWYgcGFzc2VkIGEgcmVzcGVjdGl2ZSBkZWVwLWVxdWFsXG4gKiAnbWV0YScgc3VjY2Vzc3xmYWlsdXJlIGFjdGlvbi5cbiAqXG4gKiBAcGFyYW0gbWV0YSAtIE1ldGEgb2JqZWN0IGNvbW1vbiB0byB0aGVzZSBhc3luYyBhY3Rpb25zXG4gKiBAcGFyYW0gcnR5cGUgLSBSZXF1ZXN0IGxpdGVyYWwgc3RyaW5nIHRhZ1xuICogQHBhcmFtIHN0eXBlIC0gU3VjY2VzcyBsaXRlcmFsIHN0cmluZyB0YWdcbiAqIEBwYXJhbSBmdHlwZSAtIEZhaWx1cmUgbGl0ZXJhbCBzdHJpbmcgdGFnXG4gKiBAcGFyYW0gcnBheWxvYWQgLSBSZXF1ZXN0IHBheWxvYWQgY29kZWNcbiAqIEBwYXJhbSBzcGF5bG9hZCAtIFN1Y2Nlc3MgcGF5bG9hZCBjb2RlY1xuICogQHBhcmFtIGFyZ3MgLSBPcHRpb25hbCBmcGF5bG9hZCAtIEZhaWx1cmUgcGF5bG9hZCBjb2RlYywgZGVmYXVsdHMgdG8gRXJyb3JDb2RlY1xuICogQHJldHVybnMgQXN5bmMgYWN0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXN5bmNBY3Rpb24obWV0YSwgcnR5cGUsIHN0eXBlLCBmdHlwZSwgcnBheWxvYWQsIHNwYXlsb2FkLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgZnBheWxvYWQgPSBhcmdzLmxlbmd0aCA/IGFyZ3NbMF0gOiBFcnJvckNvZGVjO1xuICAgIGNvbnN0IHJlcXVlc3QgPSBjcmVhdGVBY3Rpb24ocnR5cGUsIHJwYXlsb2FkLCBtZXRhKTtcbiAgICBjb25zdCBzdWNjZXNzID0gY3JlYXRlQWN0aW9uKHN0eXBlLCBzcGF5bG9hZCwgbWV0YSk7XG4gICAgY29uc3QgZmFpbHVyZSA9IGNyZWF0ZUFjdGlvbihmdHlwZSwgZnBheWxvYWQsIG1ldGEsIHRydWUpO1xuICAgIHJldHVybiB7IHJlcXVlc3QsIHN1Y2Nlc3MsIGZhaWx1cmUgfTtcbn1cbi8qKlxuICogTWF0Y2ggYSBwYXNzZWQgbWV0YSB3aXRoIGFuIGFjdGlvbiBpZiByZXR1cm5zIHRydWUgaWYgbWV0YXMgYXJlIGZyb20gY29ycmVzcG9uZGluZyBhY3Rpb25zXG4gKlxuICogY3VycmllZCAoYXJpdHk9MikgZm9yIGFjdGlvbiBwYXNzZWQgYXMgMm5kIHBhcmFtLlxuICpcbiAqIEBwYXJhbSBtZXRhIC0gbWV0YSBiYXNlIGZvciBjb21wYXJpc29uXG4gKiBAcGFyYW0gYXJncyAtIGN1cnJpZWQgYXJncyBhcnJheVxuICogQHBhcmFtIGFyZ3MuMCAtIGFjdGlvbiB0byB0ZXN0IG1ldGEgYWdhaW5zdCB0aGUgMXN0IHBhcmFtXG4gKiBAcmV0dXJucyB0cnVlIGlmIG1ldGFzIGFyZSBjb21wYXRpYmxlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gbWF0Y2hNZXRhKG1ldGEsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBfbWF0Y2ggPSAoYWN0aW9uKSA9PiBcbiAgICAvLyBsaWtlIGlzRXF1YWwsIGJ1dCBmb3IgQmlnTnVtYmVycywgdXNlIC5lcVxuICAgIGlzTWF0Y2hXaXRoKGFjdGlvbi5tZXRhLCBtZXRhLCAob2JqVmFsLCBvdGhWYWwpID0+IFxuICAgIC8vIGFueSBpcyB0byBhdm9pZCBsb2Rhc2gncyBpc3N1ZSB3aXRoIHVuZGVmaW5lZC1yZXR1cm5pbmcgaXNNYXRjaFdpdGhDdXN0b21pemVyIGNiIHR5cGVcbiAgICBCaWdOdW1iZXJDLmlzKG9ialZhbCkgJiYgQmlnTnVtYmVyQy5pcyhvdGhWYWwpID8gb2JqVmFsLmVxKG90aFZhbCkgOiB1bmRlZmluZWQpO1xuICAgIGlmIChhcmdzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF9tYXRjaChhcmdzWzBdKTtcbiAgICByZXR1cm4gX21hdGNoO1xufVxuLyoqXG4gKiBHaXZlbiBhbiBBc3luY0FjdGlvbkNyZWF0b3IgYW5kIGEgcmVzcGVjdGl2ZSAnbWV0YScgb2JqZWN0LCByZXR1cm5zIGEgdHlwZSBndWFyZCBmdW5jdGlvbiBmb3JcbiAqIHJlc3BvbnNlcyBhY3Rpb25zIChzdWNjZXNzfGZhaWx1cmUpIG1hdGNoaW5nIGdpdmVuICdtZXRhJ1xuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmVjZWl2ZXMgMi0zIHBhcmFtcy4gSWYgaXQgcmVjZWl2ZXMgMiwgaXQgcmV0dXJucyB0aGUgdHlwZSBndWFyZCBmdW5jdGlvbiwgdG8gYmVcbiAqIHVzZWQgZm9yIGZpbHRlcmluZy4gT3RoZXJ3aXNlLCBpdCBwZXJmb3JtcyB0aGUgY2hlY2sgb24gdGhlIDNyZCBwYXJhbS5cbiAqXG4gKiBAcGFyYW0gYXN5bmNBY3Rpb24gLSBBc3luY0FjdGlvbkNyZWF0b3Igb2JqZWN0XG4gKiBAcGFyYW0gbWV0YSAtIG1ldGEgb2JqZWN0IHRvIGZpbHRlciBtYXRjaGluZyBhY3Rpb25zXG4gKiBAcGFyYW0gYXJncyAtIGN1cnJpZWQgbGFzdCBwYXJhbVxuICogQHJldHVybnMgdHlwZSBndWFyZCBmdW5jdGlvbiB0byBmaWx0ZXIgZGVlcC1lcXVhbCBtZXRhIHN1Y2Nlc3N8ZmFpbHVyZSBhY3Rpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc3BvbnNlT2YoYXN5bmNBY3Rpb24sIG1ldGEsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBfaXNSZXNwb25zZU9mID0gKGFjdGlvbikgPT4gaXNBY3Rpb25PZihbYXN5bmNBY3Rpb24uc3VjY2VzcywgYXN5bmNBY3Rpb24uZmFpbHVyZV0sIGFjdGlvbikgJiYgbWF0Y2hNZXRhKG1ldGEsIGFjdGlvbik7XG4gICAgaWYgKGFyZ3MubGVuZ3RoKVxuICAgICAgICByZXR1cm4gX2lzUmVzcG9uc2VPZihhcmdzWzBdKTtcbiAgICByZXR1cm4gX2lzUmVzcG9uc2VPZjtcbn1cbi8qKlxuICogTGlrZSBpc1Jlc3BvbnNlT2YsIGJ1dCBpZ25vcmVzIG5vbi1jb25maXJtZWQgKG9yIHJlbW92ZWQgYnkgYSByZW9yZykgc3VjY2VzcyBhY3Rpb25cbiAqXG4gKiBDb25maXJtYWJsZSBzdWNjZXNzIGFjdGlvbnMgYXJlIGVtaXR0ZWQgdHdpY2U6IGZpcnN0IHdpdGggcGF5bG9hZC5jb25maXJtZWQ9dW5kZWZpbmVkLCB0aGVuIHdpdGhcbiAqIGVpdGhlciBjb25maXJtZWQ9dHJ1ZSwgaWYgdHggc3RpbGwgcHJlc2VudCBhZnRlciBjb25maXJtYXRpb24gYmxvY2tzLCBvciBjb25maXJtZWQ9ZmFsc2UsIGlmIHR4XG4gKiB3YXMgcmVtb3ZlZCBmcm9tIGJsb2NrY2hhaW4gYnkgYSByZW9yZy5cbiAqIFRoaXMgY3VyaWVkIGhlbHBlciBmaWx0ZXIgZnVuY3Rpb24gZW5zdXJlcyBvbmx5IG9uZSBvZiB0aGUgbGF0ZXIgY2F1c2VzIGEgcG9zaXRpdmUgZmlsdGVyLlxuICpcbiAqIEBwYXJhbSBhc3luY0FjdGlvbiAtIEFzeW5jQWN0aW9uQ3JlYXRvciBvYmplY3RcbiAqIEBwYXJhbSBtZXRhIC0gbWV0YSBvYmplY3QgdG8gZmlsdGVyIG1hdGNoaW5nIGFjdGlvbnNcbiAqIEBwYXJhbSBhcmdzIC0gY3VycmllZCBsYXN0IHBhcmFtXG4gKiBAcmV0dXJucyB0eXBlIGd1YXJkIGZ1bmN0aW9uIHRvIGZpbHRlciBkZWVwLWVxdWFsIG1ldGEgc3VjY2Vzc3xmYWlsdXJlIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29uZmlybWF0aW9uUmVzcG9uc2VPZihhc3luY0FjdGlvbiwgbWV0YSwgLi4uYXJncykge1xuICAgIGZ1bmN0aW9uIF9pc0NvbmZpcm1hdGlvbihhY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiAoKF9iID0gKF9hID0gYWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbJ3BheWxvYWQnXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWydjb25maXJtZWQnXSkgPT09ICdib29sZWFuJztcbiAgICB9XG4gICAgY29uc3QgX2lzUmVzcG9uc2VPZiA9IChhY3Rpb24pID0+IGlzUmVzcG9uc2VPZihhc3luY0FjdGlvbiwgbWV0YSwgYWN0aW9uKSAmJlxuICAgICAgICAoYXN5bmNBY3Rpb24uZmFpbHVyZS5pcyhhY3Rpb24pIHx8IF9pc0NvbmZpcm1hdGlvbihhY3Rpb24pKTtcbiAgICBpZiAoYXJncy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBfaXNSZXNwb25zZU9mKGFyZ3NbMF0pO1xuICAgIHJldHVybiBfaXNSZXNwb25zZU9mO1xufVxuLyoqXG4gKiBXYXRjaCBhIHN0cmVhbSBvZiBhY3Rpb25zIGFuZCByZXNvbHZlcyBvbiBtZXRhLW1hdGNoaW5nIHN1Y2Nlc3Mgb3IgcmVqZWN0cyBvbiBmYWlsdXJlXG4gKlxuICogQHBhcmFtIGFzeW5jQWN0aW9uIC0gYXN5bmMgYWN0aW9ucyBvYmplY3QgdG8gd2FpdCBmb3JcbiAqIEBwYXJhbSBtZXRhIC0gbWV0YSBvYmplY3Qgb2YgYSByZXF1ZXN0IHRvIHdhaXQgZm9yIHRoZSByZXNwZWN0aXZlIHJlc3BvbnNlXG4gKiBAcGFyYW0gYWN0aW9uJCAtIGFjdGlvbnMgc3RyZWFtIHRvIHdhdGNoIGZvciByZXNwb25zZXNcbiAqIEBwYXJhbSBjb25maXJtZWQgLSBzZXQgaWYgc2hvdWxkIGlnbm9yZSBub24tY29uZmlybWVkIHN1Y2Nlc3MgcmVzcG9uc2VcbiAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVqZWN0cyB3aXRoIHBheWxvYWQgaW4gY2FzZSBvZiBmYWlsdXJlLCBvciByZXNvbHZlcyBwYXlsb2FkIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXN5bmNBY3Rpb25Ub1Byb21pc2UoYXN5bmNBY3Rpb24sIG1ldGEsIGFjdGlvbiQsIGNvbmZpcm1lZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbiRcbiAgICAgICAgICAgIC5waXBlKGZpcnN0KGNvbmZpcm1lZFxuICAgICAgICAgICAgPyBpc0NvbmZpcm1hdGlvblJlc3BvbnNlT2YoYXN5bmNBY3Rpb24sIG1ldGEpXG4gICAgICAgICAgICA6IGlzUmVzcG9uc2VPZihhc3luY0FjdGlvbiwgbWV0YSkpLCBtYXAoKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKGFzeW5jQWN0aW9uLmZhaWx1cmUuaXMoYWN0aW9uKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGFjdGlvbi5wYXlsb2FkLmNvbmZpcm1lZCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuUkROX1RSQU5TQUNUSU9OX1JFT1JHLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogYWN0aW9uLnBheWxvYWQudHhIYXNoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICB9KSlcbiAgICAgICAgICAgIC50b1Byb21pc2UoKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcmVkdWNlciB3aGljaCBjYW4gYmUgZXh0ZW5kZWQgd2l0aCBhZGRpdGlvbmFsIGFjdGlvbnMgaGFuZGxlcnNcbiAqXG4gKiBVc2FnZTpcbiAqICAgY29uc3QgcmVkdWNlciA9IGNyZWF0ZVJlZHVjZXIoU3RhdGUpXG4gKiAgICAgIC5oYW5kbGUoYWN0aW9uLCAocywgYSk6IFN0YXRlID0+IC4uLilcbiAqICAgICAgLmhhbmRsZSguLi4pXG4gKiAgICAgIC5oYW5kbGUoLi4uKTtcbiAqXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIC0gc3RhdGUgZm9yIGluaXRpYWxpemF0aW9uIChpZiBubyBzdGF0ZSBpcyBwYXNzZWQgb24gcmVkdWNlciBjYWxsKVxuICogQHJldHVybnMgQSByZWR1Y2VyIGZ1bmN0aW9uLCBleHRlbmRlZCB3aXRoIGEgaGFuZGxlIG1ldGhvZCB0byBleHRlbmQgaXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlKSB7XG4gICAgLy8gbWFrZSBhIHJlZHVjZXIgZnVuY3Rpb24gZm9yIGdpdmVuIGhhbmRsZXJzXG4gICAgZnVuY3Rpb24gbWFrZVJlZHVjZXIoaGFuZGxlcnMpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IChzdGF0ZSA9IGluaXRpYWxTdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uLnR5cGUgaW4gaGFuZGxlcnMgJiYgaGFuZGxlcnNbYWN0aW9uLnR5cGVdWzBdLmlzKGFjdGlvbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJzW2FjdGlvbi50eXBlXVsxXShzdGF0ZSwgYWN0aW9uKTsgLy8gY2FsbHMgcmVnaXN0ZXJlZCBoYW5kbGVyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7IC8vIGZhbGxiYWNrIHJldHVybnMgdW5jaGFuZ2VkIHN0YXRlXG4gICAgICAgIH07XG4gICAgICAgIC8vIGNpcmN1bGFyIGRlcGVuZGVuY3kgb24gZ2VuZXJpYyBwYXJhbXMgZm9yYmlkcyBhbiBhbHJlYWR5IGhhbmRsZWQgYWN0aW9uIGZyb20gYmVpbmcgYWNjZXB0ZWRcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlKGFjLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBhcnIgPSBBcnJheS5pc0FycmF5KGFjKSA/IGFjIDogW2FjXTtcbiAgICAgICAgICAgIGFzc2VydCghYXJyLnNvbWUoKGEpID0+IGEudHlwZSBpbiBoYW5kbGVycyksICdBbHJlYWR5IGhhbmRsZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBtYWtlUmVkdWNlcihPYmplY3QuYXNzaWduKHt9LCBoYW5kbGVycywgLi4uYXJyLm1hcCgoYWMpID0+ICh7IFthYy50eXBlXTogW2FjLCBoYW5kbGVyXSB9KSkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBncm93IHJlZHVjZXIgZnVuY3Rpb24gd2l0aCBvdXIgYGhhbmRsZWAgZXh0ZW5kZXJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocmVkdWNlciwgeyBoYW5kbGUgfSk7XG4gICAgfVxuICAgIC8vIGluaXRpYWxseSBtYWtlcyBhIHJlZHVjZXIgd2hpY2ggZG9lc24ndCBoYW5kbGUgYW55dGhpbmcgKGp1c3QgcmV0dXJucyB1bmNoYW5nZWQgc3RhdGUpXG4gICAgcmV0dXJuIG1ha2VSZWR1Y2VyKHt9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGlvbnMuanMubWFwIiwiaW1wb3J0ICogYXMgdCBmcm9tICdpby10cyc7XG5pbXBvcnQgeyBBZGRyZXNzLCBIYXNoLCBTaWduYXR1cmUsIFVJbnQgfSBmcm9tICcuLi91dGlscy90eXBlcyc7XG4vLyBSZXByZXNlbnRzIGEgSGFzaFRpbWUtTG9ja2VkIGFtb3VudCBpbiBhIGNoYW5uZWxcbmV4cG9ydCBjb25zdCBMb2NrID0gdC50eXBlKHtcbiAgICBhbW91bnQ6IFVJbnQoMzIpLFxuICAgIGV4cGlyYXRpb246IFVJbnQoMzIpLFxuICAgIHNlY3JldGhhc2g6IEhhc2gsXG59LCAnTG9jaycpO1xuLyoqXG4gKiBCYWxhbmNlIFByb29mIGNvbnN0cnVjdGVkIGZyb20gYW4gRW52ZWxvcGVNZXNzYWdlXG4gKiBFaXRoZXIgcHJvZHVjZWQgYnkgdXMgb3IgcmVjZWl2ZWQgZnJvbSB0aGUgcGFydG5lciwgdGhlIEJQcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIG1lc3NhZ2VzXG4gKiBiZWNhdXNlIEJQIHNpZ25hdHVyZSByZXF1aXJlcyB0aGUgaGFzaCBvZiB0aGUgbWVzc2FnZSwgZm9yIGF1dGhlbnRpY2F0aW9uIG9mIGRhdGEgbm90IGluY2x1ZGVkXG4gKiBub3IgcmVsZXZhbnQgZm9yIHRoZSBzbWFydGNvbnRyYWN0L0JQIGl0c2VsZiwgYnV0IHNvIGZvciB0aGUgcGVlcnMgKGUuZy4gcGF5bWVudF9pZClcbiAqL1xuZXhwb3J0IGNvbnN0IFNpZ25lZEJhbGFuY2VQcm9vZiA9IHQudHlwZSh7XG4gICAgLy8gY2hhbm5lbCBkYXRhXG4gICAgY2hhaW5JZDogVUludCgzMiksXG4gICAgdG9rZW5OZXR3b3JrQWRkcmVzczogQWRkcmVzcyxcbiAgICBjaGFubmVsSWQ6IFVJbnQoMzIpLFxuICAgIC8vIGJhbGFuY2UgcHJvb2YgZGF0YVxuICAgIG5vbmNlOiBVSW50KDgpLFxuICAgIHRyYW5zZmVycmVkQW1vdW50OiBVSW50KDMyKSxcbiAgICBsb2NrZWRBbW91bnQ6IFVJbnQoMzIpLFxuICAgIGxvY2tzcm9vdDogSGFzaCxcbiAgICBtZXNzYWdlSGFzaDogSGFzaCxcbiAgICBzaWduYXR1cmU6IFNpZ25hdHVyZSxcbiAgICBzZW5kZXI6IEFkZHJlc3MsXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1uYW1lc3BhY2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9jbGFzcy1uYW1lLWNhc2luZyAqL1xuaW1wb3J0ICogYXMgdCBmcm9tICdpby10cyc7XG5pbXBvcnQgeyBjcmVhdGVBY3Rpb24sIGNyZWF0ZUFzeW5jQWN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvYWN0aW9ucyc7XG5pbXBvcnQgeyBBZGRyZXNzLCBIYXNoLCBVSW50IH0gZnJvbSAnLi4vdXRpbHMvdHlwZXMnO1xuaW1wb3J0IHsgTG9jayB9IGZyb20gJy4vdHlwZXMnO1xuLy8gaW50ZXJmYWNlcyBuZWVkIHRvIGJlIGV4cG9ydGVkLCBhbmQgd2UgbmVlZC93YW50IHRvIHN1cHBvcnQgYGltcG9ydCAqIGFzIFJhaWRlbkFjdGlvbnNgXG5jb25zdCBDaGFubmVsSWQgPSB0LnR5cGUoe1xuICAgIHRva2VuTmV0d29yazogQWRkcmVzcyxcbiAgICBwYXJ0bmVyOiBBZGRyZXNzLFxufSk7XG4vKiBBIG5ldyBoZWFkIGluIHRoZSBibG9ja2NoYWluIGlzIGRldGVjdGVkIGJ5IHByb3ZpZGVyICovXG5leHBvcnQgY29uc3QgbmV3QmxvY2sgPSBjcmVhdGVBY3Rpb24oJ25ld0Jsb2NrJywgdC50eXBlKHsgYmxvY2tOdW1iZXI6IHQubnVtYmVyIH0pKTtcbi8qKlxuICogQSBuZXcgdG9rZW4gbmV0d29yayBpcyBkZXRlY3RlZCBpbiB0aGUgVG9rZW5OZXR3b3JrUmVnaXN0cnkgaW5zdGFuY2VcbiAqIGZyb21CbG9jayBpcyBvbmx5IHNldCBvbiB0aGUgZmlyc3QgdGltZSwgdG8gZmV0Y2ggYW5kIGhhbmRsZSBwYXN0IGV2ZW50c1xuICovXG5leHBvcnQgY29uc3QgdG9rZW5Nb25pdG9yZWQgPSBjcmVhdGVBY3Rpb24oJ3Rva2VuTW9uaXRvcmVkJywgdC5pbnRlcnNlY3Rpb24oW1xuICAgIHQudHlwZSh7XG4gICAgICAgIHRva2VuOiBBZGRyZXNzLFxuICAgICAgICB0b2tlbk5ldHdvcms6IEFkZHJlc3MsXG4gICAgfSksXG4gICAgdC5wYXJ0aWFsKHtcbiAgICAgICAgZnJvbUJsb2NrOiB0Lm51bWJlcixcbiAgICB9KSxcbl0pKTtcbi8qKlxuICogQ2hhbm5lbCBhY3Rpb25zIHJlY2VpdmUgQ2hhbm5lbElkIGFzICdtZXRhJyBhY3Rpb24gcHJvcGVydHlcbiAqIFRoaXMgd2F5LCAnbWV0YScgY2FuIGJlIHVzZWQgZXF1YWxseSBmb3IgcmVxdWVzdCwgc3VjY2VzcyBhbmQgZXJyb3IgYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgY2hhbm5lbE9wZW4gPSBjcmVhdGVBc3luY0FjdGlvbihDaGFubmVsSWQsICdjaGFubmVsL29wZW4vcmVxdWVzdCcsICdjaGFubmVsL29wZW4vc3VjY2VzcycsICdjaGFubmVsL29wZW4vZmFpbGVkJywgdC5wYXJ0aWFsKHsgc2V0dGxlVGltZW91dDogdC5udW1iZXIsIHN1YmtleTogdC5ib29sZWFuLCBkZXBvc2l0OiBVSW50KDMyKSB9KSwgdC50eXBlKHtcbiAgICBpZDogdC5udW1iZXIsXG4gICAgc2V0dGxlVGltZW91dDogdC5udW1iZXIsXG4gICAgaXNGaXJzdFBhcnRpY2lwYW50OiB0LmJvb2xlYW4sXG4gICAgdHhIYXNoOiBIYXNoLFxuICAgIHR4QmxvY2s6IHQubnVtYmVyLFxuICAgIGNvbmZpcm1lZDogdC51bmlvbihbdC51bmRlZmluZWQsIHQuYm9vbGVhbl0pLFxufSkpO1xuLyogQ2hhbm5lbCB3aXRoIG1ldGE6Q2hhbm5lbElkICsgcGF5bG9hZC5pZCBzaG91bGQgYmUgbW9uaXRvcmVkICovXG5leHBvcnQgY29uc3QgY2hhbm5lbE1vbml0b3IgPSBjcmVhdGVBY3Rpb24oJ2NoYW5uZWwvbW9uaXRvcicsIHQuaW50ZXJzZWN0aW9uKFt0LnR5cGUoeyBpZDogdC5udW1iZXIgfSksIHQucGFydGlhbCh7IGZyb21CbG9jazogdC5udW1iZXIgfSldKSwgQ2hhbm5lbElkKTtcbmV4cG9ydCBjb25zdCBjaGFubmVsRGVwb3NpdCA9IGNyZWF0ZUFzeW5jQWN0aW9uKENoYW5uZWxJZCwgJ2NoYW5uZWwvZGVwb3NpdC9yZXF1ZXN0JywgJ2NoYW5uZWwvZGVwb3NpdC9zdWNjZXNzJywgJ2NoYW5uZWwvZGVwb3NpdC9mYWlsdXJlJywgdC5pbnRlcnNlY3Rpb24oW3QudHlwZSh7IGRlcG9zaXQ6IFVJbnQoMzIpIH0pLCB0LnBhcnRpYWwoeyBzdWJrZXk6IHQuYm9vbGVhbiB9KV0pLCB0LnR5cGUoe1xuICAgIGlkOiB0Lm51bWJlcixcbiAgICBwYXJ0aWNpcGFudDogQWRkcmVzcyxcbiAgICB0b3RhbERlcG9zaXQ6IFVJbnQoMzIpLFxuICAgIHR4SGFzaDogSGFzaCxcbiAgICB0eEJsb2NrOiB0Lm51bWJlcixcbiAgICBjb25maXJtZWQ6IHQudW5pb24oW3QudW5kZWZpbmVkLCB0LmJvb2xlYW5dKSxcbn0pKTtcbi8qIEEgd2l0aGRyYXcgaXMgZGV0ZWN0ZWQgb24tY2hhaW4gKi9cbmV4cG9ydCBjb25zdCBjaGFubmVsV2l0aGRyYXduID0gY3JlYXRlQWN0aW9uKCdjaGFubmVsL3dpdGhkcmF3L3N1Y2Nlc3MnLCB0LnR5cGUoe1xuICAgIGlkOiB0Lm51bWJlcixcbiAgICBwYXJ0aWNpcGFudDogQWRkcmVzcyxcbiAgICB0b3RhbFdpdGhkcmF3OiBVSW50KDMyKSxcbiAgICB0eEhhc2g6IEhhc2gsXG4gICAgdHhCbG9jazogdC5udW1iZXIsXG4gICAgY29uZmlybWVkOiB0LnVuaW9uKFt0LnVuZGVmaW5lZCwgdC5ib29sZWFuXSksXG59KSwgQ2hhbm5lbElkKTtcbmV4cG9ydCBjb25zdCBjaGFubmVsQ2xvc2UgPSBjcmVhdGVBc3luY0FjdGlvbihDaGFubmVsSWQsICdjaGFubmVsL2Nsb3NlL3JlcXVlc3QnLCAnY2hhbm5lbC9jbG9zZS9zdWNjZXNzJywgJ2NoYW5uZWwvY2xvc2UvZmFpbHVyZScsIHQudW5pb24oW3QucGFydGlhbCh7IHN1YmtleTogdC5ib29sZWFuIH0pLCB0LnVuZGVmaW5lZF0pLCB0LnR5cGUoe1xuICAgIGlkOiB0Lm51bWJlcixcbiAgICBwYXJ0aWNpcGFudDogQWRkcmVzcyxcbiAgICB0eEhhc2g6IEhhc2gsXG4gICAgdHhCbG9jazogdC5udW1iZXIsXG4gICAgY29uZmlybWVkOiB0LnVuaW9uKFt0LnVuZGVmaW5lZCwgdC5ib29sZWFuXSksXG59KSk7XG4vKiBBIGNoYW5uZWwgbWV0YTpDaGFubmVsSWQgYmVjb21lcyBzZXR0bGVhYmxlLCBzdGFydGluZyBmcm9tIHBheWxvYWQuc2V0dGxlYWJsZUJsb2NrICovXG5leHBvcnQgY29uc3QgY2hhbm5lbFNldHRsZWFibGUgPSBjcmVhdGVBY3Rpb24oJ2NoYW5uZWwvc2V0dGxlYWJsZScsIHQudHlwZSh7IHNldHRsZWFibGVCbG9jazogdC5udW1iZXIgfSksIENoYW5uZWxJZCk7XG5leHBvcnQgY29uc3QgY2hhbm5lbFNldHRsZSA9IGNyZWF0ZUFzeW5jQWN0aW9uKENoYW5uZWxJZCwgJ2NoYW5uZWwvc2V0dGxlL3JlcXVlc3QnLCAnY2hhbm5lbC9zZXR0bGUvc3VjY2VzcycsICdjaGFubmVsL3NldHRsZS9mYWlsdXJlJywgdC51bmlvbihbdC5wYXJ0aWFsKHsgc3Via2V5OiB0LmJvb2xlYW4gfSksIHQudW5kZWZpbmVkXSksIHQuaW50ZXJzZWN0aW9uKFtcbiAgICB0LnR5cGUoe1xuICAgICAgICBpZDogdC5udW1iZXIsXG4gICAgICAgIHR4SGFzaDogSGFzaCxcbiAgICAgICAgdHhCbG9jazogdC5udW1iZXIsXG4gICAgICAgIGNvbmZpcm1lZDogdC51bmlvbihbdC51bmRlZmluZWQsIHQuYm9vbGVhbl0pLFxuICAgIH0pLFxuICAgIHQucGFydGlhbCh7IGxvY2tzOiB0LnJlYWRvbmx5QXJyYXkoTG9jaykgfSksXG5dKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpb25zLmpzLm1hcCIsImltcG9ydCAqIGFzIHQgZnJvbSAnaW8tdHMnO1xuZXhwb3J0IGNvbnN0IFJhaWRlbk1hdHJpeFNldHVwID0gdC5yZWFkb25seSh0LnR5cGUoe1xuICAgIHVzZXJJZDogdC5zdHJpbmcsXG4gICAgYWNjZXNzVG9rZW46IHQuc3RyaW5nLFxuICAgIGRldmljZUlkOiB0LnN0cmluZyxcbiAgICBkaXNwbGF5TmFtZTogdC5zdHJpbmcsXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZS5qcy5tYXAiLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbmFtZXNwYWNlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2xhc3MtbmFtZS1jYXNpbmcgKi9cbmltcG9ydCAqIGFzIHQgZnJvbSAnaW8tdHMnO1xuaW1wb3J0IHsgY3JlYXRlQWN0aW9uLCBjcmVhdGVBc3luY0FjdGlvbiB9IGZyb20gJy4uL3V0aWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgQWRkcmVzcywgaW5zdGFuY2VPZiB9IGZyb20gJy4uL3V0aWxzL3R5cGVzJztcbmltcG9ydCB7IFJhaWRlbk1hdHJpeFNldHVwIH0gZnJvbSAnLi9zdGF0ZSc7XG5jb25zdCBOb2RlSWQgPSB0LnR5cGUoeyBhZGRyZXNzOiBBZGRyZXNzIH0pO1xuLyogTWF0cml4Q2xpZW50IGluc3RhbmNlIGlzIHJlYWR5IGFuZCBsb2dnZWQgaW4gdG8gcGF5bG9hZC5zZXJ2ZXIgd2l0aCBjcmVkZW50aWFscyBwYXlsb2FkLnNldHVwICovXG5leHBvcnQgY29uc3QgbWF0cml4U2V0dXAgPSBjcmVhdGVBY3Rpb24oJ21hdHJpeFNldHVwJywgdC50eXBlKHtcbiAgICBzZXJ2ZXI6IHQuc3RyaW5nLFxuICAgIHNldHVwOiBSYWlkZW5NYXRyaXhTZXR1cCxcbn0pKTtcbmV4cG9ydCBjb25zdCBtYXRyaXhQcmVzZW5jZSA9IGNyZWF0ZUFzeW5jQWN0aW9uKE5vZGVJZCwgJ21hdHJpeC9wcmVzZW5jZS9yZXF1ZXN0JywgJ21hdHJpeC9wcmVzZW5jZS9zdWNjZXNzJywgJ21hdHJpeC9wcmVzZW5jZS9mYWlsdXJlJywgdW5kZWZpbmVkLCB0LmludGVyc2VjdGlvbihbXG4gICAgdC50eXBlKHsgdXNlcklkOiB0LnN0cmluZywgYXZhaWxhYmxlOiB0LmJvb2xlYW4sIHRzOiB0Lm51bWJlciB9KSxcbiAgICB0LnBhcnRpYWwoeyBjYXBzOiB0LnJlY29yZCh0LnN0cmluZywgdC5hbnkpIH0pLFxuXSkpO1xuLyogcGF5bG9hZC5yb29tSWQgbXVzdCBnbyBmcm9udCBvbiBtZXRhLmFkZHJlc3MncyByb29tIHF1ZXVlICovXG5leHBvcnQgY29uc3QgbWF0cml4Um9vbSA9IGNyZWF0ZUFjdGlvbignbWF0cml4Um9vbScsIHQudHlwZSh7IHJvb21JZDogdC5zdHJpbmcgfSksIE5vZGVJZCk7XG4vKiBwYXlsb2FkLnJvb21JZCBtdXN0IGJlIGV4Y2x1ZGVkIGZyb20gbWV0YS5hZGRyZXNzIHJvb20gcXVldWUsIGlmIHByZXNlbnQgKi9cbmV4cG9ydCBjb25zdCBtYXRyaXhSb29tTGVhdmUgPSBjcmVhdGVBY3Rpb24oJ21hdHJpeFJvb21MZWF2ZScsIHQudHlwZSh7IHJvb21JZDogdC5zdHJpbmcgfSksIE5vZGVJZCk7XG5leHBvcnQgY29uc3QgcnRjQ2hhbm5lbCA9IGNyZWF0ZUFjdGlvbigncnRjQ2hhbm5lbCcsIHQudW5pb24oW3QudW5kZWZpbmVkLCBpbnN0YW5jZU9mKFJUQ0RhdGFDaGFubmVsKV0pLCBOb2RlSWQpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aW9ucy5qcy5tYXAiLCIvKiBpc3RhbmJ1bCBpZ25vcmUgZmlsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2NhbWVsY2FzZSAqL1xuLyoqXG4gKiBUaGVzZSBpby10cyBjb2RlY3MgdmFsaWRhdGUgYW5kIGRlY29kZSBKU09OIFJhaWRlbiBtZXNzYWdlc1xuICogVGhleSBpbmNsdWRlIEJpZ051bWJlciBzdHJpbmdzIHZhbGlkYXRpb24sIGVudW0gdmFsaWRhdGlvbiAoaWYgbmVlZGVkKSwgQWRkcmVzcyBjaGVja3N1bVxuICogdmFsaWRhdGlvbiwgZXRjLCBhbmQgY29udmVydGluZyBldmVyeXRoaW5nIHRvIGl0cyByZXNwZWN0aXZlIG9iamVjdCwgd2hlcmUgbmVlZGVkLlxuICovXG5pbXBvcnQgKiBhcyB0IGZyb20gJ2lvLXRzJztcbmltcG9ydCB7IEFkZHJlc3MsIEhhc2gsIFNlY3JldCwgVUludCwgSW50IH0gZnJvbSAnLi4vdXRpbHMvdHlwZXMnO1xuaW1wb3J0IHsgTG9jayB9IGZyb20gJy4uL2NoYW5uZWxzL3R5cGVzJztcbi8vIHR5cGVzXG5leHBvcnQgdmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIE1lc3NhZ2VUeXBlW1wiREVMSVZFUkVEXCJdID0gXCJEZWxpdmVyZWRcIjtcbiAgICBNZXNzYWdlVHlwZVtcIlBST0NFU1NFRFwiXSA9IFwiUHJvY2Vzc2VkXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJTRUNSRVRfUkVRVUVTVFwiXSA9IFwiU2VjcmV0UmVxdWVzdFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiU0VDUkVUX1JFVkVBTFwiXSA9IFwiUmV2ZWFsU2VjcmV0XCI7XG4gICAgTWVzc2FnZVR5cGVbXCJMT0NLRURfVFJBTlNGRVJcIl0gPSBcIkxvY2tlZFRyYW5zZmVyXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJSRUZVTkRfVFJBTlNGRVJcIl0gPSBcIlJlZnVuZFRyYW5zZmVyXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJVTkxPQ0tcIl0gPSBcIlVubG9ja1wiO1xuICAgIE1lc3NhZ2VUeXBlW1wiTE9DS19FWFBJUkVEXCJdID0gXCJMb2NrRXhwaXJlZFwiO1xuICAgIE1lc3NhZ2VUeXBlW1wiV0lUSERSQVdfUkVRVUVTVFwiXSA9IFwiV2l0aGRyYXdSZXF1ZXN0XCI7XG4gICAgTWVzc2FnZVR5cGVbXCJXSVRIRFJBV19DT05GSVJNQVRJT05cIl0gPSBcIldpdGhkcmF3Q29uZmlybWF0aW9uXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJXSVRIRFJBV19FWFBJUkVEXCJdID0gXCJXaXRoZHJhd0V4cGlyZWRcIjtcbiAgICBNZXNzYWdlVHlwZVtcIlBGU19DQVBBQ0lUWV9VUERBVEVcIl0gPSBcIlBGU0NhcGFjaXR5VXBkYXRlXCI7XG4gICAgTWVzc2FnZVR5cGVbXCJQRlNfRkVFX1VQREFURVwiXSA9IFwiUEZTRmVlVXBkYXRlXCI7XG59KShNZXNzYWdlVHlwZSB8fCAoTWVzc2FnZVR5cGUgPSB7fSkpO1xuLy8gTWl4aW4gb2YgYSBtZXNzYWdlIHRoYXQgY29udGFpbnMgYW4gaWRlbnRpZmllciBhbmQgc2hvdWxkIGJlIGFjaydlZCB3aXRoIGEgcmVzcGVjdGl2ZSBEZWxpdmVyZWRcbmNvbnN0IFJldHJpZWFibGVNZXNzYWdlID0gdC5yZWFkb25seSh0LnR5cGUoeyBtZXNzYWdlX2lkZW50aWZpZXI6IFVJbnQoOCkgfSkpO1xuLy8gQWNrbm93bGVkZ2VzIHRvIHRoZSBzZW5kZXIgdGhhdCBhIFJldHJpZWFibGVNZXNzYWdlIHdhcyByZWNlaXZlZFxuZXhwb3J0IGNvbnN0IERlbGl2ZXJlZCA9IHQucmVhZG9ubHkodC50eXBlKHtcbiAgICB0eXBlOiB0LmxpdGVyYWwoTWVzc2FnZVR5cGUuREVMSVZFUkVEKSxcbiAgICBkZWxpdmVyZWRfbWVzc2FnZV9pZGVudGlmaWVyOiBVSW50KDgpLFxufSkpO1xuLy8gQ29uZmlybXMgc29tZSBtZXNzYWdlIHRoYXQgcmVxdWlyZWQgc3RhdGUgdmFsaWRhdGlvbiB3YXMgc3VjY2Vzc2Z1bHkgcHJvY2Vzc2VkXG5leHBvcnQgY29uc3QgUHJvY2Vzc2VkID0gdC5yZWFkb25seSh0LmludGVyc2VjdGlvbihbXG4gICAgdC50eXBlKHtcbiAgICAgICAgdHlwZTogdC5saXRlcmFsKE1lc3NhZ2VUeXBlLlBST0NFU1NFRCksXG4gICAgfSksXG4gICAgUmV0cmllYWJsZU1lc3NhZ2UsXG5dKSk7XG4vLyBSZXF1ZXN0cyB0aGUgaW5pdGlhdG9yIHRvIHJldmVhbCB0aGUgc2VjcmV0IGZvciBhIExvY2tlZFRyYW5zZmVyIHRhcmdldGVkIHRvIHVzXG5leHBvcnQgY29uc3QgU2VjcmV0UmVxdWVzdCA9IHQucmVhZG9ubHkodC5pbnRlcnNlY3Rpb24oW1xuICAgIHQudHlwZSh7XG4gICAgICAgIHR5cGU6IHQubGl0ZXJhbChNZXNzYWdlVHlwZS5TRUNSRVRfUkVRVUVTVCksXG4gICAgICAgIHBheW1lbnRfaWRlbnRpZmllcjogVUludCg4KSxcbiAgICAgICAgc2VjcmV0aGFzaDogSGFzaCxcbiAgICAgICAgYW1vdW50OiBVSW50KDMyKSxcbiAgICAgICAgZXhwaXJhdGlvbjogVUludCgzMiksXG4gICAgfSksXG4gICAgUmV0cmllYWJsZU1lc3NhZ2UsXG5dKSk7XG4vLyBSZXZlYWwgdG8gdGhlIHRhcmdldCBvciB0aGUgcHJldmlvdXMgaG9wIGEgc2VjcmV0IHdlIGp1c3QgbGVhcm5lZCBvZmYtY2hhaW5cbmV4cG9ydCBjb25zdCBTZWNyZXRSZXZlYWwgPSB0LnJlYWRvbmx5KHQuaW50ZXJzZWN0aW9uKFtcbiAgICB0LnR5cGUoe1xuICAgICAgICB0eXBlOiB0LmxpdGVyYWwoTWVzc2FnZVR5cGUuU0VDUkVUX1JFVkVBTCksXG4gICAgICAgIHNlY3JldDogU2VjcmV0LFxuICAgIH0pLFxuICAgIFJldHJpZWFibGVNZXNzYWdlLFxuXSkpO1xuLy8gTWl4aW4gZm9yIG1lc3NhZ2VzIGNvbnRhaW5pbmcgYSBiYWxhbmNlIHByb29mXG5leHBvcnQgY29uc3QgRW52ZWxvcGVNZXNzYWdlID0gdC5yZWFkb25seSh0LmludGVyc2VjdGlvbihbXG4gICAgdC50eXBlKHtcbiAgICAgICAgY2hhaW5faWQ6IFVJbnQoMzIpLFxuICAgICAgICB0b2tlbl9uZXR3b3JrX2FkZHJlc3M6IEFkZHJlc3MsXG4gICAgICAgIGNoYW5uZWxfaWRlbnRpZmllcjogVUludCgzMiksXG4gICAgICAgIG5vbmNlOiBVSW50KDgpLFxuICAgICAgICB0cmFuc2ZlcnJlZF9hbW91bnQ6IFVJbnQoMzIpLFxuICAgICAgICBsb2NrZWRfYW1vdW50OiBVSW50KDMyKSxcbiAgICAgICAgbG9ja3Nyb290OiBIYXNoLFxuICAgIH0pLFxuICAgIFJldHJpZWFibGVNZXNzYWdlLFxuXSkpO1xuZXhwb3J0IGNvbnN0IFJvdXRlTWV0YWRhdGEgPSB0LnJlYWRvbmx5KHQudHlwZSh7XG4gICAgcm91dGU6IHQucmVhZG9ubHlBcnJheShBZGRyZXNzKSxcbn0pKTtcbmV4cG9ydCBjb25zdCBNZXRhZGF0YSA9IHQucmVhZG9ubHkodC50eXBlKHtcbiAgICByb3V0ZXM6IHQucmVhZG9ubHlBcnJheShSb3V0ZU1ldGFkYXRhKSxcbn0pKTtcbi8vIGJhc2UgZm9yIGxvY2tlZCBhbmQgcmVmdW5kIHRyYW5zZmVyLCB0aGV5IGRpZmZlcmVudGlhdGUgb25seSBvbiB0aGUgdHlwZSB0YWdcbmNvbnN0IExvY2tlZFRyYW5zZmVyQmFzZSA9IHQucmVhZG9ubHkodC5pbnRlcnNlY3Rpb24oW1xuICAgIHQudHlwZSh7XG4gICAgICAgIHBheW1lbnRfaWRlbnRpZmllcjogVUludCg4KSxcbiAgICAgICAgdG9rZW46IEFkZHJlc3MsXG4gICAgICAgIHJlY2lwaWVudDogQWRkcmVzcyxcbiAgICAgICAgbG9jazogTG9jayxcbiAgICAgICAgdGFyZ2V0OiBBZGRyZXNzLFxuICAgICAgICBpbml0aWF0b3I6IEFkZHJlc3MsXG4gICAgICAgIG1ldGFkYXRhOiBNZXRhZGF0YSxcbiAgICB9KSxcbiAgICBFbnZlbG9wZU1lc3NhZ2UsXG5dKSk7XG4vLyBhIG1lZGlhdGVkIHRyYW5zZmVyIGNvbnRhaW5pbmcgYSBsb2NrZWQgYW1vdW50XG5leHBvcnQgY29uc3QgTG9ja2VkVHJhbnNmZXIgPSB0LnJlYWRvbmx5KHQuaW50ZXJzZWN0aW9uKFtcbiAgICB0LnR5cGUoe1xuICAgICAgICB0eXBlOiB0LmxpdGVyYWwoTWVzc2FnZVR5cGUuTE9DS0VEX1RSQU5TRkVSKSxcbiAgICB9KSxcbiAgICBMb2NrZWRUcmFuc2ZlckJhc2UsXG5dKSk7XG4vLyBpZiBhIG1lZGlhdGVkIHRyYW5zZmVyIGRpZG4ndCBzdWNjZWVkLCBtZWRpYXRvciBjYW4gcmVmdW5kIHRoZSBhbW91bnQgd2l0aCB0aGUgc2FtZSBzZWNyZXRoYXNoXG4vLyBzbyB0aGUgcHJldmlvdXMgaG9wIGNhbiByZXRyeSBpdCB3aXRoIGFub3RoZXIgbmVpZ2hib3JcbmV4cG9ydCBjb25zdCBSZWZ1bmRUcmFuc2ZlciA9IHQucmVhZG9ubHkodC5pbnRlcnNlY3Rpb24oW1xuICAgIHQudHlwZSh7XG4gICAgICAgIHR5cGU6IHQubGl0ZXJhbChNZXNzYWdlVHlwZS5SRUZVTkRfVFJBTlNGRVIpLFxuICAgIH0pLFxuICAgIExvY2tlZFRyYW5zZmVyQmFzZSxcbl0pKTtcbi8vIHdoZW4gdGhlIHNlY3JldCBpcyByZXZlYWxlZCwgdW5sb2NrIHNlbmRzIGEgbmV3IGJhbGFuY2UgcHJvb2Ygd2l0aG91dCB0aGUgbG9jayBhbmQgaW5jcmVhc2luZ1xuLy8gdGhlIHRvdGFsIHRyYW5zZmVyZWQgdG8gZmluaXNoIHRoZSBvZmZjaGFpbiB0cmFuc2ZlclxuZXhwb3J0IGNvbnN0IFVubG9jayA9IHQucmVhZG9ubHkodC5pbnRlcnNlY3Rpb24oW1xuICAgIHQudHlwZSh7XG4gICAgICAgIHR5cGU6IHQubGl0ZXJhbChNZXNzYWdlVHlwZS5VTkxPQ0spLFxuICAgICAgICBwYXltZW50X2lkZW50aWZpZXI6IFVJbnQoOCksXG4gICAgICAgIHNlY3JldDogU2VjcmV0LFxuICAgIH0pLFxuICAgIEVudmVsb3BlTWVzc2FnZSxcbl0pKTtcbi8vIGFmdGVyIG1lZGlhdGVkIHRyYW5zZmVyIGZhaWxzIGFuZCB0aGUgbG9jayBleHBpcmUsIGNsZWFuIGl0IGZyb20gdGhlIGxvY2tzIHRyZWVcbmV4cG9ydCBjb25zdCBMb2NrRXhwaXJlZCA9IHQucmVhZG9ubHkodC5pbnRlcnNlY3Rpb24oW1xuICAgIHQudHlwZSh7XG4gICAgICAgIHR5cGU6IHQubGl0ZXJhbChNZXNzYWdlVHlwZS5MT0NLX0VYUElSRUQpLFxuICAgICAgICByZWNpcGllbnQ6IEFkZHJlc3MsXG4gICAgICAgIHNlY3JldGhhc2g6IEhhc2gsXG4gICAgfSksXG4gICAgRW52ZWxvcGVNZXNzYWdlLFxuXSkpO1xuZXhwb3J0IGNvbnN0IFdpdGhkcmF3QmFzZSA9IHQucmVhZG9ubHkodC50eXBlKHtcbiAgICBjaGFpbl9pZDogVUludCgzMiksXG4gICAgdG9rZW5fbmV0d29ya19hZGRyZXNzOiBBZGRyZXNzLFxuICAgIGNoYW5uZWxfaWRlbnRpZmllcjogVUludCgzMiksXG4gICAgcGFydGljaXBhbnQ6IEFkZHJlc3MsXG4gICAgdG90YWxfd2l0aGRyYXc6IFVJbnQoMzIpLFxuICAgIG5vbmNlOiBVSW50KDgpLFxuICAgIGV4cGlyYXRpb246IFVJbnQoMzIpLFxufSkpO1xuZXhwb3J0IGNvbnN0IFdpdGhkcmF3UmVxdWVzdCA9IHQucmVhZG9ubHkodC5pbnRlcnNlY3Rpb24oW1xuICAgIHQudHlwZSh7XG4gICAgICAgIHR5cGU6IHQubGl0ZXJhbChNZXNzYWdlVHlwZS5XSVRIRFJBV19SRVFVRVNUKSxcbiAgICB9KSxcbiAgICBXaXRoZHJhd0Jhc2UsXG4gICAgUmV0cmllYWJsZU1lc3NhZ2UsXG5dKSk7XG5leHBvcnQgY29uc3QgV2l0aGRyYXdDb25maXJtYXRpb24gPSB0LnJlYWRvbmx5KHQuaW50ZXJzZWN0aW9uKFtcbiAgICB0LnR5cGUoe1xuICAgICAgICB0eXBlOiB0LmxpdGVyYWwoTWVzc2FnZVR5cGUuV0lUSERSQVdfQ09ORklSTUFUSU9OKSxcbiAgICB9KSxcbiAgICBXaXRoZHJhd0Jhc2UsXG4gICAgUmV0cmllYWJsZU1lc3NhZ2UsXG5dKSk7XG5leHBvcnQgY29uc3QgV2l0aGRyYXdFeHBpcmVkID0gdC5yZWFkb25seSh0LmludGVyc2VjdGlvbihbXG4gICAgdC50eXBlKHtcbiAgICAgICAgdHlwZTogdC5saXRlcmFsKE1lc3NhZ2VUeXBlLldJVEhEUkFXX0VYUElSRUQpLFxuICAgIH0pLFxuICAgIFdpdGhkcmF3QmFzZSxcbiAgICBSZXRyaWVhYmxlTWVzc2FnZSxcbl0pKTtcbmV4cG9ydCBjb25zdCBQRlNDYXBhY2l0eVVwZGF0ZSA9IHQucmVhZG9ubHkodC50eXBlKHtcbiAgICB0eXBlOiB0LmxpdGVyYWwoTWVzc2FnZVR5cGUuUEZTX0NBUEFDSVRZX1VQREFURSksXG4gICAgY2Fub25pY2FsX2lkZW50aWZpZXI6IHQucmVhZG9ubHkodC50eXBlKHtcbiAgICAgICAgY2hhaW5faWRlbnRpZmllcjogVUludCgzMiksXG4gICAgICAgIHRva2VuX25ldHdvcmtfYWRkcmVzczogQWRkcmVzcyxcbiAgICAgICAgY2hhbm5lbF9pZGVudGlmaWVyOiBVSW50KDMyKSxcbiAgICB9KSksXG4gICAgdXBkYXRpbmdfcGFydGljaXBhbnQ6IEFkZHJlc3MsXG4gICAgb3RoZXJfcGFydGljaXBhbnQ6IEFkZHJlc3MsXG4gICAgdXBkYXRpbmdfbm9uY2U6IFVJbnQoOCksXG4gICAgb3RoZXJfbm9uY2U6IFVJbnQoOCksXG4gICAgdXBkYXRpbmdfY2FwYWNpdHk6IFVJbnQoMzIpLFxuICAgIG90aGVyX2NhcGFjaXR5OiBVSW50KDMyKSxcbiAgICByZXZlYWxfdGltZW91dDogVUludCgzMiksXG59KSk7XG5leHBvcnQgY29uc3QgUEZTRmVlVXBkYXRlID0gdC5yZWFkb25seSh0LnR5cGUoe1xuICAgIHR5cGU6IHQubGl0ZXJhbChNZXNzYWdlVHlwZS5QRlNfRkVFX1VQREFURSksXG4gICAgY2Fub25pY2FsX2lkZW50aWZpZXI6IHQucmVhZG9ubHkodC50eXBlKHtcbiAgICAgICAgY2hhaW5faWRlbnRpZmllcjogVUludCgzMiksXG4gICAgICAgIHRva2VuX25ldHdvcmtfYWRkcmVzczogQWRkcmVzcyxcbiAgICAgICAgY2hhbm5lbF9pZGVudGlmaWVyOiBVSW50KDMyKSxcbiAgICB9KSksXG4gICAgdXBkYXRpbmdfcGFydGljaXBhbnQ6IEFkZHJlc3MsXG4gICAgdGltZXN0YW1wOiB0LnN0cmluZyxcbiAgICBmZWVfc2NoZWR1bGU6IHQudHlwZSh7XG4gICAgICAgIGNhcF9mZWVzOiB0LmJvb2xlYW4sXG4gICAgICAgIC8vIGlmIG5vdCBudWxsLCBpdCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgW3Rva2VuQW1vdW50LCBmZWVdIHR1cGxlc1xuICAgICAgICBpbWJhbGFuY2VfcGVuYWx0eTogdC51bmlvbihbdC5udWxsLCB0LmFycmF5KHQudHVwbGUoW1VJbnQoMzIpLCBJbnQoMzIpXSkpXSksXG4gICAgICAgIHByb3BvcnRpb25hbDogSW50KDMyKSxcbiAgICAgICAgZmxhdDogSW50KDMyKSxcbiAgICB9KSxcbn0pKTtcbmV4cG9ydCBjb25zdCBNZXNzYWdlID0gdC51bmlvbihbXG4gICAgRGVsaXZlcmVkLFxuICAgIFByb2Nlc3NlZCxcbiAgICBTZWNyZXRSZXF1ZXN0LFxuICAgIFNlY3JldFJldmVhbCxcbiAgICBMb2NrZWRUcmFuc2ZlcixcbiAgICBSZWZ1bmRUcmFuc2ZlcixcbiAgICBVbmxvY2ssXG4gICAgTG9ja0V4cGlyZWQsXG4gICAgV2l0aGRyYXdSZXF1ZXN0LFxuICAgIFdpdGhkcmF3Q29uZmlybWF0aW9uLFxuICAgIFdpdGhkcmF3RXhwaXJlZCxcbiAgICBQRlNDYXBhY2l0eVVwZGF0ZSxcbiAgICBQRlNGZWVVcGRhdGUsXG5dKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1uYW1lc3BhY2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9jbGFzcy1uYW1lLWNhc2luZyAqL1xuaW1wb3J0ICogYXMgdCBmcm9tICdpby10cyc7XG5pbXBvcnQgeyBjcmVhdGVBY3Rpb24sIGNyZWF0ZUFzeW5jQWN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvYWN0aW9ucyc7XG5pbXBvcnQgeyBBZGRyZXNzLCBTaWduZWQgfSBmcm9tICcuLi91dGlscy90eXBlcyc7XG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSAnLi90eXBlcyc7XG4vKiogT25lLXNob3Qgc2VuZCBwYXlsb2FkLm1lc3NhZ2UgdG8gbWV0YS5hZGRyZXNzIHVzZXIgaW4gdHJhbnNwb3J0ICovXG5leHBvcnQgY29uc3QgbWVzc2FnZVNlbmQgPSBjcmVhdGVBc3luY0FjdGlvbih0LnR5cGUoeyBhZGRyZXNzOiBBZGRyZXNzLCBtc2dJZDogdC5zdHJpbmcgfSksICdtZXNzYWdlL3NlbmQvcmVxdWVzdCcsICdtZXNzYWdlL3NlbmQvc3VjY2VzcycsICdtZXNzYWdlL3NlbmQvZmFpbHVyZScsIHQudHlwZSh7IG1lc3NhZ2U6IHQudW5pb24oW3Quc3RyaW5nLCBTaWduZWQoTWVzc2FnZSldKSB9KSwgdW5kZWZpbmVkKTtcbi8qKiBPbmUtc2hvdCBzZW5kIHBheWxvYWQubWVzc2FnZSB0byBhIGdsb2JhbCByb29tIGluIHRyYW5zcG9ydCAqL1xuZXhwb3J0IGNvbnN0IG1lc3NhZ2VHbG9iYWxTZW5kID0gY3JlYXRlQWN0aW9uKCdtZXNzYWdlR2xvYmFsU2VuZCcsIHQudHlwZSh7IG1lc3NhZ2U6IHQudW5pb24oW3Quc3RyaW5nLCBTaWduZWQoTWVzc2FnZSldKSB9KSwgdC50eXBlKHsgcm9vbU5hbWU6IHQuc3RyaW5nIH0pKTtcbi8qKlxuICogcGF5bG9hZC5tZXNzYWdlIHdhcyByZWNlaXZlZCBvbiBwYXlsb2FkLnRzICh0aW1lc3RhbXApIGZyb20gbWV0YS5hZGRyZXNzXG4gKiBwYXlsb2FkLnVzZXJJZCBhbmQgcGF5bG9hZC5yb29tSWQgYXJlIG9wdGlvbmFsIGFuZCBzcGVjaWZpYyB0byBtYXRyaXggdHJhbnNwb3J0LCBhcyBzZW5kZXIgaW5mb1xuICovXG5leHBvcnQgY29uc3QgbWVzc2FnZVJlY2VpdmVkID0gY3JlYXRlQWN0aW9uKCdtZXNzYWdlUmVjZWl2ZWQnLCB0LmludGVyc2VjdGlvbihbXG4gICAgdC50eXBlKHtcbiAgICAgICAgdGV4dDogdC5zdHJpbmcsXG4gICAgICAgIHRzOiB0Lm51bWJlcixcbiAgICB9KSxcbiAgICB0LnBhcnRpYWwoe1xuICAgICAgICBtZXNzYWdlOiB0LnVuaW9uKFtNZXNzYWdlLCBTaWduZWQoTWVzc2FnZSldKSxcbiAgICAgICAgdXNlcklkOiB0LnN0cmluZyxcbiAgICAgICAgcm9vbUlkOiB0LnN0cmluZyxcbiAgICB9KSxcbl0pLCB0LnR5cGUoeyBhZGRyZXNzOiBBZGRyZXNzIH0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGlvbnMuanMubWFwIiwiaW1wb3J0ICogYXMgdCBmcm9tICdpby10cyc7XG5pbXBvcnQgeyBBZGRyZXNzLCBJbnQsIFNpZ25lZCwgVUludCB9IGZyb20gJy4uL3V0aWxzL3R5cGVzJztcbi8qKlxuICogQ29kZWMgZm9yIFBGUyBBUEkgcmV0dXJuZWQgZGF0YVxuICovXG5leHBvcnQgY29uc3QgUGF0aFJlc3VsdHMgPSB0LnJlYWRvbmx5KHQuaW50ZXJzZWN0aW9uKFtcbiAgICB0LnR5cGUoe1xuICAgICAgICByZXN1bHQ6IHQuYXJyYXkodC5yZWFkb25seSh0LnR5cGUoe1xuICAgICAgICAgICAgcGF0aDogdC5yZWFkb25seUFycmF5KEFkZHJlc3MpLFxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jYW1lbGNhc2UgKi9cbiAgICAgICAgICAgIGVzdGltYXRlZF9mZWU6IEludCgzMiksXG4gICAgICAgIH0pKSksXG4gICAgfSksXG4gICAgdC5wYXJ0aWFsKHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jYW1lbGNhc2UgKi9cbiAgICAgICAgZmVlZGJhY2tfdG9rZW46IHQuc3RyaW5nLFxuICAgIH0pLFxuXSkpO1xuLyoqXG4gKiBDb2RlYyBmb3IgcmFpZGVuLXRzIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgUEZTIHJlc3VsdC9yb3V0ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IFBhdGhzID0gdC5hcnJheSh0LnJlYWRvbmx5KHQudHlwZSh7XG4gICAgcGF0aDogdC5yZWFkb25seUFycmF5KEFkZHJlc3MpLFxuICAgIGZlZTogSW50KDMyKSxcbn0pKSk7XG4vKipcbiAqIEEgUEZTIHNlcnZlci9zZXJ2aWNlIGluc3RhbmNlIGluZm9cbiAqL1xuZXhwb3J0IGNvbnN0IFBGUyA9IHQucmVhZG9ubHkodC50eXBlKHtcbiAgICBhZGRyZXNzOiBBZGRyZXNzLFxuICAgIHVybDogdC5zdHJpbmcsXG4gICAgcnR0OiB0Lm51bWJlcixcbiAgICBwcmljZTogVUludCgzMiksXG4gICAgdG9rZW46IEFkZHJlc3MsXG59KSk7XG4vKipcbiAqIEFuIElPVSB1c2VkIHRvIHBheSB0aGUgc2VydmljZXNcbiAqL1xuZXhwb3J0IGNvbnN0IElPVSA9IHQucmVhZG9ubHkodC50eXBlKHtcbiAgICBzZW5kZXI6IEFkZHJlc3MsXG4gICAgcmVjZWl2ZXI6IEFkZHJlc3MsXG4gICAgYW1vdW50OiBVSW50KDMyKSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NhbWVsY2FzZVxuICAgIGV4cGlyYXRpb25fYmxvY2s6IFVJbnQoMzIpLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2FtZWxjYXNlXG4gICAgb25lX3RvX25fYWRkcmVzczogQWRkcmVzcyxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NhbWVsY2FzZVxuICAgIGNoYWluX2lkOiBVSW50KDMyKSxcbn0pKTtcbmV4cG9ydCBjb25zdCBMYXN0SU9VUmVzdWx0cyA9IHQucmVhZG9ubHkodC50eXBlKHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NhbWVsY2FzZVxuICAgIGxhc3RfaW91OiBTaWduZWQoSU9VKSxcbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1uYW1lc3BhY2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9jbGFzcy1uYW1lLWNhc2luZyAqL1xuaW1wb3J0ICogYXMgdCBmcm9tICdpby10cyc7XG5pbXBvcnQgeyBBZGRyZXNzLCBVSW50LCBJbnQsIFNlY3JldCwgSGFzaCwgU2lnbmVkIH0gZnJvbSAnLi4vdXRpbHMvdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlQWN0aW9uLCBjcmVhdGVBc3luY0FjdGlvbiB9IGZyb20gJy4uL3V0aWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgU2lnbmVkQmFsYW5jZVByb29mIH0gZnJvbSAnLi4vY2hhbm5lbHMvdHlwZXMnO1xuaW1wb3J0IHsgTG9ja2VkVHJhbnNmZXIsIFByb2Nlc3NlZCwgU2VjcmV0UmVxdWVzdCwgU2VjcmV0UmV2ZWFsLCBVbmxvY2ssIExvY2tFeHBpcmVkLCBSZWZ1bmRUcmFuc2ZlciwgV2l0aGRyYXdSZXF1ZXN0LCBXaXRoZHJhd0NvbmZpcm1hdGlvbiwgfSBmcm9tICcuLi9tZXNzYWdlcy90eXBlcyc7XG5pbXBvcnQgeyBQYXRocyB9IGZyb20gJy4uL3BhdGgvdHlwZXMnO1xuY29uc3QgVHJhbnNmZXJJZCA9IHQudHlwZSh7XG4gICAgc2VjcmV0aGFzaDogSGFzaCxcbiAgICBkaXJlY3Rpb246IHQua2V5b2YoeyBzZW50OiBudWxsLCByZWNlaXZlZDogbnVsbCB9KSxcbn0pO1xuLyoqXG4gKiBBIHRyYW5zZmVyIGFzeW5jIGFjdGlvbiBzZXRcbiAqXG4gKiBBIHRyYW5zZmVyIGlzIGNvbnNpZGVyZWQgYXMgaGF2aW5nIHN1Y2NlZWRlZCBmcm9tIHRoZSB0aW1lIHRoZSBzZWNyZXQgaXMgcmV2ZWFsZWQgdG8gdGhlIHRhcmdldCxcbiAqIGFzIGZyb20gdGhlcmUsIHRhcmdldCBhbmQgbWVkaWF0b3JzIGNhbiBjbGFpbSB0aGUgcGF5bWVudCBkb3duIHRvIHVzLiBCdXQgdGhlIGZ1bGwgb2ZmLWNoYWluXG4gKiBoYXBweSBjYXNlIGNvbXBsZXRlcyBvbmx5IGFmdGVyIHBhcnRuZXIvbmVpZ2hib3IgYWNrbm93bGVkZ2VzIHJlY2VpdmluZyB0aGUgVW5sb2NrLlxuICogU28sIHdlIHVzdWFsbHkgb25seSBlbWl0cyB0aGlzIGFjdGlvbiBpbiB0aGUgZW5kIG9mIHRoZSBoYXBweSBjYXNlLCBhbmQgaXQnbGwgdGhlbiBjb250YWluIHRoZVxuICogdW5sb2NrJ3MgYmFsYW5jZVByb29mLCB3aGljaCBpbmRpY2F0ZXMgdGhlIGZ1bGwgb2ZmLWNoYWluIHBhdGggc3VjY2VlZGVkLlxuICogSXQnbGwgYmUgZW1pdHRlZCB3aXRob3V0IGEgYmFsYW5jZVByb29mIGlmIHNvbWV0aGluZyBmb3JjZXMgdGhlIHRyYW5zZmVyIHRvIGNvbXBsZXRlXG4gKiAoZS5nLiAgY2hhbm5lbCBjbG9zZWQpLCB0aGUgc2VjcmV0IHdhcyByZXZlYWxlZCAoc28gdGFyZ2V0IHdhcyBwYWlkKSBidXQgZm9yIGFueSByZWFzb24gdGhlXG4gKiB1bmxvY2sgZGlkbid0IGhhcHBlbiB5ZXQuXG4gKlxuICogdHJhbnNmZXIuZmFpbHVyZSBpcyBlbWl0dGVkIGFzIHNvb24gYXMgd2Uga25vdyB0aGUgdHJhbnNmZXIgZmFpbGVkIGRlZmluaXRlbHksIGxpa2Ugd2hlbiBhXG4gKiBSZWZ1bmRUcmFuc2ZlciBpcyByZWNlaXZlZCBvciB0aGUgbG9jayBleHBpcmVzIGJlZm9yZSByZXZlYWxpbmcgdGhlIHNlY3JldC4gSXQgbm90aWZpZXMgdGhlIHVzZXJcbiAqIChlLmcuIHBlbmRpbmcgUHJvbWlzZXMpIHRoYXQgdGhlIHRyYW5zZmVyIGZhaWxlZCBhbmQgd29uJ3QgYmUgcGFpZCAoZXZlbnR1YWxseSwgbG9ja2VkIGFtb3VudFxuICogd2lsbCBiZSByZWNvdmVyZWQgYnkgZXhwaXJpbmcgdGhlIGxvY2spLlxuICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXIgPSBjcmVhdGVBc3luY0FjdGlvbihUcmFuc2ZlcklkLCAndHJhbnNmZXIvcmVxdWVzdCcsICd0cmFuc2Zlci9zdWNjZXNzJywgJ3RyYW5zZmVyL2ZhaWx1cmUnLCB0LmludGVyc2VjdGlvbihbXG4gICAgdC50eXBlKHtcbiAgICAgICAgdG9rZW5OZXR3b3JrOiBBZGRyZXNzLFxuICAgICAgICB0YXJnZXQ6IEFkZHJlc3MsXG4gICAgICAgIHZhbHVlOiBVSW50KDMyKSxcbiAgICAgICAgcGF0aHM6IFBhdGhzLFxuICAgICAgICBwYXltZW50SWQ6IFVJbnQoOCksXG4gICAgfSksXG4gICAgdC5wYXJ0aWFsKHtcbiAgICAgICAgc2VjcmV0OiBTZWNyZXQsXG4gICAgICAgIGV4cGlyYXRpb246IHQubnVtYmVyLFxuICAgICAgICBpbml0aWF0b3I6IEFkZHJlc3MsXG4gICAgfSksXG5dKSwgdC5wYXJ0aWFsKHsgYmFsYW5jZVByb29mOiBTaWduZWRCYWxhbmNlUHJvb2YgfSkpO1xuLyoqIEEgTG9ja2VkVHJhbnNmZXIgd2FzIHNpZ25lZCBhbmQgc2hvdWxkIGJlIHNlbnQgdG8gcGFydG5lciAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zZmVyU2lnbmVkID0gY3JlYXRlQWN0aW9uKCd0cmFuc2ZlclNpZ25lZCcsIHQudHlwZSh7IG1lc3NhZ2U6IFNpZ25lZChMb2NrZWRUcmFuc2ZlciksIGZlZTogSW50KDMyKSB9KSwgVHJhbnNmZXJJZCk7XG4vKiogUGFydG5lciBhY2tub3dsZWRnZSB0aGV5IHJlY2VpdmVkIGFuZCBwcm9jZXNzZWQgb3VyIExvY2tlZFRyYW5zZmVyICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXJQcm9jZXNzZWQgPSBjcmVhdGVBY3Rpb24oJ3RyYW5zZmVyUHJvY2Vzc2VkJywgdC50eXBlKHsgbWVzc2FnZTogU2lnbmVkKFByb2Nlc3NlZCkgfSksIFRyYW5zZmVySWQpO1xuLyoqIFJlZ2lzdGVyIGEgc2VjcmV0ICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXJTZWNyZXQgPSBjcmVhdGVBY3Rpb24oJ3RyYW5zZmVyU2VjcmV0JywgdC50eXBlKHsgc2VjcmV0OiBTZWNyZXQgfSksIFRyYW5zZmVySWQpO1xuZXhwb3J0IGNvbnN0IHRyYW5zZmVyU2VjcmV0UmVnaXN0ZXIgPSBjcmVhdGVBc3luY0FjdGlvbihUcmFuc2ZlcklkLCAndHJhbnNmZXJTZWNyZXQvcmVnaXN0ZXIvcmVxdWVzdCcsICd0cmFuc2ZlclNlY3JldC9yZWdpc3Rlci9zdWNjZXNzJywgJ3RyYW5zZmVyU2VjcmV0L3JlZ2lzdGVyL2ZhaWx1cmUnLCB0LmludGVyc2VjdGlvbihbdC50eXBlKHsgc2VjcmV0OiBTZWNyZXQgfSksIHQucGFydGlhbCh7IHN1YmtleTogdC5ib29sZWFuIH0pXSksIHQudHlwZSh7XG4gICAgc2VjcmV0OiBTZWNyZXQsXG4gICAgdHhIYXNoOiBIYXNoLFxuICAgIHR4QmxvY2s6IHQubnVtYmVyLFxuICAgIC8vIENvbmZpcm1hYmxlQWN0aW9uXG4gICAgY29uZmlybWVkOiB0LnVuaW9uKFt0LnVuZGVmaW5lZCwgdC5ib29sZWFuXSksXG59KSk7XG4vKiogQSB2YWxpZCBTZWNyZXRSZXF1ZXN0IHJlY2VpdmVkIGZyb20gdGFyZ2V0ICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXJTZWNyZXRSZXF1ZXN0ID0gY3JlYXRlQWN0aW9uKCd0cmFuc2ZlclNlY3JldFJlcXVlc3QnLCB0LnR5cGUoeyBtZXNzYWdlOiBTaWduZWQoU2VjcmV0UmVxdWVzdCkgfSksIFRyYW5zZmVySWQpO1xuLyoqIEEgU2VjcmV0UmV2ZWFsIHNlbnQgdG8gdGFyZ2V0ICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXJTZWNyZXRSZXZlYWwgPSBjcmVhdGVBY3Rpb24oJ3RyYW5zZmVyU2VjcmV0UmV2ZWFsJywgdC50eXBlKHsgbWVzc2FnZTogU2lnbmVkKFNlY3JldFJldmVhbCkgfSksIFRyYW5zZmVySWQpO1xuZXhwb3J0IGNvbnN0IHRyYW5zZmVyVW5sb2NrID0gY3JlYXRlQXN5bmNBY3Rpb24oVHJhbnNmZXJJZCwgJ3RyYW5zZmVyL3VubG9jay9yZXF1ZXN0JywgJ3RyYW5zZmVyL3VubG9jay9zdWNjZXNzJywgJ3RyYW5zZmVyL3VubG9jay9mYWlsdXJlJywgdW5kZWZpbmVkLCB0LnR5cGUoeyBtZXNzYWdlOiBTaWduZWQoVW5sb2NrKSB9KSk7XG4vKiogUGFydG5lciBhY2tub3dsZWRnZSB0aGV5IHJlY2VpdmVkIGFuZCBwcm9jZXNzZWQgb3VyIFVubG9jayAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zZmVyVW5sb2NrUHJvY2Vzc2VkID0gY3JlYXRlQWN0aW9uKCd0cmFuc2ZlclVubG9ja1Byb2Nlc3NlZCcsIHQudHlwZSh7IG1lc3NhZ2U6IFNpZ25lZChQcm9jZXNzZWQpIH0pLCBUcmFuc2ZlcklkKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGV4cGlyZSBhIGdpdmVuIHRyYW5zZmVyXG4gKlxuICogQSB0cmFuc2ZlciBleHBpcmF0aW9uIHJlcXVlc3QgbWF5IGZhaWwgZm9yIGFueSByZWFzb25cbiAqIGUuZy4gdXNlciByZWplY3RlZCBzaWduIHByb21vcHQuIEl0IHNob3VsZCBldmVudHVhbGx5IGdldCBwcm9tcHRlZCBhZ2Fpbiwgb24gYSBmdXR1cmUgbmV3QmxvY2tcbiAqIGFjdGlvbiB3aGljaCBzZWVzIHRoaXMgdHJhbnNmZXIgc2hvdWxkIGJlIGV4cGlyZWQgYnV0IHNlbnQubG9ja0V4cGlyZWQgZGlkbid0IGdldCBzZXQgeWV0LlxuICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXJFeHBpcmUgPSBjcmVhdGVBc3luY0FjdGlvbihUcmFuc2ZlcklkLCAndHJhbnNmZXIvZXhwaXJlL3JlcXVlc3QnLCAndHJhbnNmZXIvZXhwaXJlL3N1Y2Nlc3MnLCAndHJhbnNmZXIvZXhwaXJlL2ZhaWx1cmUnLCB1bmRlZmluZWQsIHQudHlwZSh7IG1lc3NhZ2U6IFNpZ25lZChMb2NrRXhwaXJlZCkgfSkpO1xuLyoqIFBhcnRuZXIgYWNrbm93bGVkZ2UgdGhleSByZWNlaXZlZCBhbmQgcHJvY2Vzc2VkIG91ciBMb2NrRXhwaXJlZCAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zZmVyRXhwaXJlUHJvY2Vzc2VkID0gY3JlYXRlQWN0aW9uKCd0cmFuc2ZlckV4cGlyZVByb2Nlc3NlZCcsIHQudHlwZSh7IG1lc3NhZ2U6IFNpZ25lZChQcm9jZXNzZWQpIH0pLCBUcmFuc2ZlcklkKTtcbi8qKiBBIHRyYW5zZmVyIHdhcyByZWZ1bmRlZCAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zZmVyUmVmdW5kZWQgPSBjcmVhdGVBY3Rpb24oJ3RyYW5zZmVyUmVmdW5kZWQnLCB0LnR5cGUoeyBtZXNzYWdlOiBTaWduZWQoUmVmdW5kVHJhbnNmZXIpIH0pLCBUcmFuc2ZlcklkKTtcbi8qKiBBIHBlbmRpbmcgdHJhbnNmZXIgaXNuJ3QgbmVlZGVkIGFueW1vcmUgYW5kIHNob3VsZCBiZSBjbGVhcmVkIGZyb20gc3RhdGUgKi9cbmV4cG9ydCBjb25zdCB0cmFuc2ZlckNsZWFyID0gY3JlYXRlQWN0aW9uKCd0cmFuc2ZlckNsZWFyJywgdW5kZWZpbmVkLCBUcmFuc2ZlcklkKTtcbi8vIFdpdGhkcmF3IGFjdGlvbnNcbmNvbnN0IFdpdGhkcmF3SWQgPSB0LnR5cGUoe1xuICAgIHRva2VuTmV0d29yazogQWRkcmVzcyxcbiAgICBwYXJ0bmVyOiBBZGRyZXNzLFxuICAgIHRvdGFsV2l0aGRyYXc6IFVJbnQoMzIpLFxuICAgIGV4cGlyYXRpb246IHQubnVtYmVyLFxufSk7XG4vKiogQSBXaXRoZHJhd1JlcXVlc3Qgd2FzIHJlY2VpdmVkIGZyb20gcGFydG5lciAqL1xuZXhwb3J0IGNvbnN0IHdpdGhkcmF3UmVjZWl2ZSA9IGNyZWF0ZUFzeW5jQWN0aW9uKFdpdGhkcmF3SWQsICd3aXRoZHJhdy9yZWNlaXZlL3JlcXVlc3QnLCAnd2l0aGRyYXcvcmVjZWl2ZS9zdWNjZXNzJywgJ3dpdGhkcmF3L3JlY2VpdmUvZmFpbHVyZScsIHQudHlwZSh7IG1lc3NhZ2U6IFNpZ25lZChXaXRoZHJhd1JlcXVlc3QpIH0pLCB0LnR5cGUoeyBtZXNzYWdlOiBTaWduZWQoV2l0aGRyYXdDb25maXJtYXRpb24pIH0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGlvbnMuanMubWFwIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5hbWVzcGFjZSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2NsYXNzLW5hbWUtY2FzaW5nICovXG5pbXBvcnQgKiBhcyB0IGZyb20gJ2lvLXRzJztcbmltcG9ydCB7IGNyZWF0ZUFjdGlvbiwgY3JlYXRlQXN5bmNBY3Rpb24gfSBmcm9tICcuLi91dGlscy9hY3Rpb25zJztcbmltcG9ydCB7IEFkZHJlc3MsIFVJbnQsIFNpZ25lZCB9IGZyb20gJy4uL3V0aWxzL3R5cGVzJztcbmltcG9ydCB7IFBhdGhzLCBQRlMsIElPVSB9IGZyb20gJy4vdHlwZXMnO1xuY29uc3QgUGF0aElkID0gdC50eXBlKHtcbiAgICB0b2tlbk5ldHdvcms6IEFkZHJlc3MsXG4gICAgdGFyZ2V0OiBBZGRyZXNzLFxuICAgIHZhbHVlOiBVSW50KDMyKSxcbn0pO1xuY29uc3QgU2VydmljZUlkID0gdC50eXBlKHtcbiAgICB0b2tlbk5ldHdvcms6IEFkZHJlc3MsXG4gICAgc2VydmljZUFkZHJlc3M6IEFkZHJlc3MsXG59KTtcbmV4cG9ydCBjb25zdCBwYXRoRmluZCA9IGNyZWF0ZUFzeW5jQWN0aW9uKFBhdGhJZCwgJ3BhdGgvZmluZC9yZXF1ZXN0JywgJ3BhdGgvZmluZC9zdWNjZXNzJywgJ3BhdGgvZmluZC9mYWlsdXJlJywgdC5wYXJ0aWFsKHsgcGF0aHM6IFBhdGhzLCBwZnM6IHQudW5pb24oW1BGUywgdC5udWxsXSkgfSksIHQudHlwZSh7IHBhdGhzOiBQYXRocyB9KSk7XG5leHBvcnQgY29uc3QgcGZzTGlzdFVwZGF0ZWQgPSBjcmVhdGVBY3Rpb24oJ3Bmc0xpc3RVcGRhdGVkJywgdC50eXBlKHsgcGZzTGlzdDogdC5yZWFkb25seUFycmF5KEFkZHJlc3MpIH0pKTtcbmV4cG9ydCBjb25zdCBpb3VQZXJzaXN0ID0gY3JlYXRlQWN0aW9uKCdpb3VQZXJzaXN0JywgdC50eXBlKHsgaW91OiBTaWduZWQoSU9VKSB9KSwgU2VydmljZUlkKTtcbmV4cG9ydCBjb25zdCBpb3VDbGVhciA9IGNyZWF0ZUFjdGlvbignaW91Q2xlYXInLCB1bmRlZmluZWQsIFNlcnZpY2VJZCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3Rpb25zLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9jbGFzcy1uYW1lLWNhc2luZyAqL1xuLyoqXG4gKiBBZ2dyZWdhdGUgdHlwZXMgYW5kIGV4cG9ydGVkIHByb3BlcnRpZXMgZnJvbSBhY3Rpb25zIGZyb20gYWxsIG1vZHVsZXNcbiAqL1xuaW1wb3J0ICogYXMgdCBmcm9tICdpby10cyc7XG5pbXBvcnQgeyBTaHV0ZG93blJlYXNvbiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IFBhcnRpYWxSYWlkZW5Db25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBjcmVhdGVBY3Rpb24gfSBmcm9tICcuL3V0aWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgRXJyb3JDb2RlYyB9IGZyb20gJy4vdXRpbHMvZXJyb3InO1xuaW1wb3J0ICogYXMgQ2hhbm5lbHNBY3Rpb25zIGZyb20gJy4vY2hhbm5lbHMvYWN0aW9ucyc7XG5pbXBvcnQgKiBhcyBUcmFuc3BvcnRBY3Rpb25zIGZyb20gJy4vdHJhbnNwb3J0L2FjdGlvbnMnO1xuaW1wb3J0ICogYXMgTWVzc2FnZXNBY3Rpb25zIGZyb20gJy4vbWVzc2FnZXMvYWN0aW9ucyc7XG5pbXBvcnQgKiBhcyBUcmFuc2ZlcnNBY3Rpb25zIGZyb20gJy4vdHJhbnNmZXJzL2FjdGlvbnMnO1xuaW1wb3J0ICogYXMgUGF0aEZpbmRBY3Rpb25zIGZyb20gJy4vcGF0aC9hY3Rpb25zJztcbmV4cG9ydCBjb25zdCByYWlkZW5TaHV0ZG93biA9IGNyZWF0ZUFjdGlvbigncmFpZGVuU2h1dGRvd24nLCB0LnR5cGUoe1xuICAgIHJlYXNvbjogdC51bmlvbihbXG4gICAgICAgIHQubGl0ZXJhbChTaHV0ZG93blJlYXNvbi5TVE9QKSxcbiAgICAgICAgdC5saXRlcmFsKFNodXRkb3duUmVhc29uLkFDQ09VTlRfQ0hBTkdFRCksXG4gICAgICAgIHQubGl0ZXJhbChTaHV0ZG93blJlYXNvbi5ORVRXT1JLX0NIQU5HRUQpLFxuICAgICAgICBFcnJvckNvZGVjLFxuICAgIF0pLFxufSkpO1xuZXhwb3J0IGNvbnN0IHJhaWRlbkNvbmZpZ1VwZGF0ZSA9IGNyZWF0ZUFjdGlvbigncmFpZGVuQ29uZmlnVXBkYXRlJywgUGFydGlhbFJhaWRlbkNvbmZpZyk7XG5jb25zdCBSYWlkZW5BY3Rpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgcmFpZGVuU2h1dGRvd24sXG4gICAgcmFpZGVuQ29uZmlnVXBkYXRlIH0sIENoYW5uZWxzQWN0aW9ucyksIFRyYW5zcG9ydEFjdGlvbnMpLCBNZXNzYWdlc0FjdGlvbnMpLCBUcmFuc2ZlcnNBY3Rpb25zKSwgUGF0aEZpbmRBY3Rpb25zKTtcbi8qIE1hcHBpbmcgeyBbdHlwZTogc3RyaW5nXTogQWN0aW9uIH0gb2YgYSBzdWJzZXQgb2YgUmFpZGVuQWN0aW9ucyBleHBvc2VkIGFzIGV2ZW50cyAqL1xuZXhwb3J0IGNvbnN0IFJhaWRlbkV2ZW50cyA9IFtcbiAgICBSYWlkZW5BY3Rpb25zLnJhaWRlblNodXRkb3duLFxuICAgIFJhaWRlbkFjdGlvbnMubmV3QmxvY2ssXG4gICAgUmFpZGVuQWN0aW9ucy5tYXRyaXhQcmVzZW5jZS5zdWNjZXNzLFxuICAgIFJhaWRlbkFjdGlvbnMudG9rZW5Nb25pdG9yZWQsXG5dO1xuLyoqXG4gKiBTZXQgb2YgW3NlcmlhbGl6YWJsZV0gYWN0aW9ucyB3aGljaCBhcmUgZmlyc3QgZW1pdHRlZCB3aXRoXG4gKiBwYXlsb2FkLmNvbmZpcm1lZD11bmRlZmluZWQsIHRoZW4sIGFmdGVyIGNvbmZpcm1hdGlvbiBibG9ja3MsIGVpdGhlciB3aXRoIGNvbmZpcm1lZD10cnVlIGlmIHR4XG4gKiBpcyBzdGlsbCBwcmVzZW50IG9uIGJsb2NrY2hhaW4sIG9yIGNvbmZpcm1lZD1mYWxzZSBpZiBpdCBnb3QgcmVtb3ZlZCBieSBhIHJlb3JnLlxuICpcbiAqIFRoZXNlIGFjdGlvbnMgbXVzdCBjb21wbHkgd2l0aCB0aGUgZm9sbG93aW5nIHR5cGU6XG4gKiB7XG4gKiAgIHBheWxvYWQ6IHtcbiAqICAgICB0eEhhc2g6IEhhc2g7XG4gKiAgICAgdHhCbG9jazogbnVtYmVyO1xuICogICAgIGNvbmZpcm1lZDogdW5kZWZpbmVkIHwgYm9vbGVhbjtcbiAqICAgfTtcbiAqICAgbWV0YTogYW55O1xuICogfVxuICovXG5leHBvcnQgY29uc3QgQ29uZmlybWFibGVBY3Rpb25zID0gW1xuICAgIENoYW5uZWxzQWN0aW9ucy5jaGFubmVsT3Blbi5zdWNjZXNzLFxuICAgIENoYW5uZWxzQWN0aW9ucy5jaGFubmVsRGVwb3NpdC5zdWNjZXNzLFxuICAgIENoYW5uZWxzQWN0aW9ucy5jaGFubmVsV2l0aGRyYXduLFxuICAgIENoYW5uZWxzQWN0aW9ucy5jaGFubmVsQ2xvc2Uuc3VjY2VzcyxcbiAgICBDaGFubmVsc0FjdGlvbnMuY2hhbm5lbFNldHRsZS5zdWNjZXNzLFxuICAgIFRyYW5zZmVyc0FjdGlvbnMudHJhbnNmZXJTZWNyZXRSZWdpc3Rlci5zdWNjZXNzLFxuXTtcbi8qKlxuICogVW5pb24gb2YgY29kZWNzIG9mIGFjdGlvbnMgYWJvdmVcbiAqL1xuZXhwb3J0IGNvbnN0IENvbmZpcm1hYmxlQWN0aW9uID0gdC51bmlvbihbXG4gICAgQ2hhbm5lbHNBY3Rpb25zLmNoYW5uZWxPcGVuLnN1Y2Nlc3MuY29kZWMsXG4gICAgQ2hhbm5lbHNBY3Rpb25zLmNoYW5uZWxEZXBvc2l0LnN1Y2Nlc3MuY29kZWMsXG4gICAgQ2hhbm5lbHNBY3Rpb25zLmNoYW5uZWxXaXRoZHJhd24uY29kZWMsXG4gICAgQ2hhbm5lbHNBY3Rpb25zLmNoYW5uZWxDbG9zZS5zdWNjZXNzLmNvZGVjLFxuICAgIENoYW5uZWxzQWN0aW9ucy5jaGFubmVsU2V0dGxlLnN1Y2Nlc3MuY29kZWMsXG4gICAgVHJhbnNmZXJzQWN0aW9ucy50cmFuc2ZlclNlY3JldFJlZ2lzdGVyLnN1Y2Nlc3MuY29kZWMsXG5dKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjdGlvbnMuanMubWFwIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBNaWdyYXRlIHByZXZpb3VzIHN0YXRlIHRvIHZlcnNpb24gMFxuICpcbiAqIEBwYXJhbSBzdGF0ZSAtIFJhaWRlblN0YXRlIHZlcnNpb24gLTFcbiAqIEByZXR1cm5zIFN0YXRlIHZlcnNpb24gMFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaWdyYXRlMChzdGF0ZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgeyB2ZXJzaW9uOiAwIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9MC5qcy5tYXAiLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIE1vdmUgc2VjcmV0cyB0byAnc2VjcmV0JyBtZW1iZXIgb2YgdGhlIHJlc3BlY3RpdmUgVHJhbnNmZXJTdGF0ZVxuICpcbiAqIEBwYXJhbSBzdGF0ZSAtIFJhaWRlblN0YXRlIHZlcnNpb24gMFxuICogQHJldHVybnMgU3RhdGUgdmVyc2lvbiAxXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1pZ3JhdGUxKHN0YXRlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3Qgc2VudCA9IHN0YXRlLnNlbnQ7XG4gICAgZm9yIChjb25zdCBbaCwgdF0gb2YgT2JqZWN0LmVudHJpZXMoc2VudCkpIHtcbiAgICAgICAgaWYgKHN0YXRlLnNlY3JldHNbaF0pIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odCwge1xuICAgICAgICAgICAgICAgIHNlY3JldDogW1xuICAgICAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSB0LnNlY3JldFJldmVhbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0LnRyYW5zZmVyWzBdLFxuICAgICAgICAgICAgICAgICAgICB7IHZhbHVlOiBzdGF0ZS5zZWNyZXRzW2hdLnNlY3JldCwgcmVnaXN0ZXJCbG9jazogKF9jID0gc3RhdGUuc2VjcmV0c1toXS5yZWdpc3RlckJsb2NrKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZSBzdGF0ZVsnc2VjcmV0cyddO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPTEuanMubWFwIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBBZGRzOiBDaGFubmVsLmNsb3NlUGFydGljaXBhbnQsIFRyYW5zZmVyU3RhdGUucGFydG5lciAmIFJhaWRlblN0YXRlLnJlY2VpdmVkXG4gKlxuICogQHBhcmFtIHN0YXRlIC0gUmFpZGVuU3RhdGUgdmVyc2lvbiAxXG4gKiBAcmV0dXJucyBTdGF0ZSB2ZXJzaW9uIDJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWlncmF0ZTIoc3RhdGUpIHtcbiAgICBmb3IgKGNvbnN0IHBhcnRuZXJDaGFubmVscyBvZiBPYmplY3QudmFsdWVzKHN0YXRlLmNoYW5uZWxzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgT2JqZWN0LnZhbHVlcyhwYXJ0bmVyQ2hhbm5lbHMpKSB7XG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5jbG9zZUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgLy8gYXNzdW1lIHdlIHdlcmUgdGhlIG9uZXMgY2xvc2luZyB0aGUgY2hhbm5lbFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2hhbm5lbCwgeyBjbG9zZVBhcnRpY2lwYW50OiBzdGF0ZS5hZGRyZXNzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNlbnQgPSBzdGF0ZS5zZW50O1xuICAgIGZvciAoY29uc3QgdCBvZiBPYmplY3QudmFsdWVzKHNlbnQpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odCwgeyBwYXJ0bmVyOiB0LnRyYW5zZmVyWzFdLnJlY2lwaWVudCB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwgeyByZWNlaXZlZDoge30gfSk7XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Mi5qcy5tYXAiLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5pbXBvcnQgbG9nZ2luZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgeyBhc3NlcnQgfSBmcm9tICcuLi91dGlscy90eXBlcyc7XG5pbXBvcnQgbTAgZnJvbSAnLi8wJztcbmltcG9ydCBtMSBmcm9tICcuLzEnO1xuaW1wb3J0IG0yIGZyb20gJy4vMic7XG4vLyBpbXBvcnQgYWJvdmUgYW5kIHBvcHVsYXRlIHRoaXMgZGljdCB3aXRoIG5ldyBtaWdyYXRvciBmdW5jdGlvbnNcbi8vIG11c3QgYmUgb3JkZXJlZCwgY29udGludW91cywgYW5kIGxhc3Qgb25lIE1VU1QgYmUgc3RhdGUuQ1VSUkVOVF9TVEFURV9WRVJTSU9OXG5jb25zdCBtaWdyYXRpb25zID0geyAwOiBtMCwgMTogbTEsIDI6IG0yIH07XG4vKipcbiAqIE1pZ3JhdGUgYSBSYWlkZW5TdGF0ZSBmcm9tIGFueSBwcmV2aW91cyB2ZXJzaW9uIHRvIGxhdGVzdCBvbmVcbiAqXG4gKiBAcGFyYW0gc3RhdGUgLSBQcmV2aW91cyByYWlkZW4gc3RhdGVcbiAqIEBwYXJhbSB0b1ZlcnNpb24gLSBNaWdyYXRlIHVwIHRvIHRoaXMgdmVyc2lvblxuICogQHJldHVybnMgQSBjdXJyZW50IFJhaWRlblN0YXRlIChob3BlZnVsbHkpLCB0byBiZSB2YWxpZGF0ZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWlncmF0ZVN0YXRlKHN0YXRlLCB0b1ZlcnNpb24sIHsgbG9nIH0gPSB7IGxvZzogbG9nZ2luZyB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGZvciAobGV0IHYgPSAwOyB2IDw9IHRvVmVyc2lvbjsgdisrKVxuICAgICAgICBhc3NlcnQodiBpbiBtaWdyYXRpb25zLCBgbWlzc2luZyBtaWdyYXRpb24gZm9yICR7dn1gKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIG1pZ3JhdGVdIG9mIE9iamVjdC5lbnRyaWVzKG1pZ3JhdGlvbnMpKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAra2V5O1xuICAgICAgICBpZiAoKChfYSA9IHN0YXRlID09PSBudWxsIHx8IHN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGF0ZS52ZXJzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMSkgIT09IHZlcnNpb24gLSAxKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh2ZXJzaW9uID4gdG9WZXJzaW9uKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGF0ZSA9IE9iamVjdC5hc3NpZ24obWlncmF0ZShzdGF0ZSksIHsgdmVyc2lvbiB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoYEVycm9yIG1pZ3JhdGluZyBzdGF0ZSBmcm9tIHZlcnNpb24gJHt2ZXJzaW9uIC0gMX0gdG8gJHt2ZXJzaW9ufWAsIHN0YXRlLCBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHRoaXMgbXVzdCBiZSB2YWxpZGF0ZWQgYXMgUmFpZGVuU3RhdGUsIGJ1dCBpcyBkb25lIGluIGRlY29kZVJhaWRlblN0YXRlIHRvIGF2b2lkIGN5Y2xpYyBpbXBvcnRcbiAgICByZXR1cm4gc3RhdGU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5pbXBvcnQgeyBaZXJvLCBPbmUsIFR3byB9IGZyb20gJ2V0aGVycy9jb25zdGFudHMnO1xuaW1wb3J0IHsgQmlnTnVtYmVyLCBiaWdOdW1iZXJpZnksIHRvVXRmOEJ5dGVzIH0gZnJvbSAnZXRoZXJzL3V0aWxzJztcbmltcG9ydCB7IGhleGxpZnksIGlzQXJyYXlpc2gsIGhleFplcm9QYWQsIGhleERhdGFMZW5ndGgsIGlzSGV4U3RyaW5nLCB9IGZyb20gJ2V0aGVycy91dGlscy9ieXRlcyc7XG5pbXBvcnQgKiBhcyBMb3NzbGVzc0pTT04gZnJvbSAnbG9zc2xlc3MtanNvbic7XG5pbXBvcnQgeyBCaWdOdW1iZXJDIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBSYWlkZW5FcnJvciwgRXJyb3JDb2RlcyB9IGZyb20gJy4vZXJyb3InO1xuLyoqXG4gKiBFbmNvZGUgZGF0YSB0byBoZXggc3RyaW5nIG9mIGV4YWN0bHkgbGVuZ3RoIHNpemUgKGluIGJ5dGVzKVxuICogVGhyb3cgaWYgZGF0YSBjYW4ndCBiZSBtYWRlIHRvIGZpdCBpbiBsZW5ndGguXG4gKlxuICogQHBhcmFtIGRhdGEgLSBNYXkgYmUgb2YgbXVsdGlwbGUgdHlwZXM6XG4gKiAgICAgIC0gbnVtYmVyfEJpZ051bWJlcjogRW5jb2RlZCBpbiB0aGUgYmlnLWVuZGlhbiBieXRlLW9yZGVyIGFuZCBsZWZ0LXplcm8tcGFkZGVkIHRvIGxlbmd0aFxuICogICAgICAtIHN0cmluZzogTXVzdCBiZSBoZXgtZW5jb2RlZCBzdHJpbmcgb2YgbGVuZ3RoIGJ5dGVzXG4gKiAgICAgIC0gbnVtYmVyW10gTXVzdCBiZSBvZiBleGFjdGx5IG9mIGxlbmd0aCBzaXplIChsZWZ0L3JpZ2h0LXBhZCBpdCBiZWZvcmUgaWYgbmVlZGVkKVxuICogQHBhcmFtIGxlbmd0aCAtIFRoZSBleHBlY3RlZCBsZW5ndGggb2YgdGhlIGhleCBzdHJpbmcsIGluIGJ5dGVzXG4gKiBAcmV0dXJucyBIZXhTdHJpbmcgYnl0ZS1hcnJheSBvZiBsZW5ndGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShkYXRhLCBsZW5ndGgpIHtcbiAgICBsZXQgaGV4O1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICBkYXRhID0gZGF0YSA/IE9uZSA6IFplcm87XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKVxuICAgICAgICBkYXRhID0gYmlnTnVtYmVyaWZ5KGRhdGEpO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgIWlzSGV4U3RyaW5nKGRhdGEpKVxuICAgICAgICBkYXRhID0gdG9VdGY4Qnl0ZXMoZGF0YSk7XG4gICAgaWYgKGlzQXJyYXlpc2goZGF0YSkpXG4gICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgIGlmIChCaWdOdW1iZXJDLmlzKGRhdGEpKSB7XG4gICAgICAgIGlmIChkYXRhLmx0KDApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuRFRBX05FR0FUSVZFX05VTUJFUik7XG4gICAgICAgIGlmIChkYXRhLmd0ZShUd28ucG93KGxlbmd0aCAqIDgpKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYWlkZW5FcnJvcihFcnJvckNvZGVzLkRUQV9OVU1CRVJfVE9PX0xBUkdFKTtcbiAgICAgICAgaGV4ID0gaGV4WmVyb1BhZChoZXhsaWZ5KGRhdGEpLCBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGhleERhdGFMZW5ndGgoZGF0YSkgIT09IGxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYWlkZW5FcnJvcihFcnJvckNvZGVzLkRUQV9BUlJBWV9MRU5HVEhfRElGRlJFTkNFKTtcbiAgICAgICAgaGV4ID0gZGF0YTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBSYWlkZW5FcnJvcihFcnJvckNvZGVzLkRUQV9VTkVOQ09EQUJMRV9EQVRBKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmNvbnN0IGlzTG9zc2xlc3NOdW1iZXIgPSAodSkgPT4gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudSAhPSBudWxsICYmIHVbJ2lzTG9zc2xlc3NOdW1iZXInXTtcbi8qKlxuICogT3Bwb3J0dW5pc3RpYyBKU09OLnBhcnNlIHJlZ2FyZGluZyBudW1iZXJzXG4gKiBJZiBwb3NzaWJsZSB0byBkZWNvZGUgYSBKU09OIG51bWJlciBhcyBKUyBudW1iZXIgKGkuZS4gdmFsdWUgPCAyXjUzKSBhbmQgcmV0dXJuICdudW1iZXInLFxuICogb3RoZXJ3aXNlIHJldHVybnMgQmlnTnVtYmVyIG9iamVjdFxuICogVGhyb3dzIGlmIGhhbmRsZWQgaW52YWxpZCBKU09OXG4gKlxuICogQHBhcmFtIHRleHQgLSBKU09OIHN0cmluZyB0byBwYXJzZVxuICogQHJldHVybnMgRGVjb2RlZCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvc3NsZXNzUGFyc2UodGV4dCkge1xuICAgIHJldHVybiBMb3NzbGVzc0pTT04ucGFyc2UodGV4dCwgKHt9LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoaXNMb3NzbGVzc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlT2YoKTsgLy8gcmV0dXJuIG51bWJlciwgaWYgcG9zc2libGUsIG9yIHRocm93IGlmID4gMl41M1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBlbHNlLCBjb252ZXJ0IGVhcmx5IHRvIEJpZ051bWJlclxuICAgICAgICAgICAgICAgIHJldHVybiBiaWdOdW1iZXJpZnkodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xufVxuLyoqXG4gKiBTdHJpbmdpZnkgb2JqZWN0IGxvc3NsZXNzbHksIGJ5IGNvbnZlcnRpbmcgQmlnTnVtYmVycyB0byAnc3RyaW5nJ3NcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBPYmplY3QgdG8gYmUgc2VyaWFsaXplZCBhcyBhIHN0cmluZ1xuICogQHBhcmFtIHJlcGxhY2VyIC0gUmVwbGFjZXIgZnVuY3Rpb24uIExlYXZlIGRlZmF1bHQgdG8gc3RyaW5naWZ5IEJpZ051bWJlcnNcbiAqIEBwYXJhbSBzcGFjZSAtIGluZGVudGF0aW9uIHNwYWNlc1xuICogQHJldHVybnMgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9zc2xlc3NTdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyID0gKHt9LCB2YWx1ZSkgPT4gQmlnTnVtYmVyLmlzQmlnTnVtYmVyKHZhbHVlKSA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSwgc3BhY2UpIHtcbiAgICByZXR1cm4gTG9zc2xlc3NKU09OLnN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEuanMubWFwIiwiaW1wb3J0ICogYXMgdCBmcm9tICdpby10cyc7XG5pbXBvcnQgeyBVSW50LCBBZGRyZXNzIH0gZnJvbSAnLi4vdXRpbHMvdHlwZXMnO1xuaW1wb3J0IHsgTG9jaywgU2lnbmVkQmFsYW5jZVByb29mIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgdmFyIENoYW5uZWxTdGF0ZTtcbihmdW5jdGlvbiAoQ2hhbm5lbFN0YXRlKSB7XG4gICAgQ2hhbm5lbFN0YXRlW1wib3BlbmluZ1wiXSA9IFwib3BlbmluZ1wiO1xuICAgIENoYW5uZWxTdGF0ZVtcIm9wZW5cIl0gPSBcIm9wZW5cIjtcbiAgICBDaGFubmVsU3RhdGVbXCJjbG9zaW5nXCJdID0gXCJjbG9zaW5nXCI7XG4gICAgQ2hhbm5lbFN0YXRlW1wiY2xvc2VkXCJdID0gXCJjbG9zZWRcIjtcbiAgICBDaGFubmVsU3RhdGVbXCJzZXR0bGVhYmxlXCJdID0gXCJzZXR0bGVhYmxlXCI7XG4gICAgQ2hhbm5lbFN0YXRlW1wic2V0dGxpbmdcIl0gPSBcInNldHRsaW5nXCI7XG4gICAgQ2hhbm5lbFN0YXRlW1wic2V0dGxlZFwiXSA9IFwic2V0dGxlZFwiO1xufSkoQ2hhbm5lbFN0YXRlIHx8IChDaGFubmVsU3RhdGUgPSB7fSkpO1xuLyoqXG4gKiBDb250YWlucyBpbmZvIG9mIGVhY2ggc2lkZSBvZiBhIGNoYW5uZWxcbiAqL1xuZXhwb3J0IGNvbnN0IENoYW5uZWxFbmQgPSB0LnJlYWRvbmx5KHQuaW50ZXJzZWN0aW9uKFtcbiAgICB0LnR5cGUoe1xuICAgICAgICBkZXBvc2l0OiBVSW50KDMyKSxcbiAgICB9KSxcbiAgICB0LnBhcnRpYWwoe1xuICAgICAgICBsb2NrczogdC5yZWFkb25seUFycmF5KExvY2spLFxuICAgICAgICBiYWxhbmNlUHJvb2Y6IFNpZ25lZEJhbGFuY2VQcm9vZixcbiAgICAgICAgd2l0aGRyYXc6IFVJbnQoMzIpLFxuICAgIH0pLFxuXSkpO1xuZXhwb3J0IGNvbnN0IENoYW5uZWwgPSB0LmludGVyc2VjdGlvbihbXG4gICAgdC5yZWFkb25seSh0LnR5cGUoe1xuICAgICAgICBvd246IENoYW5uZWxFbmQsXG4gICAgICAgIHBhcnRuZXI6IENoYW5uZWxFbmQsXG4gICAgfSkpLFxuICAgIHQudW5pb24oW1xuICAgICAgICAvKiB1bmlvbiBvZiB0eXBlcyB3aXRoIGxpdGVyYWxzIGludGVyc2VjdGlvbiBhbGxvd3MgbmFycm93aW5nIG90aGVyIHByb3BzIHByZXNlbmNlLiBlLmcuOlxuICAgICAgICAgKiBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gQ2hhbm5lbFN0YXRlLm9wZW4pIHtcbiAgICAgICAgICogICBpZCA9IGNoYW5uZWwuaWQ7IC8vIDwtIGlkIGNhbid0IGJlIHVuZGVmaW5lZFxuICAgICAgICAgKiAgIGNsb3NlQmxvY2sgPSBjaGFubmVsLmNsb3NlQmxvY2s7IC8vIGVycm9yOiBjbG9zZUJsb2NrIG9ubHkgZXhpc3Qgb24gc3RhdGVzIGNsb3NlZHxzZXR0bGluZ1xuICAgICAgICAgKiB9XG4gICAgICAgICAqL1xuICAgICAgICB0LnJlYWRvbmx5KHQudHlwZSh7IHN0YXRlOiB0LmxpdGVyYWwoQ2hhbm5lbFN0YXRlLm9wZW5pbmcpIH0pKSxcbiAgICAgICAgdC5yZWFkb25seSh0LnR5cGUoe1xuICAgICAgICAgICAgc3RhdGU6IHQudW5pb24oW3QubGl0ZXJhbChDaGFubmVsU3RhdGUub3BlbiksIHQubGl0ZXJhbChDaGFubmVsU3RhdGUuY2xvc2luZyldKSxcbiAgICAgICAgICAgIGlkOiB0Lm51bWJlcixcbiAgICAgICAgICAgIHNldHRsZVRpbWVvdXQ6IHQubnVtYmVyLFxuICAgICAgICAgICAgb3BlbkJsb2NrOiB0Lm51bWJlcixcbiAgICAgICAgICAgIGlzRmlyc3RQYXJ0aWNpcGFudDogdC5ib29sZWFuLFxuICAgICAgICB9KSksXG4gICAgICAgIHQucmVhZG9ubHkodC50eXBlKHtcbiAgICAgICAgICAgIHN0YXRlOiB0LnVuaW9uKFtcbiAgICAgICAgICAgICAgICB0LmxpdGVyYWwoQ2hhbm5lbFN0YXRlLmNsb3NlZCksXG4gICAgICAgICAgICAgICAgdC5saXRlcmFsKENoYW5uZWxTdGF0ZS5zZXR0bGVhYmxlKSxcbiAgICAgICAgICAgICAgICB0LmxpdGVyYWwoQ2hhbm5lbFN0YXRlLnNldHRsaW5nKSxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgaWQ6IHQubnVtYmVyLFxuICAgICAgICAgICAgc2V0dGxlVGltZW91dDogdC5udW1iZXIsXG4gICAgICAgICAgICBvcGVuQmxvY2s6IHQubnVtYmVyLFxuICAgICAgICAgICAgaXNGaXJzdFBhcnRpY2lwYW50OiB0LmJvb2xlYW4sXG4gICAgICAgICAgICBjbG9zZUJsb2NrOiB0Lm51bWJlcixcbiAgICAgICAgICAgIGNsb3NlUGFydGljaXBhbnQ6IEFkZHJlc3MsXG4gICAgICAgIH0pKSxcbiAgICBdKSxcbl0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGUuanMubWFwIiwiaW1wb3J0ICogYXMgdCBmcm9tICdpby10cyc7XG5pbXBvcnQgeyBMb2NrZWRUcmFuc2ZlciwgUHJvY2Vzc2VkLCBTZWNyZXRSZXZlYWwsIFVubG9jaywgTG9ja0V4cGlyZWQsIFJlZnVuZFRyYW5zZmVyLCBTZWNyZXRSZXF1ZXN0LCB9IGZyb20gJy4uL21lc3NhZ2VzL3R5cGVzJztcbmltcG9ydCB7IEFkZHJlc3MsIFRpbWVkLCBIYXNoLCBJbnQsIFNpZ25lZCwgU2VjcmV0IH0gZnJvbSAnLi4vdXRpbHMvdHlwZXMnO1xuZXhwb3J0IHZhciBEaXJlY3Rpb247XG4oZnVuY3Rpb24gKERpcmVjdGlvbikge1xuICAgIERpcmVjdGlvbltcIlNFTlRcIl0gPSBcInNlbnRcIjtcbiAgICBEaXJlY3Rpb25bXCJSRUNFSVZFRFwiXSA9IFwicmVjZWl2ZWRcIjtcbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcbi8qKlxuICogVGhpcyBzdHJ1Y3QgaG9sZHMgdGhlIHJlbGV2YW50IG1lc3NhZ2VzIGV4Y2hhbmdlZCBpbiBhIHRyYW5zZmVyXG4gKiBUaGUgdHJhbnNmZXIgc3RhdGUgaXMgZGVmaW5lZCBieSB0aGUgZXhjaGFuZ2VkIG1lc3NhZ2VzXG4gKi9cbmV4cG9ydCBjb25zdCBUcmFuc2ZlclN0YXRlID0gdC5yZWFkb25seSh0LmludGVyc2VjdGlvbihbXG4gICAgdC50eXBlKHtcbiAgICAgICAgLyoqIC0+IG91dGdvaW5nIGxvY2tlZCB0cmFuc2ZlciAqL1xuICAgICAgICB0cmFuc2ZlcjogVGltZWQoU2lnbmVkKExvY2tlZFRyYW5zZmVyKSksXG4gICAgICAgIGZlZTogSW50KDMyKSxcbiAgICAgICAgcGFydG5lcjogQWRkcmVzcyxcbiAgICB9KSxcbiAgICB0LnBhcnRpYWwoe1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhbnNmZXIgc2VjcmV0LCBpZiBrbm93blxuICAgICAgICAgKiByZWdpc3RlckJsb2NrIGlzIDAgaWYgbm90IHlldCByZWdpc3RlcmVkIG9uLWNoYWluXG4gICAgICAgICAqICovXG4gICAgICAgIHNlY3JldDogVGltZWQodC50eXBlKHsgdmFsdWU6IFNlY3JldCwgcmVnaXN0ZXJCbG9jazogdC5udW1iZXIgfSkpLFxuICAgICAgICAvKiogPC0gaW5jb21pbmcgcHJvY2Vzc2VkIGZvciBsb2NrZWQgdHJhbnNmZXIgKi9cbiAgICAgICAgdHJhbnNmZXJQcm9jZXNzZWQ6IFRpbWVkKFNpZ25lZChQcm9jZXNzZWQpKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDwtIGluY29taW5nIHJlZnVuZCB0cmFuc2ZlciAoaWYgc28pXG4gICAgICAgICAqIElmIHRoaXMgaXMgc2V0LCB0cmFuc2ZlciBmYWlsZWQgYW5kIHBhcnRuZXIgdHJpZWQgcmVmdW5kaW5nIHRoZSB0cmFuc2ZlciB0byB1cy4gV2UgZG9uJ3RcbiAgICAgICAgICogaGFuZGxlIHJlY2VpdmluZyB0cmFuc2ZlcnMsIGJ1dCBqdXN0IHN0b3JlIGl0IGhlcmUgdG8gbWFyayB0aGlzIHRyYW5zZmVyIGFzIGZhaWxlZCB3aXRoIGFcbiAgICAgICAgICogcmVmdW5kLCB1bnRpbCB0aGUgbG9jayBleHBpcmVzIG5vcm1hbGx5XG4gICAgICAgICAqL1xuICAgICAgICByZWZ1bmQ6IFRpbWVkKFNpZ25lZChSZWZ1bmRUcmFuc2ZlcikpLFxuICAgICAgICAvKipcbiAgICAgICAgICogISEgY2hhbm5lbCB3YXMgY2xvc2VkICEhXG4gICAgICAgICAqIEluIHRoZSBjYXNlIGEgY2hhbm5lbCBpcyBjbG9zZWQgKHBvc3NpYmx5IG1pZGRsZSB0cmFuc2ZlciksIHRoaXMgd2lsbCBiZSB0aGUgdHhIYXNoIG9mIHRoZVxuICAgICAgICAgKiBDbG9zZUNoYW5uZWwgdHJhbnNhY3Rpb24uIE5vIGZ1cnRoZXIgYWN0aW9ucyBhcmUgcG9zc2libGUgYWZ0ZXIgaXQncyBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICBjaGFubmVsQ2xvc2VkOiBUaW1lZChIYXNoKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDwtIGluY29taW5nIHNlY3JldCByZXF1ZXN0IGZyb20gdGFyZ2V0XG4gICAgICAgICAqIElmIHRoaXMgaXMgc2V0LCBpdCBtZWFucyB0aGUgdGFyZ2V0IHJlcXVlc3RlZCB0aGUgc2VjcmV0LCBub3QgbmVjZXNzYXJpbHkgd2l0aCBhIHZhbGlkXG4gICAgICAgICAqIGFtb3VudCAoYW4gaW52YWxpZCBhbW91bnQgPCB2YWx1ZSA9PSBsb2NrIC0gZmVlLCBtZWFucyB0cmFuc2ZlciBmYWlsZWQpXG4gICAgICAgICAqL1xuICAgICAgICBzZWNyZXRSZXF1ZXN0OiBUaW1lZChTaWduZWQoU2VjcmV0UmVxdWVzdCkpLFxuICAgICAgICAvKipcbiAgICAgICAgICogLT4gb3V0Z29pbmcgc2VjcmV0IHJldmVhbCB0byB0YXJnZXRcbiAgICAgICAgICogSWYgdGhpcyBpcyBzZXQsIGl0IG1lYW5zIHRoZSBzZWNyZXQgd2FzIHJldmVhbGVkIChzbyB0cmFuc2ZlciBzdWNjZWVkZWQsIGV2ZW4gaWYgaXQgZGlkbid0XG4gICAgICAgICAqIGNvbXBsZXRlIHlldClcbiAgICAgICAgICovXG4gICAgICAgIHNlY3JldFJldmVhbDogVGltZWQoU2lnbmVkKFNlY3JldFJldmVhbCkpLFxuICAgICAgICAvKipcbiAgICAgICAgICogLT4gb3V0Z29pbmcgdW5sb2NrIHRvIHJlY2lwaWVudFxuICAgICAgICAgKiBJZiB0aGlzIGlzIHNldCwgaXQgbWVhbnMgdGhlIFVubG9jayB3YXMgc2VudCAoZXZlbiBpZiBwYXJ0bmVyIGRpZG4ndCBhY2tub3dsZWRnZSBpdCB5ZXQpXG4gICAgICAgICAqL1xuICAgICAgICB1bmxvY2s6IFRpbWVkKFNpZ25lZChVbmxvY2spKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIC0+IG91dGdvaW5nIGxvY2sgZXhwaXJlZCAoaWYgc28pXG4gICAgICAgICAqIElmIHRoaXMgaXMgc2V0LCB0cmFuc2ZlciBmYWlsZWQsIGFuZCB3ZSBleHBpcmVkIHRoZSBsb2NrIChyZXRyaWV2aW5nIHRoZSBsb2NrZWQgYW1vdW50KS5cbiAgICAgICAgICogVHJhbnNmZXIgZmFpbGVkIG1heSBub3QgaGF2ZSBjb21wbGV0ZWQgeWV0LCBlLmcuIHdhaXRpbmcgZm9yIExvY2tFeHBpcmVkJ3MgUHJvY2Vzc2VkIHJlcGx5XG4gICAgICAgICAqL1xuICAgICAgICBsb2NrRXhwaXJlZDogVGltZWQoU2lnbmVkKExvY2tFeHBpcmVkKSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiA8LSBpbmNvbWluZyBwcm9jZXNzZWQgZm9yIFVubG9jayBtZXNzYWdlXG4gICAgICAgICAqIElmIHRoaXMgaXMgc2V0LCB0aGUgcHJvdG9jb2wgY29tcGxldGVkIGJ5IHRoZSB0cmFuc2ZlciBzdWNjZWVkaW5nIGFuZCBwYXJ0bmVyXG4gICAgICAgICAqIGFja25vd2xlZGdpbmcgdmFsaWRpdHkgb2Ygb3VyIG9mZi1jaGFpbiB1bmxvY2tcbiAgICAgICAgICovXG4gICAgICAgIHVubG9ja1Byb2Nlc3NlZDogVGltZWQoU2lnbmVkKFByb2Nlc3NlZCkpLFxuICAgICAgICAvKipcbiAgICAgICAgICogPC0gaW5jb21pbmcgcHJvY2Vzc2VkIGZvciBMb2NrRXhwaXJlZCBtZXNzYWdlXG4gICAgICAgICAqIElmIHRoaXMgaXMgc2V0LCB0aGUgcHJvdG9jb2wgY29tcGxldGVkIGJ5IHRoZSB0cmFuc2ZlciBmYWlsaW5nIGFuZCBwYXJ0bmVyIGFja25vd2xlZGdpbmdcbiAgICAgICAgICogdGhpcyB0cmFuc2ZlciBjYW4ndCBiZSBjbGFpbWVkIGFueW1vcmVcbiAgICAgICAgICovXG4gICAgICAgIGxvY2tFeHBpcmVkUHJvY2Vzc2VkOiBUaW1lZChTaWduZWQoUHJvY2Vzc2VkKSksXG4gICAgfSksXG5dKSk7XG4vKipcbiAqIE1hcHBpbmcgb2Ygb3V0Z29pbmcgdHJhbnNmZXJzLCBpbmRleGVkIGJ5IHRoZSBzZWNyZXRoYXNoXG4gKi9cbmV4cG9ydCBjb25zdCBUcmFuc2ZlcnNTdGF0ZSA9IHQucmVhZG9ubHkodC5yZWNvcmQodC5zdHJpbmcgLyogc2VjcmV0aGFzaDogSGFzaCAqLywgVHJhbnNmZXJTdGF0ZSkpO1xuZXhwb3J0IHZhciBSYWlkZW5UcmFuc2ZlclN0YXR1cztcbihmdW5jdGlvbiAoUmFpZGVuVHJhbnNmZXJTdGF0dXMpIHtcbiAgICBSYWlkZW5UcmFuc2ZlclN0YXR1c1tcInBlbmRpbmdcIl0gPSBcIlBFTkRJTkdcIjtcbiAgICBSYWlkZW5UcmFuc2ZlclN0YXR1c1tcInJlY2VpdmVkXCJdID0gXCJSRUNFSVZFRFwiO1xuICAgIFJhaWRlblRyYW5zZmVyU3RhdHVzW1wicmVmdW5kZWRcIl0gPSBcIlJFRlVOREVEXCI7XG4gICAgUmFpZGVuVHJhbnNmZXJTdGF0dXNbXCJjbG9zZWRcIl0gPSBcIkNMT1NFRFwiO1xuICAgIFJhaWRlblRyYW5zZmVyU3RhdHVzW1wicmVxdWVzdGVkXCJdID0gXCJSRVFVRVNURURcIjtcbiAgICBSYWlkZW5UcmFuc2ZlclN0YXR1c1tcInJldmVhbGVkXCJdID0gXCJSRVZFQUxFRFwiO1xuICAgIFJhaWRlblRyYW5zZmVyU3RhdHVzW1wicmVnaXN0ZXJlZFwiXSA9IFwiUkVHSVNURVJFRFwiO1xuICAgIFJhaWRlblRyYW5zZmVyU3RhdHVzW1widW5sb2NraW5nXCJdID0gXCJVTkxPQ0tJTkdcIjtcbiAgICBSYWlkZW5UcmFuc2ZlclN0YXR1c1tcImV4cGlyaW5nXCJdID0gXCJFWFBJUklOR1wiO1xuICAgIFJhaWRlblRyYW5zZmVyU3RhdHVzW1widW5sb2NrZWRcIl0gPSBcIlVOTE9DS0VEXCI7XG4gICAgUmFpZGVuVHJhbnNmZXJTdGF0dXNbXCJleHBpcmVkXCJdID0gXCJFWFBJUkVEXCI7XG59KShSYWlkZW5UcmFuc2ZlclN0YXR1cyB8fCAoUmFpZGVuVHJhbnNmZXJTdGF0dXMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGUuanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2FtZWxjYXNlICovXG5pbXBvcnQgKiBhcyB0IGZyb20gJ2lvLXRzJztcbmltcG9ydCB7IEFkZHJlc3NaZXJvIH0gZnJvbSAnZXRoZXJzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXROZXR3b3JrIH0gZnJvbSAnZXRoZXJzL3V0aWxzJztcbmltcG9ydCBkZWJvdW5jZSBmcm9tICdsb2Rhc2gvZGVib3VuY2UnO1xuaW1wb3J0IGxvZ2dpbmcgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgUGFydGlhbFJhaWRlbkNvbmZpZywgbWFrZURlZmF1bHRDb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBDb25maXJtYWJsZUFjdGlvbiB9IGZyb20gJy4vYWN0aW9ucyc7XG5pbXBvcnQgbWlncmF0ZVN0YXRlIGZyb20gJy4vbWlncmF0aW9uJztcbmltcG9ydCB7IGxvc3NsZXNzUGFyc2UsIGxvc3NsZXNzU3RyaW5naWZ5IH0gZnJvbSAnLi91dGlscy9kYXRhJztcbmltcG9ydCB7IEFkZHJlc3MsIFNpZ25lZCwgZGVjb2RlIH0gZnJvbSAnLi91dGlscy90eXBlcyc7XG5pbXBvcnQgeyBDaGFubmVsIH0gZnJvbSAnLi9jaGFubmVscy9zdGF0ZSc7XG5pbXBvcnQgeyBSYWlkZW5NYXRyaXhTZXR1cCB9IGZyb20gJy4vdHJhbnNwb3J0L3N0YXRlJztcbmltcG9ydCB7IFRyYW5zZmVyc1N0YXRlIH0gZnJvbSAnLi90cmFuc2ZlcnMvc3RhdGUnO1xuaW1wb3J0IHsgSU9VIH0gZnJvbSAnLi9wYXRoL3R5cGVzJztcbmltcG9ydCB7IGdldE5ldHdvcmtOYW1lIH0gZnJvbSAnLi91dGlscy9ldGhlcnMnO1xuaW1wb3J0IHsgUmFpZGVuRXJyb3IsIEVycm9yQ29kZXMgfSBmcm9tICcuL3V0aWxzL2Vycm9yJztcbi8vIHNhbWUgYXMgaGlnaGVzdCBtaWdyYXRvciBmdW5jdGlvbiBpbiBtaWdyYXRpb24uaW5kZXgubWlncmF0b3JzXG5leHBvcnQgY29uc3QgQ1VSUkVOVF9TVEFURV9WRVJTSU9OID0gMjtcbi8vIHR5cGVzXG5leHBvcnQgY29uc3QgUmFpZGVuU3RhdGUgPSB0LnJlYWRvbmx5KHQudHlwZSh7XG4gICAgYWRkcmVzczogQWRkcmVzcyxcbiAgICB2ZXJzaW9uOiB0LmxpdGVyYWwoQ1VSUkVOVF9TVEFURV9WRVJTSU9OKSxcbiAgICBjaGFpbklkOiB0Lm51bWJlcixcbiAgICByZWdpc3RyeTogQWRkcmVzcyxcbiAgICBibG9ja051bWJlcjogdC5udW1iZXIsXG4gICAgY29uZmlnOiBQYXJ0aWFsUmFpZGVuQ29uZmlnLFxuICAgIGNoYW5uZWxzOiB0LnJlYWRvbmx5KHQucmVjb3JkKHQuc3RyaW5nIC8qIHRva2VuTmV0d29yazogQWRkcmVzcyAqLywgdC5yZWFkb25seSh0LnJlY29yZCh0LnN0cmluZyAvKiBwYXJ0bmVyOiBBZGRyZXNzICovLCBDaGFubmVsKSkpKSxcbiAgICB0b2tlbnM6IHQucmVhZG9ubHkodC5yZWNvcmQodC5zdHJpbmcgLyogdG9rZW46IEFkZHJlc3MgKi8sIEFkZHJlc3MpKSxcbiAgICB0cmFuc3BvcnQ6IHQucmVhZG9ubHkodC5wYXJ0aWFsKHtcbiAgICAgICAgbWF0cml4OiB0LnJlYWRvbmx5KHQuaW50ZXJzZWN0aW9uKFtcbiAgICAgICAgICAgIHQudHlwZSh7XG4gICAgICAgICAgICAgICAgc2VydmVyOiB0LnN0cmluZyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdC5wYXJ0aWFsKHtcbiAgICAgICAgICAgICAgICBzZXR1cDogUmFpZGVuTWF0cml4U2V0dXAsXG4gICAgICAgICAgICAgICAgcm9vbXM6IHQucmVhZG9ubHkodC5yZWNvcmQodC5zdHJpbmcgLyogcGFydG5lcjogQWRkcmVzcyAqLywgdC5hcnJheSh0LnN0cmluZykpKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdKSksXG4gICAgfSkpLFxuICAgIHNlbnQ6IFRyYW5zZmVyc1N0YXRlLFxuICAgIHJlY2VpdmVkOiBUcmFuc2ZlcnNTdGF0ZSxcbiAgICBwYXRoOiB0LnR5cGUoe1xuICAgICAgICBpb3U6IHQucmVhZG9ubHkodC5yZWNvcmQodC5zdHJpbmcgLyogdG9rZW5OZXR3b3JrOiBBZGRyZXNzICovLCB0LnJlY29yZCh0LnN0cmluZyAvKiBzZXJ2aWNlOiBBZGRyZXNzICovLCBTaWduZWQoSU9VKSkpKSxcbiAgICB9KSxcbiAgICBwZW5kaW5nVHhzOiB0LnJlYWRvbmx5QXJyYXkoQ29uZmlybWFibGVBY3Rpb24pLFxufSkpO1xuLy8gaGVscGVycywgdXRpbHMgJiBjb25zdGFudHNcbi8qKlxuICogRW5jb2RlIFJhaWRlblN0YXRlIHRvIGEgSlNPTiBzdHJpbmdcbiAqIEZvciBSYWlkZW4gY2xpZW50IGNvbXBsaWFuY2UsIHRoaXMgSlNPTiBlbmNvZGVzIEJpZ051bWJlcnMgYXMgJ251bWJlcicgKHVzaW5nIGxvc3NsZXNzLWpzb24gbGliKVxuICogd2hpY2ggaXMgdmFsaWQganNvbiB0aG91Z2ggbm90IHZlcnkgY29tbW9uIGFzIGNvbW1vbiBKUyBpbXBsZW1lbnRhdGlvbnMgbG9zZSBwcmVjaXNpb24gd2hlblxuICogZGVjb2RpbmcgdGhyb3VnaCBKU09OLnBhcnNlLiBUaGlzIGlzIHNvbHZlZCBpbiBTREsgYnkgYm90aCBlbmNvZGluZyBhbmQgZGVjb2RpbmcgQmlnTnVtYmVyc1xuICogdXNpbmcgbG9zc2xlc3MtanNvbiwgd2l0aG91dCBnb2luZyB0aHJvdWdoIHRoZSBpbnRlcm1lZGlhcnkgSlMtbnVtYmVyIGZvcm0uXG4gKlxuICogQHBhcmFtIHN0YXRlIC0gUmFpZGVuU3RhdGUgb2JqZWN0XG4gKiBAcmV0dXJucyBKU09OIGVuY29kZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVSYWlkZW5TdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiBsb3NzbGVzc1N0cmluZ2lmeShSYWlkZW5TdGF0ZS5lbmNvZGUoc3RhdGUpLCB1bmRlZmluZWQsIDIpO1xufVxuLyoqXG4gKiBUcnkgdG8gbWlncmF0ZSAmIGRlY29kZSBkYXRhIGFzIFJhaWRlblN0YXRlLlxuICogSWYgaGFuZGxlZCBhIHN0cmluZywgd2lsbCBwYXJzZSBpdCB3aXRoIGxvc3NsZXNzLWpzb24sIHRvIHByZXNlcnZlIEJpZ051bWJlcnMgZW5jb2RlZCBhcyBKU09OXG4gKiAnbnVtYmVyJy4gVGhlIGRhdGEgbWF5IGJlIG1pZ3JhdGVkIGZyb20gcHJldmlvdXMgdmVyc2lvbnMsIHRoZW4gdmFsaWRhdGVkIGFzIGN1cnJlbnQgUmFpZGVuU3RhdGVcbiAqXG4gKiBAcGFyYW0gZGF0YSAtIHN0cmluZyB8IGFueSB3aGljaCBtYXkgYmUgZGVjb2RlZCBhcyBSYWlkZW5TdGF0ZVxuICogQHJldHVybnMgUmFpZGVuU3RhdGUgcGFyc2VkLCBtaWdyYXRlZCBhbmQgdmFsaWRhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSYWlkZW5TdGF0ZShkYXRhLCB7IGxvZyB9ID0geyBsb2c6IGxvZ2dpbmcgfSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSBsb3NzbGVzc1BhcnNlKGRhdGEpO1xuICAgIGNvbnN0IHN0YXRlID0gbWlncmF0ZVN0YXRlKGRhdGEsIENVUlJFTlRfU1RBVEVfVkVSU0lPTiwgeyBsb2cgfSk7XG4gICAgLy8gdmFsaWRhdGVzIGFuZCByZXR1cm5zIGFzIGN1cnJlbnQgc3RhdGVcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlKFJhaWRlblN0YXRlLCBzdGF0ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yKGBFcnJvciB2YWxpZGF0aW5nIG1pZ3JhdGVkIHN0YXRlIHZlcnNpb249JHtzdGF0ZSA9PT0gbnVsbCB8fCBzdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhdGUudmVyc2lvbn1gLCBzdGF0ZSk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhbiBpbml0aWFsIFJhaWRlblN0YXRlIGZyb20gY29tbW9uIHBhcmFtZXRlcnMgKGluY2x1ZGluZyBkZWZhdWx0IGNvbmZpZylcbiAqXG4gKiBAcGFyYW0gb2JqIC0gT2JqZWN0IGNvbnRhaW5pbmcgY29tbW9uIHBhcmFtZXRlcnMgZm9yIHN0YXRlXG4gKiBAcGFyYW0gb2JqLm5ldHdvcmsgLSBldGhlcidzIE5ldHdvcmsgb2JqZWN0IGZvciB0aGUgY3VycmVudCBibG9ja2NoYWluXG4gKiBAcGFyYW0gb2JqLmFkZHJlc3MgLSBjdXJyZW50IGFjY291bnQncyBhZGRyZXNzXG4gKiBAcGFyYW0gb3ZlcndyaXRlcyAtIEEgcGFydGlhbCBvYmplY3QgdG8gb3ZlcndyaXRlIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIG9mIHRoZSByZXR1cm5lZCBjb25maWdcbiAqIEByZXR1cm5zIEEgZnVsbCBjb25maWcgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSW5pdGlhbFN0YXRlKHsgbmV0d29yaywgYWRkcmVzcywgY29udHJhY3RzSW5mbywgfSwgb3ZlcndyaXRlcyA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIHZlcnNpb246IENVUlJFTlRfU1RBVEVfVkVSU0lPTixcbiAgICAgICAgY2hhaW5JZDogbmV0d29yay5jaGFpbklkLFxuICAgICAgICByZWdpc3RyeTogY29udHJhY3RzSW5mby5Ub2tlbk5ldHdvcmtSZWdpc3RyeS5hZGRyZXNzLFxuICAgICAgICBibG9ja051bWJlcjogY29udHJhY3RzSW5mby5Ub2tlbk5ldHdvcmtSZWdpc3RyeS5ibG9ja19udW1iZXIsXG4gICAgICAgIGNvbmZpZzogKF9hID0gb3ZlcndyaXRlcy5jb25maWcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LFxuICAgICAgICBjaGFubmVsczoge30sXG4gICAgICAgIHRva2Vuczoge30sXG4gICAgICAgIHRyYW5zcG9ydDoge30sXG4gICAgICAgIHNlbnQ6IHt9LFxuICAgICAgICByZWNlaXZlZDoge30sXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgIGlvdToge30sXG4gICAgICAgIH0sXG4gICAgICAgIHBlbmRpbmdUeHM6IFtdLFxuICAgIH07XG59XG4vKipcbiAqIHN0YXRlIGNvbnN0YW50IHVzZWQgYXMgZGVmYXVsdCBzdGF0ZSByZWR1Y2VyIHBhcmFtZXRlciBvbmx5LlxuICogVG8gYnVpbGQgYW4gYWN0dWFsIGluaXRpYWwgc3RhdGUgYXQgcnVudGltZSwgdXNlIFtbbWFrZUluaXRpYWxTdGF0ZV1dIGluc3RlYWQuXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0aWFsU3RhdGUgPSBtYWtlSW5pdGlhbFN0YXRlKHtcbiAgICBuZXR3b3JrOiBnZXROZXR3b3JrKCd1bnNwZWNpZmllZCcpLFxuICAgIGFkZHJlc3M6IEFkZHJlc3NaZXJvLFxuICAgIGNvbnRyYWN0c0luZm86IHtcbiAgICAgICAgVG9rZW5OZXR3b3JrUmVnaXN0cnk6IHsgYWRkcmVzczogQWRkcmVzc1plcm8sIGJsb2NrX251bWJlcjogMCB9LFxuICAgICAgICBTZXJ2aWNlUmVnaXN0cnk6IHsgYWRkcmVzczogQWRkcmVzc1plcm8sIGJsb2NrX251bWJlcjogMCB9LFxuICAgICAgICBVc2VyRGVwb3NpdDogeyBhZGRyZXNzOiBBZGRyZXNzWmVybywgYmxvY2tfbnVtYmVyOiAwIH0sXG4gICAgICAgIFNlY3JldFJlZ2lzdHJ5OiB7IGFkZHJlc3M6IEFkZHJlc3NaZXJvLCBibG9ja19udW1iZXI6IDAgfSxcbiAgICB9LFxufSk7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGBzdG9yYWdlT3JTdGF0ZWAgaXMgW1tTdG9yYWdlXV1cbiAqXG4gKiBAcGFyYW0gc3RvcmFnZSAtIGVpdGhlciBzdGF0ZSBvciBbW1N0b3JhZ2VdXVxuICogQHJldHVybnMgdHJ1ZSBpZiBzdG9yYWdlT3JTdGF0ZSBpcyBbW1N0b3JhZ2VdXVxuICovXG5jb25zdCBpc1N0b3JhZ2UgPSAoc3RvcmFnZSkgPT4gc3RvcmFnZSAmJiB0eXBlb2Ygc3RvcmFnZS5nZXRJdGVtID09PSAnZnVuY3Rpb24nO1xuLyoqXG4gKiBMb2FkcyBzdGF0ZSBmcm9tIGBzdG9yYWdlT3JTdGF0ZWAuIFJldHVybnMgdGhlIGluaXRpYWwgW1tSYWlkZW5TdGF0ZV1dIGlmXG4gKiBgc3RvcmFnZU9yU3RhdGVgIGRvZXMgbm90IGV4aXN0LlxuICpcbiAqIEBwYXJhbSBuZXR3b3JrIC0gY3VycmVudCBuZXR3b3JrXG4gKiBAcGFyYW0gY29udHJhY3RzIC0gY3VycmVudCBjb250cmFjdHNcbiAqIEBwYXJhbSBhZGRyZXNzIC0gY3VycmVudCBhZGRyZXNzIG9mIHRoZSBzaWduZXJcbiAqIEBwYXJhbSBzdG9yYWdlT3JTdGF0ZSAtIGVpdGhlciBbW1N0b3JhZ2VdXSBvciBbW1JhaWRlblN0YXRlXV0gb3JcbiAqICAgICAgICB7IHN0b3JhZ2U6IFtbU3RvcmFnZV1dOyBzdGF0ZT86IFtbUmFpZGVuU3RhdGVdXSB9XG4gKiBAcGFyYW0gY29uZmlnIC0gcmFpZGVuIGNvbmZpZ1xuICogQHJldHVybnMgdHJ1ZSBpZiBzdG9yYWdlT3JTdGF0ZSBpcyBbW1N0b3JhZ2VdXVxuICovXG5leHBvcnQgY29uc3QgZ2V0U3RhdGUgPSAobmV0d29yaywgY29udHJhY3RzLCBhZGRyZXNzLCBzdG9yYWdlT3JTdGF0ZSwgY29uZmlnKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBsb2cgPSBsb2dnaW5nLmdldExvZ2dlcihgcmFpZGVuOiR7YWRkcmVzc31gKTtcbiAgICBsZXQgb25TdGF0ZTtcbiAgICBsZXQgb25TdGF0ZUNvbXBsZXRlO1xuICAgIGxldCBzdG9yYWdlO1xuICAgIGxldCBwcm92aWRlZFN0YXRlO1xuICAgIGlmIChpc1N0b3JhZ2Uoc3RvcmFnZU9yU3RhdGUpKSB7XG4gICAgICAgIC8vIHN0YXRlT3JTdG9yYWdlIGlzIHN0b3JhZ2VcbiAgICAgICAgc3RvcmFnZSA9IHN0b3JhZ2VPclN0YXRlO1xuICAgICAgICBwcm92aWRlZFN0YXRlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N0b3JhZ2Uoc3RvcmFnZU9yU3RhdGUgPT09IG51bGwgfHwgc3RvcmFnZU9yU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0b3JhZ2VPclN0YXRlLnN0b3JhZ2UpKSB7XG4gICAgICAgIC8vIHN0YXRlT3JTdG9yYWdlIGlzIGluIHRoZSBmb3JtYXQgeyBzdG9yYWdlOiBTdG9yYWdlOyBzdGF0ZT86IFJhaWRlblN0YXRlIHwgdW5rbm93biB9XG4gICAgICAgIHN0b3JhZ2UgPSBzdG9yYWdlT3JTdGF0ZS5zdG9yYWdlO1xuICAgICAgICBwcm92aWRlZFN0YXRlID0gc3RvcmFnZU9yU3RhdGUuc3RhdGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzdGF0ZU9yU3RvcmFnZSBpcyBzdGF0ZSwgbm8gc3RvcmFnZSBwcm92aWRlZFxuICAgICAgICBzdG9yYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICBwcm92aWRlZFN0YXRlID0gc3RvcmFnZU9yU3RhdGU7XG4gICAgfVxuICAgIGxldCBzdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAocHJvdmlkZWRTdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IGRlY29kZVJhaWRlblN0YXRlKHByb3ZpZGVkU3RhdGUsIHsgbG9nIH0pO1xuICAgIH1cbiAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgICBjb25zdCBucyA9IGByYWlkZW5fJHtnZXROZXR3b3JrTmFtZShuZXR3b3JrKX1fJHtjb250cmFjdHMuVG9rZW5OZXR3b3JrUmVnaXN0cnkuYWRkcmVzc31fJHthZGRyZXNzfWA7XG4gICAgICAgIGNvbnN0IHN0b3JlZERhdGEgPSB5aWVsZCBzdG9yYWdlLmdldEl0ZW0obnMpO1xuICAgICAgICBpZiAoc3RvcmVkRGF0YSkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkU3RhdGUgPSBkZWNvZGVSYWlkZW5TdGF0ZShzdG9yZWREYXRhLCB7IGxvZyB9KTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAvKiBwcm92aWRlZCAqLykge1xuICAgICAgICAgICAgICAgIC8vIGlmIGJvdGggc3RvcmVkICYgcHJvdmlkZWQgc3RhdGUsIGVuc3VyZSB3ZSB3ZXJlbid0IGhhbmRlZCBhbiBvbGRlciBvbmUhXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmJsb2NrTnVtYmVyIDwgc3RvcmVkU3RhdGUuYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuUkROX1NUQVRFX01JR1JBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkU3RhdGVCbG9ja051bWJlcjogc3RvcmVkU3RhdGUuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlZFN0YXRlQmxvY2tOdW1iZXI6IHN0YXRlLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKGBSZXBsYWNpbmcgc3RvcmVkIHN0YXRlIEBibG9ja051bWJlcj0ke3N0b3JlZFN0YXRlLmJsb2NrTnVtYmVyfSB3aXRoIG5ld2VyIHByb3ZpZGVkIHN0YXRlIEBibG9ja051bWJlcj0ke3N0YXRlLmJsb2NrTnVtYmVyfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vIHByb3ZpZGVkIHN0YXRlIGJ1dCB0aGVyZSdzIGEgc3RvcmVkIG9uZSwgdXNlIGl0XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBzdG9yZWRTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBlbHNlLCBubyBzdG9yZWQgc3RhdGUsIGluaXRpYWxpemUgYSBuZXcgb25lIGJlbG93LCBpZiBuZWVkZWRcbiAgICAgICAgLy8gdG8gYmUgc3Vic2NyaWJlZCBvbiByYWlkZW4uc3RhdGUkXG4gICAgICAgIGNvbnN0IGRlYm91bmNlZFN0YXRlID0gZGVib3VuY2UoKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0obnMsIGVuY29kZVJhaWRlblN0YXRlKHN0YXRlKSk7XG4gICAgICAgIH0sIDEwMDAsIHsgbWF4V2FpdDogNTAwMCB9KTtcbiAgICAgICAgb25TdGF0ZSA9IGRlYm91bmNlZFN0YXRlO1xuICAgICAgICBvblN0YXRlQ29tcGxldGUgPSAoKSA9PiBkZWJvdW5jZWRTdGF0ZS5mbHVzaCgpO1xuICAgIH1cbiAgICAvLyBpZiBubyBwcm92aWRlZCBub3Igc3RvcmVkIHN0YXRlLCBpbml0aWFsaXplIGEgcHJpc3RpbmUgb25lXG4gICAgaWYgKCFzdGF0ZSlcbiAgICAgICAgc3RhdGUgPSBtYWtlSW5pdGlhbFN0YXRlKHsgbmV0d29yaywgYWRkcmVzcywgY29udHJhY3RzSW5mbzogY29udHJhY3RzIH0pO1xuICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSBtYWtlRGVmYXVsdENvbmZpZyh7IG5ldHdvcmsgfSwgY29uZmlnKTtcbiAgICByZXR1cm4geyBzdGF0ZSwgb25TdGF0ZSwgb25TdGF0ZUNvbXBsZXRlLCBkZWZhdWx0Q29uZmlnIH07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlLmpzLm1hcCIsIi8qKlxuICogTGlrZSByZWR1eCdzIGNvbWJpbmVSZWR1Y2VycywgYnV0IGFsbG93cyBwYXNzaW5nIG9ubHkgYSBwYXJ0aWFsIHJlZHVjZXIgbWFwcGluZ1xuICogcmVkdXgncyBjb21iaW5lUmVkdWNlcnMgb3V0cHV0IHN0YXRlIG11c3QgYmUgZXhhY3RseSB0aGUgbWFwcGluZyBwYXNzZWQgYXMgcGFyYW1ldGVyLFxuICogd2hpY2ggZG9lc24ndCBhbGxvdyB0byBvbmx5IHByb3ZpZGUgYSBwYXJ0aWFsIHNldCBvZiByZWR1Y2VycyBhbmQgcGFzc3Rocm91Z2ggdGhlIG90aGVyIHN0YXRlJ3NcbiAqIGtleXMuIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHRoYXQsIGFsc28gcHJlc2VydmluZyBzdGF0ZS9vYmplY3QgcmVmZXJlbmNlIHdoZW4gcmVkdWNlcnMgZG9uJ3RcbiAqIGNoYW5nZSBzdGF0ZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gcmVkdWNlcnMgLSBBIG1hcHBpbmcgb2YgYSBzdWJzZXQgb2Ygc3RhdGUncyBrZXkgdG8gbmVzdGVkIHJlZHVjZXJzIGZ1bmN0aW9uc1xuICogQHBhcmFtIGluaXRpYWxTdGF0ZSAtIGdsb2JhbCBpbml0aWFsIHN0YXRlLCByZXF1aXJlZCB3aGVuIGluaXRpYWxpemluZyBmaXJzdCBvYmplY3Qgd2l0aCBwYXJ0aWFsXG4gKiAgICAgICAgICAgICAgICAgICAgICByZWR1Y2Vyc1xuICogQHJldHVybnMgRnVsbCByZWR1Y2VyIGZvciBzdGF0ZSBTIGFuZCBhY3Rpb25zIEFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnRpYWxDb21iaW5lUmVkdWNlcnMocmVkdWNlcnMsIGluaXRpYWxTdGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUgPSBpbml0aWFsU3RhdGUsIGFjdGlvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlZHVjZXJzKSB7XG4gICAgICAgICAgICBjb25zdCByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICAgICAgICAgIGlmICghcmVkdWNlcilcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2hvdWxkbid0IGhhcHBlbiwgb25seSBoZXJlIGZvciB0eXBlIHNhZmV0eSBiZWxvd1xuICAgICAgICAgICAgY29uc3Qgc3ViU3RhdGUgPSAoX2EgPSBzdGF0ZVtrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpbml0aWFsU3RhdGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N1YlN0YXRlID0gcmVkdWNlcihzdWJTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChuZXdTdWJTdGF0ZSAhPT0gc3ViU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7IFtrZXldOiBuZXdTdWJTdGF0ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHV4LmpzLm1hcCIsImltcG9ydCBnZXQgZnJvbSAnbG9kYXNoL2ZwL2dldCc7XG5pbXBvcnQgc2V0IGZyb20gJ2xvZGFzaC9mcC9zZXQnO1xuaW1wb3J0IHVuc2V0IGZyb20gJ2xvZGFzaC9mcC91bnNldCc7XG5pbXBvcnQgZ2V0T3IgZnJvbSAnbG9kYXNoL2ZwL2dldE9yJztcbmltcG9ydCB7IFplcm8gfSBmcm9tICdldGhlcnMvY29uc3RhbnRzJztcbmltcG9ydCB7IGNyZWF0ZVJlZHVjZXIsIGlzQWN0aW9uT2YgfSBmcm9tICcuLi91dGlscy9hY3Rpb25zJztcbmltcG9ydCB7IHBhcnRpYWxDb21iaW5lUmVkdWNlcnMgfSBmcm9tICcuLi91dGlscy9yZWR1eCc7XG5pbXBvcnQgeyBpbml0aWFsU3RhdGUgfSBmcm9tICcuLi9zdGF0ZSc7XG5pbXBvcnQgeyBDb25maXJtYWJsZUFjdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zJztcbmltcG9ydCB7IGNoYW5uZWxDbG9zZSwgY2hhbm5lbERlcG9zaXQsIGNoYW5uZWxPcGVuLCBjaGFubmVsU2V0dGxlLCBjaGFubmVsU2V0dGxlYWJsZSwgbmV3QmxvY2ssIHRva2VuTW9uaXRvcmVkLCBjaGFubmVsV2l0aGRyYXduLCB9IGZyb20gJy4vYWN0aW9ucyc7XG5pbXBvcnQgeyBDaGFubmVsU3RhdGUgfSBmcm9tICcuL3N0YXRlJztcbi8vIHN0YXRlLmJsb2NrTnVtYmVyIHNwZWNpZmljIHJlZHVjZXIsIGhhbmRsZXMgb25seSBuZXdCbG9jayBhY3Rpb25cbmNvbnN0IGJsb2NrTnVtYmVyID0gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUuYmxvY2tOdW1iZXIpLmhhbmRsZShuZXdCbG9jaywgKHt9LCB7IHBheWxvYWQgfSkgPT4gcGF5bG9hZC5ibG9ja051bWJlcik7XG4vLyBzdGF0ZS50b2tlbnMgc3BlY2lmaWMgcmVkdWNlciwgaGFuZGxlcyBvbmx5IHRva2VuTW9uaXRvcmVkIGFjdGlvblxuY29uc3QgdG9rZW5zID0gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUudG9rZW5zKS5oYW5kbGUodG9rZW5Nb25pdG9yZWQsIChzdGF0ZSwgeyBwYXlsb2FkOiB7IHRva2VuLCB0b2tlbk5ldHdvcmsgfSB9KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgW3Rva2VuXTogdG9rZW5OZXR3b3JrIH0pKSk7XG4vLyBSZWR1Y2VycyBmb3IgZGlmZmVyZW50IGFjdGlvbnNcbmZ1bmN0aW9uIGNoYW5uZWxPcGVuUmVxdWVzdFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIGNvbnN0IHBhdGggPSBbYWN0aW9uLm1ldGEudG9rZW5OZXR3b3JrLCBhY3Rpb24ubWV0YS5wYXJ0bmVyXTtcbiAgICBpZiAoZ2V0KHBhdGgsIHN0YXRlKSlcbiAgICAgICAgcmV0dXJuIHN0YXRlOyAvLyB0aGVyZSdzIGFscmVhZHkgYSBjaGFubmVsIHdpdGggcGFydG5lclxuICAgIGNvbnN0IGNoYW5uZWwgPSB7XG4gICAgICAgIHN0YXRlOiBDaGFubmVsU3RhdGUub3BlbmluZyxcbiAgICAgICAgb3duOiB7IGRlcG9zaXQ6IFplcm8gfSxcbiAgICAgICAgcGFydG5lcjogeyBkZXBvc2l0OiBaZXJvIH0sXG4gICAgfTtcbiAgICByZXR1cm4gc2V0KHBhdGgsIGNoYW5uZWwsIHN0YXRlKTtcbn1cbmZ1bmN0aW9uIGNoYW5uZWxPcGVuU3VjY2Vzc1JlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIGNvbnN0IHBhdGggPSBbYWN0aW9uLm1ldGEudG9rZW5OZXR3b3JrLCBhY3Rpb24ubWV0YS5wYXJ0bmVyXTtcbiAgICAvLyBpZ25vcmUgaWYgb2xkZXIgdGhhbiBjdXJyZW50bHkgc2V0IGNoYW5uZWwsIG9yIHVuY29uZmlybWVkIG9yIHJlbW92ZWRcbiAgICBpZiAoZ2V0T3IoMCwgWy4uLnBhdGgsICdvcGVuQmxvY2snXSwgc3RhdGUpID49IGFjdGlvbi5wYXlsb2FkLnR4QmxvY2sgfHxcbiAgICAgICAgIWFjdGlvbi5wYXlsb2FkLmNvbmZpcm1lZClcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGNvbnN0IGNoYW5uZWwgPSB7XG4gICAgICAgIHN0YXRlOiBDaGFubmVsU3RhdGUub3BlbixcbiAgICAgICAgb3duOiB7IGRlcG9zaXQ6IFplcm8gfSxcbiAgICAgICAgcGFydG5lcjogeyBkZXBvc2l0OiBaZXJvIH0sXG4gICAgICAgIGlkOiBhY3Rpb24ucGF5bG9hZC5pZCxcbiAgICAgICAgc2V0dGxlVGltZW91dDogYWN0aW9uLnBheWxvYWQuc2V0dGxlVGltZW91dCxcbiAgICAgICAgaXNGaXJzdFBhcnRpY2lwYW50OiBhY3Rpb24ucGF5bG9hZC5pc0ZpcnN0UGFydGljaXBhbnQsXG4gICAgICAgIG9wZW5CbG9jazogYWN0aW9uLnBheWxvYWQudHhCbG9jayxcbiAgICB9O1xuICAgIHJldHVybiBzZXQocGF0aCwgY2hhbm5lbCwgc3RhdGUpO1xufVxuZnVuY3Rpb24gY2hhbm5lbE9wZW5GYWlsdXJlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgcGF0aCA9IFthY3Rpb24ubWV0YS50b2tlbk5ldHdvcmssIGFjdGlvbi5tZXRhLnBhcnRuZXJdO1xuICAgIGlmIChnZXQoWy4uLnBhdGgsICdzdGF0ZSddLCBzdGF0ZSkgIT09IENoYW5uZWxTdGF0ZS5vcGVuaW5nKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgcmV0dXJuIHVuc2V0KHBhdGgsIHN0YXRlKTtcbn1cbmZ1bmN0aW9uIGNoYW5uZWxVcGRhdGVPbmNoYWluQmFsYW5jZVN0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgLy8gaWdub3JlIGV2ZW50IGlmIHVuY29uZmlybWVkIG9yIHJlbW92ZWRcbiAgICBpZiAoIWFjdGlvbi5wYXlsb2FkLmNvbmZpcm1lZClcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGNvbnN0IHBhdGggPSBbYWN0aW9uLm1ldGEudG9rZW5OZXR3b3JrLCBhY3Rpb24ubWV0YS5wYXJ0bmVyXTtcbiAgICBsZXQgY2hhbm5lbCA9IGdldChwYXRoLCBzdGF0ZSk7XG4gICAgaWYgKCFjaGFubmVsIHx8IGNoYW5uZWwuc3RhdGUgIT09IENoYW5uZWxTdGF0ZS5vcGVuIHx8IGNoYW5uZWwuaWQgIT09IGFjdGlvbi5wYXlsb2FkLmlkKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgY29uc3Qga2V5ID0gY2hhbm5lbFdpdGhkcmF3bi5pcyhhY3Rpb24pID8gJ3dpdGhkcmF3JyA6ICdkZXBvc2l0JztcbiAgICBjb25zdCB0b3RhbCA9IGNoYW5uZWxXaXRoZHJhd24uaXMoYWN0aW9uKVxuICAgICAgICA/IGFjdGlvbi5wYXlsb2FkLnRvdGFsV2l0aGRyYXdcbiAgICAgICAgOiBhY3Rpb24ucGF5bG9hZC50b3RhbERlcG9zaXQ7XG4gICAgY29uc3QgaXNQYXJ0bmVyID0gYWN0aW9uLnBheWxvYWQucGFydGljaXBhbnQgPT09IGFjdGlvbi5tZXRhLnBhcnRuZXI7XG4gICAgY29uc3QgY2hhbm5lbFNpZGUgPSBpc1BhcnRuZXIgPyAncGFydG5lcicgOiAnb3duJztcbiAgICBjb25zdCBjaGFubmVsRW5kRGF0YSA9IGlzUGFydG5lciA/IGNoYW5uZWwucGFydG5lciA6IGNoYW5uZWwub3duO1xuICAgIGNoYW5uZWwgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoYW5uZWwpLCB7IFtjaGFubmVsU2lkZV06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hhbm5lbEVuZERhdGEpLCB7IFtrZXldOiB0b3RhbCB9KSB9KTtcbiAgICByZXR1cm4gc2V0KHBhdGgsIGNoYW5uZWwsIHN0YXRlKTtcbn1cbmZ1bmN0aW9uIGNoYW5uZWxDbG9zZVN1Y2Nlc3NSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCBwYXRoID0gW2FjdGlvbi5tZXRhLnRva2VuTmV0d29yaywgYWN0aW9uLm1ldGEucGFydG5lcl07XG4gICAgbGV0IGNoYW5uZWwgPSBnZXQocGF0aCwgc3RhdGUpO1xuICAgIGlmICghY2hhbm5lbCB8fFxuICAgICAgICAhKGNoYW5uZWwuc3RhdGUgPT09IENoYW5uZWxTdGF0ZS5vcGVuIHx8IGNoYW5uZWwuc3RhdGUgPT09IENoYW5uZWxTdGF0ZS5jbG9zaW5nKSB8fFxuICAgICAgICBjaGFubmVsLmlkICE9PSBhY3Rpb24ucGF5bG9hZC5pZClcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIC8vIGV2ZW4gb24gbm9uLWNvbmZpcm1lZCBhY3Rpb24sIGFscmVhZHkgc2V0IGNoYW5uZWwgc3RhdGUgYXMgY2xvc2luZywgc28gaXQgY2FuJ3QgYmUgdXNlZCBmb3IgbmV3IHRyYW5zZmVyc1xuICAgIGlmIChhY3Rpb24ucGF5bG9hZC5jb25maXJtZWQgPT09IHVuZGVmaW5lZCAmJiBjaGFubmVsLnN0YXRlID09PSBDaGFubmVsU3RhdGUub3BlbilcbiAgICAgICAgY2hhbm5lbCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hhbm5lbCksIHsgc3RhdGU6IENoYW5uZWxTdGF0ZS5jbG9zaW5nIH0pO1xuICAgIGVsc2UgaWYgKGFjdGlvbi5wYXlsb2FkLmNvbmZpcm1lZClcbiAgICAgICAgY2hhbm5lbCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hhbm5lbCksIHsgc3RhdGU6IENoYW5uZWxTdGF0ZS5jbG9zZWQsIGNsb3NlQmxvY2s6IGFjdGlvbi5wYXlsb2FkLnR4QmxvY2ssIGNsb3NlUGFydGljaXBhbnQ6IGFjdGlvbi5wYXlsb2FkLnBhcnRpY2lwYW50IH0pO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIHJldHVybiBzZXQocGF0aCwgY2hhbm5lbCwgc3RhdGUpO1xufVxuZnVuY3Rpb24gY2hhbm5lbFVwZGF0ZVN0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgcGF0aCA9IFthY3Rpb24ubWV0YS50b2tlbk5ldHdvcmssIGFjdGlvbi5tZXRhLnBhcnRuZXJdO1xuICAgIGxldCBjaGFubmVsID0gZ2V0KHBhdGgsIHN0YXRlKTtcbiAgICBpZiAoIWNoYW5uZWwpXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICBpZiAoY2hhbm5lbENsb3NlLnJlcXVlc3QuaXMoYWN0aW9uKSAmJiBjaGFubmVsLnN0YXRlID09PSBDaGFubmVsU3RhdGUub3Blbikge1xuICAgICAgICBjaGFubmVsID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGFubmVsKSwgeyBzdGF0ZTogQ2hhbm5lbFN0YXRlLmNsb3NpbmcgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYW5uZWxTZXR0bGUucmVxdWVzdC5pcyhhY3Rpb24pICYmIGNoYW5uZWwuc3RhdGUgPT09IENoYW5uZWxTdGF0ZS5zZXR0bGVhYmxlKSB7XG4gICAgICAgIGNoYW5uZWwgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoYW5uZWwpLCB7IHN0YXRlOiBDaGFubmVsU3RhdGUuc2V0dGxpbmcgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYW5uZWxTZXR0bGVhYmxlLmlzKGFjdGlvbikgJiYgY2hhbm5lbC5zdGF0ZSA9PT0gQ2hhbm5lbFN0YXRlLmNsb3NlZCkge1xuICAgICAgICBjaGFubmVsID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGFubmVsKSwgeyBzdGF0ZTogQ2hhbm5lbFN0YXRlLnNldHRsZWFibGUgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiBzZXQocGF0aCwgY2hhbm5lbCwgc3RhdGUpO1xufVxuZnVuY3Rpb24gY2hhbm5lbFNldHRsZVN1Y2Nlc3NSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCBwYXRoID0gW2FjdGlvbi5tZXRhLnRva2VuTmV0d29yaywgYWN0aW9uLm1ldGEucGFydG5lcl07XG4gICAgY29uc3QgY2hhbm5lbCA9IGdldChwYXRoLCBzdGF0ZSk7XG4gICAgaWYgKCFjaGFubmVsIHx8XG4gICAgICAgIGNoYW5uZWwuc3RhdGUgPT09IENoYW5uZWxTdGF0ZS5vcGVuaW5nIHx8XG4gICAgICAgIGNoYW5uZWwuc3RhdGUgPT09IENoYW5uZWxTdGF0ZS5vcGVuIHx8XG4gICAgICAgIGNoYW5uZWwuc3RhdGUgPT09IENoYW5uZWxTdGF0ZS5jbG9zaW5nIHx8XG4gICAgICAgIGNoYW5uZWwuaWQgIT09IGFjdGlvbi5wYXlsb2FkLmlkKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgLy8gZXZlbiBvbiBub24tY29uZmlybWVkIGFjdGlvbiwgYWxyZWFkeSBzZXQgY2hhbm5lbCBhcyBzZXR0bGluZ1xuICAgIGlmIChhY3Rpb24ucGF5bG9hZC5jb25maXJtZWQgPT09IHVuZGVmaW5lZCAmJiBjaGFubmVsLnN0YXRlICE9PSBDaGFubmVsU3RhdGUuc2V0dGxpbmcpXG4gICAgICAgIHJldHVybiBzZXQocGF0aCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGFubmVsKSwgeyBzdGF0ZTogQ2hhbm5lbFN0YXRlLnNldHRsaW5nIH0pLCBzdGF0ZSk7XG4gICAgZWxzZSBpZiAoYWN0aW9uLnBheWxvYWQuY29uZmlybWVkKVxuICAgICAgICByZXR1cm4gdW5zZXQocGF0aCwgc3RhdGUpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xufVxuLy8gaGFuZGxlcyBhbGwgY2hhbm5lbCBhY3Rpb25zIGFuZCByZXF1ZXN0c1xuY29uc3QgY2hhbm5lbHMgPSBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZS5jaGFubmVscylcbiAgICAuaGFuZGxlKGNoYW5uZWxPcGVuLnJlcXVlc3QsIGNoYW5uZWxPcGVuUmVxdWVzdFJlZHVjZXIpXG4gICAgLmhhbmRsZShjaGFubmVsT3Blbi5zdWNjZXNzLCBjaGFubmVsT3BlblN1Y2Nlc3NSZWR1Y2VyKVxuICAgIC5oYW5kbGUoY2hhbm5lbE9wZW4uZmFpbHVyZSwgY2hhbm5lbE9wZW5GYWlsdXJlUmVkdWNlcilcbiAgICAuaGFuZGxlKFtjaGFubmVsRGVwb3NpdC5zdWNjZXNzLCBjaGFubmVsV2l0aGRyYXduXSwgY2hhbm5lbFVwZGF0ZU9uY2hhaW5CYWxhbmNlU3RhdGVSZWR1Y2VyKVxuICAgIC5oYW5kbGUoW2NoYW5uZWxDbG9zZS5yZXF1ZXN0LCBjaGFubmVsU2V0dGxlYWJsZSwgY2hhbm5lbFNldHRsZS5yZXF1ZXN0XSwgY2hhbm5lbFVwZGF0ZVN0YXRlUmVkdWNlcilcbiAgICAuaGFuZGxlKGNoYW5uZWxDbG9zZS5zdWNjZXNzLCBjaGFubmVsQ2xvc2VTdWNjZXNzUmVkdWNlcilcbiAgICAuaGFuZGxlKGNoYW5uZWxTZXR0bGUuc3VjY2VzcywgY2hhbm5lbFNldHRsZVN1Y2Nlc3NSZWR1Y2VyKTtcbmNvbnN0IHBlbmRpbmdUeHMgPSAoc3RhdGUgPSBpbml0aWFsU3RhdGUucGVuZGluZ1R4cywgYWN0aW9uKSA9PiB7XG4gICAgLy8gZmlsdGVyIG91dCBub24tQ29uZmlybWFibGVBY3Rpb25zJ3NcbiAgICBpZiAoIWlzQWN0aW9uT2YoQ29uZmlybWFibGVBY3Rpb25zLCBhY3Rpb24pKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgLy8gaWYgY29uZmlybWVkPT11bmRlZmluZWQsIGFkZCBhY3Rpb24gdG8gc3RhdGVcbiAgICBlbHNlIGlmIChhY3Rpb24ucGF5bG9hZC5jb25maXJtZWQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIFsuLi5zdGF0ZSwgYWN0aW9uXTtcbiAgICAvLyBlbHNlIChlaXRoZXIgY29uZmlybWVkIG9yIHJlbW92ZWQpLCByZW1vdmUgZnJvbSBzdGF0ZVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlLmZpbHRlcigoYSkgPT4gYS50eXBlICE9PSBhY3Rpb24udHlwZSB8fCBhY3Rpb24ucGF5bG9hZC50eEhhc2ggIT09IGEucGF5bG9hZC50eEhhc2gpO1xuICAgICAgICBpZiAobmV3U3RhdGUubGVuZ3RoICE9PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59O1xuLyoqXG4gKiBOZXN0ZWQvY29tYmluZWQgcmVkdWNlciBmb3IgY2hhbm5lbHNcbiAqIGJsb2NrTnVtYmVyLCB0b2tlbnMgJiBjaGFubmVscyByZWR1Y2VycyBnZXQgaXRzIG93biBzbGljZSBvZiB0aGUgc3RhdGUsIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gKiBuYW1lIG9mIHRoZSByZWR1Y2VyLiBjaGFubmVscyByb290IHJlZHVjZXIgaW5zdGVhZCBtdXN0IGJlIGhhbmRsZWQgdGhlIGNvbXBsZXRlIHN0YXRlIGluc3RlYWQsXG4gKiBzbyBpdCBjb21wb3NlIHRoZSBvdXRwdXQgd2l0aCBlYWNoIGtleS9uZXN0ZWQvY29tYmluZWQgc3RhdGUuXG4gKi9cbmV4cG9ydCBjb25zdCBjaGFubmVsc1JlZHVjZXIgPSBwYXJ0aWFsQ29tYmluZVJlZHVjZXJzKHsgYmxvY2tOdW1iZXIsIHRva2VucywgY2hhbm5lbHMsIHBlbmRpbmdUeHMgfSwgaW5pdGlhbFN0YXRlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZXIuanMubWFwIiwiLyoqXG4gKiBzdGF0ZS5wYXRoIHJlZHVjZXJcbiAqIEhhbmRsZXMgYWxsIHBhdGggYWN0aW9ucyBhbmQgcmVxdWVzdHNcbiAqXG4gKiBAcGFyYW0gc3RhdGUgLSBDdXJyZW50IFJhaWRlblN0YXRlWydwYXRoJ10gc2xpY2VcbiAqIEBwYXJhbSBhY3Rpb24gLSBSYWlkZW5BY3Rpb24gdG8gaGFuZGxlXG4gKiBAcmV0dXJucyBOZXcgUmFpZGVuU3RhdGVbJ3BhdGgnXSBzbGljZVxuICovXG5pbXBvcnQgc2V0IGZyb20gJ2xvZGFzaC9mcC9zZXQnO1xuaW1wb3J0IHVuc2V0IGZyb20gJ2xvZGFzaC9mcC91bnNldCc7XG5pbXBvcnQgeyBpbml0aWFsU3RhdGUgfSBmcm9tICcuLi9zdGF0ZSc7XG5pbXBvcnQgeyBwYXJ0aWFsQ29tYmluZVJlZHVjZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVkdXgnO1xuaW1wb3J0IHsgY3JlYXRlUmVkdWNlciB9IGZyb20gJy4uL3V0aWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgaW91Q2xlYXIsIGlvdVBlcnNpc3QgfSBmcm9tICcuL2FjdGlvbnMnO1xuY29uc3QgcGF0aCA9IGNyZWF0ZVJlZHVjZXIoaW5pdGlhbFN0YXRlLnBhdGgpXG4gICAgLmhhbmRsZShpb3VQZXJzaXN0LCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IHBhdGggPSBbJ2lvdScsIGFjdGlvbi5tZXRhLnRva2VuTmV0d29yaywgYWN0aW9uLm1ldGEuc2VydmljZUFkZHJlc3NdO1xuICAgIHJldHVybiBzZXQocGF0aCwgYWN0aW9uLnBheWxvYWQuaW91LCBzdGF0ZSk7XG59KVxuICAgIC5oYW5kbGUoaW91Q2xlYXIsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgcGF0aCA9IFsnaW91JywgYWN0aW9uLm1ldGEudG9rZW5OZXR3b3JrLCBhY3Rpb24ubWV0YS5zZXJ2aWNlQWRkcmVzc107XG4gICAgcmV0dXJuIHVuc2V0KHBhdGgsIHN0YXRlKTtcbn0pO1xuLyoqXG4gKiBOZXN0ZWQgY29tYmluZWQgcmVkdWNlciBmb3IgcGF0aFxuICogSGFuZGxlcyB0aGUgJ3BhdGgnIHN1YnN0YXRlLlxuICovXG5leHBvcnQgY29uc3QgcGF0aFJlZHVjZXIgPSBwYXJ0aWFsQ29tYmluZVJlZHVjZXJzKHsgcGF0aCB9LCBpbml0aWFsU3RhdGUpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkdWNlci5qcy5tYXAiLCJ2YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5pbXBvcnQgZ2V0IGZyb20gJ2xvZGFzaC9mcC9nZXQnO1xuaW1wb3J0IGdldE9yIGZyb20gJ2xvZGFzaC9mcC9nZXRPcic7XG5pbXBvcnQgaXNFbXB0eSBmcm9tICdsb2Rhc2gvZnAvaXNFbXB0eSc7XG5pbXBvcnQgc2V0IGZyb20gJ2xvZGFzaC9mcC9zZXQnO1xuaW1wb3J0IHVuc2V0IGZyb20gJ2xvZGFzaC9mcC91bnNldCc7XG5pbXBvcnQgeyBwYXJ0aWFsQ29tYmluZVJlZHVjZXJzIH0gZnJvbSAnLi4vdXRpbHMvcmVkdXgnO1xuaW1wb3J0IHsgY3JlYXRlUmVkdWNlciB9IGZyb20gJy4uL3V0aWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgaW5pdGlhbFN0YXRlIH0gZnJvbSAnLi4vc3RhdGUnO1xuaW1wb3J0IHsgbWF0cml4U2V0dXAsIG1hdHJpeFJvb20sIG1hdHJpeFJvb21MZWF2ZSB9IGZyb20gJy4vYWN0aW9ucyc7XG4vKipcbiAqIHN0YXRlLnRyYW5zcG9ydCByZWR1Y2VyXG4gKiBIYW5kbGVzIGFsbCB0cmFuc3BvcnQgYWN0aW9ucyBhbmQgcmVxdWVzdHNcbiAqXG4gKiBAcGFyYW0gc3RhdGUgLSBDdXJyZW50IFJhaWRlblN0YXRlWyd0cmFuc3BvcnQnXSBzbGljZVxuICogQHBhcmFtIGFjdGlvbiAtIFJhaWRlbkFjdGlvbiB0byBoYW5kbGVcbiAqIEByZXR1cm5zIE5ldyBSYWlkZW5TdGF0ZVsndHJhbnNwb3J0J10gc2xpY2VcbiAqL1xuY29uc3QgdHJhbnNwb3J0ID0gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUudHJhbnNwb3J0KVxuICAgIC5oYW5kbGUobWF0cml4U2V0dXAsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIC8vIGltbXV0YWJseSByZW1vdmUgcm9vbXMgZnJvbSBzdGF0ZS5tYXRyaXhcbiAgICBjb25zdCBfYiA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLm1hdHJpeCksIHsgcm9vbXM6IF8gfSA9IF9iLCBub1Jvb21zID0gX19yZXN0KF9iLCBbXCJyb29tc1wiXSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCB7IG1hdHJpeDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoKChfYSA9IHN0YXRlLm1hdHJpeCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlcnZlcikgIT09IGFjdGlvbi5wYXlsb2FkLnNlcnZlciA/IG5vUm9vbXMgOiBzdGF0ZS5tYXRyaXgpKSwgYWN0aW9uLnBheWxvYWQpIH0pO1xufSlcbiAgICAuaGFuZGxlKG1hdHJpeFJvb20sIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgcGF0aCA9IFsnbWF0cml4JywgJ3Jvb21zJywgYWN0aW9uLm1ldGEuYWRkcmVzc107XG4gICAgcmV0dXJuIHNldChwYXRoLCBbXG4gICAgICAgIGFjdGlvbi5wYXlsb2FkLnJvb21JZCxcbiAgICAgICAgLi4uZ2V0T3IoW10sIHBhdGgsIHN0YXRlKS5maWx0ZXIoKHJvb20pID0+IHJvb20gIT09IGFjdGlvbi5wYXlsb2FkLnJvb21JZCksXG4gICAgXSwgc3RhdGUpO1xufSlcbiAgICAuaGFuZGxlKG1hdHJpeFJvb21MZWF2ZSwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBjb25zdCBwYXRoID0gWydtYXRyaXgnLCAncm9vbXMnLCBhY3Rpb24ubWV0YS5hZGRyZXNzXTtcbiAgICBzdGF0ZSA9IHNldChwYXRoLCBnZXRPcihbXSwgcGF0aCwgc3RhdGUpLmZpbHRlcigocikgPT4gciAhPT0gYWN0aW9uLnBheWxvYWQucm9vbUlkKSwgc3RhdGUpO1xuICAgIGlmIChpc0VtcHR5KGdldChwYXRoLCBzdGF0ZSkpKVxuICAgICAgICBzdGF0ZSA9IHVuc2V0KHBhdGgsIHN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGU7XG59KTtcbi8qKlxuICogTmVzdGVkL2NvbWJpbmVkIHJlZHVjZXIgZm9yIHRyYW5zcG9ydFxuICogQ3VycmVudGx5IG9ubHkgaGFuZGxlcyAndHJhbnNwb3J0JyBzdWJzdGF0ZVxuICovXG5leHBvcnQgY29uc3QgdHJhbnNwb3J0UmVkdWNlciA9IHBhcnRpYWxDb21iaW5lUmVkdWNlcnMoeyB0cmFuc3BvcnQgfSwgaW5pdGlhbFN0YXRlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZXIuanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgKiBhcyB0IGZyb20gJ2lvLXRzJztcbmltcG9ydCB7IGtlY2NhazI1NiwgUkxQLCB2ZXJpZnlNZXNzYWdlIH0gZnJvbSAnZXRoZXJzL3V0aWxzJztcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleGxpZnkgfSBmcm9tICdldGhlcnMvdXRpbHMvYnl0ZXMnO1xuaW1wb3J0IHsgZW5jb2RlIGFzIHJscEVuY29kZSB9IGZyb20gJ2V0aGVycy91dGlscy9ybHAnO1xuaW1wb3J0IHsgSGFzaFplcm8gfSBmcm9tICdldGhlcnMvY29uc3RhbnRzJztcbmltcG9ydCBsb2dnaW5nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7IFNpZ25hdHVyZSwgU2lnbmVkLCBkZWNvZGUsIGFzc2VydCB9IGZyb20gJy4uL3V0aWxzL3R5cGVzJztcbmltcG9ydCB7IGVuY29kZSwgbG9zc2xlc3NQYXJzZSwgbG9zc2xlc3NTdHJpbmdpZnkgfSBmcm9tICcuLi91dGlscy9kYXRhJztcbmltcG9ydCB7IE1lc3NhZ2UsIE1lc3NhZ2VUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBtZXNzYWdlUmVjZWl2ZWQgfSBmcm9tICcuL2FjdGlvbnMnO1xuY29uc3QgQ01ESURzID0ge1xuICAgIFtNZXNzYWdlVHlwZS5ERUxJVkVSRURdOiAxMixcbiAgICBbTWVzc2FnZVR5cGUuUFJPQ0VTU0VEXTogMCxcbiAgICBbTWVzc2FnZVR5cGUuU0VDUkVUX1JFUVVFU1RdOiAzLFxuICAgIFtNZXNzYWdlVHlwZS5TRUNSRVRfUkVWRUFMXTogMTEsXG4gICAgW01lc3NhZ2VUeXBlLkxPQ0tFRF9UUkFOU0ZFUl06IDcsXG4gICAgW01lc3NhZ2VUeXBlLlJFRlVORF9UUkFOU0ZFUl06IDgsXG4gICAgW01lc3NhZ2VUeXBlLlVOTE9DS106IDQsXG4gICAgW01lc3NhZ2VUeXBlLkxPQ0tfRVhQSVJFRF06IDEzLFxuICAgIFtNZXNzYWdlVHlwZS5XSVRIRFJBV19SRVFVRVNUXTogMTUsXG4gICAgW01lc3NhZ2VUeXBlLldJVEhEUkFXX0NPTkZJUk1BVElPTl06IDE2LFxuICAgIFtNZXNzYWdlVHlwZS5XSVRIRFJBV19FWFBJUkVEXTogMTcsXG4gICAgW01lc3NhZ2VUeXBlLlBGU19DQVBBQ0lUWV9VUERBVEVdOiAtMSxcbiAgICBbTWVzc2FnZVR5cGUuUEZTX0ZFRV9VUERBVEVdOiAtMSxcbn07XG4vLyByYWlkZW5fY29udHJhY3RzLmNvbnN0YW50cy5NZXNzYWdlVHlwZUlkXG5leHBvcnQgdmFyIE1lc3NhZ2VUeXBlSWQ7XG4oZnVuY3Rpb24gKE1lc3NhZ2VUeXBlSWQpIHtcbiAgICBNZXNzYWdlVHlwZUlkW01lc3NhZ2VUeXBlSWRbXCJCQUxBTkNFX1BST09GXCJdID0gMV0gPSBcIkJBTEFOQ0VfUFJPT0ZcIjtcbiAgICBNZXNzYWdlVHlwZUlkW01lc3NhZ2VUeXBlSWRbXCJXSVRIRFJBV1wiXSA9IDNdID0gXCJXSVRIRFJBV1wiO1xuICAgIE1lc3NhZ2VUeXBlSWRbTWVzc2FnZVR5cGVJZFtcIklPVVwiXSA9IDVdID0gXCJJT1VcIjtcbn0pKE1lc3NhZ2VUeXBlSWQgfHwgKE1lc3NhZ2VUeXBlSWQgPSB7fSkpO1xuLyoqXG4gKiBDcmVhdGUgdGhlIGhhc2ggb2YgTWV0YWRhdGEgc3RydWN0dXJlLlxuICpcbiAqIEBwYXJhbSBtZXRhZGF0YSAtIFRoZSBMb2NrZWRUcmFuc2ZlciBtZXRhZGF0YVxuICogQHJldHVybnMgSGFzaCBvZiB0aGUgbWV0YWRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZXRhZGF0YUhhc2gobWV0YWRhdGEpIHtcbiAgICBjb25zdCByb3V0ZUhhc2hlcyA9IG1ldGFkYXRhLnJvdXRlcy5tYXAoKHZhbHVlKSA9PiBrZWNjYWsyNTYoUkxQLmVuY29kZSh2YWx1ZS5yb3V0ZSkpKTtcbiAgICByZXR1cm4ga2VjY2FrMjU2KFJMUC5lbmNvZGUocm91dGVIYXNoZXMpKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGJhbGFuY2VfaGFzaCBmcm9tIHRyYW5zZmVycmVkJmxvY2tlZCBhbW91bnRzICYgbG9ja3Nyb290XG4gKlxuICogQHBhcmFtIHRyYW5zZmVycmVkQW1vdW50IC0gRW52ZWxvcGVNZXNzYWdlLnRyYW5zZmVycmVkX2Ftb3VudFxuICogQHBhcmFtIGxvY2tlZEFtb3VudCAtIEVudmVsb3BlTWVzc2FnZS5sb2NrZWRfYW1vdW50XG4gKiBAcGFyYW0gbG9ja3Nyb290IC0gSGFzaCBvZiBhbGwgY3VycmVudCBsb2Nrc1xuICogQHJldHVybnMgSGFzaCBvZiB0aGUgYmFsYW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQmFsYW5jZUhhc2godHJhbnNmZXJyZWRBbW91bnQsIGxvY2tlZEFtb3VudCwgbG9ja3Nyb290KSB7XG4gICAgcmV0dXJuICh0cmFuc2ZlcnJlZEFtb3VudC5pc1plcm8oKSAmJiBsb2NrZWRBbW91bnQuaXNaZXJvKCkgJiYgbG9ja3Nyb290ID09PSBIYXNoWmVyb1xuICAgICAgICA/IEhhc2haZXJvXG4gICAgICAgIDoga2VjY2FrMjU2KGNvbmNhdChbZW5jb2RlKHRyYW5zZmVycmVkQW1vdW50LCAzMiksIGVuY29kZShsb2NrZWRBbW91bnQsIDMyKSwgZW5jb2RlKGxvY2tzcm9vdCwgMzIpXSkpKTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBtZXNzYWdlSGFzaCBmb3IgYSBnaXZlbiBFbnZlbG9wZU1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIEVudmVsb3BlTWVzc2FnZSB0byBwYWNrXG4gKiBAcmV0dXJucyBIYXNoIG9mIHRoZSBtZXNzYWdlIHBhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VIYXNoKG1lc3NhZ2UpIHtcbiAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLkxPQ0tFRF9UUkFOU0ZFUjpcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5SRUZVTkRfVFJBTlNGRVI6XG4gICAgICAgICAgICAvLyBoYXNoIG9mIHBhY2tlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgd2hvbGUgbWVzc2FnZVxuICAgICAgICAgICAgbGV0IHBhY2tlZCA9IGNvbmNhdChbXG4gICAgICAgICAgICAgICAgZW5jb2RlKENNRElEc1ttZXNzYWdlLnR5cGVdLCAxKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5tZXNzYWdlX2lkZW50aWZpZXIsIDgpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLnBheW1lbnRfaWRlbnRpZmllciwgOCksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UubG9jay5leHBpcmF0aW9uLCAzMiksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UudG9rZW4sIDIwKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5yZWNpcGllbnQsIDIwKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS50YXJnZXQsIDIwKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5pbml0aWF0b3IsIDIwKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5sb2NrLnNlY3JldGhhc2gsIDMyKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5sb2NrLmFtb3VudCwgMzIpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBNZXNzYWdlVHlwZS5MT0NLRURfVFJBTlNGRVIpXG4gICAgICAgICAgICAgICAgcGFja2VkID0gY29uY2F0KFtwYWNrZWQsIGNyZWF0ZU1ldGFkYXRhSGFzaChtZXNzYWdlLm1ldGFkYXRhKV0pO1xuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1NihwYWNrZWQpO1xuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlVOTE9DSzpcbiAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoY29uY2F0KFtcbiAgICAgICAgICAgICAgICBlbmNvZGUoQ01ESURzW21lc3NhZ2UudHlwZV0sIDEpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLm1lc3NhZ2VfaWRlbnRpZmllciwgOCksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UucGF5bWVudF9pZGVudGlmaWVyLCA4KSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5zZWNyZXQsIDMyKSxcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5MT0NLX0VYUElSRUQ6XG4gICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChbXG4gICAgICAgICAgICAgICAgZW5jb2RlKENNRElEc1ttZXNzYWdlLnR5cGVdLCAxKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5tZXNzYWdlX2lkZW50aWZpZXIsIDgpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLnJlY2lwaWVudCwgMjApLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLnNlY3JldGhhc2gsIDMyKSxcbiAgICAgICAgICAgIF0pKTtcbiAgICB9XG59XG4vKipcbiAqIFBhY2sgYSBtZXNzYWdlIGluIGEgaGV4LXN0cmluZyBmb3JtYXQsICoqd2l0aG91dCoqIHNpZ25hdHVyZVxuICogVGhpcyBwYWNrZWQgaGV4LWJ5dGUtYXJyYXkgY2FuIHRoZW4gYmUgdXNlZCBmb3Igc2lnbmluZy5cbiAqIE9uIFJhaWRlbiBweXRob24gY2xpZW50LCB0aGlzIGlzIHRoZSBvdXRwdXQgb2YgYF9kYXRhX3RvX3NpZ25gIG1ldGhvZCBvZiB0aGUgbWVzc2FnZXMsIGFzIHRoZVxuICogYWN0dWFsIHBhY2tlZCBlbmNvZGluZyB3YXMgb25jZSB1c2VkIGZvciBiaW5hcnkgdHJhbnNwb3J0IHByb3RvY29scywgYnV0IG5vd2FkYXlzIGlzIHVzZWQgb25seVxuICogZm9yIGdlbmVyYXRpbmcgZGF0YSB0byBiZSBzaWduZWQsIHdoaWNoIGlzIHRoZSBwdXJwb3NlIG9mIG91ciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIE1lc3NhZ2UgdG8gYmUgcGFja2VkXG4gKiBAcmV0dXJucyBIZXhCeXRlcyBoZXgtZW5jb2RlZCBzdHJpbmcgZGF0YSByZXByZXNlbnRpbmcgbWVzc2FnZSBpbiBiaW5hcnkgZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWNrTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgdmFyIF9hO1xuICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuREVMSVZFUkVEOlxuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcbiAgICAgICAgICAgICAgICBlbmNvZGUoQ01ESURzW21lc3NhZ2UudHlwZV0sIDEpLFxuICAgICAgICAgICAgICAgIGVuY29kZSgwLCAzKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5kZWxpdmVyZWRfbWVzc2FnZV9pZGVudGlmaWVyLCA4KSxcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5QUk9DRVNTRUQ6XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICAgICAgICAgIGVuY29kZShDTURJRHNbbWVzc2FnZS50eXBlXSwgMSksXG4gICAgICAgICAgICAgICAgZW5jb2RlKDAsIDMpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLm1lc3NhZ2VfaWRlbnRpZmllciwgOCksXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuTE9DS0VEX1RSQU5TRkVSOlxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlJFRlVORF9UUkFOU0ZFUjpcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5VTkxPQ0s6XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuTE9DS19FWFBJUkVEOiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlSGFzaCA9IGNyZWF0ZU1lc3NhZ2VIYXNoKG1lc3NhZ2UpLCBiYWxhbmNlSGFzaCA9IGNyZWF0ZUJhbGFuY2VIYXNoKG1lc3NhZ2UudHJhbnNmZXJyZWRfYW1vdW50LCBtZXNzYWdlLmxvY2tlZF9hbW91bnQsIG1lc3NhZ2UubG9ja3Nyb290KTtcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChbXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UudG9rZW5fbmV0d29ya19hZGRyZXNzLCAyMCksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UuY2hhaW5faWQsIDMyKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUoTWVzc2FnZVR5cGVJZC5CQUxBTkNFX1BST09GLCAzMiksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UuY2hhbm5lbF9pZGVudGlmaWVyLCAzMiksXG4gICAgICAgICAgICAgICAgZW5jb2RlKGJhbGFuY2VIYXNoLCAzMiksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2Uubm9uY2UsIDMyKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZUhhc2gsIDMyKSxcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlNFQ1JFVF9SRVFVRVNUOlxuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcbiAgICAgICAgICAgICAgICBlbmNvZGUoQ01ESURzW21lc3NhZ2UudHlwZV0sIDEpLFxuICAgICAgICAgICAgICAgIGVuY29kZSgwLCAzKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5tZXNzYWdlX2lkZW50aWZpZXIsIDgpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLnBheW1lbnRfaWRlbnRpZmllciwgOCksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2Uuc2VjcmV0aGFzaCwgMzIpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLmFtb3VudCwgMzIpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLmV4cGlyYXRpb24sIDMyKSxcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5TRUNSRVRfUkVWRUFMOlxuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcbiAgICAgICAgICAgICAgICBlbmNvZGUoQ01ESURzW21lc3NhZ2UudHlwZV0sIDEpLFxuICAgICAgICAgICAgICAgIGVuY29kZSgwLCAzKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5tZXNzYWdlX2lkZW50aWZpZXIsIDgpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLnNlY3JldCwgMzIpLFxuICAgICAgICAgICAgXSkpO1xuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLldJVEhEUkFXX1JFUVVFU1Q6XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuV0lUSERSQVdfQ09ORklSTUFUSU9OOlxuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS50b2tlbl9uZXR3b3JrX2FkZHJlc3MsIDIwKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5jaGFpbl9pZCwgMzIpLFxuICAgICAgICAgICAgICAgIGVuY29kZShNZXNzYWdlVHlwZUlkLldJVEhEUkFXLCAzMiksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UuY2hhbm5lbF9pZGVudGlmaWVyLCAzMiksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UucGFydGljaXBhbnQsIDIwKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS50b3RhbF93aXRoZHJhdywgMzIpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLmV4cGlyYXRpb24sIDMyKSxcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5XSVRIRFJBV19FWFBJUkVEOlxuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcbiAgICAgICAgICAgICAgICBlbmNvZGUoQ01ESURzW21lc3NhZ2UudHlwZV0sIDEpLFxuICAgICAgICAgICAgICAgIGVuY29kZSgwLCAzKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5ub25jZSwgMzIpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLm1lc3NhZ2VfaWRlbnRpZmllciwgOCksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UudG9rZW5fbmV0d29ya19hZGRyZXNzLCAyMCksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UuY2hhaW5faWQsIDMyKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUoTWVzc2FnZVR5cGVJZC5XSVRIRFJBVywgMzIpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLmNoYW5uZWxfaWRlbnRpZmllciwgMzIpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLnBhcnRpY2lwYW50LCAyMCksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UudG90YWxfd2l0aGRyYXcsIDMyKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5leHBpcmF0aW9uLCAzMiksXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuUEZTX0NBUEFDSVRZX1VQREFURTpcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChbXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UuY2Fub25pY2FsX2lkZW50aWZpZXIuY2hhaW5faWRlbnRpZmllciwgMzIpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLmNhbm9uaWNhbF9pZGVudGlmaWVyLnRva2VuX25ldHdvcmtfYWRkcmVzcywgMjApLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLmNhbm9uaWNhbF9pZGVudGlmaWVyLmNoYW5uZWxfaWRlbnRpZmllciwgMzIpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLnVwZGF0aW5nX3BhcnRpY2lwYW50LCAyMCksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2Uub3RoZXJfcGFydGljaXBhbnQsIDIwKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS51cGRhdGluZ19ub25jZSwgOCksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2Uub3RoZXJfbm9uY2UsIDgpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLnVwZGF0aW5nX2NhcGFjaXR5LCAzMiksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2Uub3RoZXJfY2FwYWNpdHksIDMyKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5yZXZlYWxfdGltZW91dCwgMzIpLFxuICAgICAgICAgICAgXSkpO1xuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlBGU19GRUVfVVBEQVRFOlxuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5jYW5vbmljYWxfaWRlbnRpZmllci5jaGFpbl9pZGVudGlmaWVyLCAzMiksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UuY2Fub25pY2FsX2lkZW50aWZpZXIudG9rZW5fbmV0d29ya19hZGRyZXNzLCAyMCksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UuY2Fub25pY2FsX2lkZW50aWZpZXIuY2hhbm5lbF9pZGVudGlmaWVyLCAzMiksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UudXBkYXRpbmdfcGFydGljaXBhbnQsIDIwKSxcbiAgICAgICAgICAgICAgICBlbmNvZGUobWVzc2FnZS5mZWVfc2NoZWR1bGUuY2FwX2ZlZXMsIDEpLFxuICAgICAgICAgICAgICAgIGVuY29kZShtZXNzYWdlLmZlZV9zY2hlZHVsZS5mbGF0LCAzMiksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UuZmVlX3NjaGVkdWxlLnByb3BvcnRpb25hbCwgMzIpLFxuICAgICAgICAgICAgICAgIHJscEVuY29kZSgoX2EgPSBtZXNzYWdlLmZlZV9zY2hlZHVsZS5pbWJhbGFuY2VfcGVuYWx0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJzB4JyksXG4gICAgICAgICAgICAgICAgZW5jb2RlKG1lc3NhZ2UudGltZXN0YW1wLCAxOSksXG4gICAgICAgICAgICBdKSk7IC8vIHZhcmlhYmxlIHNpemUgb2YgZmVlX3NjaGVkdWxlLmltYmFsYW5jZV9wZW5hbHR5IHJscEVuY29kaW5nLCB3aGVuIG5vdCBudWxsXG4gICAgfVxufVxuLyoqXG4gKiBUeXBlZ3VhcmQgdG8gY2hlY2sgaWYgYSBtZXNzYWdlIGNvbnRhaW5zIGEgdmFsaWQgc2lnbmF0dXJlXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBNYXkgb3IgbWF5IG5vdCBiZSBhIHNpZ25lZCBtZXNzYWdlXG4gKiBAcmV0dXJucyBCb29sZWFuIGlmIG1lc3NhZ2UgaXMgc2lnbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NpZ25lZChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIFNpZ25hdHVyZS5pcyhtZXNzYWdlLnNpZ25hdHVyZSk7XG59XG4vKipcbiAqIFJlcXVpcmVzIGEgc2lnbmVkIG1lc3NhZ2UgYW5kIHJldHVybnMgaXRzIHNpZ25lciBhZGRyZXNzXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBTaWduZWQgbWVzc2FnZSB0byByZXRyaWV2ZSBzaWduZXIgYWRkcmVzc1xuICogQHJldHVybnMgQWRkcmVzcyB3aGljaCBzaWduZWQgbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWVzc2FnZVNpZ25lcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHZlcmlmeU1lc3NhZ2UoYXJyYXlpZnkocGFja01lc3NhZ2UobWVzc2FnZSkpLCBtZXNzYWdlLnNpZ25hdHVyZSk7XG59XG4vKipcbiAqIEdldCB0aGUgU2lnbmVkQmFsYW5jZVByb29mIGFzc29jaWF0ZWQgd2l0aCBhbiBFbnZlbG9wZU1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFNpZ25lZCBFbnZlbG9wZU1lc3NhZ2VcbiAqIEByZXR1cm5zIFNpZ25lZEJhbGFuY2VQcm9vZiBvYmplY3QgZm9yIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJhbGFuY2VQcm9vZkZyb21FbnZlbG9wZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoYWluSWQ6IG1lc3NhZ2UuY2hhaW5faWQsXG4gICAgICAgIHRva2VuTmV0d29ya0FkZHJlc3M6IG1lc3NhZ2UudG9rZW5fbmV0d29ya19hZGRyZXNzLFxuICAgICAgICBjaGFubmVsSWQ6IG1lc3NhZ2UuY2hhbm5lbF9pZGVudGlmaWVyLFxuICAgICAgICBub25jZTogbWVzc2FnZS5ub25jZSxcbiAgICAgICAgdHJhbnNmZXJyZWRBbW91bnQ6IG1lc3NhZ2UudHJhbnNmZXJyZWRfYW1vdW50LFxuICAgICAgICBsb2NrZWRBbW91bnQ6IG1lc3NhZ2UubG9ja2VkX2Ftb3VudCxcbiAgICAgICAgbG9ja3Nyb290OiBtZXNzYWdlLmxvY2tzcm9vdCxcbiAgICAgICAgbWVzc2FnZUhhc2g6IGNyZWF0ZU1lc3NhZ2VIYXNoKG1lc3NhZ2UpLFxuICAgICAgICBzaWduYXR1cmU6IG1lc3NhZ2Uuc2lnbmF0dXJlLFxuICAgICAgICBzZW5kZXI6IGdldE1lc3NhZ2VTaWduZXIobWVzc2FnZSksXG4gICAgfTtcbn1cbi8qKlxuICogRW5jb2RlIGEgTWVzc2FnZSBhcyBhIEpTT04gc3RyaW5nXG4gKiBVc2VzIGxvc3NsZXNzLWpzb24gdG8gZW5jb2RlIEJpZ051bWJlcnMgYXMgSlNPTiAnc3RyaW5nJyB0eXBlLCBhcyBSYWlkZW5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIE1lc3NhZ2Ugb2JqZWN0IHRvIGJlIHNlcmlhbGl6ZWRcbiAqIEByZXR1cm5zIEpTT04gc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVKc29uTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKCdzaWduYXR1cmUnIGluIG1lc3NhZ2UpXG4gICAgICAgIHJldHVybiBsb3NzbGVzc1N0cmluZ2lmeShTaWduZWQoTWVzc2FnZSkuZW5jb2RlKG1lc3NhZ2UpKTtcbiAgICByZXR1cm4gbG9zc2xlc3NTdHJpbmdpZnkoTWVzc2FnZS5lbmNvZGUobWVzc2FnZSkpO1xufVxuLyoqXG4gKiBUcnkgdG8gZGVjb2RlIHRleHQgYXMgYSBNZXNzYWdlLCB1c2luZyBsb3NzbGVzcy1qc29uIHRvIGRlY29kZSBCaWdOdW1iZXJzXG4gKiBUaHJvd3MgaWYgY2FuJ3QgZGVjb2RlLCBvciBtZXNzYWdlIGlzIGludmFsaWQgcmVnYXJkaW5nIGFueSBvZiB0aGUgZW5jb2RlZCBjb25zdHJhaW50c1xuICpcbiAqIEBwYXJhbSB0ZXh0IC0gSlNPTiBzdHJpbmcgdG8gdHJ5IHRvIGRlY29kZVxuICogQHJldHVybnMgTWVzc2FnZSBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUpzb25NZXNzYWdlKHRleHQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBsb3NzbGVzc1BhcnNlKHRleHQpO1xuICAgIGFzc2VydChwYXJzZWQgJiZcbiAgICAgICAgdHlwZW9mIHBhcnNlZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3R5cGUnIGluIHBhcnNlZCAmJlxuICAgICAgICBPYmplY3QudmFsdWVzKE1lc3NhZ2VUeXBlKS5zb21lKCh0KSA9PiB0ID09PSBwYXJzZWRbJ3R5cGUnXSksIGBJbnZhbGlkIG1lc3NhZ2UgdHlwZTogJHtwYXJzZWQgPT09IG51bGwgfHwgcGFyc2VkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJzZWRbJ3R5cGUnXX1gKTtcbiAgICBpZiAoJ3NpZ25hdHVyZScgaW4gcGFyc2VkKVxuICAgICAgICByZXR1cm4gZGVjb2RlKFNpZ25lZChNZXNzYWdlKSwgcGFyc2VkKTtcbiAgICByZXR1cm4gZGVjb2RlKE1lc3NhZ2UsIHBhcnNlZCk7XG59XG4vKipcbiAqIFBhY2sgbWVzc2FnZSBhbmQgcmVxdWVzdCBzaWduZXIgdG8gc2lnbiBpdCwgYW5kIHJldHVybnMgc2lnbmVkIG1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0gc2lnbmVyIC0gU2lnbmVyIGluc3RhbmNlXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFVuc2lnbmVkIG1lc3NhZ2UgdG8gcGFjayBhbmQgc2lnblxuICogQHJldHVybnMgUHJvbWlzZSB0byBzaWduZWQgbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbk1lc3NhZ2Uoc2lnbmVyLCBtZXNzYWdlLCB7IGxvZyB9ID0geyBsb2c6IGxvZ2dpbmcgfSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChpc1NpZ25lZChtZXNzYWdlKSlcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICBsb2cuZGVidWcoYFNpZ25pbmcgbWVzc2FnZSBcIiR7bWVzc2FnZS50eXBlfVwiYCwgbWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9ICh5aWVsZCBzaWduZXIuc2lnbk1lc3NhZ2UoYXJyYXlpZnkocGFja01lc3NhZ2UobWVzc2FnZSkpKSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1lc3NhZ2UpLCB7IHNpZ25hdHVyZSB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogVHlwZWd1YXJkIHRvIGVuc3VyZSBhbiBhY3Rpb24gaXMgYSBtZXNzYWdlUmVjZWl2ZWQgb2YgYW55IG9mIGEgc2V0IG9mIE1lc3NhZ2UgdHlwZXNcbiAqXG4gKiBAcGFyYW0gbWVzc2FnZUNvZGVjcyAtIE1lc3NhZ2UgY29kZWMgdG8gdGVzdCBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlIGFnYWluc3RcbiAqIEByZXR1cm5zIFR5cGVndWFyZCBpbnRlcnNlY3RpbmcgbWVzc2FnZVJlY2VpdmVkIGFjdGlvbiBhbmQgcGF5bG9hZC5tZXNzYWdlIHNjaGVtYXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTWVzc2FnZVJlY2VpdmVkT2ZUeXBlKG1lc3NhZ2VDb2RlY3MpIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gbWVzc2FnZVJlY2VpdmVkLmlzKGFjdGlvbikgJiZcbiAgICAgICAgKEFycmF5LmlzQXJyYXkobWVzc2FnZUNvZGVjcylcbiAgICAgICAgICAgID8gdC51bmlvbihtZXNzYWdlQ29kZWNzKS5pcyhhY3Rpb24ucGF5bG9hZC5tZXNzYWdlKVxuICAgICAgICAgICAgOiBtZXNzYWdlQ29kZWNzLmlzKGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2UpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsImltcG9ydCB7IGNvbmNhdCwgaGV4bGlmeSB9IGZyb20gJ2V0aGVycy91dGlscy9ieXRlcyc7XG5pbXBvcnQgeyBrZWNjYWsyNTYsIHJhbmRvbUJ5dGVzLCBiaWdOdW1iZXJpZnksIHNoYTI1NiB9IGZyb20gJ2V0aGVycy91dGlscyc7XG5pbXBvcnQgeyBlbmNvZGUgfSBmcm9tICcuLi91dGlscy9kYXRhJztcbmltcG9ydCB7IFJhaWRlblRyYW5zZmVyU3RhdHVzIH0gZnJvbSAnLi9zdGF0ZSc7XG4vKipcbiAqIEdldCB0aGUgbG9ja3Nyb290IG9mIGEgZ2l2ZW4gYXJyYXkgb2YgcGVuZGluZyBsb2Nrc1xuICogT24gQWxkZXJhYW4sIGl0J3MgdGhlIGtlY2NhazI1NiBoYXNoIG9mIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSBvcmRlcmVkIGxvY2tzIGRhdGFcbiAqXG4gKiBAcGFyYW0gbG9ja3MgLSBMb2NrIGFycmF5IHRvIGNhbGN1bGF0ZSB0aGUgbG9ja3Nyb290IGZyb21cbiAqIEByZXR1cm5zIGhhc2ggb2YgdGhlIGxvY2tzIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2Nrc3Jvb3QobG9ja3MpIHtcbiAgICBjb25zdCBlbmNvZGVkID0gW107XG4gICAgZm9yIChjb25zdCBsb2NrIG9mIGxvY2tzKVxuICAgICAgICBlbmNvZGVkLnB1c2goZW5jb2RlKGxvY2suZXhwaXJhdGlvbiwgMzIpLCBlbmNvZGUobG9jay5hbW91bnQsIDMyKSwgbG9jay5zZWNyZXRoYXNoKTtcbiAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChlbmNvZGVkKSk7XG59XG4vKipcbiAqIFJldHVybiB0aGUgc2VjcmV0aGFzaCBvZiBhIGdpdmVuIHNlY3JldFxuICogT24gQWxkZXJhYW4sIHRoZSBzaGEyNTYgaGFzaCBpcyB1c2VkIGZvciB0aGUgc2VjcmV0LlxuICpcbiAqIEBwYXJhbSBzZWNyZXQgLSBTZWNyZXQgdG8gZ2V0IHRoZSBoYXNoIGZyb21cbiAqIEByZXR1cm5zIGhhc2ggb2YgdGhlIHNlY3JldFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VjcmV0aGFzaChzZWNyZXQpIHtcbiAgICByZXR1cm4gc2hhMjU2KHNlY3JldCk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBzZWNyZXQgb2YgZ2l2ZW4gbGVuZ3RoLCBhcyBhbiBIZXhTdHJpbmc8MzI+XG4gKlxuICogQHBhcmFtIGxlbmd0aCAtIG9mIHRoZSBzZWNyZXQgdG8gZ2VuZXJhdGVcbiAqIEByZXR1cm5zIEhleFN0cmluZzwzMj5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTZWNyZXQobGVuZ3RoID0gMzIpIHtcbiAgICByZXR1cm4gaGV4bGlmeShyYW5kb21CeXRlcyhsZW5ndGgpKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHBheW1lbnQgaWRlbnRpZmllciwgYXMgYW4gVUludDw4PiAoNjQgYml0cylcbiAqXG4gKiBAcmV0dXJucyBVSW50PDg+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUGF5bWVudElkKCkge1xuICAgIHJldHVybiBiaWdOdW1iZXJpZnkoRGF0ZS5ub3coKSk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIG1lc3NhZ2UgaWRlbnRpZmllciwgYXMgYW4gVUludDw4PiAoNjQgYml0cylcbiAqXG4gKiBAcmV0dXJucyBVSW50PDg+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTWVzc2FnZUlkKCkge1xuICAgIHJldHVybiBiaWdOdW1iZXJpZnkoRGF0ZS5ub3coKSk7XG59XG5mdW5jdGlvbiBnZXRUaW1lSWZQcmVzZW50KGspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiAobykgPT4gKG9ba10gPyBvW2tdWzBdIDogdW5kZWZpbmVkKTtcbn1cbmNvbnN0IHN0YXR1c2VzTWFwID0ge1xuICAgIFtSYWlkZW5UcmFuc2ZlclN0YXR1cy5leHBpcmVkXTogZ2V0VGltZUlmUHJlc2VudCgnbG9ja0V4cGlyZWRQcm9jZXNzZWQnKSxcbiAgICBbUmFpZGVuVHJhbnNmZXJTdGF0dXMudW5sb2NrZWRdOiBnZXRUaW1lSWZQcmVzZW50KCd1bmxvY2tQcm9jZXNzZWQnKSxcbiAgICBbUmFpZGVuVHJhbnNmZXJTdGF0dXMuZXhwaXJpbmddOiBnZXRUaW1lSWZQcmVzZW50KCdsb2NrRXhwaXJlZCcpLFxuICAgIFtSYWlkZW5UcmFuc2ZlclN0YXR1cy51bmxvY2tpbmddOiBnZXRUaW1lSWZQcmVzZW50KCd1bmxvY2snKSxcbiAgICBbUmFpZGVuVHJhbnNmZXJTdGF0dXMucmVnaXN0ZXJlZF06IChzZW50KSA9PiB7IHZhciBfYSwgX2I7IFxuICAgIC8vIG9ubHkgc2V0IHN0YXR1cyBhcyByZWdpc3RlcmVkIGlmIHRoZXJlJ3MgYSB2YWxpZCByZWdpc3RlckJsb2NrXG4gICAgcmV0dXJuICgoX2IgPSAoX2EgPSBzZW50LnNlY3JldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzFdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVnaXN0ZXJCbG9jaykgPyBzZW50LnNlY3JldFswXSA6IHVuZGVmaW5lZDsgfSxcbiAgICBbUmFpZGVuVHJhbnNmZXJTdGF0dXMucmV2ZWFsZWRdOiBnZXRUaW1lSWZQcmVzZW50KCdzZWNyZXRSZXZlYWwnKSxcbiAgICBbUmFpZGVuVHJhbnNmZXJTdGF0dXMucmVxdWVzdGVkXTogZ2V0VGltZUlmUHJlc2VudCgnc2VjcmV0UmVxdWVzdCcpLFxuICAgIFtSYWlkZW5UcmFuc2ZlclN0YXR1cy5jbG9zZWRdOiBnZXRUaW1lSWZQcmVzZW50KCdjaGFubmVsQ2xvc2VkJyksXG4gICAgW1JhaWRlblRyYW5zZmVyU3RhdHVzLnJlZnVuZGVkXTogZ2V0VGltZUlmUHJlc2VudCgncmVmdW5kJyksXG4gICAgW1JhaWRlblRyYW5zZmVyU3RhdHVzLnJlY2VpdmVkXTogZ2V0VGltZUlmUHJlc2VudCgndHJhbnNmZXJQcm9jZXNzZWQnKSxcbiAgICBbUmFpZGVuVHJhbnNmZXJTdGF0dXMucGVuZGluZ106IGdldFRpbWVJZlByZXNlbnQoJ3RyYW5zZmVyJyksXG59O1xuLyoqXG4gKiBDb252ZXJ0IGEgc3RhdGUuc2VudDogVHJhbnNmZXJTdGF0ZSB0byBhIHB1YmxpYyBSYWlkZW5UcmFuc2ZlciBvYmplY3RcbiAqXG4gKiBAcGFyYW0gc2VudCAtIFJhaWRlblN0YXRlLnNlbnQgdmFsdWVcbiAqIEByZXR1cm5zIFB1YmxpYyByYWlkZW4gc2VudCB0cmFuc2ZlciBpbmZvIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFpZGVuU2VudFRyYW5zZmVyKHNlbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgY29uc3Qgc3RhcnRlZEF0ID0gbmV3IERhdGUoc2VudC50cmFuc2ZlclswXSk7XG4gICAgbGV0IGNoYW5nZWRBdCA9IHN0YXJ0ZWRBdDtcbiAgICBsZXQgc3RhdHVzID0gUmFpZGVuVHJhbnNmZXJTdGF0dXMucGVuZGluZztcbiAgICAvLyBvcmRlciBtYXR0ZXJzISBmcm9tIHRvcCB0byBib3R0b20gcHJpb3JpdHksIGZpcnN0IG1hdGNoIGJyZWFrcyBsb29wXG4gICAgZm9yIChjb25zdCBbcywgZ10gb2YgT2JqZWN0LmVudHJpZXMoc3RhdHVzZXNNYXApKSB7XG4gICAgICAgIGNvbnN0IHRzID0gZyhzZW50KTtcbiAgICAgICAgaWYgKHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9IHM7XG4gICAgICAgICAgICBjaGFuZ2VkQXQgPSBuZXcgRGF0ZSh0cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0cmFuc2ZlciA9IHNlbnQudHJhbnNmZXJbMV07XG4gICAgY29uc3QgdmFsdWUgPSB0cmFuc2Zlci5sb2NrLmFtb3VudC5zdWIoc2VudC5mZWUpO1xuICAgIGNvbnN0IGludmFsaWRTZWNyZXRSZXF1ZXN0ID0gc2VudC5zZWNyZXRSZXF1ZXN0ICYmIHNlbnQuc2VjcmV0UmVxdWVzdFsxXS5hbW91bnQubHQodmFsdWUpO1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSBzZW50LnNlY3JldFJldmVhbCB8fCBzZW50LnVubG9jayB8fCAoKF9iID0gKF9hID0gc2VudC5zZWNyZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsxXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlZ2lzdGVyQmxvY2spXG4gICAgICAgID8gdHJ1ZVxuICAgICAgICA6IGludmFsaWRTZWNyZXRSZXF1ZXN0IHx8IHNlbnQucmVmdW5kIHx8IHNlbnQubG9ja0V4cGlyZWQgfHwgc2VudC5jaGFubmVsQ2xvc2VkXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBjb21wbGV0ZWQgPSAhIShzZW50LnVubG9ja1Byb2Nlc3NlZCB8fFxuICAgICAgICBzZW50LmxvY2tFeHBpcmVkUHJvY2Vzc2VkIHx8ICgoX2QgPSAoX2MgPSBzZW50LnNlY3JldCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jWzFdKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucmVnaXN0ZXJCbG9jaykgfHxcbiAgICAgICAgc2VudC5jaGFubmVsQ2xvc2VkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWNyZXRoYXNoOiB0cmFuc2Zlci5sb2NrLnNlY3JldGhhc2gsXG4gICAgICAgIGRpcmVjdGlvbjogJ3NlbnQnLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGluaXRpYXRvcjogdHJhbnNmZXIuaW5pdGlhdG9yLFxuICAgICAgICBwYXJ0bmVyOiB0cmFuc2Zlci5yZWNpcGllbnQsXG4gICAgICAgIHRhcmdldDogdHJhbnNmZXIudGFyZ2V0LFxuICAgICAgICBtZXRhZGF0YTogdHJhbnNmZXIubWV0YWRhdGEsXG4gICAgICAgIHBheW1lbnRJZDogdHJhbnNmZXIucGF5bWVudF9pZGVudGlmaWVyLFxuICAgICAgICBjaGFpbklkOiB0cmFuc2Zlci5jaGFpbl9pZC50b051bWJlcigpLFxuICAgICAgICB0b2tlbjogdHJhbnNmZXIudG9rZW4sXG4gICAgICAgIHRva2VuTmV0d29yazogdHJhbnNmZXIudG9rZW5fbmV0d29ya19hZGRyZXNzLFxuICAgICAgICBjaGFubmVsSWQ6IHRyYW5zZmVyLmNoYW5uZWxfaWRlbnRpZmllcixcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGZlZTogc2VudC5mZWUsXG4gICAgICAgIGFtb3VudDogdHJhbnNmZXIubG9jay5hbW91bnQsXG4gICAgICAgIGV4cGlyYXRpb25CbG9jazogdHJhbnNmZXIubG9jay5leHBpcmF0aW9uLnRvTnVtYmVyKCksXG4gICAgICAgIHN0YXJ0ZWRBdCxcbiAgICAgICAgY2hhbmdlZEF0LFxuICAgICAgICBzdWNjZXNzLFxuICAgICAgICBjb21wbGV0ZWQsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsImltcG9ydCBnZXQgZnJvbSAnbG9kYXNoL2ZwL2dldCc7XG5pbXBvcnQgc2V0IGZyb20gJ2xvZGFzaC9mcC9zZXQnO1xuaW1wb3J0IHVuc2V0IGZyb20gJ2xvZGFzaC9mcC91bnNldCc7XG5pbXBvcnQgeyBaZXJvLCBIYXNoWmVybyB9IGZyb20gJ2V0aGVycy9jb25zdGFudHMnO1xuaW1wb3J0IHsgaGV4bGlmeSB9IGZyb20gJ2V0aGVycy91dGlscyc7XG5pbXBvcnQgeyBpbml0aWFsU3RhdGUgfSBmcm9tICcuLi9zdGF0ZSc7XG5pbXBvcnQgeyBDaGFubmVsU3RhdGUgfSBmcm9tICcuLi9jaGFubmVscy9zdGF0ZSc7XG5pbXBvcnQgeyBjaGFubmVsQ2xvc2UgfSBmcm9tICcuLi9jaGFubmVscy9hY3Rpb25zJztcbmltcG9ydCB7IFNpZ25hdHVyZVplcm8gfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgdGltZWQgfSBmcm9tICcuLi91dGlscy90eXBlcyc7XG5pbXBvcnQgeyBjcmVhdGVSZWR1Y2VyIH0gZnJvbSAnLi4vdXRpbHMvYWN0aW9ucyc7XG5pbXBvcnQgeyBnZXRCYWxhbmNlUHJvb2ZGcm9tRW52ZWxvcGVNZXNzYWdlLCBnZXRNZXNzYWdlU2lnbmVyIH0gZnJvbSAnLi4vbWVzc2FnZXMvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0TG9ja3Nyb290IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBEaXJlY3Rpb24gfSBmcm9tICcuL3N0YXRlJztcbmltcG9ydCB7IHRyYW5zZmVyU2lnbmVkLCB0cmFuc2ZlclNlY3JldCwgdHJhbnNmZXJQcm9jZXNzZWQsIHRyYW5zZmVyVW5sb2NrLCB0cmFuc2ZlckV4cGlyZSwgdHJhbnNmZXJTZWNyZXRSZXZlYWwsIHRyYW5zZmVyUmVmdW5kZWQsIHRyYW5zZmVyVW5sb2NrUHJvY2Vzc2VkLCB0cmFuc2ZlckV4cGlyZVByb2Nlc3NlZCwgdHJhbnNmZXJDbGVhciwgd2l0aGRyYXdSZWNlaXZlLCB0cmFuc2ZlclNlY3JldFJlcXVlc3QsIHRyYW5zZmVyU2VjcmV0UmVnaXN0ZXIsIH0gZnJvbSAnLi9hY3Rpb25zJztcbmNvbnN0IEVORCA9IHsgW0RpcmVjdGlvbi5TRU5UXTogJ293bicsIFtEaXJlY3Rpb24uUkVDRUlWRURdOiAncGFydG5lcicgfTtcbi8vIFJlZHVjZXJzIGZvciBkaWZmZXJlbnQgYWN0aW9uc1xuZnVuY3Rpb24gdHJhbnNmZXJTZWNyZXRSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICBjb25zdCBzZWNyZXRoYXNoID0gYWN0aW9uLm1ldGEuc2VjcmV0aGFzaDtcbiAgICAvLyBzdG9yZSB3aGVuIHNlZWluZyB1bmNvbmZpcm1lZCwgYnV0IHJlZ2lzdGVyQmxvY2sgb25seSBhZnRlciBjb25maXJtYXRpb25cbiAgICBjb25zdCByZWdpc3RlckJsb2NrID0gdHJhbnNmZXJTZWNyZXRSZWdpc3Rlci5zdWNjZXNzLmlzKGFjdGlvbikgJiYgYWN0aW9uLnBheWxvYWQuY29uZmlybWVkXG4gICAgICAgID8gYWN0aW9uLnBheWxvYWQudHhCbG9ja1xuICAgICAgICA6IChfZCA9IChfYyA9IChfYiA9IChfYSA9IHN0YXRlW2FjdGlvbi5tZXRhLmRpcmVjdGlvbl1bc2VjcmV0aGFzaF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZWNyZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlsxXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlZ2lzdGVyQmxvY2spICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDA7XG4gICAgLy8gZG9uJ3Qgb3ZlcndyaXRlIHJlZ2lzdGVyQmxvY2sgaWYgc2VjcmV0IGFscmVhZHkgc3RvcmVkIHdpdGggaXRcbiAgICBpZiAoc2VjcmV0aGFzaCBpbiBzdGF0ZVthY3Rpb24ubWV0YS5kaXJlY3Rpb25dICYmXG4gICAgICAgICgoX2YgPSAoX2UgPSBzdGF0ZVthY3Rpb24ubWV0YS5kaXJlY3Rpb25dW3NlY3JldGhhc2hdLnNlY3JldCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzFdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YucmVnaXN0ZXJCbG9jaykgIT09IHJlZ2lzdGVyQmxvY2spXG4gICAgICAgIHN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgW2FjdGlvbi5tZXRhLmRpcmVjdGlvbl06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGVbYWN0aW9uLm1ldGEuZGlyZWN0aW9uXSksIHsgW3NlY3JldGhhc2hdOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlW2FjdGlvbi5tZXRhLmRpcmVjdGlvbl1bc2VjcmV0aGFzaF0pLCB7IHNlY3JldDogdGltZWQoeyB2YWx1ZTogYWN0aW9uLnBheWxvYWQuc2VjcmV0LCByZWdpc3RlckJsb2NrIH0pIH0pIH0pIH0pO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHRyYW5zZmVyU2lnbmVkUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgdHJhbnNmZXIgPSBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlO1xuICAgIGNvbnN0IGxvY2sgPSB0cmFuc2Zlci5sb2NrO1xuICAgIGNvbnN0IHNlY3JldGhhc2ggPSBsb2NrLnNlY3JldGhhc2g7XG4gICAgY29uc3QgcGFydG5lciA9IGFjdGlvbi5tZXRhLmRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlNFTlQgPyB0cmFuc2Zlci5yZWNpcGllbnQgOiBnZXRNZXNzYWdlU2lnbmVyKHRyYW5zZmVyKTtcbiAgICBjb25zdCBlbmQgPSBFTkRbYWN0aW9uLm1ldGEuZGlyZWN0aW9uXTtcbiAgICAvLyB0cmFuc2ZlclNpZ25lZCBtdXN0IGJlIHRoZSBmaXJzdCBhY3Rpb24sIHRvIGluaXQgVHJhbnNmZXJTdGF0ZSBzdGF0ZVxuICAgIGlmIChzZWNyZXRoYXNoIGluIHN0YXRlW2FjdGlvbi5tZXRhLmRpcmVjdGlvbl0pXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICBjb25zdCBjaGFubmVsUGF0aCA9IFsnY2hhbm5lbHMnLCB0cmFuc2Zlci50b2tlbl9uZXR3b3JrX2FkZHJlc3MsIHBhcnRuZXJdO1xuICAgIGxldCBjaGFubmVsID0gZ2V0KGNoYW5uZWxQYXRoLCBzdGF0ZSk7XG4gICAgaWYgKCFjaGFubmVsKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgY29uc3QgbG9ja3MgPSBbLi4uKChfYSA9IGNoYW5uZWxbZW5kXS5sb2NrcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLCBsb2NrXTsgLy8gYXBwZW5kIGxvY2tcbiAgICBjb25zdCBsb2Nrc3Jvb3QgPSBnZXRMb2Nrc3Jvb3QobG9ja3MpO1xuICAgIGlmICh0cmFuc2Zlci5sb2Nrc3Jvb3QgIT09IGxvY2tzcm9vdCB8fFxuICAgICAgICAvLyBub25jZSBtdXN0IGJlIG5leHRcbiAgICAgICAgIXRyYW5zZmVyLm5vbmNlLmVxKChjaGFubmVsW2VuZF0uYmFsYW5jZVByb29mID8gY2hhbm5lbFtlbmRdLmJhbGFuY2VQcm9vZi5ub25jZSA6IFplcm8pLmFkZCgxKSkgfHxcbiAgICAgICAgIXRyYW5zZmVyLnRyYW5zZmVycmVkX2Ftb3VudC5lcShjaGFubmVsW2VuZF0uYmFsYW5jZVByb29mID8gY2hhbm5lbFtlbmRdLmJhbGFuY2VQcm9vZi50cmFuc2ZlcnJlZEFtb3VudCA6IFplcm8pIHx8XG4gICAgICAgICF0cmFuc2Zlci5sb2NrZWRfYW1vdW50LmVxKCgoX2MgPSAoX2IgPSBjaGFubmVsW2VuZF0uYmFsYW5jZVByb29mKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubG9ja2VkQW1vdW50KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBaZXJvKS5hZGQobG9jay5hbW91bnQpKSlcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGNoYW5uZWwgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoYW5uZWwpLCB7IFtlbmRdOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoYW5uZWxbZW5kXSksIHsgbG9ja3MsIFxuICAgICAgICAgICAgLy8gc2V0IGN1cnJlbnQvbGF0ZXN0IGNoYW5uZWxbZW5kXS5iYWxhbmNlUHJvb2YgdG8gTG9ja2VkVHJhbnNmZXInc1xuICAgICAgICAgICAgYmFsYW5jZVByb29mOiBnZXRCYWxhbmNlUHJvb2ZGcm9tRW52ZWxvcGVNZXNzYWdlKHRyYW5zZmVyKSB9KSB9KTtcbiAgICBjb25zdCB0cmFuc2ZlclN0YXRlID0ge1xuICAgICAgICB0cmFuc2ZlcjogdGltZWQodHJhbnNmZXIpLFxuICAgICAgICBmZWU6IGFjdGlvbi5wYXlsb2FkLmZlZSxcbiAgICAgICAgcGFydG5lcixcbiAgICB9O1xuICAgIHN0YXRlID0gc2V0KGNoYW5uZWxQYXRoLCBjaGFubmVsLCBzdGF0ZSk7XG4gICAgc3RhdGUgPSBzZXQoW2FjdGlvbi5tZXRhLmRpcmVjdGlvbiwgc2VjcmV0aGFzaF0sIHRyYW5zZmVyU3RhdGUsIHN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB0cmFuc2ZlclNlY3JldFJlcXVlc3RlZFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIGNvbnN0IHNlY3JldGhhc2ggPSBhY3Rpb24ubWV0YS5zZWNyZXRoYXNoO1xuICAgIGlmICghKHNlY3JldGhhc2ggaW4gc3RhdGVbYWN0aW9uLm1ldGEuZGlyZWN0aW9uXSkpXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgW2FjdGlvbi5tZXRhLmRpcmVjdGlvbl06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGVbYWN0aW9uLm1ldGEuZGlyZWN0aW9uXSksIHsgW3NlY3JldGhhc2hdOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlW2FjdGlvbi5tZXRhLmRpcmVjdGlvbl1bc2VjcmV0aGFzaF0pLCB7IHNlY3JldFJlcXVlc3Q6IHRpbWVkKGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2UpIH0pIH0pIH0pO1xufVxuZnVuY3Rpb24gdHJhbnNmZXJTZWNyZXRSZXZlbGVkUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3Qgc2VjcmV0aGFzaCA9IGFjdGlvbi5tZXRhLnNlY3JldGhhc2g7XG4gICAgaWYgKCEoc2VjcmV0aGFzaCBpbiBzdGF0ZVthY3Rpb24ubWV0YS5kaXJlY3Rpb25dKSB8fFxuICAgICAgICBzdGF0ZVthY3Rpb24ubWV0YS5kaXJlY3Rpb25dW3NlY3JldGhhc2hdLnNlY3JldFJldmVhbClcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgeyBbYWN0aW9uLm1ldGEuZGlyZWN0aW9uXTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZVthY3Rpb24ubWV0YS5kaXJlY3Rpb25dKSwgeyBbc2VjcmV0aGFzaF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGVbYWN0aW9uLm1ldGEuZGlyZWN0aW9uXVtzZWNyZXRoYXNoXSksIHsgc2VjcmV0UmV2ZWFsOiB0aW1lZChhY3Rpb24ucGF5bG9hZC5tZXNzYWdlKSB9KSB9KSB9KTtcbn1cbmZ1bmN0aW9uIHRyYW5zZmVyVW5sb2NrU3VjY2Vzc1JlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIGNvbnN0IHVubG9jayA9IGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2U7XG4gICAgY29uc3Qgc2VjcmV0aGFzaCA9IGFjdGlvbi5tZXRhLnNlY3JldGhhc2g7XG4gICAgaWYgKCEoc2VjcmV0aGFzaCBpbiBzdGF0ZVthY3Rpb24ubWV0YS5kaXJlY3Rpb25dKSB8fFxuICAgICAgICBzdGF0ZVthY3Rpb24ubWV0YS5kaXJlY3Rpb25dW3NlY3JldGhhc2hdLnVubG9jaylcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGNvbnN0IHRyYW5zZmVyID0gc3RhdGVbYWN0aW9uLm1ldGEuZGlyZWN0aW9uXVtzZWNyZXRoYXNoXS50cmFuc2ZlclsxXTtcbiAgICBjb25zdCBwYXJ0bmVyID0gc3RhdGVbYWN0aW9uLm1ldGEuZGlyZWN0aW9uXVtzZWNyZXRoYXNoXS5wYXJ0bmVyO1xuICAgIGNvbnN0IGVuZCA9IEVORFthY3Rpb24ubWV0YS5kaXJlY3Rpb25dO1xuICAgIGNvbnN0IGxvY2sgPSB0cmFuc2Zlci5sb2NrO1xuICAgIGNvbnN0IGNoYW5uZWxQYXRoID0gWydjaGFubmVscycsIHRyYW5zZmVyLnRva2VuX25ldHdvcmtfYWRkcmVzcywgcGFydG5lcl07XG4gICAgbGV0IGNoYW5uZWwgPSBnZXQoY2hhbm5lbFBhdGgsIHN0YXRlKTtcbiAgICBpZiAoIWNoYW5uZWwgfHwgIWNoYW5uZWxbZW5kXS5sb2NrcyB8fCAhY2hhbm5lbFtlbmRdLmJhbGFuY2VQcm9vZilcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGNvbnN0IGxvY2tzID0gY2hhbm5lbFtlbmRdLmxvY2tzLmZpbHRlcigobCkgPT4gbC5zZWNyZXRoYXNoICE9PSBzZWNyZXRoYXNoKTtcbiAgICBjb25zdCBsb2Nrc3Jvb3QgPSBnZXRMb2Nrc3Jvb3QobG9ja3MpO1xuICAgIGlmICh1bmxvY2subG9ja3Nyb290ICE9PSBsb2Nrc3Jvb3QgfHxcbiAgICAgICAgIWNoYW5uZWxbZW5kXS5iYWxhbmNlUHJvb2Yubm9uY2UuYWRkKDEpLmVxKHVubG9jay5ub25jZSkgfHwgLy8gbm9uY2UgbXVzdCBiZSBuZXh0XG4gICAgICAgICF1bmxvY2sudHJhbnNmZXJyZWRfYW1vdW50LmVxKGNoYW5uZWxbZW5kXS5iYWxhbmNlUHJvb2YudHJhbnNmZXJyZWRBbW91bnQuYWRkKGxvY2suYW1vdW50KSkgfHxcbiAgICAgICAgIXVubG9jay5sb2NrZWRfYW1vdW50LmVxKGNoYW5uZWxbZW5kXS5iYWxhbmNlUHJvb2YubG9ja2VkQW1vdW50LnN1Yihsb2NrLmFtb3VudCkpKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgY2hhbm5lbCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hhbm5lbCksIHsgW2VuZF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hhbm5lbFtlbmRdKSwgeyBsb2NrcywgXG4gICAgICAgICAgICAvLyBzZXQgY3VycmVudC9sYXRlc3QgY2hhbm5lbFtlbmRdLmJhbGFuY2VQcm9vZiB0byBVbmxvY2snc1xuICAgICAgICAgICAgYmFsYW5jZVByb29mOiBnZXRCYWxhbmNlUHJvb2ZGcm9tRW52ZWxvcGVNZXNzYWdlKHVubG9jaykgfSkgfSk7XG4gICAgY29uc3QgdHJhbnNmZXJTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGVbYWN0aW9uLm1ldGEuZGlyZWN0aW9uXVtzZWNyZXRoYXNoXSksIHsgdW5sb2NrOiB0aW1lZCh1bmxvY2spIH0pO1xuICAgIHN0YXRlID0gc2V0KGNoYW5uZWxQYXRoLCBjaGFubmVsLCBzdGF0ZSk7XG4gICAgc3RhdGUgPSBzZXQoW2FjdGlvbi5tZXRhLmRpcmVjdGlvbiwgc2VjcmV0aGFzaF0sIHRyYW5zZmVyU3RhdGUsIHN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB0cmFuc2ZlckV4cGlyZVN1Y2Nlc3NSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCBleHBpcmVkID0gYWN0aW9uLnBheWxvYWQubWVzc2FnZTtcbiAgICBjb25zdCBzZWNyZXRoYXNoID0gYWN0aW9uLm1ldGEuc2VjcmV0aGFzaDtcbiAgICBpZiAoIShzZWNyZXRoYXNoIGluIHN0YXRlW2FjdGlvbi5tZXRhLmRpcmVjdGlvbl0pIHx8XG4gICAgICAgIHN0YXRlW2FjdGlvbi5tZXRhLmRpcmVjdGlvbl1bc2VjcmV0aGFzaF0udW5sb2NrIHx8IC8vIGRvbid0IGFjY2VwdCBleHBpcmUgaWYgYWxyZWFkeSB1bmxvY2tlZFxuICAgICAgICBzdGF0ZVthY3Rpb24ubWV0YS5kaXJlY3Rpb25dW3NlY3JldGhhc2hdLmxvY2tFeHBpcmVkIC8vIGFscmVhZHkgZXhwaXJlZFxuICAgIClcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGNvbnN0IHRyYW5zZmVyID0gc3RhdGVbYWN0aW9uLm1ldGEuZGlyZWN0aW9uXVtzZWNyZXRoYXNoXS50cmFuc2ZlclsxXTtcbiAgICBjb25zdCBwYXJ0bmVyID0gc3RhdGVbYWN0aW9uLm1ldGEuZGlyZWN0aW9uXVtzZWNyZXRoYXNoXS5wYXJ0bmVyO1xuICAgIGNvbnN0IGVuZCA9IEVORFthY3Rpb24ubWV0YS5kaXJlY3Rpb25dO1xuICAgIGNvbnN0IGxvY2sgPSB0cmFuc2Zlci5sb2NrO1xuICAgIGNvbnN0IGNoYW5uZWxQYXRoID0gWydjaGFubmVscycsIHRyYW5zZmVyLnRva2VuX25ldHdvcmtfYWRkcmVzcywgcGFydG5lcl07XG4gICAgbGV0IGNoYW5uZWwgPSBnZXQoY2hhbm5lbFBhdGgsIHN0YXRlKTtcbiAgICBpZiAoIWNoYW5uZWwgfHwgIWNoYW5uZWxbZW5kXS5sb2NrcyB8fCAhY2hhbm5lbFtlbmRdLmJhbGFuY2VQcm9vZilcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGNvbnN0IGxvY2tzID0gY2hhbm5lbFtlbmRdLmxvY2tzLmZpbHRlcigobCkgPT4gbC5zZWNyZXRoYXNoICE9PSBzZWNyZXRoYXNoKTtcbiAgICBjb25zdCBsb2Nrc3Jvb3QgPSBnZXRMb2Nrc3Jvb3QobG9ja3MpO1xuICAgIGlmIChleHBpcmVkLmxvY2tzcm9vdCAhPT0gbG9ja3Nyb290IHx8XG4gICAgICAgICFjaGFubmVsW2VuZF0uYmFsYW5jZVByb29mLm5vbmNlLmFkZCgxKS5lcShleHBpcmVkLm5vbmNlKSB8fCAvLyBub25jZSBtdXN0IGJlIG5leHRcbiAgICAgICAgIWV4cGlyZWQudHJhbnNmZXJyZWRfYW1vdW50LmVxKGNoYW5uZWxbZW5kXS5iYWxhbmNlUHJvb2YudHJhbnNmZXJyZWRBbW91bnQpIHx8XG4gICAgICAgICFleHBpcmVkLmxvY2tlZF9hbW91bnQuZXEoY2hhbm5lbFtlbmRdLmJhbGFuY2VQcm9vZi5sb2NrZWRBbW91bnQuc3ViKGxvY2suYW1vdW50KSkpXG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICBjaGFubmVsID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGFubmVsKSwgeyBbZW5kXTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGFubmVsW2VuZF0pLCB7IGxvY2tzLCBcbiAgICAgICAgICAgIC8vIHNldCBjdXJyZW50L2xhdGVzdCBjaGFubmVsW2VuZF0uYmFsYW5jZVByb29mIHRvIExvY2tFeHBpcmVkJ3NcbiAgICAgICAgICAgIGJhbGFuY2VQcm9vZjogZ2V0QmFsYW5jZVByb29mRnJvbUVudmVsb3BlTWVzc2FnZShleHBpcmVkKSB9KSB9KTtcbiAgICBjb25zdCB0cmFuc2ZlclN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZVthY3Rpb24ubWV0YS5kaXJlY3Rpb25dW3NlY3JldGhhc2hdKSwgeyBsb2NrRXhwaXJlZDogdGltZWQoZXhwaXJlZCkgfSk7XG4gICAgc3RhdGUgPSBzZXQoY2hhbm5lbFBhdGgsIGNoYW5uZWwsIHN0YXRlKTtcbiAgICBzdGF0ZSA9IHNldChbYWN0aW9uLm1ldGEuZGlyZWN0aW9uLCBzZWNyZXRoYXNoXSwgdHJhbnNmZXJTdGF0ZSwgc3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHRyYW5zZmVyU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBjb25zdCBzZWNyZXRoYXNoID0gYWN0aW9uLm1ldGEuc2VjcmV0aGFzaDtcbiAgICBpZiAoIShzZWNyZXRoYXNoIGluIHN0YXRlW2FjdGlvbi5tZXRhLmRpcmVjdGlvbl0pKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgbGV0IGtleTtcbiAgICBpZiAodHJhbnNmZXJQcm9jZXNzZWQuaXMoYWN0aW9uKSkge1xuICAgICAgICBrZXkgPSAndHJhbnNmZXJQcm9jZXNzZWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2ZlclVubG9ja1Byb2Nlc3NlZC5pcyhhY3Rpb24pKSB7XG4gICAgICAgIGtleSA9ICd1bmxvY2tQcm9jZXNzZWQnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2ZlckV4cGlyZVByb2Nlc3NlZC5pcyhhY3Rpb24pKSB7XG4gICAgICAgIGtleSA9ICdsb2NrRXhwaXJlZFByb2Nlc3NlZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zZmVyUmVmdW5kZWQuaXMoYWN0aW9uKSkge1xuICAgICAgICBrZXkgPSAncmVmdW5kJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlW2FjdGlvbi5tZXRhLmRpcmVjdGlvbl1bc2VjcmV0aGFzaF1ba2V5XSlcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgeyBbYWN0aW9uLm1ldGEuZGlyZWN0aW9uXTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZVthY3Rpb24ubWV0YS5kaXJlY3Rpb25dKSwgeyBbc2VjcmV0aGFzaF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGVbYWN0aW9uLm1ldGEuZGlyZWN0aW9uXVtzZWNyZXRoYXNoXSksIHsgW2tleV06IHRpbWVkKGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2UpIH0pIH0pIH0pO1xufVxuZnVuY3Rpb24gY2hhbm5lbENsb3NlU3VjY2Vzc1JlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIGxldCBzZW50ID0gc3RhdGUuc2VudDtcbiAgICBmb3IgKGNvbnN0IFtzZWNyZXRoYXNoLCB2XSBvZiBPYmplY3QuZW50cmllcyhzZW50KSkge1xuICAgICAgICBjb25zdCB0cmFuc2ZlciA9IHYudHJhbnNmZXJbMV07XG4gICAgICAgIGlmICghdHJhbnNmZXIuY2hhbm5lbF9pZGVudGlmaWVyLmVxKGFjdGlvbi5wYXlsb2FkLmlkKSB8fFxuICAgICAgICAgICAgdHJhbnNmZXIucmVjaXBpZW50ICE9PSBhY3Rpb24ubWV0YS5wYXJ0bmVyIHx8XG4gICAgICAgICAgICB0cmFuc2Zlci50b2tlbl9uZXR3b3JrX2FkZHJlc3MgIT09IGFjdGlvbi5tZXRhLnRva2VuTmV0d29yaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBzZW50ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZW50KSwgeyBbc2VjcmV0aGFzaF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdiksIHsgY2hhbm5lbENsb3NlZDogdGltZWQoYWN0aW9uLnBheWxvYWQudHhIYXNoKSB9KSB9KTtcbiAgICB9XG4gICAgaWYgKHNlbnQgIT09IHN0YXRlLnNlbnQpXG4gICAgICAgIHN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHsgc2VudCB9KTtcbiAgICBsZXQgcmVjZWl2ZWQgPSBzdGF0ZS5yZWNlaXZlZDtcbiAgICBmb3IgKGNvbnN0IFtzZWNyZXRoYXNoLCB2XSBvZiBPYmplY3QuZW50cmllcyhyZWNlaXZlZCkpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmZXIgPSB2LnRyYW5zZmVyWzFdO1xuICAgICAgICBpZiAoIXRyYW5zZmVyLmNoYW5uZWxfaWRlbnRpZmllci5lcShhY3Rpb24ucGF5bG9hZC5pZCkgfHxcbiAgICAgICAgICAgIHRyYW5zZmVyLnJlY2lwaWVudCAhPT0gYWN0aW9uLm1ldGEucGFydG5lciB8fFxuICAgICAgICAgICAgdHJhbnNmZXIudG9rZW5fbmV0d29ya19hZGRyZXNzICE9PSBhY3Rpb24ubWV0YS50b2tlbk5ldHdvcmspXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmVjZWl2ZWQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlY2VpdmVkKSwgeyBbc2VjcmV0aGFzaF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdiksIHsgY2hhbm5lbENsb3NlZDogdGltZWQoYWN0aW9uLnBheWxvYWQudHhIYXNoKSB9KSB9KTtcbiAgICB9XG4gICAgaWYgKHJlY2VpdmVkICE9PSBzdGF0ZS5yZWNlaXZlZClcbiAgICAgICAgc3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgeyByZWNlaXZlZCB9KTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB0cmFuc2ZlckNsZWFyUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3Qgc2VjcmV0aGFzaCA9IGFjdGlvbi5tZXRhLnNlY3JldGhhc2g7XG4gICAgaWYgKCEoc2VjcmV0aGFzaCBpbiBzdGF0ZVthY3Rpb24ubWV0YS5kaXJlY3Rpb25dKSlcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIHN0YXRlID0gdW5zZXQoW2FjdGlvbi5tZXRhLmRpcmVjdGlvbiwgc2VjcmV0aGFzaF0sIHN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiB3aXRoZHJhd1JlY2VpdmVTdWNjZXNzUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgLy8gVE9ETzogc3VidHJhY3QgdGhpcyBwZW5kaW5nIHdpdGhkcmF3IHJlcXVlc3QgZnJvbSBwYXJ0bmVyJ3MgY2FwYWNpdHkgKG1heWJlIHNvbWUgcGVuZGluZ1xuICAgIC8vIHdpdGhkcmF3cyBzdGF0ZSksIHJldmVydCB1cG9uIGV4cGlyYXRpb24gb3IgY29uc29saWRhdGUgb24gY29uZmlybWVkIGNoYW5uZWxXaXRoZHJhd25cbiAgICBjb25zdCBtZXNzYWdlID0gYWN0aW9uLnBheWxvYWQubWVzc2FnZTtcbiAgICBjb25zdCBjaGFubmVsUGF0aCA9IFsnY2hhbm5lbHMnLCBhY3Rpb24ubWV0YS50b2tlbk5ldHdvcmssIGFjdGlvbi5tZXRhLnBhcnRuZXJdO1xuICAgIGxldCBjaGFubmVsID0gZ2V0KGNoYW5uZWxQYXRoLCBzdGF0ZSk7XG4gICAgaWYgKCFjaGFubmVsIHx8IGNoYW5uZWwuc3RhdGUgIT09IENoYW5uZWxTdGF0ZS5vcGVuKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgLy8gY3VycmVudCBvd24gYmFsYW5jZVByb29mLCBvciB6ZXJvIGJhbGFuY2UgcHJvb2YsIHdpdGggc29tZSBrbm93biBmaWVsZHMgZmlsbGVkXG4gICAgY29uc3QgYmFsYW5jZVByb29mID0gY2hhbm5lbC5vd24uYmFsYW5jZVByb29mIHx8IHtcbiAgICAgICAgY2hhaW5JZDogbWVzc2FnZS5jaGFpbl9pZCxcbiAgICAgICAgdG9rZW5OZXR3b3JrQWRkcmVzczogYWN0aW9uLm1ldGEudG9rZW5OZXR3b3JrLFxuICAgICAgICBjaGFubmVsSWQ6IG1lc3NhZ2UuY2hhbm5lbF9pZGVudGlmaWVyLFxuICAgICAgICAvLyBiYWxhbmNlIHByb29mIGRhdGFcbiAgICAgICAgbm9uY2U6IFplcm8sXG4gICAgICAgIHRyYW5zZmVycmVkQW1vdW50OiBaZXJvLFxuICAgICAgICBsb2NrZWRBbW91bnQ6IFplcm8sXG4gICAgICAgIGxvY2tzcm9vdDogSGFzaFplcm8sXG4gICAgICAgIG1lc3NhZ2VIYXNoOiBIYXNoWmVybyxcbiAgICAgICAgc2lnbmF0dXJlOiBoZXhsaWZ5KFNpZ25hdHVyZVplcm8pLFxuICAgICAgICBzZW5kZXI6IHN0YXRlLmFkZHJlc3MsXG4gICAgfTtcbiAgICAvLyBpZiBpdCdzIHRoZSBuZXh0IG5vbmNlLCB1cGRhdGUgYmFsYW5jZSBwcm9vZlxuICAgIGlmIChtZXNzYWdlLm5vbmNlLmVxKGJhbGFuY2VQcm9vZi5ub25jZS5hZGQoMSkpICYmIG1lc3NhZ2UuZXhwaXJhdGlvbi5ndChzdGF0ZS5ibG9ja051bWJlcikpIHtcbiAgICAgICAgY2hhbm5lbCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hhbm5lbCksIHsgb3duOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoYW5uZWwub3duKSwgeyBiYWxhbmNlUHJvb2Y6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFsYW5jZVByb29mKSwgeyBub25jZTogbWVzc2FnZS5ub25jZSB9KSB9KSB9KTtcbiAgICAgICAgc3RhdGUgPSBzZXQoY2hhbm5lbFBhdGgsIGNoYW5uZWwsIHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuLyoqXG4gKiBIYW5kbGVzIGFsbCB0cmFuc2ZlcnMgYWN0aW9ucyBhbmQgcmVxdWVzdHNcbiAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zZmVyc1JlZHVjZXIgPSBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSlcbiAgICAuaGFuZGxlKFt0cmFuc2ZlclNlY3JldCwgdHJhbnNmZXJTZWNyZXRSZWdpc3Rlci5zdWNjZXNzXSwgdHJhbnNmZXJTZWNyZXRSZWR1Y2VyKVxuICAgIC5oYW5kbGUodHJhbnNmZXJTaWduZWQsIHRyYW5zZmVyU2lnbmVkUmVkdWNlcilcbiAgICAuaGFuZGxlKFt0cmFuc2ZlclByb2Nlc3NlZCwgdHJhbnNmZXJVbmxvY2tQcm9jZXNzZWQsIHRyYW5zZmVyRXhwaXJlUHJvY2Vzc2VkLCB0cmFuc2ZlclJlZnVuZGVkXSwgdHJhbnNmZXJTdGF0ZVJlZHVjZXIpXG4gICAgLmhhbmRsZSh0cmFuc2ZlclNlY3JldFJlcXVlc3QsIHRyYW5zZmVyU2VjcmV0UmVxdWVzdGVkUmVkdWNlcilcbiAgICAuaGFuZGxlKHRyYW5zZmVyU2VjcmV0UmV2ZWFsLCB0cmFuc2ZlclNlY3JldFJldmVsZWRSZWR1Y2VyKVxuICAgIC5oYW5kbGUodHJhbnNmZXJVbmxvY2suc3VjY2VzcywgdHJhbnNmZXJVbmxvY2tTdWNjZXNzUmVkdWNlcilcbiAgICAuaGFuZGxlKHRyYW5zZmVyRXhwaXJlLnN1Y2Nlc3MsIHRyYW5zZmVyRXhwaXJlU3VjY2Vzc1JlZHVjZXIpXG4gICAgLmhhbmRsZShjaGFubmVsQ2xvc2Uuc3VjY2VzcywgY2hhbm5lbENsb3NlU3VjY2Vzc1JlZHVjZXIpXG4gICAgLmhhbmRsZSh0cmFuc2ZlckNsZWFyLCB0cmFuc2ZlckNsZWFyUmVkdWNlcilcbiAgICAuaGFuZGxlKHdpdGhkcmF3UmVjZWl2ZS5zdWNjZXNzLCB3aXRoZHJhd1JlY2VpdmVTdWNjZXNzUmVkdWNlcik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1Y2VyLmpzLm1hcCIsImltcG9ydCB1bnNldCBmcm9tICdsb2Rhc2gvZnAvdW5zZXQnO1xuaW1wb3J0IHsgY2hhbm5lbHNSZWR1Y2VyIH0gZnJvbSAnLi9jaGFubmVscy9yZWR1Y2VyJztcbmltcG9ydCB7IHBhdGhSZWR1Y2VyIH0gZnJvbSAnLi9wYXRoL3JlZHVjZXInO1xuaW1wb3J0IHsgdHJhbnNwb3J0UmVkdWNlciB9IGZyb20gJy4vdHJhbnNwb3J0L3JlZHVjZXInO1xuaW1wb3J0IHsgdHJhbnNmZXJzUmVkdWNlciB9IGZyb20gJy4vdHJhbnNmZXJzL3JlZHVjZXInO1xuaW1wb3J0IHsgcmFpZGVuQ29uZmlnVXBkYXRlIH0gZnJvbSAnLi9hY3Rpb25zJztcbmltcG9ydCB7IGluaXRpYWxTdGF0ZSB9IGZyb20gJy4vc3RhdGUnO1xuaW1wb3J0IHsgY3JlYXRlUmVkdWNlciB9IGZyb20gJy4vdXRpbHMvYWN0aW9ucyc7XG4vLyB1cGRhdGUgc3RhdGUuY29uZmlnIG9uIHJhaWRlbkNvbmZpZ1VwZGF0ZSBhY3Rpb25cbi8vIHJlc2V0cyBrZXkgdG8gZGVmYXVsdCB2YWx1ZSBpZiB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBvdmVyd3JpdGVzIGl0XG5jb25zdCBjb25maWdSZWR1Y2VyID0gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUpLmhhbmRsZShyYWlkZW5Db25maWdVcGRhdGUsIChzdGF0ZSwgeyBwYXlsb2FkIH0pID0+IHtcbiAgICBsZXQgY29uZmlnID0gc3RhdGUuY29uZmlnO1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHBheWxvYWQpKSB7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBjb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyksIHsgW2tdOiB2IH0pO1xuICAgICAgICBlbHNlIGlmIChrIGluIGNvbmZpZylcbiAgICAgICAgICAgIGNvbmZpZyA9IHVuc2V0KGssIGNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChjb25maWcgPT09IHN0YXRlLmNvbmZpZylcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwgeyBjb25maWcgfSk7XG59KTtcbmNvbnN0IHJhaWRlblJlZHVjZXJzID0ge1xuICAgIGNvbmZpZ1JlZHVjZXIsXG4gICAgY2hhbm5lbHNSZWR1Y2VyLFxuICAgIHBhdGhSZWR1Y2VyLFxuICAgIHRyYW5zcG9ydFJlZHVjZXIsXG4gICAgdHJhbnNmZXJzUmVkdWNlcixcbn07XG4vKipcbiAqIFJhaWRlbiByb290IHJlZHVjZXJcbiAqIEFwcGx5IGFjdGlvbiBvdmVyIGVhY2ggc3VibW9kdWxlIHJvb3QgcmVkdWNlciBpbiBhIGZsYXR0ZW5lZCBtYW5uZXIgKGl0ZXJhdGl2ZWx5KS5cbiAqIE5vdGljZSB0aGUgc3VibW9kdWxlcyByZWR1Y2VycyBhcmVuJ3QgaGFuZGxlZCBvbmx5IGEgcGFydGlhbC9kZWVwIHByb3BlcnR5IG9mIHRoZSBzdGF0ZVxuICogKGFzIGNvbWJpbmVSZWR1Y2VycyksIGJ1dCBpbnN0ZWFkIHJlY2VpdmUgdGhlIHdob2xlIHN0YXRlLCBzbyB0aGV5IGNhbiBhY3Qgb24gYW55IHBhcnQgb2YgdGhlXG4gKiBzdGF0ZS4gVGhpcyBhcHByb2FjaCBpcyBzaW1pbGFyIHRvIGByZWR1Y2UtcmVkdWNlcnNgIHV0aWwuXG4gKiBFYWNoIHN1Ym1vZHVsZSByb290IHJlZHVjZXIgbWF5IHRoZW4gY2hvb3NlIHRvIHNwbGl0IGl0cyBjb25jZXJucyBpbnRvIG5lc3RlZCBvciBmbGF0dGVuZWRcbiAqIHJlZHVjZXJzIChsaWtlIHRoaXMgb25lKS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgLSBDdXJyZW50IFJhaWRlblN0YXRlIHRvIHJlZHVjZVxuICogQHBhcmFtIGFjdGlvbiAtIFJhaWRlbkFjdGlvbiB0byBhcHBseSBvdmVyIHN0YXRlXG4gKiBAcmV0dXJucyBOZXcgUmFpZGVuU3RhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHJhaWRlblJlZHVjZXIgPSAoc3RhdGUgPSBpbml0aWFsU3RhdGUsIGFjdGlvbikgPT4gT2JqZWN0LnZhbHVlcyhyYWlkZW5SZWR1Y2VycykucmVkdWNlKChzLCByZWR1Y2VyKSA9PiByZWR1Y2VyKHMsIGFjdGlvbiksIHN0YXRlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZXIuanMubWFwIiwiaW1wb3J0IHsgcGx1Y2ssIGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuLyoqXG4gKiBNYXBzIGVhY2ggc291cmNlIHZhbHVlIChhbiBvYmplY3QpIHRvIGl0cyBzcGVjaWZpZWQgbmVzdGVkIHByb3BlcnR5LFxuICogYW5kIGVtaXRzIG9ubHkgaWYgdGhlIHZhbHVlIGNoYW5nZWQgc2luY2UgbGFzdCBlbWlzc2lvblxuICpcbiAqIEl0J3MgYSBjb21iaW5hdGlvbiBvZiBgcGx1Y2tgIGFuZCBgZGlzdGluY3RVbnRpbENoYW5nZWRgIG9wZXJhdG9ycy5cbiBcbiAqIEBwYXJhbSBwcm9wZXJ0aWVzIC0gVGhlIG5lc3RlZCBwcm9wZXJ0aWVzIHRvIHBsdWNrIGZyb20gZWFjaCBzb3VyY2UgdmFsdWUgKGFuIG9iamVjdCkuXG4gKiBAcmV0dXJucyBBIG5ldyBPYnNlcnZhYmxlIG9mIHByb3BlcnR5IHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgdmFsdWVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGx1Y2tEaXN0aW5jdCguLi5wcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIChzb3VyY2UpID0+IHNvdXJjZS5waXBlKHBsdWNrKC4uLnByb3BlcnRpZXMpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ4LmpzLm1hcCIsImltcG9ydCB7IGZpbHRlciwgc2Nhbiwgc3RhcnRXaXRoLCBzaGFyZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCBtZW1vaXplIGZyb20gJ2xvZGFzaC9tZW1vaXplJztcbmltcG9ydCB7IG1hdHJpeFByZXNlbmNlIH0gZnJvbSAnLi9hY3Rpb25zJztcbi8qKlxuICogSGVscGVyIHRvIG1hcC9nZXQgYW4gYWdncmVnYXRlZCBQcmVzZW5jZXMgb2JzZXJ2YWJsZSBmcm9tIGFjdGlvbiQgYnVzXG4gKiBLbm93biBwcmVzZW5jZXMgYXMgeyBhZGRyZXNzOiA8bGFzdCBzZWVuIE1hdHJpeFByZXNlbmNlVXBkYXRlQWN0aW9uPiB9IG1hcHBpbmdcbiAqIEl0J3MgbWVtb2l6ZWQgYW5kIHNoYXJlZCwgc28gYWxsIHN1YnNjcmlwdGlvbnMgc2hhcmUgdGhlIHNhbWUgbWFwcGVkL291dHB1dCBvYmplY3QsIGJ1dCB0aGUgdHlwZVxuICogaXMgZXhwbGljaXRseSBzZXQgdG8gYXZvaWQgcmVxdWlyaW5nIHRoZSBleHBvcnRlZCBNZW1vaXplZEZ1bmN0aW9uIHR5cGVcbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGVcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgYWdncmVnYXRlZCBQcmVzZW5jZXMgZnJvbSBzdWJzY3JpcHRpb24gdG8gbm93XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRQcmVzZW5jZXMkID0gbWVtb2l6ZSgoYWN0aW9uJCkgPT4gYWN0aW9uJC5waXBlKGZpbHRlcihtYXRyaXhQcmVzZW5jZS5zdWNjZXNzLmlzKSwgc2Nhbihcbi8vIHNjYW4gYWxsIHByZXNlbmNlIHVwZGF0ZSBhY3Rpb25zIGFuZCBwb3B1bGF0ZS9vdXRwdXQgYSBwZXItYWRkcmVzcyBtYXBwaW5nXG4ocHJlc2VuY2VzLCB1cGRhdGUpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXNlbmNlcyksIHsgW3VwZGF0ZS5tZXRhLmFkZHJlc3NdOiB1cGRhdGUgfSkpLCB7fSksIHNoYXJlKCksIHN0YXJ0V2l0aCh7fSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsImV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9zdGF0ZSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBmcm9tIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YXAsIG1lcmdlTWFwLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBaZXJvIH0gZnJvbSAnZXRoZXJzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBSYWlkZW5FcnJvciB9IGZyb20gJy4uL3V0aWxzL2Vycm9yJztcbmltcG9ydCB7IENoYW5uZWxTdGF0ZSB9IGZyb20gJy4vc3RhdGUnO1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHBhcnRpYWwgYW5kIHRvdGFsIGFtb3VudHMgb2YgZ2l2ZW4gY2hhbm5lbCBzdGF0ZVxuICpcbiAqIEBwYXJhbSBjaGFubmVsIC0gQSBDaGFubmVsIHN0YXRlIHRvIGNhbGN1bGF0ZSBhbW91bnRzIGZyb21cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBob2xkaW5nIG93biZwYXJ0bmVyJ3MgZGVwb3NpdCwgd2l0aGRyYXcsIHRyYW5zZmVycmVkLCBsb2NrZWQsIGJhbGFuY2UgYW5kXG4gKiAgICAgICAgICBjYXBhY2l0eS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoYW5uZWxBbW91bnRzKGNoYW5uZWwpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XG4gICAgY29uc3QgWmVybzMyID0gWmVybztcbiAgICBpZiAoY2hhbm5lbC5zdGF0ZSAhPT0gQ2hhbm5lbFN0YXRlLm9wZW4pXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvd25EZXBvc2l0OiBaZXJvMzIsXG4gICAgICAgICAgICBvd25XaXRoZHJhdzogWmVybzMyLFxuICAgICAgICAgICAgb3duVHJhbnNmZXJyZWQ6IFplcm8zMixcbiAgICAgICAgICAgIG93bkxvY2tlZDogWmVybzMyLFxuICAgICAgICAgICAgb3duQmFsYW5jZTogWmVybzMyLFxuICAgICAgICAgICAgb3duQ2FwYWNpdHk6IFplcm8zMixcbiAgICAgICAgICAgIHBhcnRuZXJEZXBvc2l0OiBaZXJvMzIsXG4gICAgICAgICAgICBwYXJ0bmVyV2l0aGRyYXc6IFplcm8zMixcbiAgICAgICAgICAgIHBhcnRuZXJUcmFuc2ZlcnJlZDogWmVybzMyLFxuICAgICAgICAgICAgcGFydG5lckxvY2tlZDogWmVybzMyLFxuICAgICAgICAgICAgcGFydG5lckJhbGFuY2U6IFplcm8zMixcbiAgICAgICAgICAgIHBhcnRuZXJDYXBhY2l0eTogWmVybzMyLFxuICAgICAgICB9O1xuICAgIGNvbnN0IG93bldpdGhkcmF3ID0gKF9hID0gY2hhbm5lbC5vd24ud2l0aGRyYXcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFplcm8zMiwgcGFydG5lcldpdGhkcmF3ID0gKF9iID0gY2hhbm5lbC5wYXJ0bmVyLndpdGhkcmF3KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBaZXJvMzIsIG93blRyYW5zZmVycmVkID0gKF9kID0gKF9jID0gY2hhbm5lbC5vd24uYmFsYW5jZVByb29mKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudHJhbnNmZXJyZWRBbW91bnQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFplcm8zMiwgcGFydG5lclRyYW5zZmVycmVkID0gKF9mID0gKF9lID0gY2hhbm5lbC5wYXJ0bmVyLmJhbGFuY2VQcm9vZikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnRyYW5zZmVycmVkQW1vdW50KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBaZXJvMzIsIG93bkxvY2tlZCA9IChfaCA9IChfZyA9IGNoYW5uZWwub3duLmJhbGFuY2VQcm9vZikgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmxvY2tlZEFtb3VudCkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogWmVybzMyLCBwYXJ0bmVyTG9ja2VkID0gKF9rID0gKF9qID0gY2hhbm5lbC5wYXJ0bmVyLmJhbGFuY2VQcm9vZikgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmxvY2tlZEFtb3VudCkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogWmVybzMyLCBvd25CYWxhbmNlID0gcGFydG5lclRyYW5zZmVycmVkLnN1Yihvd25UcmFuc2ZlcnJlZCksIHBhcnRuZXJCYWxhbmNlID0gb3duVHJhbnNmZXJyZWQuc3ViKHBhcnRuZXJUcmFuc2ZlcnJlZCksIC8vID09IC1vd25CYWxhbmNlXG4gICAgb3duQ2FwYWNpdHkgPSBjaGFubmVsLm93bi5kZXBvc2l0LnN1Yihvd25XaXRoZHJhdykuc3ViKG93bkxvY2tlZCkuYWRkKG93bkJhbGFuY2UpLCBwYXJ0bmVyQ2FwYWNpdHkgPSBjaGFubmVsLnBhcnRuZXIuZGVwb3NpdFxuICAgICAgICAuc3ViKHBhcnRuZXJXaXRoZHJhdylcbiAgICAgICAgLnN1YihwYXJ0bmVyTG9ja2VkKVxuICAgICAgICAuYWRkKHBhcnRuZXJCYWxhbmNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvd25EZXBvc2l0OiBjaGFubmVsLm93bi5kZXBvc2l0LFxuICAgICAgICBvd25XaXRoZHJhdyxcbiAgICAgICAgb3duVHJhbnNmZXJyZWQsXG4gICAgICAgIG93bkxvY2tlZCxcbiAgICAgICAgb3duQmFsYW5jZSxcbiAgICAgICAgb3duQ2FwYWNpdHksXG4gICAgICAgIHBhcnRuZXJEZXBvc2l0OiBjaGFubmVsLnBhcnRuZXIuZGVwb3NpdCxcbiAgICAgICAgcGFydG5lcldpdGhkcmF3LFxuICAgICAgICBwYXJ0bmVyVHJhbnNmZXJyZWQsXG4gICAgICAgIHBhcnRuZXJMb2NrZWQsXG4gICAgICAgIHBhcnRuZXJCYWxhbmNlLFxuICAgICAgICBwYXJ0bmVyQ2FwYWNpdHksXG4gICAgfTtcbn1cbi8qKlxuICogQ3VzdG9tIG9wZXJhdG9yIHRvIHdhaXQgJiBhc3NlcnQgdHJhbnNhY3Rpb24gc3VjY2Vzc1xuICpcbiAqIEBwYXJhbSBtZXRob2QgLSBtZXRob2QgbmFtZSB0byB1c2UgaW4gbG9nc1xuICogQHBhcmFtIGVycm9yIC0gRXJyb3JDb2RlIHRvIHRocm93IGlmIHRyYW5zYWN0aW9uIGZhaWxzXG4gKiBAcGFyYW0gZGVwcyAtIG9iamVjdCBjb250YWluaW5nIGxvZ2dlclxuICogQHJldHVybnMgb3BlcmF0b3IgZnVuY3Rpb24gdG8gd2FpdCBmb3IgdHJhbnNhY3Rpb24gYW5kIG91dHB1dCBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUeChtZXRob2QsIGVycm9yLCB7IGxvZyB9KSB7XG4gICAgcmV0dXJuICh0eCkgPT4gdHgucGlwZSh0YXAoKHR4KSA9PiBsb2cuZGVidWcoYHNlbnQgJHttZXRob2R9IHR4IFwiJHt0eC5oYXNofVwiIHRvIFwiJHt0eC50b31cImApKSwgbWVyZ2VNYXAoKHR4KSA9PiBmcm9tKHR4LndhaXQoKSkucGlwZShtYXAoKHJlY2VpcHQpID0+IHtcbiAgICAgICAgaWYgKCFyZWNlaXB0LnN0YXR1cylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYWlkZW5FcnJvcihlcnJvciwgeyB0cmFuc2FjdGlvbkhhc2g6IHR4Lmhhc2ggfSk7XG4gICAgICAgIGxvZy5kZWJ1ZyhgJHttZXRob2R9IHR4IFwiJHt0eC5oYXNofVwiIHN1Y2Nlc3NmdWx5IG1pbmVkIWApO1xuICAgICAgICByZXR1cm4gdHguaGFzaDtcbiAgICB9KSkpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgU2lnbmVyIH0gZnJvbSAnZXRoZXJzL2Fic3RyYWN0LXNpZ25lcic7XG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tICdldGhlcnMvd2FsbGV0JztcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCBzaGEyNTYgfSBmcm9tICdldGhlcnMvdXRpbHMnO1xuaW1wb3J0IHsgZnJvbSwgZGVmZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgbWFwLCBzY2FuLCBjb25jYXRNYXAsIHBsdWNrLCB3aXRoTGF0ZXN0RnJvbSwgZmlyc3QsIGV4aGF1c3RNYXAsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHBpY2sgZnJvbSAnbG9kYXNoL3BpY2snO1xuaW1wb3J0IHRyYW5zZm9ybSBmcm9tICdsb2Rhc2gvdHJhbnNmb3JtJztcbmltcG9ydCBmaW5kS2V5IGZyb20gJ2xvZGFzaC9maW5kS2V5JztcbmltcG9ydCBsb2dnaW5nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7IHJhaWRlblNlbnRUcmFuc2ZlciB9IGZyb20gJy4vdHJhbnNmZXJzL3V0aWxzJztcbmltcG9ydCB7IGNoYW5uZWxBbW91bnRzIH0gZnJvbSAnLi9jaGFubmVscy91dGlscyc7XG5pbXBvcnQgeyBwbHVja0Rpc3RpbmN0IH0gZnJvbSAnLi91dGlscy9yeCc7XG5pbXBvcnQgeyBBZGRyZXNzLCBQcml2YXRlS2V5LCBpc250TmlsLCBhc3NlcnQgfSBmcm9tICcuL3V0aWxzL3R5cGVzJztcbmltcG9ydCB7IGdldE5ldHdvcmtOYW1lIH0gZnJvbSAnLi91dGlscy9ldGhlcnMnO1xuaW1wb3J0IHJvcHN0ZW5EZXBsb3kgZnJvbSAnLi9kZXBsb3ltZW50L2RlcGxveW1lbnRfcm9wc3Rlbi5qc29uJztcbmltcG9ydCByaW5rZWJ5RGVwbG95IGZyb20gJy4vZGVwbG95bWVudC9kZXBsb3ltZW50X3JpbmtlYnkuanNvbic7XG5pbXBvcnQgZ29lcmxpRGVwbG95IGZyb20gJy4vZGVwbG95bWVudC9kZXBsb3ltZW50X2dvZXJsaS5qc29uJztcbmltcG9ydCByb3BzdGVuU2VydmljZXNEZXBsb3kgZnJvbSAnLi9kZXBsb3ltZW50L2RlcGxveW1lbnRfc2VydmljZXNfcm9wc3Rlbi5qc29uJztcbmltcG9ydCByaW5rZWJ5U2VydmljZXNEZXBsb3kgZnJvbSAnLi9kZXBsb3ltZW50L2RlcGxveW1lbnRfc2VydmljZXNfcmlua2VieS5qc29uJztcbmltcG9ydCBnb2VybGlTZXJ2aWNlc0RlcGxveSBmcm9tICcuL2RlcGxveW1lbnQvZGVwbG95bWVudF9zZXJ2aWNlc19nb2VybGkuanNvbic7XG5pbXBvcnQgeyBSYWlkZW5FcnJvciwgRXJyb3JDb2RlcyB9IGZyb20gJy4vdXRpbHMvZXJyb3InO1xuLyoqXG4gKiBSZXR1cm5zIGNvbnRyYWN0IGluZm9ybWF0aW9uIGRlcGVuZGluZyBvbiB0aGUgcGFzc2VkIFtbTmV0d29ya11dLiBDdXJyZW50bHksIG9ubHlcbiAqIGByaW5rZWJ5YCwgYHJvcHN0ZW5gIGFuZCBgZ29lcmxpYCBhcmUgc3VwcG9ydGVkLlxuICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBjYWxsZWQgd2l0aCBhbm90aGVyIFtbTmV0d29ya11dLlxuICpcbiAqIEBwYXJhbSBuZXR3b3JrIC0gYW4gYWNjb3VudCB1c2VkIGZvciBzaWduaW5nXG4gKiBAcmV0dXJucyBkZXBsb3llZCBjb250cmFjdCBpbmZvcm1hdGlvbiBvZiB0aGUgbmV0d29ya1xuICovXG5leHBvcnQgY29uc3QgZ2V0Q29udHJhY3RzID0gKG5ldHdvcmspID0+IHtcbiAgICBzd2l0Y2ggKG5ldHdvcmsubmFtZSkge1xuICAgICAgICBjYXNlICdyaW5rZWJ5JzpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJpbmtlYnlEZXBsb3kuY29udHJhY3RzKSwgcmlua2VieVNlcnZpY2VzRGVwbG95LmNvbnRyYWN0cyk7XG4gICAgICAgIGNhc2UgJ3JvcHN0ZW4nOlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcm9wc3RlbkRlcGxveS5jb250cmFjdHMpLCByb3BzdGVuU2VydmljZXNEZXBsb3kuY29udHJhY3RzKTtcbiAgICAgICAgY2FzZSAnZ29lcmxpJzpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGdvZXJsaURlcGxveS5jb250cmFjdHMpLCBnb2VybGlTZXJ2aWNlc0RlcGxveS5jb250cmFjdHMpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuUkROX1VOUkVDT0dOSVpFRF9ORVRXT1JLLCB7IG5ldHdvcms6IG5ldHdvcmsubmFtZSB9KTtcbiAgICB9XG59O1xuLyoqXG4gKiBHZW5lcmF0ZSwgc2lnbiBhbmQgcmV0dXJuIGEgc3Via2V5IGZyb20gcHJvdmlkZWQgbWFpbiBhY2NvdW50XG4gKlxuICogQHBhcmFtIG5ldHdvcmsgLSBOZXR3b3JrIHRvIGluY2x1ZGUgaW4gbWVzc2FnZVxuICogQHBhcmFtIG1haW4gLSBNYWluIHNpZ25lciB0byBkZXJpdmUgc3Via2V5IGZyb21cbiAqIEByZXR1cm5zIFN1YmtleSdzIHNpZ25lciAmIGFkZHJlc3NcbiAqL1xuZnVuY3Rpb24gZ2VuU3Via2V5KG5ldHdvcmssIG1haW4pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IChfYiA9IChfYSA9IGdsb2JhbFRoaXMgPT09IG51bGwgfHwgZ2xvYmFsVGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2xvYmFsVGhpcy5sb2NhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9yaWdpbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYD09PSBSQUlERU4gU1VCS0VZIEdFTkVSQVRJT04gPT09XG5cbk5ldHdvcms6ICR7Z2V0TmV0d29ya05hbWUobmV0d29yaykudG9VcHBlckNhc2UoKX1cblJhaWRlbiBkQXBwIFVSTDogJHt1cmx9XG5cbldBUk5JTkc6IGVuc3VyZSB0aGlzIHNpZ25hdHVyZSBpcyBiZWluZyByZXF1ZXN0ZWQgZnJvbSBSYWlkZW4gZEFwcCBydW5uaW5nIGF0IFVSTCBhYm92ZSBieSBjb21wYXJpbmcgaXQgdG8geW91ciBicm93c2VyJ3MgdXJsIGJhci5cblNpZ25pbmcgdGhpcyBtZXNzYWdlIGF0IGFueSBvdGhlciBhZGRyZXNzIFdJTEwgZ2l2ZSBpdCBGVUxMIGNvbnRyb2wgb2YgdGhpcyBzdWJrZXkncyBmdW5kcywgdG9rZW5zIGFuZCBSYWlkZW4gY2hhbm5lbHMhYDtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0geWllbGQgbWFpbi5zaWduTWVzc2FnZSh0b1V0ZjhCeXRlcyhtZXNzYWdlKSk7XG4gICAgICAgIGNvbnN0IHBrID0gc2hhMjU2KHNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IHNpZ25lciA9IG5ldyBXYWxsZXQocGssIG1haW4ucHJvdmlkZXIpO1xuICAgICAgICByZXR1cm4geyBzaWduZXIsIGFkZHJlc3M6IHNpZ25lci5hZGRyZXNzIH07XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBbW1NpZ25lcl1dIGJhc2VkIG9uIHRoZSBgYWNjb3VudGAgYW5kIGBwcm92aWRlcmAuXG4gKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBgYWNjb3VudGAgaXMgbm90IGEgdmFsaWQgYWRkcmVzcyBvciBwcml2YXRlIGtleS5cbiAqXG4gKiBAcGFyYW0gYWNjb3VudCAtIGFuIGFjY291bnQgdXNlZCBmb3Igc2lnbmluZ1xuICogQHBhcmFtIHByb3ZpZGVyIC0gYSBwcm92aWRlclxuICogQHBhcmFtIHN1YmtleSAtIFdoZXRoZXIgdG8gZ2VuZXJhdGUgYSBzdWJrZXlcbiAqIEByZXR1cm5zIGEgW1tTaWduZXJdXSBvciBbW1dhbGxldF1dIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHNpZ25pbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFNpZ25lciA9IChhY2NvdW50LCBwcm92aWRlciwgc3Via2V5KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBsZXQgc2lnbmVyO1xuICAgIGxldCBhZGRyZXNzO1xuICAgIGxldCBtYWluO1xuICAgIGlmIChTaWduZXIuaXNTaWduZXIoYWNjb3VudCkpIHtcbiAgICAgICAgaWYgKGFjY291bnQucHJvdmlkZXIgPT09IHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBzaWduZXIgPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY291bnQgaW5zdGFuY2VvZiBXYWxsZXQpIHtcbiAgICAgICAgICAgIHNpZ25lciA9IGFjY291bnQuY29ubmVjdChwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFpZGVuRXJyb3IoRXJyb3JDb2Rlcy5SRE5fU0lHTkVSX05PVF9DT05ORUNURUQsIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50OiBhY2NvdW50LnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHByb3ZpZGVyLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzID0gKHlpZWxkIHNpZ25lci5nZXRBZGRyZXNzKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYWNjb3VudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gaW5kZXggb2YgYWNjb3VudCBpbiBwcm92aWRlclxuICAgICAgICBzaWduZXIgPSBwcm92aWRlci5nZXRTaWduZXIoYWNjb3VudCk7XG4gICAgICAgIGFkZHJlc3MgPSAoeWllbGQgc2lnbmVyLmdldEFkZHJlc3MoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFkZHJlc3MuaXMoYWNjb3VudCkpIHtcbiAgICAgICAgLy8gYWRkcmVzc1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IHlpZWxkIHByb3ZpZGVyLmxpc3RBY2NvdW50cygpO1xuICAgICAgICBpZiAoIWFjY291bnRzLmluY2x1ZGVzKGFjY291bnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFpZGVuRXJyb3IoRXJyb3JDb2Rlcy5SRE5fQUNDT1VOVF9OT1RfRk9VTkQsIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgICAgIGFjY291bnRzOiBKU09OLnN0cmluZ2lmeShhY2NvdW50cyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzaWduZXIgPSBwcm92aWRlci5nZXRTaWduZXIoYWNjb3VudCk7XG4gICAgICAgIGFkZHJlc3MgPSBhY2NvdW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChQcml2YXRlS2V5LmlzKGFjY291bnQpKSB7XG4gICAgICAgIC8vIHByaXZhdGUga2V5XG4gICAgICAgIHNpZ25lciA9IG5ldyBXYWxsZXQoYWNjb3VudCwgcHJvdmlkZXIpO1xuICAgICAgICBhZGRyZXNzID0gc2lnbmVyLmFkZHJlc3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUmFpZGVuRXJyb3IoRXJyb3JDb2Rlcy5SRE5fU1RSSU5HX0FDQ09VTlRfSU5WQUxJRCk7XG4gICAgfVxuICAgIGlmIChzdWJrZXkpIHtcbiAgICAgICAgbWFpbiA9IHsgc2lnbmVyLCBhZGRyZXNzIH07XG4gICAgICAgICh7IHNpZ25lciwgYWRkcmVzcyB9ID0geWllbGQgZ2VuU3Via2V5KHlpZWxkIHByb3ZpZGVyLmdldE5ldHdvcmsoKSwgbWFpbi5zaWduZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2lnbmVyLCBhZGRyZXNzLCBtYWluIH07XG59KTtcbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIFtbdHJhbnNmZXJzJF1dIG9ic2VydmFibGVcbiAqXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiB0aGUgY3VycmVudCBSYWlkZW5TdGF0ZVxuICogQHJldHVybnMgb2JzZXJ2YWJsZSBvZiBzZW50IGFuZCBjb21wbGV0ZWQgUmFpZGVuIHRyYW5zZmVyc1xuICovXG5leHBvcnQgY29uc3QgaW5pdFRyYW5zZmVycyQgPSAoc3RhdGUkKSA9PiBzdGF0ZSQucGlwZShwbHVja0Rpc3RpbmN0KCdzZW50JyksIGNvbmNhdE1hcCgoc2VudCkgPT4gZnJvbShPYmplY3QuZW50cmllcyhzZW50KSkpLCBcbi8qIHRoaXMgc2NhbiBzdG9yZXMgYSByZWZlcmVuY2UgdG8gZWFjaCBba2V5LHZhbHVlXSBpbiAnYWNjJywgYW5kIGVtaXQgYXMgJ2NoYW5nZWQnIGlmZiBpdFxuICogY2hhbmdlcyBmcm9tIGxhc3QgdGltZSBzZWVuLiBJdCByZWxpZXMgb24gdmFsdWUgcmVmZXJlbmNlcyBjaGFuZ2luZyBvbmx5IGlmIG5lZWRlZCAqL1xuc2NhbigoeyBhY2MgfSwgW3NlY3JldGhhc2gsIHNlbnRdKSA9PiBcbi8vIGlmIHJlZiBkaWRuJ3QgY2hhbmdlLCBlbWl0IHByZXZpb3VzIGFjY3VtdWxhdG9yLCB3aXRob3V0ICdjaGFuZ2VkJyB2YWx1ZVxuYWNjW3NlY3JldGhhc2hdID09PSBzZW50XG4gICAgPyB7IGFjYyB9XG4gICAgOiAvLyBlbHNlLCB1cGRhdGUgcmVmIGluICdhY2MnIGFuZCBlbWl0IHZhbHVlIGluICdjaGFuZ2VkJyBwcm9wXG4gICAgICAgIHsgYWNjOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW3NlY3JldGhhc2hdOiBzZW50IH0pLCBjaGFuZ2VkOiBzZW50IH0sIHsgYWNjOiB7fSB9KSwgcGx1Y2soJ2NoYW5nZWQnKSwgZmlsdGVyKGlzbnROaWwpLCAvLyBmaWx0ZXIgb3V0IGlmIHJlZmVyZW5jZSBkaWRuJ3QgY2hhbmdlIGZyb20gbGFzdCBlbWl0XG4vLyBmcm9tIGhlcmUsIHdlIGdldCBUcmFuc2ZlclN0YXRlIG9iamVjdHMgd2hpY2ggY2hhbmdlZCBmcm9tIHByZXZpb3VzIHN0YXRlIChhbGwgb24gZmlyc3QpXG5tYXAocmFpZGVuU2VudFRyYW5zZmVyKSk7XG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgbWFwcyBwYXJ0bmVyIGFkZHJlc3NlcyB0byB0aGVpciBbW1JhaWRlbkNoYW5uZWxdXS5cbiAqXG4gKiBAcGFyYW0gcGFydG5lckNoYW5uZWxNYXAgLSBhbiBvYmplY3QgdGhhdCBtYXBzIHBhcnRuZXJBZGRyZXNzIHRvIGEgY2hhbm5lbFxuICogQHBhcmFtIHRva2VuIC0gYSB0b2tlbiBhZGRyZXNzXG4gKiBAcGFyYW0gdG9rZW5OZXR3b3JrIC0gYSB0b2tlbiBuZXR3b3JrXG4gKiBAcmV0dXJucyByYWlkZW4gY2hhbm5lbFxuICovXG5jb25zdCBtYXBQYXJ0bmVyVG9DaGFubmVsID0gKHBhcnRuZXJDaGFubmVsTWFwLCB0b2tlbiwgdG9rZW5OZXR3b3JrKSA9PiB0cmFuc2Zvcm0oXG4vLyB0cmFuc2Zvcm0gQ2hhbm5lbCB0byBSYWlkZW5DaGFubmVsLCB3aXRoIG1vcmUgaW5mb1xucGFydG5lckNoYW5uZWxNYXAsIChwYXJ0bmVyMnJhaWRlbkNoYW5uZWwsIGNoYW5uZWwsIHBhcnRuZXIpID0+IHtcbiAgICBjb25zdCB7IG93bkRlcG9zaXQsIHBhcnRuZXJEZXBvc2l0LCBvd25CYWxhbmNlOiBiYWxhbmNlLCBvd25DYXBhY2l0eTogY2FwYWNpdHksIH0gPSBjaGFubmVsQW1vdW50cyhjaGFubmVsKTtcbiAgICBwYXJ0bmVyMnJhaWRlbkNoYW5uZWxbcGFydG5lcl0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBzdGF0ZTogY2hhbm5lbC5zdGF0ZSB9LCBwaWNrKGNoYW5uZWwsIFsnaWQnLCAnc2V0dGxlVGltZW91dCcsICdvcGVuQmxvY2snLCAnY2xvc2VCbG9jayddKSksIHsgdG9rZW4sIHRva2VuTmV0d29yazogdG9rZW5OZXR3b3JrLCBwYXJ0bmVyOiBwYXJ0bmVyLCBvd25EZXBvc2l0LFxuICAgICAgICBwYXJ0bmVyRGVwb3NpdCxcbiAgICAgICAgYmFsYW5jZSxcbiAgICAgICAgY2FwYWNpdHkgfSk7XG59KTtcbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgcmVkdXggY2hhbm5lbCBzdGF0ZSB0byBbW1JhaWRlbkNoYW5uZWxzXV1cbiAqXG4gKiBAcGFyYW0gc3RhdGUgLSBjdXJyZW50IHN0YXRlXG4gKiBAcmV0dXJucyByYWlkZW4gY2hhbm5lbHNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hcFRva2VuVG9QYXJ0bmVyID0gKHN0YXRlKSA9PiB0cmFuc2Zvcm0oXG4vLyB0cmFuc2Zvcm0gc3RhdGUuY2hhbm5lbHMgdG8gdG9rZW4tcGFydG5lci1yYWlkZW5DaGFubmVsIG1hcFxuc3RhdGUuY2hhbm5lbHMsIChyZXN1bHQsIHBhcnRuZXJDaGFubmVsTWFwLCB0b2tlbk5ldHdvcmspID0+IHtcbiAgICBjb25zdCB0b2tlbiA9IGZpbmRLZXkoc3RhdGUudG9rZW5zLCAodG4pID0+IHRuID09PSB0b2tlbk5ldHdvcmspO1xuICAgIGlmICghdG9rZW4pXG4gICAgICAgIHJldHVybjsgLy8gc2hvdWxkbid0IGhhcHBlbiwgdG9rZW4gbWFwcGluZyBpcyBhbHdheXMgYmktZGlyZWN0aW9uYWxcbiAgICByZXN1bHRbdG9rZW5dID0gbWFwUGFydG5lclRvQ2hhbm5lbChwYXJ0bmVyQ2hhbm5lbE1hcCwgdG9rZW4sIHRva2VuTmV0d29yayk7XG59KTtcbi8qKlxuICogUmV0dXJuIHNpZ25lciAmIGFkZHJlc3MgdG8gdXNlIGZvciBvbi1jaGFpbiB0eHMgZGVwZW5kaW5nIG9uIHN1YmtleSBwYXJhbVxuICpcbiAqIEBwYXJhbSBkZXBzIC0gUmFpZGVuRXBpY0RlcHMgc3Vic2V0XG4gKiBAcGFyYW0gc3Via2V5IC0gV2hldGhlciB0byBwcmVmZXIgdGhlIHN1YmtleSBvciB0aGUgbWFpbiBrZXlcbiAqIEByZXR1cm5zIFNpZ25lciAmIEFkZHJlc3MgdG8gdXNlIGZvciBvbi1jaGFpbiBvcGVyYXRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaG9vc2VPbmNoYWluQWNjb3VudCh7IHNpZ25lciwgYWRkcmVzcywgbWFpbiwgfSwgc3Via2V5KSB7XG4gICAgaWYgKG1haW4gJiYgIXN1YmtleSlcbiAgICAgICAgcmV0dXJuIG1haW47XG4gICAgcmV0dXJuIHsgc2lnbmVyLCBhZGRyZXNzIH07XG59XG4vKipcbiAqIFJldHVybnMgYSBjb250cmFjdCBpbnN0YW5jZSB3aXRoIGF0dGFjaGVkIHNpZ25lclxuICpcbiAqIEBwYXJhbSBjb250cmFjdCAtIENvbnRyYWN0IGluc3RhbmNlXG4gKiBAcGFyYW0gc2lnbmVyIC0gU2lnbmVyIHRvIHVzZSBvbiBjb250cmFjdFxuICogQHJldHVybnMgY29udHJhY3QgaW5zdGFuY2Ugd2l0aCBzaWduZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRyYWN0V2l0aFNpZ25lcihjb250cmFjdCwgc2lnbmVyKSB7XG4gICAgaWYgKGNvbnRyYWN0LnNpZ25lciA9PT0gc2lnbmVyKVxuICAgICAgICByZXR1cm4gY29udHJhY3Q7XG4gICAgcmV0dXJuIGNvbnRyYWN0LmNvbm5lY3Qoc2lnbmVyKTtcbn1cbi8qKlxuICogQ2FsbHMgYSBjb250cmFjdCBtZXRob2QgYW5kIHdhaXQgZm9yIGl0IHRvIGJlIG1pbmVkIHN1Y2Nlc3NmdWx5LCByZWplY3RzIG90aGVyd2lzZVxuICpcbiAqIEBwYXJhbSBjb250cmFjdCAtIENvbnRyYWN0IGluc3RhbmNlXG4gKiBAcGFyYW0gbWV0aG9kIC0gTWV0aG9kIG5hbWVcbiAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbXMgdHVwbGUgdG8gbWV0aG9kXG4gKiBAcGFyYW0gZXJyb3JDb2RlIC0gRXJyb3JDb2RlIHRvIHRocm93IGluIGNhc2Ugb2YgZmFpbHVyZVxuICogQHJldHVybnMgUHJvbWlzZSB0byBzdWNjZXNzZnVsIHJlY2VpcHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGxBbmRXYWl0TWluZWQoY29udHJhY3QsIG1ldGhvZCwgcGFyYW1zLCBlcnJvckNvZGUsIHsgbG9nIH0gPSB7IGxvZzogbG9nZ2luZyB9KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgbGV0IHR4O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gJ2FzIEMnIGp1c3QgdG8gYXZvaWQgZXJyb3Igd2l0aCB1bmtub3duIGZ1bmN0aW9ucyBCdWNrZXRcbiAgICAgICAgICAgIHR4ID0geWllbGQgY29udHJhY3QuZnVuY3Rpb25zW21ldGhvZF0oLi4ucGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoYEVycm9yIHNlbmRpbmcgJHttZXRob2R9IHR4YCwgZXJyKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYWlkZW5FcnJvcihlcnJvckNvZGUsIHsgZXJyb3I6IGVyci5tZXNzYWdlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZy5kZWJ1Zyhgc2VudCAke21ldGhvZH0gdHggXCIke3R4Lmhhc2h9XCIgdG8gXCIke2NvbnRyYWN0LmFkZHJlc3N9XCJgKTtcbiAgICAgICAgbGV0IHJlY2VpcHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZWNlaXB0ID0geWllbGQgdHgud2FpdCgpO1xuICAgICAgICAgICAgYXNzZXJ0KHJlY2VpcHQuc3RhdHVzLCBgdHggc3RhdHVzOiAke3JlY2VpcHQuc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihgRXJyb3IgbWluaW5nICR7bWV0aG9kfSB0eGAsIGVycik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFpZGVuRXJyb3IoZXJyb3JDb2RlLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiB0eC5oYXNoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nLmRlYnVnKGAke21ldGhvZH0gdHggXCIke3R4Lmhhc2h9XCIgc3VjY2Vzc2Z1bHkgbWluZWQhYCk7XG4gICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgIH0pO1xufVxuLyoqXG4gKiBXYWl0cyBmb3IgYSBnaXZlbiByZWNlaXB0IHRvIGJlIGNvbmZpcm1lZDsgdGhyb3dzIGlmIGl0IGdldHMgcmVtb3ZlZCBieSBhIHJlb3JnIGluc3RlYWRcbiAqXG4gKiBAcGFyYW0gcmVjZWlwdCAtIFJlY2VpcHQgdG8gd2FpdCBmb3IgY29uZmlybWF0aW9uXG4gKiBAcGFyYW0gZGVwcyAtIFJhaWRlbkVwaWNEZXBzXG4gKiBAcGFyYW0gY29uZkJsb2NrcyAtIE92ZXJ3cml0ZXMgY29uZmlnXG4gKiBAcmV0dXJucyBQcm9taXNlIGZpbmFsIGJsb2NrIG9mIHRyYW5zYWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3YWl0Q29uZmlybWF0aW9uKHJlY2VpcHQsIHsgbGF0ZXN0JCwgY29uZmlnJCwgcHJvdmlkZXIgfSwgY29uZkJsb2Nrcykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHR4QmxvY2sgPSByZWNlaXB0LmJsb2NrTnVtYmVyO1xuICAgICAgICBjb25zdCB0eEhhc2ggPSByZWNlaXB0LnRyYW5zYWN0aW9uSGFzaDtcbiAgICAgICAgcmV0dXJuIGxhdGVzdCRcbiAgICAgICAgICAgIC5waXBlKHBsdWNrRGlzdGluY3QoJ3N0YXRlJywgJ2Jsb2NrTnVtYmVyJyksIHdpdGhMYXRlc3RGcm9tKGNvbmZpZyQpLCBmaWx0ZXIoKFtibG9ja051bWJlciwgeyBjb25maXJtYXRpb25CbG9ja3MgfV0pID0+IHR4QmxvY2sgKyAoY29uZkJsb2NrcyAhPT0gbnVsbCAmJiBjb25mQmxvY2tzICE9PSB2b2lkIDAgPyBjb25mQmxvY2tzIDogY29uZmlybWF0aW9uQmxvY2tzKSA8PSBibG9ja051bWJlciksIGV4aGF1c3RNYXAoKFtibG9ja051bWJlciwgeyBjb25maXJtYXRpb25CbG9ja3MgfV0pID0+IGRlZmVyKCgpID0+IHByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpKS5waXBlKG1hcCgocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgaWYgKChyZWNlaXB0ID09PSBudWxsIHx8IHJlY2VpcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlY2VpcHQuY29uZmlybWF0aW9ucykgJiZcbiAgICAgICAgICAgICAgICByZWNlaXB0LmNvbmZpcm1hdGlvbnMgPj0gKGNvbmZCbG9ja3MgIT09IG51bGwgJiYgY29uZkJsb2NrcyAhPT0gdm9pZCAwID8gY29uZkJsb2NrcyA6IGNvbmZpcm1hdGlvbkJsb2NrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICBlbHNlIGlmICh0eEJsb2NrICsgMiAqIChjb25mQmxvY2tzICE9PSBudWxsICYmIGNvbmZCbG9ja3MgIT09IHZvaWQgMCA/IGNvbmZCbG9ja3MgOiBjb25maXJtYXRpb25CbG9ja3MpIDwgYmxvY2tOdW1iZXIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuUkROX1RSQU5TQUNUSU9OX1JFT1JHLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogdHhIYXNoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSkpLCBmaXJzdChpc250TmlsKSlcbiAgICAgICAgICAgIC50b1Byb21pc2UoKTtcbiAgICB9KTtcbn1cbi8qXG4gKiBSZXR1cm5zIHRydWUgaWYgYHVybGAgaXMgYSB2YWxpZCBVUkwgb3IgZG9tYWluLlxuICogT24gcHJvZHVjdGlvbiBgaHR0cHM6Ly9gIGlzIHJlcXVpcmVkIGZvciBVUkxzLCBvdGhlcndpc2UgYGh0dHA6Ly9gIG1hdGNoZXMgYXMgd2VsbC5cbiAqXG4gKiBAcGFyYW0gdXJsIC0gQSBVUkwgb3IgaG9zdG5hbWVcbiAqIEByZXR1cm5zIHRydWUgaWYgdmFsaWQgVVJMIG9yIGRvbWFpblxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZFVybCA9ICh1cmwpID0+IHtcbiAgICBjb25zdCByZWdleCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbidcbiAgICAgICAgPyAvXig/Omh0dHBzOlxcL1xcLyk/W15cXHNcXC8kLj8jJlwiJ10rXFwuW15cXHNcXC8kPyMmXCInXSskL1xuICAgICAgICA6IC9eKD86KGh0dHB8aHR0cHMpOlxcL1xcLyk/KFteXFxzXFwvJC4/IyZcIiddK1xcLikqW15cXHNcXC8kPyMmXCInXSsoPzooXFxkKykpKiQvO1xuICAgIHJldHVybiByZWdleC50ZXN0KHVybCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiLCJpbXBvcnQgeyBmcm9tLCBvZiwgRU1QVFksIG1lcmdlLCBpbnRlcnZhbCwgZGVmZXIsIGNvbmNhdCBhcyBjb25jYXQkLCBjb21iaW5lTGF0ZXN0LCB0aW1lciwgdGhyb3dFcnJvciwgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IsIGZpbHRlciwgbWFwLCBtZXJnZU1hcCwgdGFwLCB0YWtlV2hpbGUsIHdpdGhMYXRlc3RGcm9tLCBncm91cEJ5LCBleGhhdXN0TWFwLCBmaXJzdCwgdGFrZSwgbWFwVG8sIHBsdWNrLCBwdWJsaXNoUmVwbGF5LCBpZ25vcmVFbGVtZW50cywgc2tpcCwgc3RhcnRXaXRoLCByZXRyeVdoZW4sIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IGZpbmRLZXkgZnJvbSAnbG9kYXNoL2ZpbmRLZXknO1xuaW1wb3J0IGlzRW1wdHkgZnJvbSAnbG9kYXNoL2lzRW1wdHknO1xuaW1wb3J0IG5lZ2F0ZSBmcm9tICdsb2Rhc2gvbmVnYXRlJztcbmltcG9ydCB7IGhleGxpZnksIGNvbmNhdCwgZGVmYXVsdEFiaUNvZGVyIH0gZnJvbSAnZXRoZXJzL3V0aWxzJztcbmltcG9ydCB7IEhhc2haZXJvLCBaZXJvIH0gZnJvbSAnZXRoZXJzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyByYWlkZW5TaHV0ZG93biB9IGZyb20gJy4uL2FjdGlvbnMnO1xuaW1wb3J0IHsgQ2hhbm5lbFN0YXRlIH0gZnJvbSAnLi4vY2hhbm5lbHMnO1xuaW1wb3J0IHsgU2lnbmF0dXJlWmVybywgU2h1dGRvd25SZWFzb24gfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgY2hvb3NlT25jaGFpbkFjY291bnQsIGdldENvbnRyYWN0V2l0aFNpZ25lciB9IGZyb20gJy4uL2hlbHBlcnMnO1xuaW1wb3J0IHsgaXNudE5pbCwgYXNzZXJ0IH0gZnJvbSAnLi4vdXRpbHMvdHlwZXMnO1xuaW1wb3J0IHsgaXNBY3Rpb25PZiB9IGZyb20gJy4uL3V0aWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgcGx1Y2tEaXN0aW5jdCB9IGZyb20gJy4uL3V0aWxzL3J4JztcbmltcG9ydCB7IGZyb21FdGhlcnNFdmVudCwgZ2V0RXZlbnRzU3RyZWFtLCBnZXROZXR3b3JrIH0gZnJvbSAnLi4vdXRpbHMvZXRoZXJzJztcbmltcG9ydCB7IGVuY29kZSB9IGZyb20gJy4uL3V0aWxzL2RhdGEnO1xuaW1wb3J0IHsgUmFpZGVuRXJyb3IsIEVycm9yQ29kZXMgfSBmcm9tICcuLi91dGlscy9lcnJvcic7XG5pbXBvcnQgeyBjcmVhdGVCYWxhbmNlSGFzaCB9IGZyb20gJy4uL21lc3NhZ2VzL3V0aWxzJztcbmltcG9ydCB7IG5ld0Jsb2NrLCB0b2tlbk1vbml0b3JlZCwgY2hhbm5lbE1vbml0b3IsIGNoYW5uZWxPcGVuLCBjaGFubmVsRGVwb3NpdCwgY2hhbm5lbENsb3NlLCBjaGFubmVsU2V0dGxlLCBjaGFubmVsU2V0dGxlYWJsZSwgY2hhbm5lbFdpdGhkcmF3biwgfSBmcm9tICcuL2FjdGlvbnMnO1xuaW1wb3J0IHsgYXNzZXJ0VHggfSBmcm9tICcuL3V0aWxzJztcbi8qKlxuICogUmVjZWl2ZXMgYW4gYXN5bmMgZnVuY3Rpb24gYW5kIHJldHVybnMgYW4gb2JzZXJ2YWJsZSB3aGljaCB3aWxsIHJldHJ5IGl0IGV2ZXJ5IGludGVydmFsIHVudGlsIGl0XG4gKiByZXNvbHZlcywgb3IgdGhyb3cgaWYgaXQgY2FuJ3Qgc3VjY2VlZCBhZnRlciAxMCByZXRyaWVzLlxuICogSXQgaXMgbmVlZGVkIGUuZy4gb24gcHJvdmlkZXIgbWV0aG9kcyB3aGljaCBwZXJmb3JtIFJQQyByZXF1ZXN0cyBkaXJlY3RseSwgYXMgdGhleSBjYW4gZmFpbFxuICogdGVtcG9yYXJpbHkgZHVlIHRvIG5ldHdvcmsgZXJyb3JzLCBzbyB0aGV5IG5lZWQgdG8gYmUgcmV0cmllZCBmb3IgYSB3aGlsZS5cbiAqIEpzb25ScGNQcm92aWRlci5fZG9Qb2xsIGFsc28gY2F0Y2hlcywgc3VwcHJlc3NlcyAmIHJldHJ5XG4gKlxuICogQHBhcmFtIGZ1bmMgLSBBbiBhc3luYyBmdW5jdGlvbiAoZS5nLiBhIFByb21pc2UgZmFjdG9yeSwgbGlrZSBhIGRlZmVyIGNhbGxiYWNrKVxuICogQHBhcmFtIGludGVydmFsIC0gSW50ZXJ2YWwgdG8gcmV0cnkgaW4gY2FzZSBvZiByZWplY3Rpb25cbiAqIEBwYXJhbSByZXRyaWVzIC0gTWF4IG51bWJlciBvZiB0aW1lcyB0byByZXRyeVxuICogQHJldHVybnMgT2JzZXJ2YWJsZSB2ZXJzaW9uIG9mIGFzeW5jIGZ1bmN0aW9uLCB3aXRoIHJldHJpZXNcbiAqL1xuZnVuY3Rpb24gcmV0cnlBc3luYyQoZnVuYywgaW50ZXJ2YWwgPSAxZTMsIHJldHJpZXMgPSAxMCkge1xuICAgIHJldHVybiBkZWZlcihmdW5jKS5waXBlKHJldHJ5V2hlbigoZXJyJCkgPT4gZXJyJC5waXBlKG1lcmdlTWFwKChlcnIsIGkpID0+IChpIDwgcmV0cmllcyA/IHRpbWVyKGludGVydmFsKSA6IHRocm93RXJyb3IoZXJyKSkpKSkpO1xufVxuLyoqXG4gKiBGZXRjaCBjdXJyZW50IGJsb2NrTnVtYmVyLCByZWdpc3RlciBmb3IgbmV3IGJsb2NrIGV2ZW50cyBhbmQgZW1pdCBuZXdCbG9jayBhY3Rpb25zXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlbkFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHBhcmFtIHByb3ZpZGVyIC0gUmFpZGVuRXBpY0RlcHMgbWVtYmVyc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBuZXdCbG9jayBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0TmV3QmxvY2tFcGljID0gKHt9LCB7fSwgeyBwcm92aWRlciB9KSA9PiByZXRyeUFzeW5jJCgoKSA9PiBwcm92aWRlci5nZXRCbG9ja051bWJlcigpLCBwcm92aWRlci5wb2xsaW5nSW50ZXJ2YWwpLnBpcGUobWVyZ2VNYXAoKGJsb2NrTnVtYmVyKSA9PiBtZXJnZShvZihibG9ja051bWJlciksIGZyb21FdGhlcnNFdmVudChwcm92aWRlciwgJ2Jsb2NrJykpKSwgbWFwKChibG9ja051bWJlcikgPT4gbmV3QmxvY2soeyBibG9ja051bWJlciB9KSkpO1xuLyoqXG4gKiBPbiBmaXJzdCBydW4sIHNjYW4gcmVnaXN0cnkgYW5kIHRva2VuIG5ldHdvcmtzIGZvciByZWdpc3RlcmVkIFRva2VuTmV0d29ya3Mgb2YgaW50ZXJlc3RcbiAqIChvbmVzIHdoaWNoIGhhcy9oYWQgY2hhbm5lbHMgd2l0aCB1cykgYW5kIG1vbml0b3JzIHRoZW0uIE9uIG5leHQgcnVucywganVzdCBtb25pdG9ycyB0aGVcbiAqIHByZXZpb3VzbHkgbW9uaXRvcmVkIG9uZXMuXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlbkFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHBhcmFtIHJlZ2lzdHJ5Q29udHJhY3QsY29udHJhY3RzSW5mbyAtIFJhaWRlbkVwaWNEZXBzIG1lbWJlcnNcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgdG9rZW5Nb25pdG9yZWQgYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgaW5pdFRva2Vuc1JlZ2lzdHJ5RXBpYyA9ICh7fSwgc3RhdGUkLCB7IGFkZHJlc3MsIHByb3ZpZGVyLCByZWdpc3RyeUNvbnRyYWN0LCBjb250cmFjdHNJbmZvIH0pID0+IHN0YXRlJC5waXBlKHRha2UoMSksIG1lcmdlTWFwKChzdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGVuY29kZWRBZGRyZXNzID0gZGVmYXVsdEFiaUNvZGVyLmVuY29kZShbJ2FkZHJlc3MnXSwgW2FkZHJlc3NdKTtcbiAgICAvLyBpZiB0b2tlbnMgYXJlIGFscmVhZHkgaW5pdGlhbGl6ZWQsIHVzZSBpdFxuICAgIGlmICghaXNFbXB0eShzdGF0ZS50b2tlbnMpKVxuICAgICAgICByZXR1cm4gZnJvbShPYmplY3QuZW50cmllcyhzdGF0ZS50b2tlbnMpLm1hcCgoW3Rva2VuLCB0b2tlbk5ldHdvcmtdKSA9PiB0b2tlbk1vbml0b3JlZCh7IHRva2VuOiB0b2tlbiwgdG9rZW5OZXR3b3JrIH0pKSk7XG4gICAgLy8gZWxzZSwgZG8gYW4gaW5pdGlhbCByZWdpc3RyeSBzY2FuLCBmcm9tIGRlcGxveSB0byBub3dcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiByZXRyeUFzeW5jJCgoKSA9PiBwcm92aWRlci5nZXRMb2dzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVnaXN0cnlDb250cmFjdC5maWx0ZXJzLlRva2VuTmV0d29ya0NyZWF0ZWQobnVsbCwgbnVsbCkpLCB7IGZyb21CbG9jazogY29udHJhY3RzSW5mby5Ub2tlbk5ldHdvcmtSZWdpc3RyeS5ibG9ja19udW1iZXIsIHRvQmxvY2s6ICdsYXRlc3QnIH0pKSwgcHJvdmlkZXIucG9sbGluZ0ludGVydmFsKS5waXBlKG1lcmdlTWFwKChsb2dzKSA9PiBmcm9tKGxvZ3MpKSwgbWFwKChsb2cpID0+ICh7IGxvZywgcGFyc2VkOiByZWdpc3RyeUNvbnRyYWN0LmludGVyZmFjZS5wYXJzZUxvZyhsb2cpIH0pKSwgZmlsdGVyKCh7IHBhcnNlZCB9KSA9PiB7IHZhciBfYTsgcmV0dXJuICEhKChfYSA9IHBhcnNlZC52YWx1ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b2tlbl9uZXR3b3JrX2FkZHJlc3MpOyB9KSwgXG4gICAgICAgIC8vIGZvciBlYWNoIFRva2VuTmV0d29yayBmb3VuZCwgc2NhbiBmb3IgY2hhbm5lbHMgd2l0aCB1c1xuICAgICAgICBtZXJnZU1hcCgoeyBsb2csIHBhcnNlZCB9KSA9PiBjb25jYXQkKFxuICAgICAgICAvLyBjb25jYXQgY2hhbm5lbHMgb3BlbmVkIGJ5IHVzIGFuZCB0byB1cyBzZXBhcmF0ZWx5XG4gICAgICAgIC8vIHRha2UoMSkgd29uJ3Qgc3Vic2NyaWJlIHRoZSBsYXRlciBpZiBzb21ldGhpbmcgaXMgZm91bmQgb24gZm9ybWVyXG4gICAgICAgIHJldHJ5QXN5bmMkKCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRMb2dzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBwYXJzZWQudmFsdWVzLnRva2VuX25ldHdvcmtfYWRkcmVzcyxcbiAgICAgICAgICAgICAgICB0b3BpY3M6IFtudWxsLCBudWxsLCBlbmNvZGVkQWRkcmVzc10sXG4gICAgICAgICAgICAgICAgZnJvbUJsb2NrOiAoX2EgPSBsb2cuYmxvY2tOdW1iZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnRyYWN0c0luZm8uVG9rZW5OZXR3b3JrUmVnaXN0cnkuYmxvY2tfbnVtYmVyLFxuICAgICAgICAgICAgICAgIHRvQmxvY2s6ICdsYXRlc3QnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHByb3ZpZGVyLnBvbGxpbmdJbnRlcnZhbCkucGlwZShtZXJnZU1hcChmcm9tKSksIHJldHJ5QXN5bmMkKCgpID0+IHByb3ZpZGVyLmdldExvZ3Moe1xuICAgICAgICAgICAgYWRkcmVzczogcGFyc2VkLnZhbHVlcy50b2tlbl9uZXR3b3JrX2FkZHJlc3MsXG4gICAgICAgICAgICB0b3BpY3M6IFtudWxsLCBudWxsLCBudWxsLCBlbmNvZGVkQWRkcmVzc10sXG4gICAgICAgICAgICBmcm9tQmxvY2s6IGxvZy5ibG9ja051bWJlcixcbiAgICAgICAgICAgIHRvQmxvY2s6ICdsYXRlc3QnLFxuICAgICAgICB9KSwgcHJvdmlkZXIucG9sbGluZ0ludGVydmFsKS5waXBlKG1lcmdlTWFwKGZyb20pKSkucGlwZShcbiAgICAgICAgLy8gaWYgZm91bmQgYXQgbGVhc3Qgb25lLCByZWdpc3RlciB0aGlzIFRva2VuTmV0d29yayBhcyBvZiBpbnRlcmVzdFxuICAgICAgICAvLyBlbHNlLCBkbyBub3RoaW5nXG4gICAgICAgIHRha2UoMSksIG1hcFRvKHRva2VuTW9uaXRvcmVkKHtcbiAgICAgICAgICAgIHRva2VuOiBwYXJzZWQudmFsdWVzLnRva2VuX2FkZHJlc3MsXG4gICAgICAgICAgICB0b2tlbk5ldHdvcms6IHBhcnNlZC52YWx1ZXMudG9rZW5fbmV0d29ya19hZGRyZXNzLFxuICAgICAgICAgICAgZnJvbUJsb2NrOiBsb2cuYmxvY2tOdW1iZXIsXG4gICAgICAgIH0pKSksIDUpKTtcbn0pKTtcbi8qKlxuICogTW9uaXRvciBjaGFubmVscyBwcmV2aW91c2x5IGFscmVhZHkgb24gc3RhdGVcbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuQWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIGNoYW5uZWxNb25pdG9yIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRNb25pdG9yQ2hhbm5lbHNFcGljID0gKHt9LCBzdGF0ZSQpID0+IHN0YXRlJC5waXBlKGZpcnN0KCksIG1lcmdlTWFwKGZ1bmN0aW9uKiAoc3RhdGUpIHtcbiAgICBmb3IgKGNvbnN0IFt0b2tlbk5ldHdvcmssIG9ial0gb2YgT2JqZWN0LmVudHJpZXMoc3RhdGUuY2hhbm5lbHMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3BhcnRuZXIsIGNoYW5uZWxdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICAgICAgICAgIGlmIChjaGFubmVsLnN0YXRlID09PSBDaGFubmVsU3RhdGUub3BlbmluZylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHlpZWxkIGNoYW5uZWxNb25pdG9yKHsgaWQ6IGNoYW5uZWwuaWQgfSwgeyB0b2tlbk5ldHdvcms6IHRva2VuTmV0d29yaywgcGFydG5lcjogcGFydG5lciB9KTtcbiAgICAgICAgfVxuICAgIH1cbn0pKTtcbi8qKlxuICogTW9uaXRvciBwcm92aWRlciB0byBlbnN1cmUgYWNjb3VudCBjb250aW51ZXMgdG8gYmUgYXZhaWxhYmxlIGFuZCBuZXR3b3JrIHN0YXlzIHRoZSBzYW1lXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlbkFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHBhcmFtIGFkZHJlc3MsbmV0d29yayxwcm92aWRlciAtIFJhaWRlbkVwaWNEZXBzIG1lbWJlcnNcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgcmFpZGVuU2h1dGRvd24gYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgaW5pdE1vbml0b3JQcm92aWRlckVwaWMgPSAoe30sIHt9LCB7IGFkZHJlc3MsIG5ldHdvcmssIHByb3ZpZGVyIH0pID0+IHJldHJ5QXN5bmMkKCgpID0+IHByb3ZpZGVyLmxpc3RBY2NvdW50cygpLCBwcm92aWRlci5wb2xsaW5nSW50ZXJ2YWwpLnBpcGUoXG4vLyBhdCBpbml0IHRpbWUsIGNoZWNrIGlmIG91ciBhZGRyZXNzIGlzIGluIHByb3ZpZGVyJ3MgYWNjb3VudHMgbGlzdFxuLy8gaWYgbm90LCBpdCBtZWFucyBTaWduZXIgaXMgYSBsb2NhbCBXYWxsZXQgb3IgYW5vdGhlciBub24tcHJvdmlkZXItc2lkZSBhY2NvdW50XG4vLyBpZiB5ZXMsIHBvbGwgYWNjb3VudHMgZXZlcnkgMXMgYW5kIG1vbml0b3JzIGlmIGFkZHJlc3MgaXMgc3RpbGwgdGhlcmVcbi8vIGFsc28sIGV2ZXJ5IDFzIHBvbGwgY3VycmVudCBwcm92aWRlciBuZXR3b3JrIGFuZCBtb25pdG9ycyBpZiBpdCdzIHRoZSBzYW1lXG4vLyBpZiBhbnkgY2hlY2sgZmFpbHMsIGVtaXRzIFJhaWRlblNodXRkb3duQWN0aW9uLCBub3RoaW5nIG90aGVyd2lzZVxuLy8gUG9sbCByZWFzb24gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL2ZhcS9ibG9iL21hc3Rlci9ERVZFTE9QRVJTLm1kXG4vLyBmaXJzdC9pbml0LXRpbWUgY2hlY2tcbm1hcCgoYWNjb3VudHMpID0+IGFjY291bnRzLmluY2x1ZGVzKGFkZHJlc3MpKSwgbWVyZ2VNYXAoKGlzUHJvdmlkZXJBY2NvdW50KSA9PiBpbnRlcnZhbChwcm92aWRlci5wb2xsaW5nSW50ZXJ2YWwpLnBpcGUoZXhoYXVzdE1hcCgoKSA9PiBtZXJnZShcbi8vIGlmIGlzUHJvdmlkZXJBY2NvdW50LCBhbHNvIHBvbGxzIGFuZCBtb25pdG9ycyBhY2NvdW50cyBsaXN0XG5pc1Byb3ZpZGVyQWNjb3VudFxuICAgID8gcmV0cnlBc3luYyQoKCkgPT4gcHJvdmlkZXIubGlzdEFjY291bnRzKCksIHByb3ZpZGVyLnBvbGxpbmdJbnRlcnZhbCkucGlwZShtZXJnZU1hcCgoYWNjb3VudHMpID0+ICFhY2NvdW50cy5pbmNsdWRlcyhhZGRyZXNzKVxuICAgICAgICA/IG9mKHJhaWRlblNodXRkb3duKHsgcmVhc29uOiBTaHV0ZG93blJlYXNvbi5BQ0NPVU5UX0NIQU5HRUQgfSkpXG4gICAgICAgIDogRU1QVFkpKVxuICAgIDogRU1QVFksIFxuLy8gdW5jb25kaXRpb25hbGx5IG1vbml0b3JzIG5ldHdvcmsgY2hhbmdlc1xucmV0cnlBc3luYyQoKCkgPT4gZ2V0TmV0d29yayhwcm92aWRlciksIHByb3ZpZGVyLnBvbGxpbmdJbnRlcnZhbCkucGlwZShtZXJnZU1hcCgoY3VyTmV0d29yaykgPT4gY3VyTmV0d29yay5jaGFpbklkICE9PSBuZXR3b3JrLmNoYWluSWRcbiAgICA/IG9mKHJhaWRlblNodXRkb3duKHsgcmVhc29uOiBTaHV0ZG93blJlYXNvbi5ORVRXT1JLX0NIQU5HRUQgfSkpXG4gICAgOiBFTVBUWSkpKSkpKSk7XG4vKipcbiAqIFN0YXJ0cyBtb25pdG9yaW5nIGEgdG9rZW4gbmV0d29yayBmb3IgZXZlbnRzXG4gKiBXaGVuIHRoaXMgYWN0aW9uIGdvZXMgdGhyb3VnaCAoYmVjYXVzZSBhIGZvcm1lciBvciBuZXcgdG9rZW4gcmVnaXN0cnkgZXZlbnQgd2FzIGRldGVjZXRlZCksXG4gKiBzdWJzY3JpYmUgdG8gZXZlbnRzIGFuZCBlbWl0IHJlc3BlY3RpdmUgYWN0aW9ucyB0byB0aGUgc3RyZWFtLiBDdXJyZW50bHk6XG4gKiAtIENoYW5uZWxPcGVuZWQgZXZlbnRzIHdpdGggdXMgb3IgYnkgdXNcbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgdG9rZW5Nb25pdG9yZWQgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gbWF0cml4JCAtIFJhaWRlbkVwaWNEZXBzIG1lbWJlcnNcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgY2hhbm5lbE9wZW4uc3VjY2VzcyBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCB0b2tlbk1vbml0b3JlZEVwaWMgPSAoYWN0aW9uJCwge30sIHsgYWRkcmVzcywgZ2V0VG9rZW5OZXR3b3JrQ29udHJhY3QgfSkgPT4gYWN0aW9uJC5waXBlKGZpbHRlcihpc0FjdGlvbk9mKHRva2VuTW9uaXRvcmVkKSksIGdyb3VwQnkoKGFjdGlvbikgPT4gYWN0aW9uLnBheWxvYWQudG9rZW5OZXR3b3JrKSwgbWVyZ2VNYXAoKGdyb3VwZWQkKSA9PiBncm91cGVkJC5waXBlKGV4aGF1c3RNYXAoKGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IHRva2VuTmV0d29ya0NvbnRyYWN0ID0gZ2V0VG9rZW5OZXR3b3JrQ29udHJhY3QoYWN0aW9uLnBheWxvYWQudG9rZW5OZXR3b3JrKTtcbiAgICAvLyB0eXBlIG9mIGVsZW1lbnRzIGVtaXR0ZWQgYnkgZ2V0RXZlbnRzU3RyZWFtIChwYXN0IGFuZCBuZXcgZXZlbnRzIGNvbWluZyBmcm9tXG4gICAgLy8gY29udHJhY3QpOiBbY2hhbm5lbElkLCBwYXJ0bmVyMSwgcGFydG5lcjIsIHNldHRsZVRpbWVvdXQsIEV2ZW50XVxuICAgIHJldHVybiBnZXRFdmVudHNTdHJlYW0odG9rZW5OZXR3b3JrQ29udHJhY3QsIFxuICAgIC8vIGl0J3MgY2hlYXBlciBmb3IgbW9uaXRvcmluZyB0byBmZXRjaCBhbGwgY2hhbm5lbHMgYW5kIGZpbHRlciBjbGllbnQtc2lkZSxcbiAgICAvLyB0aGFuIHRvIHF1ZXJ5L2NyZWF0ZS9yZXF1ZXN0IDIgZmlsdGVycyBvbiBldmVyeSBibG9jayAoZnJvbSBhbmQgdG8gdXMpXG4gICAgW3Rva2VuTmV0d29ya0NvbnRyYWN0LmZpbHRlcnMuQ2hhbm5lbE9wZW5lZChudWxsLCBudWxsLCBudWxsLCBudWxsKV0sIFxuICAgIC8vIGlmIGZpcnN0IHRpbWUgbW9uaXRvcmluZyB0aGlzIHRva2VuIG5ldHdvcmssXG4gICAgLy8gZmV0Y2ggVG9rZW5OZXR3b3JrJ3MgcGFzdEV2ZW50cyBzaW5jZSByZWdpc3RyeSBkZXBsb3ltZW50IGFzIGZyb21CbG9jayRcbiAgICBhY3Rpb24ucGF5bG9hZC5mcm9tQmxvY2sgPyBvZihhY3Rpb24ucGF5bG9hZC5mcm9tQmxvY2spIDogdW5kZWZpbmVkKS5waXBlKGZpbHRlcigoWywgcDEsIHAyXSkgPT4gcDEgPT09IGFkZHJlc3MgfHwgcDIgPT09IGFkZHJlc3MpLCBtYXAoKFtpZCwgcDEsIHAyLCBzZXR0bGVUaW1lb3V0LCBldmVudF0pID0+IGNoYW5uZWxPcGVuLnN1Y2Nlc3Moe1xuICAgICAgICBpZDogaWQudG9OdW1iZXIoKSxcbiAgICAgICAgc2V0dGxlVGltZW91dDogc2V0dGxlVGltZW91dC50b051bWJlcigpLFxuICAgICAgICBpc0ZpcnN0UGFydGljaXBhbnQ6IGFkZHJlc3MgPT09IHAxLFxuICAgICAgICB0eEhhc2g6IGV2ZW50LnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgdHhCbG9jazogZXZlbnQuYmxvY2tOdW1iZXIsXG4gICAgICAgIGNvbmZpcm1lZDogdW5kZWZpbmVkLFxuICAgIH0sIHtcbiAgICAgICAgdG9rZW5OZXR3b3JrOiB0b2tlbk5ldHdvcmtDb250cmFjdC5hZGRyZXNzLFxuICAgICAgICBwYXJ0bmVyOiBhZGRyZXNzID09PSBwMSA/IHAyIDogcDEsXG4gICAgfSkpKTtcbn0pKSkpO1xuLyoqXG4gKiBXaGVuIHdlIHNlZSBhIG5ldyBDaGFubmVsT3BlbmVkQWN0aW9uIGV2ZW50LCBzdGFydHMgbW9uaXRvcmluZyBjaGFubmVsXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIGNoYW5uZWxPcGVuLnN1Y2Nlc3MgYWN0aW9uc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBjaGFubmVsTW9uaXRvciBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBjaGFubmVsT3BlbmVkRXBpYyA9IChhY3Rpb24kKSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzQWN0aW9uT2YoY2hhbm5lbE9wZW4uc3VjY2VzcykpLCBmaWx0ZXIoKGFjdGlvbikgPT4gISFhY3Rpb24ucGF5bG9hZC5jb25maXJtZWQpLCBtYXAoKGFjdGlvbikgPT4gY2hhbm5lbE1vbml0b3Ioe1xuICAgIGlkOiBhY3Rpb24ucGF5bG9hZC5pZCxcbiAgICAvLyBmZXRjaCBwYXN0IGV2ZW50cyBhcyB3ZWxsLCBpZiBuZWVkZWQsIGluY2x1ZGluZyBldmVudHMgYmVmb3JlIGNvbmZpcm1hdGlvblxuICAgIGZyb21CbG9jazogYWN0aW9uLnBheWxvYWQudHhCbG9jayxcbn0sIGFjdGlvbi5tZXRhKSkpO1xuLyoqXG4gKiBNb25pdG9ycyBhIGNoYW5uZWwgZm9yIGNoYW5uZWwgRXZlbnRzXG4gKiBDYW4gYmUgY2FsbGVkIGVpdGhlciBhdCBpbml0aWFsaXphdGlvbiB0aW1lIChmb3IgcHJldmlvdXNseSBrbm93biBjaGFubmVscyBvbiBwcmV2aW91c2x5XG4gKiBtb25pdG9yZWQgVG9rZW5OZXR3b3JrKSBvciBieSBhIG5ldyBkZXRlY3RlZCBDaGFubmVsT3BlbmVkQWN0aW9uLiBPbiB0aGUgbGF0ZXIgY2FzZSxcbiAqIGFsc28gZmV0Y2hlcyBldmVudHMgc2luY2UgQ2hhbm5lbC5vcGVuQmxvY2suXG4gKiBDdXJyZW50bHkgbW9uaXRvcmVkIGV2ZW50czpcbiAqIC0gQ2hhbm5lbE5ld0RlcG9zaXQsIGZpcmVzIGEgY2hhbm5lbERlcG9zaXQuc3VjY2VzcyBhY3Rpb25cbiAqIC0gQ2hhbm5lbENsb3NlZEV2ZW50LCBmaXJlcyBhIGNoYW5uZWxDbG9zZS5zdWNjZXNzIGFjdGlvblxuICogLSBDaGFubmVsU2V0dGxlZEV2ZW50LCBmaXJlcyBhIGNoYW5uZWxTZXR0bGUuc3VjY2VzcyBhY3Rpb24gYW5kIGNvbXBsZXRlcyB0aGF0IGNoYW5uZWwgb2JzZXJ2YWJsZVxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBjaGFubmVsTW9uaXRvciBhY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEBwYXJhbSBtYXRyaXgkIC0gUmFpZGVuRXBpY0RlcHMgbWVtYmVyc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBjaGFubmVsRGVwb3NpdC5zdWNjZXNzLGNoYW5uZWxDbG9zZS5zdWNjZXNzLGNoYW5uZWxTZXR0bGUuc3VjY2VzcyBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBjaGFubmVsTW9uaXRvcmVkRXBpYyA9IChhY3Rpb24kLCBzdGF0ZSQsIHsgZ2V0VG9rZW5OZXR3b3JrQ29udHJhY3QgfSkgPT4gYWN0aW9uJC5waXBlKGZpbHRlcihpc0FjdGlvbk9mKGNoYW5uZWxNb25pdG9yKSksIGdyb3VwQnkoKGFjdGlvbikgPT4gYCR7YWN0aW9uLnBheWxvYWQuaWR9IyR7YWN0aW9uLm1ldGEucGFydG5lcn1AJHthY3Rpb24ubWV0YS50b2tlbk5ldHdvcmt9YCksIG1lcmdlTWFwKChncm91cGVkJCkgPT4gZ3JvdXBlZCQucGlwZShleGhhdXN0TWFwKChhY3Rpb24pID0+IHtcbiAgICBjb25zdCB7IHRva2VuTmV0d29yaywgcGFydG5lciB9ID0gYWN0aW9uLm1ldGE7XG4gICAgY29uc3QgdG9rZW5OZXR3b3JrQ29udHJhY3QgPSBnZXRUb2tlbk5ldHdvcmtDb250cmFjdCh0b2tlbk5ldHdvcmspO1xuICAgIGNvbnN0IGRlcG9zaXRGaWx0ZXIgPSB0b2tlbk5ldHdvcmtDb250cmFjdC5maWx0ZXJzLkNoYW5uZWxOZXdEZXBvc2l0KGFjdGlvbi5wYXlsb2FkLmlkLCBudWxsLCBudWxsKSwgd2l0aGRyYXdGaWx0ZXIgPSB0b2tlbk5ldHdvcmtDb250cmFjdC5maWx0ZXJzLkNoYW5uZWxXaXRoZHJhdyhhY3Rpb24ucGF5bG9hZC5pZCwgbnVsbCwgbnVsbCksIGNsb3NlZEZpbHRlciA9IHRva2VuTmV0d29ya0NvbnRyYWN0LmZpbHRlcnMuQ2hhbm5lbENsb3NlZChhY3Rpb24ucGF5bG9hZC5pZCwgbnVsbCwgbnVsbCwgbnVsbCksIHNldHRsZWRGaWx0ZXIgPSB0b2tlbk5ldHdvcmtDb250cmFjdC5maWx0ZXJzLkNoYW5uZWxTZXR0bGVkKGFjdGlvbi5wYXlsb2FkLmlkLCBudWxsLCBudWxsLCBudWxsLCBudWxsKSwgbWVyZ2VkRmlsdGVyID0ge1xuICAgICAgICBhZGRyZXNzOiB0b2tlbk5ldHdvcmtDb250cmFjdC5hZGRyZXNzLFxuICAgICAgICB0b3BpY3M6IFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBkZXBvc2l0RmlsdGVyLnRvcGljc1swXSxcbiAgICAgICAgICAgICAgICB3aXRoZHJhd0ZpbHRlci50b3BpY3NbMF0sXG4gICAgICAgICAgICAgICAgY2xvc2VkRmlsdGVyLnRvcGljc1swXSxcbiAgICAgICAgICAgICAgICBzZXR0bGVkRmlsdGVyLnRvcGljc1swXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBbc2V0dGxlZEZpbHRlci50b3BpY3NbMV1dLFxuICAgICAgICBdLFxuICAgIH07XG4gICAgLyoqXG4gICAgICogR3VhcmRzIHRoYXQgYW4gZXZlbnQgZGF0YSB0dXBsZSBtYXRjaGVzIHRoZSB0eXBlIG9mIGEgZ2l2ZW4gZmlsdGVyXG4gICAgICpcbiAgICAgKiBUeXBlIG11c3QgYmUgZXhwbGljaXRseSBwYXNzZWQgYXMgZ2VuZXJpYyB0eXBlIHBhcmFtZXRlciwgYW5kIGEgY29ycmVzcG9uZGluZyBmaWx0ZXJcbiAgICAgKiBhcyBmaXJzdCBwYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgLSBGaWx0ZXIgb2YgYW4gZXZlbnQgb2YgdHlwZSBUXG4gICAgICogQHBhcmFtIGRhdGEgLSBldmVudCBkYXRhIHR1cGxlLCB3aGVyZSBsYXN0IGVsZW1lbnQgaXMgdGhlIEV2ZW50IG9iamVjdFxuICAgICAqIEByZXR1cm5zIFRydXR5IGlmIGV2ZW50IGRhdGEgbWF0Y2hlcyBmaWx0ZXJcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGZ1bmN0aW9uIGlzRXZlbnQoZmlsdGVyLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWV2ZW50IHx8ICFldmVudC50b3BpY3MgfHwgIWZpbHRlci50b3BpY3MpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHRvcGljMCA9IGZpbHRlci50b3BpY3NbMF07XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRvcGljMClcbiAgICAgICAgICAgID8gdG9waWMwLmluY2x1ZGVzKGV2ZW50LnRvcGljc1swXSlcbiAgICAgICAgICAgIDogdG9waWMwID09PSBldmVudC50b3BpY3NbMF07XG4gICAgfVxuICAgIHJldHVybiBnZXRFdmVudHNTdHJlYW0odG9rZW5OZXR3b3JrQ29udHJhY3QsIFttZXJnZWRGaWx0ZXJdLCBcbiAgICAvLyBpZiBjaGFubmVsTW9uaXRvciB0cmlnZ2VyZWQgYnkgY2hhbm5lbE9wZW4uc3VjY2VzcyxcbiAgICAvLyBmZXRjaCBDaGFubmVsJ3MgcGFzdEV2ZW50cyBzaW5jZSBjaGFubmVsT3Blbi5zdWNjZXNzIGJsb2NrTnVtYmVyIGFzIGZyb21CbG9jayRcbiAgICBhY3Rpb24ucGF5bG9hZC5mcm9tQmxvY2sgPyBvZihhY3Rpb24ucGF5bG9hZC5mcm9tQmxvY2spIDogdW5kZWZpbmVkKS5waXBlKHdpdGhMYXRlc3RGcm9tKHN0YXRlJC5waXBlKHBsdWNrKCdjaGFubmVscycpLCBzdGFydFdpdGgoe30pKSksIG1hcCgoW2RhdGEsIGNoYW5uZWxzXSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKGlzRXZlbnQoZGVwb3NpdEZpbHRlciwgZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpZCwgcGFydGljaXBhbnQsIHRvdGFsRGVwb3NpdCwgZXZlbnRdID0gZGF0YTtcbiAgICAgICAgICAgIHJldHVybiBjaGFubmVsRGVwb3NpdC5zdWNjZXNzKHtcbiAgICAgICAgICAgICAgICBpZDogaWQudG9OdW1iZXIoKSxcbiAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudCxcbiAgICAgICAgICAgICAgICB0b3RhbERlcG9zaXQsXG4gICAgICAgICAgICAgICAgdHhIYXNoOiBldmVudC50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgdHhCbG9jazogZXZlbnQuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgY29uZmlybWVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9LCBhY3Rpb24ubWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFdmVudCh3aXRoZHJhd0ZpbHRlciwgZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpZCwgcGFydGljaXBhbnQsIHRvdGFsV2l0aGRyYXcsIGV2ZW50XSA9IGRhdGE7XG4gICAgICAgICAgICByZXR1cm4gY2hhbm5lbFdpdGhkcmF3bih7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLnRvTnVtYmVyKCksXG4gICAgICAgICAgICAgICAgcGFydGljaXBhbnQsXG4gICAgICAgICAgICAgICAgdG90YWxXaXRoZHJhdyxcbiAgICAgICAgICAgICAgICB0eEhhc2g6IGV2ZW50LnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICB0eEJsb2NrOiBldmVudC5ibG9ja051bWJlcixcbiAgICAgICAgICAgICAgICBjb25maXJtZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sIGFjdGlvbi5tZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0V2ZW50KGNsb3NlZEZpbHRlciwgZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpZCwgcGFydGljaXBhbnQsICwgLCBldmVudF0gPSBkYXRhO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5uZWxDbG9zZS5zdWNjZXNzKHtcbiAgICAgICAgICAgICAgICBpZDogaWQudG9OdW1iZXIoKSxcbiAgICAgICAgICAgICAgICBwYXJ0aWNpcGFudCxcbiAgICAgICAgICAgICAgICB0eEhhc2g6IGV2ZW50LnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICB0eEJsb2NrOiBldmVudC5ibG9ja051bWJlcixcbiAgICAgICAgICAgICAgICBjb25maXJtZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sIGFjdGlvbi5tZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0V2ZW50KHNldHRsZWRGaWx0ZXIsIGRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBbaWQsICwgLCAsICwgZXZlbnRdID0gZGF0YTtcbiAgICAgICAgICAgIHJldHVybiBjaGFubmVsU2V0dGxlLnN1Y2Nlc3Moe1xuICAgICAgICAgICAgICAgIGlkOiBpZC50b051bWJlcigpLFxuICAgICAgICAgICAgICAgIHR4SGFzaDogZXZlbnQudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgIHR4QmxvY2s6IGV2ZW50LmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgICAgIGNvbmZpcm1lZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGxvY2tzOiAoX2MgPSAoX2IgPSAoX2EgPSBjaGFubmVsc1t0b2tlbk5ldHdvcmtdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbcGFydG5lcl0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJ0bmVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubG9ja3MsXG4gICAgICAgICAgICB9LCBhY3Rpb24ubWV0YSk7XG4gICAgICAgIH1cbiAgICB9KSwgZmlsdGVyKGlzbnROaWwpLCBcbiAgICAvLyB0YWtlV2hpbGUgdGVuZHMgdG8gYnJvYWQgaW5wdXQgdG8gZ2VuZXJpYyBBY3Rpb24uIFdlIG5lZWQgdG8gbmFycm93IGl0IGV4cGxpY2l0bHlcbiAgICB0YWtlV2hpbGUobmVnYXRlKGNoYW5uZWxTZXR0bGUuc3VjY2Vzcy5pcyksIHRydWUpKTtcbn0pKSkpO1xuLyoqXG4gKiBBIGNoYW5uZWxPcGVuIGFjdGlvbiByZXF1ZXN0ZWQgYnkgdXNlclxuICogTmVlZHMgdG8gYmUgY2FsbGVkIG9uIGEgcHJldmlvdXNseSBtb25pdG9yZWQgdG9rZW5OZXR3b3JrLiBDYWxscyBUb2tlbk5ldHdvcmsub3BlbkNoYW5uZWxcbiAqIHdpdGggZ2l2ZW4gcGFyYW1ldGVycy4gSWYgdHggZ29lcyB0aHJvdWdoIHN1Y2Nlc3NmdWx5LCBzdG9wIGFzIENoYW5uZWxPcGVuZWQgc3VjY2VzcyBhY3Rpb25cbiAqIHdpbGwgaW5zdGVhZCBiZSBkZXRlY3RlZCBhbmQgZmlyZWQgYnkgdG9rZW5Nb25pdG9yZWRFcGljLiBJZiBhbnl0aGluZyBkZXRlY3RhYmxlIGdvZXMgd3JvbmcsXG4gKiBmaXJlcyBhIENoYW5ubmVsT3BlbkFjdGlvbkZhaWxlZCBpbnN0ZWFkXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIGNoYW5uZWxPcGVuIGFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHBhcmFtIGdldFRva2VuTmV0d29ya0NvbnRyYWN0IC0gUmFpZGVuRXBpY0RlcHMgbWVtYmVyc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBjaGFubmVsT3Blbi5mYWlsdXJlIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGNoYW5uZWxPcGVuRXBpYyA9IChhY3Rpb24kLCBzdGF0ZSQsIHsgbG9nLCBzaWduZXIsIGFkZHJlc3MsIG1haW4sIGdldFRva2VuQ29udHJhY3QsIGdldFRva2VuTmV0d29ya0NvbnRyYWN0LCBjb25maWckLCB9KSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzQWN0aW9uT2YoY2hhbm5lbE9wZW4ucmVxdWVzdCkpLCB3aXRoTGF0ZXN0RnJvbShzdGF0ZSQsIGNvbmZpZyQpLCBtZXJnZU1hcCgoW2FjdGlvbiwgc3RhdGUsIHsgc2V0dGxlVGltZW91dCwgc3Via2V5OiBjb25maWdTdWJrZXkgfV0pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB7IHRva2VuTmV0d29yaywgcGFydG5lciB9ID0gYWN0aW9uLm1ldGE7XG4gICAgY29uc3QgY2hhbm5lbFN0YXRlID0gKF9iID0gKF9hID0gc3RhdGUuY2hhbm5lbHNbdG9rZW5OZXR3b3JrXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3BhcnRuZXJdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhdGU7XG4gICAgLy8gcHJvY2VlZCBvbmx5IGlmIGNoYW5uZWwgaXMgaW4gJ29wZW5pbmcnIHN0YXRlLCBzZXQgYnkgdGhpcyBhY3Rpb25cbiAgICBpZiAoY2hhbm5lbFN0YXRlICE9PSBDaGFubmVsU3RhdGUub3BlbmluZylcbiAgICAgICAgcmV0dXJuIG9mKGNoYW5uZWxPcGVuLmZhaWx1cmUobmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuQ05MX0lOVkFMSURfU1RBVEUsIHsgc3RhdGU6IGNoYW5uZWxTdGF0ZSB9KSwgYWN0aW9uLm1ldGEpKTtcbiAgICBjb25zdCB7IHNpZ25lcjogb25jaGFpblNpZ25lciB9ID0gY2hvb3NlT25jaGFpbkFjY291bnQoeyBzaWduZXIsIGFkZHJlc3MsIG1haW4gfSwgKF9jID0gYWN0aW9uLnBheWxvYWQuc3Via2V5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjb25maWdTdWJrZXkpO1xuICAgIGNvbnN0IHRva2VuTmV0d29ya0NvbnRyYWN0ID0gZ2V0Q29udHJhY3RXaXRoU2lnbmVyKGdldFRva2VuTmV0d29ya0NvbnRyYWN0KHRva2VuTmV0d29yayksIG9uY2hhaW5TaWduZXIpO1xuICAgIC8vIGlmIGFsc28gcmVxdWVzdGVkIGRlcG9zaXRcbiAgICBjb25zdCBkZXBvc2l0ID0gIWFjdGlvbi5wYXlsb2FkLmRlcG9zaXQgfHwgYWN0aW9uLnBheWxvYWQuZGVwb3NpdC5pc1plcm8oKVxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IGFjdGlvbi5wYXlsb2FkLmRlcG9zaXQ7XG4gICAgY29uc3QgdG9rZW4gPSBmaW5kS2V5KHN0YXRlLnRva2VucywgKHRuKSA9PiB0biA9PT0gdG9rZW5OZXR3b3JrKTtcbiAgICBjb25zdCB0b2tlbkNvbnRyYWN0ID0gZ2V0Q29udHJhY3RXaXRoU2lnbmVyKGdldFRva2VuQ29udHJhY3QodG9rZW4pLCBvbmNoYWluU2lnbmVyKTtcbiAgICByZXR1cm4gYWN0aW9uJC5waXBlKGZpbHRlcihjaGFubmVsT3Blbi5zdWNjZXNzLmlzKSwgZmlsdGVyKChhKSA9PiBhLm1ldGEudG9rZW5OZXR3b3JrID09PSB0b2tlbk5ldHdvcmsgJiYgYS5tZXRhLnBhcnRuZXIgPT09IHBhcnRuZXIpLCBcbiAgICAvLyBvcGVuZWQkIHdpbGwgXCJjYWNoZVwiIG1hdGNoaW5nIGNoYW5uZWxPcGVuLnN1Y2Nlc3MsIGlmIG5lZWRlZFxuICAgIHB1Ymxpc2hSZXBsYXkoMSwgdW5kZWZpbmVkLCAob3BlbmVkJCkgPT4gXG4gICAgLy8gc2VuZCBvcGVuQ2hhbm5lbCB0cmFuc2FjdGlvblxuICAgIGRlZmVyKCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gdG9rZW5OZXR3b3JrQ29udHJhY3QuZnVuY3Rpb25zLm9wZW5DaGFubmVsKGFkZHJlc3MsIHBhcnRuZXIsIChfYSA9IGFjdGlvbi5wYXlsb2FkLnNldHRsZVRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNldHRsZVRpbWVvdXQpO1xuICAgIH0pLnBpcGUoXG4gICAgLy8gV2FsbGV0IHNpZ25lciBkZXBlbmRzIG9uIGZldGNoaW5nIHRoZSAncGVuZGluZycgdHggY291bnQgdG8gZmlsbCAnbm9uY2UnXG4gICAgLy8gdGhlcmVmb3JlIHdlIG5lZWQgdG8gc2VuZCBvcGVuIHRoZW4gYXBwcm92ZSwgaW5zdGVhZCBvZiBkb2luZyB0aGVtIHBhcmFsbGVseVxuICAgIG1lcmdlTWFwKChvcGVuVHgpID0+IGRlcG9zaXRcbiAgICAgICAgPyBmcm9tKHRva2VuQ29udHJhY3QuZnVuY3Rpb25zLmFwcHJvdmUodG9rZW5OZXR3b3JrLCBkZXBvc2l0KSkucGlwZShtYXAoKGFwcHJvdmVUeCkgPT4gW29wZW5UeCwgYXBwcm92ZVR4XSkpXG4gICAgICAgIDogb2YoW29wZW5UeF0pKSwgXG4gICAgLy8gY2FuJ3Qgc2hhcmUgbG9naWMgd2l0aCBjaGFubmVsRGVwb3NpdEVwaWMsIGJlY2F1c2UgcGFyYWxsZWxpc20gb2YgdHhzIG5lZWRzIHRvIGJlXG4gICAgLy8gc3RyaWN0LCBub3IgdXNlIGFzc2VydFR4IGZvciBhcHByb3ZlfG9wZW5DaGFubmVsIHBhcmFsbGVsIHR4c1xuICAgIHRhcCgoW3R4XSkgPT4gbG9nLmRlYnVnKGBzZW50IG9wZW5DaGFubmVsIHR4IFwiJHt0eC5oYXNofVwiIHRvIFwiJHt0b2tlbk5ldHdvcmt9XCJgKSksIHRhcCgoWywgdHhdKSA9PiAodHggPyBsb2cuZGVidWcoYHNlbnQgYXBwcm92ZSB0eCBcIiR7dHguaGFzaH1cIiB0byBcIiR7dG9rZW59XCJgKSA6IDApKSwgbWVyZ2VNYXAoKFtvcGVuVHgsIGFwcHJvdmVUeF0pID0+IGNvbWJpbmVMYXRlc3QoW1xuICAgICAgICBmcm9tKG9wZW5UeC53YWl0KCkpLnBpcGUobWFwKChyZWNlaXB0KSA9PiAoeyB0eDogb3BlblR4LCByZWNlaXB0IH0pKSksXG4gICAgICAgIGFwcHJvdmVUeFxuICAgICAgICAgICAgPyBmcm9tKGFwcHJvdmVUeC53YWl0KCkpLnBpcGUobWFwKChyZWNlaXB0KSA9PiAoeyB0eDogYXBwcm92ZVR4LCByZWNlaXB0IH0pKSlcbiAgICAgICAgICAgIDogb2YodW5kZWZpbmVkKSxcbiAgICBdKSksIG1lcmdlTWFwKChbb3BlbiwgYXBwcm92ZV0pID0+IHtcbiAgICAgICAgaWYgKCFvcGVuLnJlY2VpcHQuc3RhdHVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuQ05MX09QRU5DSEFOTkVMX0ZBSUxFRCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24ubWV0YSksIHsgdHJhbnNhY3Rpb25IYXNoOiBvcGVuLnR4Lmhhc2ggfSkpO1xuICAgICAgICBsb2cuZGVidWcoYG9wZW5DaGFubmVsIHR4IFwiJHtvcGVuLnR4Lmhhc2h9XCIgc3VjY2Vzc2Z1bHkgbWluZWQhYCk7XG4gICAgICAgIC8vIG5vdyB0aGF0IGNoYW5uZWwgaXMgb3BlbmVkLCBjaGVjayBhcHByb3ZlIGFuZCBwcm9jZWVkIHRvIHNldFRvdGFsRGVwb3NpdFxuICAgICAgICAvLyBpZiBubyBkZXBvc2l0IHJlcXVlc3RlZCwgRU1QVFkgd2lsbCBza2lwIHJlc3Qgb2YgdGhpcyBjaGFpblxuICAgICAgICByZXR1cm4gKGFwcHJvdmUgPyBvZihhcHByb3ZlKSA6IEVNUFRZKS5waXBlKG1lcmdlTWFwKCh7IHR4LCByZWNlaXB0IH0pID0+IHtcbiAgICAgICAgICAgIGlmICghcmVjZWlwdC5zdGF0dXMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuQ05MX0FQUFJPVkVfVFJBTlNBQ1RJT05fRkFJTEVELCB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IHR4Lmhhc2gsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2cuZGVidWcoYGFwcHJvdmUgdHggXCIke3R4Lmhhc2h9XCIgc3VjY2Vzc2Z1bHkgbWluZWQhYCk7XG4gICAgICAgICAgICAvLyB3YWl0IG9yIHVzZSBjYWNoZWQgY2hhbm5lbE9wZW4uc3VjY2VzcywgdW5jb25maXJtZWRcbiAgICAgICAgICAgIHJldHVybiBvcGVuZWQkLnBpcGUoZmlyc3QoKSwgbWVyZ2VNYXAoKHsgcGF5bG9hZDogeyBpZCB9IH0pID0+IHRva2VuTmV0d29ya0NvbnRyYWN0LmZ1bmN0aW9ucy5zZXRUb3RhbERlcG9zaXQoaWQsIGFkZHJlc3MsIGRlcG9zaXQsIHBhcnRuZXIpKSk7XG4gICAgICAgIH0pLCBhc3NlcnRUeCgnc2V0VG90YWxEZXBvc2l0JywgRXJyb3JDb2Rlcy5DTkxfU0VUVE9UQUxERVBPU0lUX0ZBSUxFRCwgeyBsb2cgfSksIFxuICAgICAgICAvLyBpZ25vcmUgc3VjY2VzcyBzbyBpdCdzIHBpY2tlZCBieSBjaGFubmVsTW9uaXRvcmVkRXBpY1xuICAgICAgICBpZ25vcmVFbGVtZW50cygpLCBjYXRjaEVycm9yKChlcnJvcikgPT4gb2YoY2hhbm5lbERlcG9zaXQuZmFpbHVyZShlcnJvciwgYWN0aW9uLm1ldGEpKSkpO1xuICAgIH0pLCBcbiAgICAvLyBpZ25vcmUgc3VjY2VzcyBzbyBpdCdzIHBpY2tlZCBieSB0b2tlbk1vbml0b3JlZEVwaWNcbiAgICBjYXRjaEVycm9yKChlcnJvcikgPT4gb2YoY2hhbm5lbE9wZW4uZmFpbHVyZShlcnJvciwgYWN0aW9uLm1ldGEpKSkpKSk7XG59KSk7XG4vKipcbiAqIEEgQ2hhbm5lbERlcG9zaXQgYWN0aW9uIHJlcXVlc3RlZCBieSB1c2VyXG4gKiBOZWVkcyB0byBiZSBjYWxsZWQgb24gYSBwcmV2aW91c2x5IG1vbml0b3JlZCBjaGFubmVsLiBDYWxscyBUb2tlbi5hcHByb3ZlIGZvciBUb2tlbk5ldHdvcmtcbiAqIGFuZCB0aGVuIHNldCByZXNwZWN0aXZlIHNldFRvdGFsRGVwb3NpdC4gSWYgYWxsIHR4IGdvIHRocm91Z2ggc3VjY2Vzc2Z1bHksIHN0b3AgYXNcbiAqIENoYW5uZWxEZXBvc2l0ZWQgc3VjY2VzcyBhY3Rpb24gd2lsbCBpbnN0ZWFkIGJlIGRldGVjdGVkIGFuZCByZWFjdGVkIGJ5XG4gKiBjaGFubmVsTW9uaXRvcmVkRXBpYy4gSWYgYW55dGhpbmcgZGV0ZWN0YWJsZSBnb2VzIHdyb25nLCBmaXJlcyBhIENoYW5uZWxEZXBvc2l0QWN0aW9uRmFpbGVkXG4gKiBpbnN0ZWFkXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIGNoYW5uZWxEZXBvc2l0LnJlcXVlc3QgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gYWRkcmVzcyxnZXRUb2tlbkNvbnRyYWN0LGdldFRva2VuTmV0d29ya0NvbnRyYWN0IC0gUmFpZGVuRXBpY0RlcHMgbWVtYmVyc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBjaGFubmVsRGVwb3NpdC5mYWlsdXJlIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGNoYW5uZWxEZXBvc2l0RXBpYyA9IChhY3Rpb24kLCBzdGF0ZSQsIHsgbG9nLCBzaWduZXIsIGFkZHJlc3MsIG1haW4sIGdldFRva2VuQ29udHJhY3QsIGdldFRva2VuTmV0d29ya0NvbnRyYWN0LCBjb25maWckLCB9KSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzQWN0aW9uT2YoY2hhbm5lbERlcG9zaXQucmVxdWVzdCkpLCB3aXRoTGF0ZXN0RnJvbShzdGF0ZSQsIGNvbmZpZyQpLCBtZXJnZU1hcCgoW2FjdGlvbiwgc3RhdGUsIHsgc3Via2V5OiBjb25maWdTdWJrZXkgfV0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyB0b2tlbk5ldHdvcmssIHBhcnRuZXIgfSA9IGFjdGlvbi5tZXRhO1xuICAgIGNvbnN0IHRva2VuID0gZmluZEtleShzdGF0ZS50b2tlbnMsICh0bikgPT4gdG4gPT09IHRva2VuTmV0d29yayk7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBSYWlkZW5FcnJvcihFcnJvckNvZGVzLkNOTF9UT0tFTl9OT1RfRk9VTkQsIGFjdGlvbi5tZXRhKTtcbiAgICAgICAgcmV0dXJuIG9mKGNoYW5uZWxEZXBvc2l0LmZhaWx1cmUoZXJyb3IsIGFjdGlvbi5tZXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IHsgc2lnbmVyOiBvbmNoYWluU2lnbmVyIH0gPSBjaG9vc2VPbmNoYWluQWNjb3VudCh7IHNpZ25lciwgYWRkcmVzcywgbWFpbiB9LCAoX2EgPSBhY3Rpb24ucGF5bG9hZC5zdWJrZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbmZpZ1N1YmtleSk7XG4gICAgY29uc3QgdG9rZW5Db250cmFjdCA9IGdldENvbnRyYWN0V2l0aFNpZ25lcihnZXRUb2tlbkNvbnRyYWN0KHRva2VuKSwgb25jaGFpblNpZ25lcik7XG4gICAgY29uc3QgdG9rZW5OZXR3b3JrQ29udHJhY3QgPSBnZXRDb250cmFjdFdpdGhTaWduZXIoZ2V0VG9rZW5OZXR3b3JrQ29udHJhY3QodG9rZW5OZXR3b3JrKSwgb25jaGFpblNpZ25lcik7XG4gICAgY29uc3QgY2hhbm5lbCA9IHN0YXRlLmNoYW5uZWxzW3Rva2VuTmV0d29ya11bcGFydG5lcl07XG4gICAgaWYgKChjaGFubmVsID09PSBudWxsIHx8IGNoYW5uZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWwuc3RhdGUpICE9PSBDaGFubmVsU3RhdGUub3Blbikge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBSYWlkZW5FcnJvcihFcnJvckNvZGVzLkNOTF9OT19PUEVOX0NIQU5ORUxfRk9VTkQsIGFjdGlvbi5tZXRhKTtcbiAgICAgICAgcmV0dXJuIG9mKGNoYW5uZWxEZXBvc2l0LmZhaWx1cmUoZXJyb3IsIGFjdGlvbi5tZXRhKSk7XG4gICAgfVxuICAgIC8vIHNlbmQgYXBwcm92ZSB0cmFuc2FjdGlvblxuICAgIHJldHVybiBmcm9tKHRva2VuQ29udHJhY3QuZnVuY3Rpb25zLmFwcHJvdmUodG9rZW5OZXR3b3JrLCBhY3Rpb24ucGF5bG9hZC5kZXBvc2l0KSkucGlwZShhc3NlcnRUeCgnYXBwcm92ZScsIEVycm9yQ29kZXMuQ05MX0FQUFJPVkVfVFJBTlNBQ1RJT05fRkFJTEVELCB7IGxvZyB9KSwgd2l0aExhdGVzdEZyb20oc3RhdGUkKSwgbWVyZ2VNYXAoKFssIHN0YXRlXSkgPT4gXG4gICAgLy8gc2VuZCBzZXRUb3RhbERlcG9zaXQgdHJhbnNhY3Rpb25cbiAgICB0b2tlbk5ldHdvcmtDb250cmFjdC5mdW5jdGlvbnMuc2V0VG90YWxEZXBvc2l0KGNoYW5uZWwuaWQsIGFkZHJlc3MsIHN0YXRlLmNoYW5uZWxzW3Rva2VuTmV0d29ya11bcGFydG5lcl0ub3duLmRlcG9zaXQuYWRkKGFjdGlvbi5wYXlsb2FkLmRlcG9zaXQpLCBwYXJ0bmVyKSksIGFzc2VydFR4KCdzZXRUb3RhbERlcG9zaXQnLCBFcnJvckNvZGVzLkNOTF9TRVRUT1RBTERFUE9TSVRfRkFJTEVELCB7IGxvZyB9KSwgXG4gICAgLy8gaWYgc3VjY2VlZGVkLCByZXR1cm4gYSBlbXB0eS9jb21wbGV0ZWQgb2JzZXJ2YWJsZVxuICAgIC8vIGFjdHVhbCBDaGFubmVsRGVwb3NpdGVkQWN0aW9uIHdpbGwgYmUgZGV0ZWN0ZWQgYW5kIGhhbmRsZWQgYnkgY2hhbm5lbE1vbml0b3JlZEVwaWNcbiAgICAvLyBpZiBhbnkgZXJyb3IgaGFwcGVuZWQgb24gdHggY2FsbC9waXBlbGluZSwgbWVyZ2VNYXAgYmVsb3cgd29uJ3QgYmUgaGl0LCBhbmQgY2F0Y2hFcnJvclxuICAgIC8vIHdpbGwgdGhlbiBlbWl0IHRoZSBjaGFubmVsRGVwb3NpdC5mYWlsdXJlIGFjdGlvbiBpbnN0ZWFkXG4gICAgaWdub3JlRWxlbWVudHMoKSwgY2F0Y2hFcnJvcigoZXJyb3IpID0+IG9mKGNoYW5uZWxEZXBvc2l0LmZhaWx1cmUoZXJyb3IsIGFjdGlvbi5tZXRhKSkpKTtcbn0pKTtcbi8qKlxuICogQSBDaGFubmVsQ2xvc2UgYWN0aW9uIHJlcXVlc3RlZCBieSB1c2VyXG4gKiBOZWVkcyB0byBiZSBjYWxsZWQgb24gYW4gb3BlbmVkIG9yIGNsb3NpbmcgKGZvciByZXRyaWVzKSBjaGFubmVsLlxuICogSWYgdHggZ29lcyB0aHJvdWdoIHN1Y2Nlc3NmdWx5LCBzdG9wIGFzIENoYW5uZWxDbG9zZWQgc3VjY2VzcyBhY3Rpb24gd2lsbCBpbnN0ZWFkIGJlXG4gKiBkZXRlY3RlZCBhbmQgcmVhY3RlZCBieSBjaGFubmVsTW9uaXRvcmVkRXBpYy4gSWYgYW55dGhpbmcgZGV0ZWN0YWJsZSBnb2VzIHdyb25nLCBmaXJlcyBhXG4gKiBDaGFubmVsQ2xvc2VBY3Rpb25GYWlsZWQgaW5zdGVhZFxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBjaGFubmVsQ2xvc2UgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gZ2V0VG9rZW5OZXR3b3JrQ29udHJhY3QgLSBSYWlkZW5FcGljRGVwcyBtZW1iZXJzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIGNoYW5uZWxDbG9zZS5mYWlsdXJlIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGNoYW5uZWxDbG9zZUVwaWMgPSAoYWN0aW9uJCwgc3RhdGUkLCB7IGxvZywgc2lnbmVyLCBhZGRyZXNzLCBtYWluLCBuZXR3b3JrLCBnZXRUb2tlbk5ldHdvcmtDb250cmFjdCwgY29uZmlnJCB9KSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzQWN0aW9uT2YoY2hhbm5lbENsb3NlLnJlcXVlc3QpKSwgd2l0aExhdGVzdEZyb20oc3RhdGUkLCBjb25maWckKSwgbWVyZ2VNYXAoKFthY3Rpb24sIHN0YXRlLCB7IHN1YmtleTogY29uZmlnU3Via2V5IH1dKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgeyB0b2tlbk5ldHdvcmssIHBhcnRuZXIgfSA9IGFjdGlvbi5tZXRhO1xuICAgIGNvbnN0IHsgc2lnbmVyOiBvbmNoYWluU2lnbmVyIH0gPSBjaG9vc2VPbmNoYWluQWNjb3VudCh7IHNpZ25lciwgYWRkcmVzcywgbWFpbiB9LCAoX2IgPSAoX2EgPSBhY3Rpb24ucGF5bG9hZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN1YmtleSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29uZmlnU3Via2V5KTtcbiAgICBjb25zdCB0b2tlbk5ldHdvcmtDb250cmFjdCA9IGdldENvbnRyYWN0V2l0aFNpZ25lcihnZXRUb2tlbk5ldHdvcmtDb250cmFjdCh0b2tlbk5ldHdvcmspLCBvbmNoYWluU2lnbmVyKTtcbiAgICBjb25zdCBjaGFubmVsID0gKF9jID0gc3RhdGUuY2hhbm5lbHNbdG9rZW5OZXR3b3JrXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jW3BhcnRuZXJdO1xuICAgIGlmICgoY2hhbm5lbCA9PT0gbnVsbCB8fCBjaGFubmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVsLnN0YXRlKSAhPT0gQ2hhbm5lbFN0YXRlLm9wZW4gJiYgKGNoYW5uZWwgPT09IG51bGwgfHwgY2hhbm5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbC5zdGF0ZSkgIT09IENoYW5uZWxTdGF0ZS5jbG9zaW5nKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuQ05MX05PX09QRU5fT1JfQ0xPU0lOR19DSEFOTkVMX0ZPVU5ELCBhY3Rpb24ubWV0YSk7XG4gICAgICAgIHJldHVybiBvZihjaGFubmVsQ2xvc2UuZmFpbHVyZShlcnJvciwgYWN0aW9uLm1ldGEpKTtcbiAgICB9XG4gICAgbGV0IGJhbGFuY2VIYXNoID0gSGFzaFplcm8sIG5vbmNlID0gWmVybywgYWRkaXRpb25hbEhhc2ggPSBIYXNoWmVybywgbm9uQ2xvc2luZ1NpZ25hdHVyZSA9IGhleGxpZnkoU2lnbmF0dXJlWmVybyk7XG4gICAgaWYgKGNoYW5uZWwucGFydG5lci5iYWxhbmNlUHJvb2YpIHtcbiAgICAgICAgYmFsYW5jZUhhc2ggPSBjcmVhdGVCYWxhbmNlSGFzaChjaGFubmVsLnBhcnRuZXIuYmFsYW5jZVByb29mLnRyYW5zZmVycmVkQW1vdW50LCBjaGFubmVsLnBhcnRuZXIuYmFsYW5jZVByb29mLmxvY2tlZEFtb3VudCwgY2hhbm5lbC5wYXJ0bmVyLmJhbGFuY2VQcm9vZi5sb2Nrc3Jvb3QpO1xuICAgICAgICBub25jZSA9IGNoYW5uZWwucGFydG5lci5iYWxhbmNlUHJvb2Yubm9uY2U7XG4gICAgICAgIGFkZGl0aW9uYWxIYXNoID0gY2hhbm5lbC5wYXJ0bmVyLmJhbGFuY2VQcm9vZi5tZXNzYWdlSGFzaDtcbiAgICAgICAgbm9uQ2xvc2luZ1NpZ25hdHVyZSA9IGNoYW5uZWwucGFydG5lci5iYWxhbmNlUHJvb2Yuc2lnbmF0dXJlO1xuICAgIH1cbiAgICBjb25zdCBjbG9zaW5nTWVzc2FnZSA9IGNvbmNhdChbXG4gICAgICAgIGVuY29kZSh0b2tlbk5ldHdvcmssIDIwKSxcbiAgICAgICAgZW5jb2RlKG5ldHdvcmsuY2hhaW5JZCwgMzIpLFxuICAgICAgICBlbmNvZGUoMSwgMzIpLFxuICAgICAgICBlbmNvZGUoY2hhbm5lbC5pZCwgMzIpLFxuICAgICAgICBlbmNvZGUoYmFsYW5jZUhhc2gsIDMyKSxcbiAgICAgICAgZW5jb2RlKG5vbmNlLCAzMiksXG4gICAgICAgIGVuY29kZShhZGRpdGlvbmFsSGFzaCwgMzIpLFxuICAgICAgICBlbmNvZGUobm9uQ2xvc2luZ1NpZ25hdHVyZSwgNjUpLFxuICAgIF0pOyAvLyBVSW50OEFycmF5IG9mIDI3NyBieXRlc1xuICAgIC8vIHNpZ24gY291bnRlciBiYWxhbmNlIHByb29mLCB0aGVuIHNlbmQgY2xvc2VDaGFubmVsIHRyYW5zYWN0aW9uIHdpdGggb3VyIHNpZ25hdHVyZVxuICAgIHJldHVybiBmcm9tKHNpZ25lci5zaWduTWVzc2FnZShjbG9zaW5nTWVzc2FnZSkpLnBpcGUobWVyZ2VNYXAoKGNsb3NpbmdTaWduYXR1cmUpID0+IHRva2VuTmV0d29ya0NvbnRyYWN0LmZ1bmN0aW9ucy5jbG9zZUNoYW5uZWwoY2hhbm5lbC5pZCwgcGFydG5lciwgYWRkcmVzcywgYmFsYW5jZUhhc2gsIG5vbmNlLCBhZGRpdGlvbmFsSGFzaCwgbm9uQ2xvc2luZ1NpZ25hdHVyZSwgY2xvc2luZ1NpZ25hdHVyZSkpLCBhc3NlcnRUeCgnY2xvc2VDaGFubmVsJywgRXJyb3JDb2Rlcy5DTkxfQ0xPU0VDSEFOTkVMX0ZBSUxFRCwgeyBsb2cgfSksIFxuICAgIC8vIGlmIHN1Y2NlZWRlZCwgcmV0dXJuIGEgZW1wdHkvY29tcGxldGVkIG9ic2VydmFibGVcbiAgICAvLyBhY3R1YWwgQ2hhbm5lbENsb3NlZEFjdGlvbiB3aWxsIGJlIGRldGVjdGVkIGFuZCBoYW5kbGVkIGJ5IGNoYW5uZWxNb25pdG9yZWRFcGljXG4gICAgLy8gaWYgYW55IGVycm9yIGhhcHBlbmVkIG9uIHR4IGNhbGwvcGlwZWxpbmUsIGNhdGNoRXJyb3Igd2lsbCB0aGVuIGVtaXQgdGhlXG4gICAgLy8gY2hhbm5lbENsb3NlLmZhaWx1cmUgYWN0aW9uIGluc3RlYWRcbiAgICBpZ25vcmVFbGVtZW50cygpLCBjYXRjaEVycm9yKChlcnJvcikgPT4gb2YoY2hhbm5lbENsb3NlLmZhaWx1cmUoZXJyb3IsIGFjdGlvbi5tZXRhKSkpKTtcbn0pKTtcbi8qKlxuICogV2hlbiBkZXRlY3RpbmcgYSBDaGFubmVsQ2xvc2VkIGV2ZW50LCBjYWxscyB1cGRhdGVOb25DbG9zaW5nQmFsYW5jZVByb29mIHdpdGggcGFydG5lcidzIGJhbGFuY2VcbiAqIHByb29mLCBpZmYgdGhlcmUncyBhbnlcbiAqIFRPRE86IGRvIGl0IG9ubHkgaWYgZWNvbm9taWNhbGx5IHZpYWJsZSAoYW5kIGRlZmluZSB3aGF0IHRoYXQgbWVhbnMpXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIGNoYW5uZWxDbG9zZS5zdWNjZXNzfG5ld0Jsb2NrIGFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHBhcmFtIGRlcHMgLSBSYWlkZW5FcGljRGVwcyBtZW1iZXJzXG4gKiBAcmV0dXJucyBFbXB0eSBvYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBjb25zdCBjaGFubmVsVXBkYXRlRXBpYyA9IChhY3Rpb24kLCBzdGF0ZSQsIHsgbG9nLCBzaWduZXIsIGFkZHJlc3MsIG1haW4sIG5ldHdvcmssIGdldFRva2VuTmV0d29ya0NvbnRyYWN0LCBjb25maWckIH0pID0+IGFjdGlvbiQucGlwZShmaWx0ZXIoaXNBY3Rpb25PZihjaGFubmVsQ2xvc2Uuc3VjY2VzcykpLCBmaWx0ZXIoKGFjdGlvbikgPT4gISFhY3Rpb24ucGF5bG9hZC5jb25maXJtZWQpLCBcbi8vIHdhaXQgMiBuZXdCbG9jayBhY3Rpb25zIGdvIHRocm91Z2ggYWZ0ZXIgY2hhbm5lbENsb3NlIGNvbmZpcm1hdGlvbiwgdG8gZW5zdXJlIGFueSBwZW5kaW5nXG4vLyBjaGFubmVsU2V0dGxlIGNvdWxkIGhhdmUgYmVlbiBwcm9jZXNzZWRcbm1lcmdlTWFwKChhY3Rpb24pID0+IGFjdGlvbiQucGlwZShmaWx0ZXIobmV3QmxvY2suaXMpLCBza2lwKDEpLCB0YWtlKDEpLCBtYXBUbyhhY3Rpb24pKSksIHdpdGhMYXRlc3RGcm9tKHN0YXRlJCwgY29uZmlnJCksIGZpbHRlcigoW2FjdGlvbiwgc3RhdGVdKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNoYW5uZWwgPSAoX2EgPSBzdGF0ZS5jaGFubmVsc1thY3Rpb24ubWV0YS50b2tlbk5ldHdvcmtdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYWN0aW9uLm1ldGEucGFydG5lcl07XG4gICAgcmV0dXJuICgoY2hhbm5lbCA9PT0gbnVsbCB8fCBjaGFubmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVsLnN0YXRlKSA9PT0gQ2hhbm5lbFN0YXRlLmNsb3NlZCAmJlxuICAgICAgICBjaGFubmVsLmlkID09PSBhY3Rpb24ucGF5bG9hZC5pZCAmJlxuICAgICAgICAhIWNoYW5uZWwucGFydG5lci5iYWxhbmNlUHJvb2YgJiYgLy8gdGhlcmUncyBwYXJ0bmVycyBiYWxhbmNlUHJvb2YgKGkuZS4gcmVjZWl2ZWQgdHJhbnNmZXJzKVxuICAgICAgICBjaGFubmVsLmNsb3NlUGFydGljaXBhbnQgIT09IGFkZHJlc3MgLy8gd2UncmUgbm90IHRoZSBjbG9zaW5nIGVuZFxuICAgICk7XG59KSwgbWVyZ2VNYXAoKFthY3Rpb24sIHN0YXRlLCB7IHN1YmtleSB9XSkgPT4ge1xuICAgIGNvbnN0IHsgdG9rZW5OZXR3b3JrLCBwYXJ0bmVyIH0gPSBhY3Rpb24ubWV0YTtcbiAgICBjb25zdCB7IHNpZ25lcjogb25jaGFpblNpZ25lciB9ID0gY2hvb3NlT25jaGFpbkFjY291bnQoeyBzaWduZXIsIGFkZHJlc3MsIG1haW4gfSwgc3Via2V5KTtcbiAgICBjb25zdCB0b2tlbk5ldHdvcmtDb250cmFjdCA9IGdldENvbnRyYWN0V2l0aFNpZ25lcihnZXRUb2tlbk5ldHdvcmtDb250cmFjdCh0b2tlbk5ldHdvcmspLCBvbmNoYWluU2lnbmVyKTtcbiAgICBjb25zdCBjaGFubmVsID0gc3RhdGUuY2hhbm5lbHNbdG9rZW5OZXR3b3JrXVtwYXJ0bmVyXTtcbiAgICAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuIGJlY2F1c2Ugb2YgZmlsdGVyLCBqdXN0IGhlcmUgdG8gbmFycm93IHVuaW9uXG4gICAgYXNzZXJ0KChjaGFubmVsID09PSBudWxsIHx8IGNoYW5uZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWwuc3RhdGUpID09PSBDaGFubmVsU3RhdGUuY2xvc2VkKTtcbiAgICBhc3NlcnQoY2hhbm5lbC5wYXJ0bmVyLmJhbGFuY2VQcm9vZik7XG4gICAgY29uc3QgYmFsYW5jZUhhc2ggPSBjcmVhdGVCYWxhbmNlSGFzaChjaGFubmVsLnBhcnRuZXIuYmFsYW5jZVByb29mLnRyYW5zZmVycmVkQW1vdW50LCBjaGFubmVsLnBhcnRuZXIuYmFsYW5jZVByb29mLmxvY2tlZEFtb3VudCwgY2hhbm5lbC5wYXJ0bmVyLmJhbGFuY2VQcm9vZi5sb2Nrc3Jvb3QpO1xuICAgIGNvbnN0IG5vbmNlID0gY2hhbm5lbC5wYXJ0bmVyLmJhbGFuY2VQcm9vZi5ub25jZTtcbiAgICBjb25zdCBhZGRpdGlvbmFsSGFzaCA9IGNoYW5uZWwucGFydG5lci5iYWxhbmNlUHJvb2YubWVzc2FnZUhhc2g7XG4gICAgY29uc3QgY2xvc2luZ1NpZ25hdHVyZSA9IGNoYW5uZWwucGFydG5lci5iYWxhbmNlUHJvb2Yuc2lnbmF0dXJlO1xuICAgIGNvbnN0IG5vbkNsb3NpbmdNZXNzYWdlID0gY29uY2F0KFtcbiAgICAgICAgZW5jb2RlKHRva2VuTmV0d29yaywgMjApLFxuICAgICAgICBlbmNvZGUobmV0d29yay5jaGFpbklkLCAzMiksXG4gICAgICAgIGVuY29kZSgyLCAzMiksXG4gICAgICAgIGVuY29kZShjaGFubmVsLmlkLCAzMiksXG4gICAgICAgIGVuY29kZShiYWxhbmNlSGFzaCwgMzIpLFxuICAgICAgICBlbmNvZGUobm9uY2UsIDMyKSxcbiAgICAgICAgZW5jb2RlKGFkZGl0aW9uYWxIYXNoLCAzMiksXG4gICAgICAgIGVuY29kZShjbG9zaW5nU2lnbmF0dXJlLCA2NSksXG4gICAgXSk7IC8vIFVJbnQ4QXJyYXkgb2YgMjc3IGJ5dGVzXG4gICAgLy8gc2VuZCB1cGRhdGVOb25DbG9zaW5nQmFsYW5jZVByb29mIHRyYW5zYWN0aW9uXG4gICAgcmV0dXJuIGZyb20oc2lnbmVyLnNpZ25NZXNzYWdlKG5vbkNsb3NpbmdNZXNzYWdlKSkucGlwZShtZXJnZU1hcCgobm9uQ2xvc2luZ1NpZ25hdHVyZSkgPT4gdG9rZW5OZXR3b3JrQ29udHJhY3QuZnVuY3Rpb25zLnVwZGF0ZU5vbkNsb3NpbmdCYWxhbmNlUHJvb2YoY2hhbm5lbC5pZCwgcGFydG5lciwgYWRkcmVzcywgYmFsYW5jZUhhc2gsIG5vbmNlLCBhZGRpdGlvbmFsSGFzaCwgY2xvc2luZ1NpZ25hdHVyZSwgbm9uQ2xvc2luZ1NpZ25hdHVyZSkpLCBhc3NlcnRUeCgndXBkYXRlTm9uQ2xvc2luZ0JhbGFuY2VQcm9vZicsIEVycm9yQ29kZXMuQ05MX1VQREFURV9OT05DTE9TSU5HX0JQX0ZBSUxFRCwge1xuICAgICAgICBsb2csXG4gICAgfSksIFxuICAgIC8vIGlmIHN1Y2NlZWRlZCwgcmV0dXJuIGEgZW1wdHkvY29tcGxldGVkIG9ic2VydmFibGVcbiAgICBpZ25vcmVFbGVtZW50cygpLCBjYXRjaEVycm9yKChlcnJvcikgPT4ge1xuICAgICAgICBsb2cuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIG5vbi1jbG9zaW5nIGJhbGFuY2UtcHJvb2YsIGlnbm9yaW5nJywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgfSkpO1xufSkpO1xuLyoqXG4gKiBBIENoYW5uZWxTZXR0bGUgYWN0aW9uIHJlcXVlc3RlZCBieSB1c2VyXG4gKiBOZWVkcyB0byBiZSBjYWxsZWQgb24gYW4gc2V0dGxlYWJsZSBvciBzZXR0bGluZyAoZm9yIHJldHJpZXMpIGNoYW5uZWwuXG4gKiBJZiB0eCBnb2VzIHRocm91Z2ggc3VjY2Vzc2Z1bHksIHN0b3AgYXMgQ2hhbm5lbFNldHRsZWQgc3VjY2VzcyBhY3Rpb24gd2lsbCBpbnN0ZWFkIGJlXG4gKiBkZXRlY3RlZCBhbmQgcmVhY3RlZCBieSBjaGFubmVsTW9uaXRvcmVkRXBpYy4gSWYgYW55dGhpbmcgZGV0ZWN0YWJsZSBnb2VzIHdyb25nLCBmaXJlcyBhXG4gKiBDaGFubmVsU2V0dGxlQWN0aW9uRmFpbGVkIGluc3RlYWRcbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgY2hhbm5lbFNldHRsZSBhY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEBwYXJhbSBhZGRyZXNzLGdldFRva2VuTmV0d29ya0NvbnRyYWN0IC0gUmFpZGVuRXBpY0RlcHMgbWVtYmVyc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBjaGFubmVsU2V0dGxlLmZhaWx1cmUgYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgY2hhbm5lbFNldHRsZUVwaWMgPSAoYWN0aW9uJCwgc3RhdGUkLCB7IGxvZywgc2lnbmVyLCBhZGRyZXNzLCBtYWluLCBnZXRUb2tlbk5ldHdvcmtDb250cmFjdCwgY29uZmlnJCB9KSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzQWN0aW9uT2YoY2hhbm5lbFNldHRsZS5yZXF1ZXN0KSksIHdpdGhMYXRlc3RGcm9tKHN0YXRlJCwgY29uZmlnJCksIG1lcmdlTWFwKChbYWN0aW9uLCBzdGF0ZSwgeyBzdWJrZXk6IGNvbmZpZ1N1YmtleSB9XSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IHsgdG9rZW5OZXR3b3JrLCBwYXJ0bmVyIH0gPSBhY3Rpb24ubWV0YTtcbiAgICBjb25zdCB7IHNpZ25lcjogb25jaGFpblNpZ25lciB9ID0gY2hvb3NlT25jaGFpbkFjY291bnQoeyBzaWduZXIsIGFkZHJlc3MsIG1haW4gfSwgKF9iID0gKF9hID0gYWN0aW9uLnBheWxvYWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJrZXkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvbmZpZ1N1YmtleSk7XG4gICAgY29uc3QgdG9rZW5OZXR3b3JrQ29udHJhY3QgPSBnZXRDb250cmFjdFdpdGhTaWduZXIoZ2V0VG9rZW5OZXR3b3JrQ29udHJhY3QodG9rZW5OZXR3b3JrKSwgb25jaGFpblNpZ25lcik7XG4gICAgY29uc3QgY2hhbm5lbCA9IChfYyA9IHN0YXRlLmNoYW5uZWxzW3Rva2VuTmV0d29ya10pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1twYXJ0bmVyXTtcbiAgICBpZiAoKGNoYW5uZWwgPT09IG51bGwgfHwgY2hhbm5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbC5zdGF0ZSkgIT09IENoYW5uZWxTdGF0ZS5zZXR0bGVhYmxlICYmIChjaGFubmVsID09PSBudWxsIHx8IGNoYW5uZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWwuc3RhdGUpICE9PSBDaGFubmVsU3RhdGUuc2V0dGxpbmcpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgUmFpZGVuRXJyb3IoRXJyb3JDb2Rlcy5DTkxfTk9fU0VUVExFQUJMRV9PUl9TRVRUTElOR19DSEFOTkVMX0ZPVU5ELCBhY3Rpb24ubWV0YSk7XG4gICAgICAgIHJldHVybiBvZihjaGFubmVsU2V0dGxlLmZhaWx1cmUoZXJyb3IsIGFjdGlvbi5tZXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IHplcm9CYWxhbmNlUHJvb2YgPSB7XG4gICAgICAgIHRyYW5zZmVycmVkQW1vdW50OiBaZXJvLFxuICAgICAgICBsb2NrZWRBbW91bnQ6IFplcm8sXG4gICAgICAgIGxvY2tzcm9vdDogSGFzaFplcm8sXG4gICAgfTtcbiAgICBsZXQgcGFydDEgPSBPYmplY3QuYXNzaWduKHsgYWRkcmVzczogcGFydG5lciB9LCAoY2hhbm5lbC5wYXJ0bmVyLmJhbGFuY2VQcm9vZiB8fCB6ZXJvQmFsYW5jZVByb29mKSksIHBhcnQyID0gT2JqZWN0LmFzc2lnbih7IGFkZHJlc3MgfSwgKGNoYW5uZWwub3duLmJhbGFuY2VQcm9vZiB8fCB6ZXJvQmFsYW5jZVByb29mKSk7XG4gICAgaWYgKGNoYW5uZWwuaXNGaXJzdFBhcnRpY2lwYW50KVxuICAgICAgICBbcGFydDEsIHBhcnQyXSA9IFtwYXJ0MiwgcGFydDFdO1xuICAgIC8vIHNlbmQgc2V0dGxlQ2hhbm5lbCB0cmFuc2FjdGlvblxuICAgIHJldHVybiBmcm9tKHRva2VuTmV0d29ya0NvbnRyYWN0LmZ1bmN0aW9ucy5zZXR0bGVDaGFubmVsKGNoYW5uZWwuaWQsIHBhcnQxLmFkZHJlc3MsIHBhcnQxLnRyYW5zZmVycmVkQW1vdW50LCBwYXJ0MS5sb2NrZWRBbW91bnQsIHBhcnQxLmxvY2tzcm9vdCwgcGFydDIuYWRkcmVzcywgcGFydDIudHJhbnNmZXJyZWRBbW91bnQsIHBhcnQyLmxvY2tlZEFtb3VudCwgcGFydDIubG9ja3Nyb290KSkucGlwZShhc3NlcnRUeCgnc2V0dGxlQ2hhbm5lbCcsIEVycm9yQ29kZXMuQ05MX1NFVFRMRUNIQU5ORUxfRkFJTEVELCB7IGxvZyB9KSwgXG4gICAgLy8gaWYgc3VjY2VlZGVkLCByZXR1cm4gYSBlbXB0eS9jb21wbGV0ZWQgb2JzZXJ2YWJsZVxuICAgIC8vIGFjdHVhbCBDaGFubmVsU2V0dGxlZEFjdGlvbiB3aWxsIGJlIGRldGVjdGVkIGFuZCBoYW5kbGVkIGJ5IGNoYW5uZWxNb25pdG9yZWRFcGljXG4gICAgLy8gaWYgYW55IGVycm9yIGhhcHBlbmVkIG9uIHR4IGNhbGwvcGlwZWxpbmUsIG1lcmdlTWFwIGJlbG93IHdvbid0IGJlIGhpdCwgYW5kIGNhdGNoRXJyb3JcbiAgICAvLyB3aWxsIHRoZW4gZW1pdCB0aGUgY2hhbm5lbFNldHRsZS5mYWlsdXJlIGFjdGlvbiBpbnN0ZWFkXG4gICAgaWdub3JlRWxlbWVudHMoKSwgY2F0Y2hFcnJvcigoZXJyb3IpID0+IG9mKGNoYW5uZWxTZXR0bGUuZmFpbHVyZShlcnJvciwgYWN0aW9uLm1ldGEpKSkpO1xufSkpO1xuLyoqXG4gKiBQcm9jZXNzIG5ld0Jsb2NrcywgZW1pdHMgQ2hhbm5lbFNldHRsZWFibGVBY3Rpb24gaWYgYW55IGNsb3NlZCBjaGFubmVsIGlzIG5vdyBzZXR0bGVhYmxlXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIG5ld0Jsb2NrIGFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBjaGFubmVsU2V0dGxlYWJsZSBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBjaGFubmVsU2V0dGxlYWJsZUVwaWMgPSAoYWN0aW9uJCwgc3RhdGUkKSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzQWN0aW9uT2YobmV3QmxvY2spKSwgd2l0aExhdGVzdEZyb20oc3RhdGUkKSwgbWVyZ2VNYXAoZnVuY3Rpb24qIChbeyBwYXlsb2FkOiB7IGJsb2NrTnVtYmVyIH0sIH0sIHN0YXRlLF0pIHtcbiAgICBmb3IgKGNvbnN0IHRva2VuTmV0d29yayBpbiBzdGF0ZS5jaGFubmVscykge1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnRuZXIgaW4gc3RhdGUuY2hhbm5lbHNbdG9rZW5OZXR3b3JrXSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHN0YXRlLmNoYW5uZWxzW3Rva2VuTmV0d29ya11bcGFydG5lcl07XG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gQ2hhbm5lbFN0YXRlLmNsb3NlZCAmJlxuICAgICAgICAgICAgICAgIGNoYW5uZWwuc2V0dGxlVGltZW91dCAmJiAvLyBjbG9zZWQgY2hhbm5lbHMgYWx3YXlzIGhhdmUgc2V0dGxlVGltZW91dCAmIGNsb3NlQmxvY2sgc2V0XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5jbG9zZUJsb2NrICYmXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPiBjaGFubmVsLmNsb3NlQmxvY2sgKyBjaGFubmVsLnNldHRsZVRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaGFubmVsU2V0dGxlYWJsZSh7IHNldHRsZWFibGVCbG9jazogYmxvY2tOdW1iZXIgfSwgeyB0b2tlbk5ldHdvcms6IHRva2VuTmV0d29yaywgcGFydG5lcjogcGFydG5lciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pKTtcbi8qKlxuICogV2hlbiBjaGFubmVsIGlzIHNldHRsZWQsIHVubG9jayBhbnkgcGVuZGluZyBsb2NrIG9uLWNoYWluXG4gKiBUT0RPOiBjaGVjayBpZiBpdCdzIHdvcnRoIGl0IHRvIGFsc28gdW5sb2NrIHBhcnRuZXIncyBlbmRcbiAqIFRPRE86IGRvIGl0IG9ubHkgaWYgZWNvbm9taWNhbGx5IHZpYWJsZSAoYW5kIGRlZmluZSB3aGF0IHRoYXQgbWVhbnMpXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIGNoYW5uZWxTZXR0bGUuc3VjY2VzcyBhY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEBwYXJhbSBkZXBzIC0gUmFpZGVuRXBpY0RlcHMgbWVtYmVyc1xuICogQHJldHVybnMgRW1wdHkgb2JzZXJ2YWJsZVxuICovXG5leHBvcnQgY29uc3QgY2hhbm5lbFVubG9ja0VwaWMgPSAoYWN0aW9uJCwgc3RhdGUkLCB7IGxvZywgc2lnbmVyLCBhZGRyZXNzLCBtYWluLCBnZXRUb2tlbk5ldHdvcmtDb250cmFjdCwgY29uZmlnJCB9KSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzQWN0aW9uT2YoY2hhbm5lbFNldHRsZS5zdWNjZXNzKSksIGZpbHRlcigoYWN0aW9uKSA9PiB7IHZhciBfYTsgcmV0dXJuICEhKGFjdGlvbi5wYXlsb2FkLmNvbmZpcm1lZCAmJiAoKF9hID0gYWN0aW9uLnBheWxvYWQubG9ja3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpKTsgfSksIHdpdGhMYXRlc3RGcm9tKHN0YXRlJCwgY29uZmlnJCksIGZpbHRlcigoW2FjdGlvbiwgc3RhdGVdKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGNoYW5uZWwgPSAoX2EgPSBzdGF0ZS5jaGFubmVsc1thY3Rpb24ubWV0YS50b2tlbk5ldHdvcmtdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYWN0aW9uLm1ldGEucGFydG5lcl07XG4gICAgcmV0dXJuICFjaGFubmVsIHx8ICEoJ2lkJyBpbiBjaGFubmVsKSB8fCBjaGFubmVsLmlkICE9PSBhY3Rpb24ucGF5bG9hZC5pZDtcbn0pLCBtZXJnZU1hcCgoW2FjdGlvbiwgLCB7IHN1YmtleSB9XSkgPT4ge1xuICAgIGNvbnN0IHsgdG9rZW5OZXR3b3JrLCBwYXJ0bmVyIH0gPSBhY3Rpb24ubWV0YTtcbiAgICBjb25zdCB0b2tlbk5ldHdvcmtDb250cmFjdCA9IGdldENvbnRyYWN0V2l0aFNpZ25lcihnZXRUb2tlbk5ldHdvcmtDb250cmFjdCh0b2tlbk5ldHdvcmspLCBjaG9vc2VPbmNoYWluQWNjb3VudCh7IHNpZ25lciwgYWRkcmVzcywgbWFpbiB9LCBzdWJrZXkpLnNpZ25lcik7XG4gICAgY29uc3QgbG9ja3MgPSBjb25jYXQoYWN0aW9uLnBheWxvYWQubG9ja3MucmVkdWNlKChhY2MsIGxvY2spID0+IFtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBlbmNvZGUobG9jay5leHBpcmF0aW9uLCAzMiksXG4gICAgICAgIGVuY29kZShsb2NrLmFtb3VudCwgMzIpLFxuICAgICAgICBsb2NrLnNlY3JldGhhc2gsXG4gICAgXSwgW10pKTtcbiAgICAvLyBzZW5kIHVubG9jayB0cmFuc2FjdGlvblxuICAgIHJldHVybiBmcm9tKHRva2VuTmV0d29ya0NvbnRyYWN0LmZ1bmN0aW9ucy51bmxvY2soYWN0aW9uLnBheWxvYWQuaWQsIGFkZHJlc3MsIHBhcnRuZXIsIGxvY2tzKSkucGlwZShhc3NlcnRUeCgndW5sb2NrJywgRXJyb3JDb2Rlcy5DTkxfT05DSEFJTl9VTkxPQ0tfRkFJTEVELCB7IGxvZyB9KSwgaWdub3JlRWxlbWVudHMoKSwgY2F0Y2hFcnJvcigoZXJyb3IpID0+IHtcbiAgICAgICAgbG9nLmVycm9yKCdFcnJvciB1bmxvY2tpbmcgcGVuZGluZyBsb2NrcyBvbi1jaGFpbiwgaWdub3JpbmcnLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBFTVBUWTtcbiAgICB9KSk7XG59KSk7XG5mdW5jdGlvbiBjaGVja1BlbmRpbmdBY3Rpb24oYWN0aW9uLCBwcm92aWRlciwgYmxvY2tOdW1iZXIsIGNvbmZpcm1hdGlvbkJsb2Nrcykge1xuICAgIHJldHVybiByZXRyeUFzeW5jJCgoKSA9PiBwcm92aWRlci5nZXRUcmFuc2FjdGlvblJlY2VpcHQoYWN0aW9uLnBheWxvYWQudHhIYXNoKSwgcHJvdmlkZXIucG9sbGluZ0ludGVydmFsKS5waXBlKG1hcCgocmVjZWlwdCkgPT4ge1xuICAgICAgICBpZiAoKHJlY2VpcHQgPT09IG51bGwgfHwgcmVjZWlwdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVjZWlwdC5jb25maXJtYXRpb25zKSAhPT0gdW5kZWZpbmVkICYmIHJlY2VpcHQuY29uZmlybWF0aW9ucyA+PSBjb25maXJtYXRpb25CbG9ja3MpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbiksIHsgXG4gICAgICAgICAgICAgICAgLy8gYmV5b25kIHNldHRpbmcgY29uZmlybWVkLCBhbHNvIHJlLXNldCBibG9ja051bWJlcixcbiAgICAgICAgICAgICAgICAvLyB3aGljaCBtYXkgaGF2ZSBjaGFuZ2VkIG9uIGEgcmVvcmdcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbi5wYXlsb2FkKSwgeyB0eEJsb2NrOiByZWNlaXB0LmJsb2NrTnVtYmVyLCBjb25maXJtZWQ6IHRydWUgfSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uLnBheWxvYWQudHhCbG9jayArIDIgKiBjb25maXJtYXRpb25CbG9ja3MgPCBibG9ja051bWJlcikge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyB0eHMgZGlkbid0IGdldCBjb25maXJtZWQgZm9yIG1vcmUgdGhhbiAyKmNvbmZpcm1hdGlvbkJsb2NrcywgaXQgd2FzIHJlbW92ZWRcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjdGlvbiksIHsgcGF5bG9hZDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY3Rpb24ucGF5bG9hZCksIHsgY29uZmlybWVkOiBmYWxzZSB9KSB9KTtcbiAgICAgICAgfSAvLyBlbHNlLCBpdCBzZWVtcyByZW1vdmVkLCBidXQgZ2l2ZSBpdCB0d2ljZSBjb25maXJtYXRpb25CbG9ja3MgdG8gYmUgcGlja2VkIHVwIGFnYWluXG4gICAgfSksIGZpbHRlcihpc250TmlsKSk7XG59XG4vKipcbiAqIFByb2Nlc3MgbmV3IGJsb2NrcyBhbmQgcmUtZW1pdCBjb25maXJtZWQgb3IgcmVtb3ZlZCBhY3Rpb25zXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIGNoYW5uZWxTZXR0bGUgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gZGVwcyAtIFJhaWRlbkVwaWNEZXBzXG4gKiBAcGFyYW0gZGVwcy5jb25maWckLGRlcHMucHJvdmlkZXIgLSBSYWlkZW5FcGljRGVwcyBtZW1iZXJzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIGNvbmZpcm1lZCBvciByZW1vdmVkIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbmZpcm1hdGlvbkVwaWMgPSAoe30sIHN0YXRlJCwgeyBjb25maWckLCBwcm92aWRlciB9KSA9PiBjb21iaW5lTGF0ZXN0KHN0YXRlJC5waXBlKHBsdWNrRGlzdGluY3QoJ2Jsb2NrTnVtYmVyJykpLCBzdGF0ZSQucGlwZShwbHVjaygncGVuZGluZ1R4cycpKSwgY29uZmlnJC5waXBlKHBsdWNrRGlzdGluY3QoJ2NvbmZpcm1hdGlvbkJsb2NrcycpKSkucGlwZShmaWx0ZXIoKFssIHBlbmRpbmdUeHNdKSA9PiBwZW5kaW5nVHhzLmxlbmd0aCA+IDApLCBcbi8vIGV4aGF1c3Qgd2lsbCBpZ25vcmUgYmxvY2tzIHdoaWxlIGNvbmNhdCQgaXMgYnVzeVxuZXhoYXVzdE1hcCgoW2Jsb2NrTnVtYmVyLCBwZW5kaW5nVHhzLCBjb25maXJtYXRpb25CbG9ja3NdKSA9PiBjb25jYXQkKC4uLnBlbmRpbmdUeHNcbiAgICAvLyBvbmx5IHR4cy9jb25maXJtYWJsZSBhY3Rpb25zIHdoaWNoIGFyZSBtb3JlIHRoYW4gY29uZmlybWF0aW9uQmxvY2tzIGluIHRoZSBwYXN0XG4gICAgLmZpbHRlcigoYSkgPT4gYS5wYXlsb2FkLnR4QmxvY2sgKyBjb25maXJtYXRpb25CbG9ja3MgPD0gYmxvY2tOdW1iZXIpXG4gICAgLm1hcCgoYWN0aW9uKSA9PiBjaGVja1BlbmRpbmdBY3Rpb24oYWN0aW9uLCBwcm92aWRlciwgYmxvY2tOdW1iZXIsIGNvbmZpcm1hdGlvbkJsb2NrcykpKSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXBpY3MuanMubWFwIiwiaW1wb3J0IHsgZW5jb2RlVXJpIH0gZnJvbSAnbWF0cml4LWpzLXNkay9saWIvdXRpbHMnO1xuLyoqXG4gKiBSZXR1cm4gc2VydmVyIG5hbWUgd2l0aG91dCBzY2hlbWEgb3IgcGF0aFxuICpcbiAqIEBwYXJhbSBzZXJ2ZXIgLSBhbnkgVVJMXG4gKiBAcmV0dXJucyBzZXJ2ZXIgVVJMIHdpdGggZG9tYWluIGFuZCBwb3J0IChpZiBwcmVzZW50KSwgd2l0aG91dCBzY2hlbWEsIHBhdGhzIG9yIHF1ZXJ5IHBhcmFtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VydmVyTmFtZShzZXJ2ZXIpIHtcbiAgICBjb25zdCBtYXRjaCA9IC9eKD86XFx3Kjo/XFwvXFwvKT8oW14vIz8mXSspLy5leGVjKHNlcnZlcik7XG4gICAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuLyoqXG4gKiBNYXRyaXhDbGllbnQgZG9lc24ndCBleHBvc2UgdGhpcyBBUEksIGJ1dCBpdCBkb2VzIGV4aXN0LCBzbyB3ZSBjcmVhdGUgaXQgaGVyZVxuICpcbiAqIEBwYXJhbSBtYXRyaXggLSBhbiBhbHJlYWR5IHNldHVwIGFuZCBzdGFydGVkIE1hdHJpeENsaWVudFxuICogQHBhcmFtIHVzZXJJZCAtIHRvIGZldGNoIHN0YXR1cy9wcmVzZW5jZSBmcm9tXG4gKiBAcmV0dXJucyBQcm9taXNlIHRvIG9iamVjdCBjb250YWluaW5nIHN0YXR1cyBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyUHJlc2VuY2UobWF0cml4LCB1c2VySWQpIHtcbiAgICBjb25zdCBwYXRoID0gZW5jb2RlVXJpKCcvcHJlc2VuY2UvJHVzZXJJZC9zdGF0dXMnLCB7ICR1c2VySWQ6IHVzZXJJZCB9KTtcbiAgICByZXR1cm4gbWF0cml4Ll9odHRwLmF1dGhlZFJlcXVlc3QodW5kZWZpbmVkLCAnR0VUJywgcGF0aCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRyaXguanMubWFwIiwiLyoqXG4gKiBTaW1wbGUgTWFwLWJhc2VkIExSVSBjYWNoZVxuICpcbiAqIEBwYXJhbSBtYXggLSBNYXhpbXVtIHNpemUgb2YgY2FjaGVcbiAqL1xuZXhwb3J0IGNsYXNzIExydUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihtYXgpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy52YWx1ZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgLy8gcGVlayB0aGUgZW50cnksIHJlLWluc2VydCBmb3IgTFJVIHN0cmF0ZWd5XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnNldChrZXksIGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICAgIHB1dChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlcy5zaXplID49IHRoaXMubWF4KSB7XG4gICAgICAgICAgICAvLyBsZWFzdC1yZWNlbnRseSB1c2VkIGNhY2hlIGV2aWN0aW9uIHN0cmF0ZWd5XG4gICAgICAgICAgICBjb25zdCBrZXlUb0RlbGV0ZSA9IHRoaXMudmFsdWVzLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5kZWxldGUoa2V5VG9EZWxldGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVzLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1scnUuanMubWFwIiwidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2FtZWxjYXNlICovXG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0LCBmcm9tLCBvZiwgRU1QVFksIGZyb21FdmVudCwgdGltZXIsIHRocm93RXJyb3IsIG1lcmdlLCBkZWZlciwgY29uY2F0LCBBc3luY1N1YmplY3QsIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBjb25jYXRNYXAsIGRlbGF5LCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCBncm91cEJ5LCBpZ25vcmVFbGVtZW50cywgbWFwLCBtZXJnZU1hcCwgd2l0aExhdGVzdEZyb20sIHNjYW4sIHN0YXJ0V2l0aCwgc3dpdGNoTWFwLCB0YWtlLCB0YWtlVW50aWwsIHRhcCwgdG9BcnJheSwgbWFwVG8sIGZpbmFsaXplLCBmaXJzdCwgdGltZW91dCwgcGx1Y2ssIHJlcGVhdFdoZW4sIGV4aGF1c3RNYXAsIHRocm93SWZFbXB0eSwgcmV0cnlXaGVuLCBkaXN0aW5jdCwgZGVsYXlXaGVuLCB0YWtlV2hpbGUsIGJ1ZmZlclRpbWUsIGVuZFdpdGgsIG1lcmdlTWFwVG8sIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgZnJvbUZldGNoIH0gZnJvbSAncnhqcy9mZXRjaCc7XG5pbXBvcnQgZmluZCBmcm9tICdsb2Rhc2gvZmluZCc7XG5pbXBvcnQgbWluQnkgZnJvbSAnbG9kYXNoL21pbkJ5JztcbmltcG9ydCBzb3J0QnkgZnJvbSAnbG9kYXNoL3NvcnRCeSc7XG5pbXBvcnQgY3VycnkgZnJvbSAnbG9kYXNoL2N1cnJ5JztcbmltcG9ydCB7IGdldEFkZHJlc3MsIHZlcmlmeU1lc3NhZ2UgfSBmcm9tICdldGhlcnMvdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50LCBNYXRyaXhFdmVudCwgfSBmcm9tICdtYXRyaXgtanMtc2RrJztcbmltcG9ydCB7IGxvZ2dlciBhcyBtYXRyaXhMb2dnZXIgfSBmcm9tICdtYXRyaXgtanMtc2RrL2xpYi9sb2dnZXInO1xuaW1wb3J0IHsgQ2FwYWJpbGl0aWVzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IFJhaWRlbkVycm9yLCBFcnJvckNvZGVzIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3InO1xuaW1wb3J0IHsgU2lnbmVkLCBpc250TmlsLCBhc3NlcnQsIFNpZ25hdHVyZSB9IGZyb20gJy4uL3V0aWxzL3R5cGVzJztcbmltcG9ydCB7IGlzQWN0aW9uT2YgfSBmcm9tICcuLi91dGlscy9hY3Rpb25zJztcbmltcG9ydCB7IHJhaWRlblNodXRkb3duIH0gZnJvbSAnLi4vYWN0aW9ucyc7XG5pbXBvcnQgeyBjaGFubmVsTW9uaXRvciB9IGZyb20gJy4uL2NoYW5uZWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgTWVzc2FnZVR5cGUsIFByb2Nlc3NlZCwgU2VjcmV0UmVxdWVzdCwgU2VjcmV0UmV2ZWFsLCB9IGZyb20gJy4uL21lc3NhZ2VzL3R5cGVzJztcbmltcG9ydCB7IGRlY29kZUpzb25NZXNzYWdlLCBlbmNvZGVKc29uTWVzc2FnZSwgZ2V0TWVzc2FnZVNpZ25lciwgc2lnbk1lc3NhZ2UsIGlzTWVzc2FnZVJlY2VpdmVkT2ZUeXBlLCB9IGZyb20gJy4uL21lc3NhZ2VzL3V0aWxzJztcbmltcG9ydCB7IG1lc3NhZ2VTZW5kLCBtZXNzYWdlUmVjZWl2ZWQsIG1lc3NhZ2VHbG9iYWxTZW5kIH0gZnJvbSAnLi4vbWVzc2FnZXMvYWN0aW9ucyc7XG5pbXBvcnQgeyB0cmFuc2ZlclNpZ25lZCB9IGZyb20gJy4uL3RyYW5zZmVycy9hY3Rpb25zJztcbmltcG9ydCB7IGdldFNlcnZlck5hbWUsIGdldFVzZXJQcmVzZW5jZSB9IGZyb20gJy4uL3V0aWxzL21hdHJpeCc7XG5pbXBvcnQgeyBMcnVDYWNoZSB9IGZyb20gJy4uL3V0aWxzL2xydSc7XG5pbXBvcnQgeyBwbHVja0Rpc3RpbmN0IH0gZnJvbSAnLi4vdXRpbHMvcngnO1xuaW1wb3J0IHsgbWF0cml4Um9vbSwgbWF0cml4Um9vbUxlYXZlLCBtYXRyaXhTZXR1cCwgbWF0cml4UHJlc2VuY2UsIHJ0Y0NoYW5uZWwgfSBmcm9tICcuL2FjdGlvbnMnO1xuLy8gdW5hdmFpbGFibGUganVzdCBtZWFucyB0aGUgdXNlciBkaWRuJ3QgZG8gYW55dGhpbmcgb3ZlciBhIGNlcnRhaW4gYW1vdW50IG9mIHRpbWUsIGJ1dCB0aGV5J3JlXG4vLyBzdGlsbCB0aGVyZSwgc28gd2UgY29uc2lkZXIgdGhlIHVzZXIgYXMgYXZhaWxhYmxlL29ubGluZSB0aGVuXG5jb25zdCBBVkFJTEFCTEUgPSBbJ29ubGluZScsICd1bmF2YWlsYWJsZSddO1xuY29uc3QgdXNlclJlID0gL15AKDB4WzAtOWEtZl17NDB9KVsuOl0vaTtcbmNvbnN0IERFVklDRV9JRCA9ICdSQUlERU4nO1xuLyoqXG4gKiBSZXR1cm4gdGhlIGFycmF5IG9mIGNvbmZpZ3VyZWQgZ2xvYmFsIHJvb21zXG4gKlxuICogQHBhcmFtIGNvbmZpZyAtIG9iamVjdCB0byBnYXRoZXIgdGhlIGxpc3QgZnJvbVxuICogQHJldHVybnMgQXJyYXkgb2Ygcm9vbSBuYW1lc1xuICovXG5mdW5jdGlvbiBnbG9iYWxSb29tTmFtZXMoY29uZmlnKSB7XG4gICAgcmV0dXJuIFtjb25maWcuZGlzY292ZXJ5Um9vbSwgY29uZmlnLnBmc1Jvb21dLmZpbHRlcihpc250TmlsKTtcbn1cbi8qKlxuICogQ3VycmllZCBmdW5jdGlvbiAoYXJpdHk9Mikgd2hpY2ggbWF0Y2hlcyByb29tIHBhc3NlZCBhcyBzZWNvbmQgYXJndW1lbnQgYmFzZWQgb24gcm9vbUlkLCBuYW1lIG9yXG4gKiBhbGlhcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnRcbiAqXG4gKiBAcGFyYW0gcm9vbUlkT3JBbGlhcyAtIFJvb20gSWQsIG5hbWUsIGNhbm9uaWNhbCBvciBub3JtYWwgYWxpYXMgZm9yIHJvb21cbiAqIEBwYXJhbSByb29tIC0gUm9vbSB0byB0ZXN0XG4gKiBAcmV0dXJucyBUcnVlIGlmIHJvb20gbWF0Y2hlcyB0ZXJtLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuY29uc3Qgcm9vbU1hdGNoID0gY3VycnkoKHJvb21JZE9yQWxpYXMsIHJvb20pID0+IHJvb21JZE9yQWxpYXMgPT09IHJvb20ucm9vbUlkIHx8XG4gICAgcm9vbUlkT3JBbGlhcyA9PT0gcm9vbS5uYW1lIHx8XG4gICAgcm9vbUlkT3JBbGlhcyA9PT0gcm9vbS5nZXRDYW5vbmljYWxBbGlhcygpIHx8XG4gICAgcm9vbS5nZXRBbGlhc2VzKCkuaW5jbHVkZXMocm9vbUlkT3JBbGlhcykpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgdG8gYSAocG9zc2libHkgcGVuZGluZykgcm9vbSBtYXRjaGluZyByb29tSWQgb3Igc29tZSBhbGlhc1xuICogVGhpcyBtZXRob2QgZG9lc24ndCB0cnkgdG8gam9pbiB0aGUgcm9vbSwganVzdCB3YWl0IGZvciBpdCB0byBzaG93IHVwIGluIE1hdHJpeENsaWVudC5cbiAqXG4gKiBAcGFyYW0gbWF0cml4IC0gQ2xpZW50IGluc3RhbmNlIHRvIGZldGNoIHJvb20gaW5mbyBmcm9tXG4gKiBAcGFyYW0gcm9vbUlkT3JBbGlhcyAtIHJvb20gaWQgb3IgYWxpYXMgdG8gbG9vayBmb3JcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgdG8gcG9wdWxhdGVkIHJvb20gaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vbSQobWF0cml4LCByb29tSWRPckFsaWFzKSB7XG4gICAgbGV0IHJvb20gPSBtYXRyaXguZ2V0Um9vbShyb29tSWRPckFsaWFzKTtcbiAgICBpZiAoIXJvb20pXG4gICAgICAgIHJvb20gPSBtYXRyaXguZ2V0Um9vbXMoKS5maW5kKHJvb21NYXRjaChyb29tSWRPckFsaWFzKSk7XG4gICAgaWYgKHJvb20pXG4gICAgICAgIHJldHVybiBvZihyb29tKTtcbiAgICByZXR1cm4gZnJvbUV2ZW50KG1hdHJpeCwgJ1Jvb20nKS5waXBlKGZpbHRlcihyb29tTWF0Y2gocm9vbUlkT3JBbGlhcykpLCB0YWtlKDEpKTtcbn1cbi8qKlxuICogSm9pbnMgdGhlIGdsb2JhbCBicm9hZGNhc3Qgcm9vbXMgYW5kIHJldHVybnMgdGhlIHJvb20gaWRzLlxuICpcbiAqIEBwYXJhbSBjb25maWcgLSBUaGUge0BsaW5rIFJhaWRlbkNvbmZpZ30gcHJvdmlkZXMgdGhlIGJyb2FkY2FzdCByb29tIGFsaWFzZXMgZm9yIHBmcyBhbmQgZGlzY292ZXJ5LlxuICogQHBhcmFtIG1hdHJpeCAtIFRoZSB7QGxpbmsgTWF0cml4Q2xpZW50fSBpbnN0YW5jZSB1c2VkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyLlxuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB0aGUgbGlzdCBvZiByb29tIGlkcyBmb3IgdGhlIHRoZSBicm9hZGNhc3Qgcm9vbXMuXG4gKi9cbmZ1bmN0aW9uIGpvaW5HbG9iYWxSb29tcyhjb25maWcsIG1hdHJpeCkge1xuICAgIGNvbnN0IHNlcnZlck5hbWUgPSBnZXRTZXJ2ZXJOYW1lKG1hdHJpeC5nZXRIb21lc2VydmVyVXJsKCkpO1xuICAgIHJldHVybiBmcm9tKGdsb2JhbFJvb21OYW1lcyhjb25maWcpKS5waXBlKG1hcCgoZ2xvYmFsUm9vbSkgPT4gYCMke2dsb2JhbFJvb219OiR7c2VydmVyTmFtZX1gKSwgbWVyZ2VNYXAoKGFsaWFzKSA9PiBtYXRyaXguam9pblJvb20oYWxpYXMpLnRoZW4oKHJvb20pID0+IHtcbiAgICAgICAgLy8gc2V0IGFsaWFzIGluIHJvb20gc3RhdGUgZGlyZWN0bHlcbiAgICAgICAgLy8gdGhpcyB0cmljayBpcyBuZWVkZWQgYmVjYXVzZSBnbG9iYWwgcm9vbXMgYXJlbid0IHN5bmNlZFxuICAgICAgICByb29tLmN1cnJlbnRTdGF0ZS5zZXRTdGF0ZUV2ZW50cyhbXG4gICAgICAgICAgICBuZXcgTWF0cml4RXZlbnQoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdtLnJvb20uYWxpYXNlcycsXG4gICAgICAgICAgICAgICAgc3RhdGVfa2V5OiBzZXJ2ZXJOYW1lLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHsgYWxpYXNlczogW2FsaWFzXSB9LFxuICAgICAgICAgICAgICAgIGV2ZW50X2lkOiBgJGxvY2FsXyR7RGF0ZS5ub3coKX1gLFxuICAgICAgICAgICAgICAgIHJvb21faWQ6IHJvb20ucm9vbUlkLFxuICAgICAgICAgICAgICAgIHNlbmRlcjogbWF0cml4LmdldFVzZXJJZCgpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF0pO1xuICAgICAgICBtYXRyaXguc3RvcmUuc3RvcmVSb29tKHJvb20pO1xuICAgICAgICByZXR1cm4gcm9vbTtcbiAgICB9KSksIHBsdWNrKCdyb29tSWQnKSwgdG9BcnJheSgpKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG1hdHJpeCBmaWx0ZXIuIFRoZSBmaWx0ZXIgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgaW5pdGlhbCBzeW5jIGJ5XG4gKiBmaWx0ZXJpbmcgb3V0IGJyb2FkY2FzdCByb29tcywgZW1waGVtZXJhbCBtZXNzYWdlcyBsaWtlIHJlY2VpcHRzIGV0Yy5cbiAqXG4gKiBAcGFyYW0gbWF0cml4IC0gVGhlIHtAbGluayBNYXRyaXhDbGllbnR9IGluc3RhbmNlIHVzZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIuXG4gKiBAcGFyYW0gcm9vbUlkcyAtIFRoZSBpZHMgb2YgdGhlIHJvb21zIHRvIGZpbHRlciBvdXQgZHVyaW5nIHN5bmMuXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIHRoZSB7QGxpbmsgRmlsdGVyfSB0aGF0IHdhcyBjcmVhdGVkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXIobWF0cml4LCByb29tSWRzKSB7XG4gICAgcmV0dXJuIGRlZmVyKCgpID0+IHtcbiAgICAgICAgY29uc3Qgcm9vbUZpbHRlciA9IHtcbiAgICAgICAgICAgIG5vdF9yb29tczogcm9vbUlkcyxcbiAgICAgICAgICAgIGVwaGVtZXJhbDoge1xuICAgICAgICAgICAgICAgIG5vdF90eXBlczogWydtLnJlY2VpcHQnLCAnbS50eXBpbmcnXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aW1lbGluZToge1xuICAgICAgICAgICAgICAgIGxpbWl0OiAwLFxuICAgICAgICAgICAgICAgIG5vdF9zZW5kZXJzOiBbbWF0cml4LmdldFVzZXJJZCgpXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpbHRlckRlZmluaXRpb24gPSB7XG4gICAgICAgICAgICByb29tOiByb29tRmlsdGVyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWF0cml4LmNyZWF0ZUZpbHRlcihmaWx0ZXJEZWZpbml0aW9uKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHN0YXJ0TWF0cml4U3luYyhhY3Rpb24kLCBtYXRyaXgsIG1hdHJpeCQsIGNvbmZpZyQpIHtcbiAgICByZXR1cm4gYWN0aW9uJC5waXBlKGZpbHRlcihtYXRyaXhTZXR1cC5pcyksIHRha2UoMSksIHRhcCgoKSA9PiB7XG4gICAgICAgIG1hdHJpeCQubmV4dChtYXRyaXgpO1xuICAgICAgICBtYXRyaXgkLmNvbXBsZXRlKCk7XG4gICAgfSksIGRlbGF5KDFlMyksIC8vIHdhaXQgMXMgYmVmb3JlIHN0YXJ0aW5nIG1hdHJpeCwgc28gZXZlbnQgbGlzdGVuZXJzIGNhbiBiZSByZWdpc3RlcmVkXG4gICAgd2l0aExhdGVzdEZyb20oY29uZmlnJCksIG1lcmdlTWFwKChbLCBjb25maWddKSA9PiBqb2luR2xvYmFsUm9vbXMoY29uZmlnLCBtYXRyaXgpLnBpcGUobWVyZ2VNYXAoKHJvb21JZHMpID0+IGNyZWF0ZUZpbHRlcihtYXRyaXgsIHJvb21JZHMpKSwgbWVyZ2VNYXAoKGZpbHRlcikgPT4gbWF0cml4LnN0YXJ0Q2xpZW50KHsgZmlsdGVyIH0pKSkpLCBpZ25vcmVFbGVtZW50cygpKTtcbn1cbi8qKlxuICogU2VhcmNoIHVzZXIgZGlyZWN0b3J5IGZvciB2YWxpZCB1c2VycyBtYXRjaGluZyBhIGdpdmVuIGFkZHJlc3MgYW5kIHJldHVybiBsYXRlc3RcbiAqXG4gKiBAcGFyYW0gbWF0cml4IC0gTWF0cml4IGNsaWVudCB0byBzZWFyY2ggdXNlcnMgZnJvbVxuICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIG9mIGludGVyZXN0XG4gKiBAcGFyYW0gbG9nIC0gTG9nZ2VyIG9iamVjdFxuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB1c2VyIHdpdGggbW9zdCByZWNlbnQgcHJlc2VuY2VcbiAqL1xuZnVuY3Rpb24gc2VhcmNoQWRkcmVzc1ByZXNlbmNlJChtYXRyaXgsIGFkZHJlc3MsIHsgbG9nIH0pIHtcbiAgICByZXR1cm4gZGVmZXIoKCkgPT4gXG4gICAgLy8gc2VhcmNoIGZvciBhbnkgdXNlciBjb250YWluaW5nIHRoZSBhZGRyZXNzIG9mIGludGVyZXN0IGluIGl0cyB1c2VySWRcbiAgICBtYXRyaXguc2VhcmNoVXNlckRpcmVjdG9yeSh7IHRlcm06IGFkZHJlc3MudG9Mb3dlckNhc2UoKSB9KSkucGlwZShcbiAgICAvLyBmb3IgZXZlcnkgcmVzdWx0IG1hdGNoZXMsIHZlcmlmeSBkaXNwbGF5TmFtZSBzaWduYXR1cmUgaXMgYWRkcmVzcyBvZiBpbnRlcmVzdFxuICAgIG1lcmdlTWFwKGZ1bmN0aW9uKiAoeyByZXN1bHRzIH0pIHtcbiAgICAgICAgZm9yIChjb25zdCB1c2VyIG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmICghdXNlci5kaXNwbGF5X25hbWUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdXNlclJlLmV4ZWModXNlci51c2VyX2lkKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoIHx8IGdldEFkZHJlc3MobWF0Y2hbMV0pICE9PSBhZGRyZXNzKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNvdmVyZWQgPSB2ZXJpZnlNZXNzYWdlKHVzZXIudXNlcl9pZCwgdXNlci5kaXNwbGF5X25hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghcmVjb3ZlcmVkIHx8IHJlY292ZXJlZCAhPT0gYWRkcmVzcylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB1c2VyO1xuICAgICAgICB9XG4gICAgfSksIG1lcmdlTWFwKCh1c2VyKSA9PiBnZXRVc2VyUHJlc2VuY2UobWF0cml4LCB1c2VyLnVzZXJfaWQpXG4gICAgICAgIC50aGVuKChwcmVzZW5jZSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJlc2VuY2UpLCB1c2VyKSkpXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiAobG9nLmluZm8oJ0Vycm9yIGZldGNoaW5nIHVzZXIgcHJlc2VuY2UsIGlnbm9yaW5nOicsIGVyciksIHVuZGVmaW5lZCkpKSwgZmlsdGVyKGlzbnROaWwpLCB0b0FycmF5KCksIFxuICAgIC8vIGZvciBhbGwgbWF0Y2hlZC92ZXJpZmllZCB1c2VycywgZ2V0IGl0cyBwcmVzZW5jZSB0aHJvdWdoIGRlZGljYXRlZCBBUElcbiAgICAvLyBpdCdzIHJlcXVpcmVkIGJlY2F1c2UsIGFzIHRoZSB1c2VyIGV2ZW50cyBjb3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBoYW5kbGVkXG4gICAgLy8gYW5kIGZpbHRlcmVkIG91dCBieSBtYXRyaXhQcmVzZW5jZVVwZGF0ZUVwaWMgYmVjYXVzZSBpdCB3YXNuJ3QgeWV0IGFcbiAgICAvLyB1c2VyLW9mLWludGVyZXN0LCB3ZSBjb3VsZCBoYXZlIG1pc3NlZCBwcmVzZW5jZSB1cGRhdGVzLCB0aGVuIHdlIG5lZWQgdG9cbiAgICAvLyBmZXRjaCBpdCBoZXJlIGRpcmVjdGx5LCBhbmQgZnJvbSBub3cgb24sIHRoYXQgb3RoZXIgZXBpYyB3aWxsIG1vbml0b3IgaXRzXG4gICAgLy8gdXBkYXRlcywgYW5kIHNvcnQgYnkgbW9zdCByZWNlbnRseSBzZWVuIHVzZXJcbiAgICBtYXAoKHByZXNlbmNlcykgPT4ge1xuICAgICAgICBpZiAoIXByZXNlbmNlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFpZGVuRXJyb3IoRXJyb3JDb2Rlcy5UUk5TX05PX1ZBTElEX1VTRVIsIHsgYWRkcmVzcyB9KTtcbiAgICAgICAgcmV0dXJuIG1pbkJ5KHByZXNlbmNlcywgJ2xhc3RfYWN0aXZlX2FnbycpO1xuICAgIH0pKTtcbn1cbi8qKlxuICogUGFyc2UgYSBjYXBzIHN0cmluZyBpbiB0aGUgZm9ybWF0ICdrMSxrMj12MixrMz1cInYzXCInIHRvIHsgazE6IHRydWUsIGsyOiB2MiwgazM6IHYzIH0gb2JqZWN0XG4gKlxuICogQHBhcmFtIGNhcHMgLSBjYXBzIHN0cmluZ1xuICogQHJldHVybnMgQ2FwcyBtYXBwaW5nIG9iamVjdFxuICovXG5mdW5jdGlvbiBwYXJzZUNhcHMoY2Fwcykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWNhcHMpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICB0cnkge1xuICAgICAgICAvLyB0aGlzIHJlZ2V4IHNwbGl0cyBieSBjb21tYSwgYnV0IHJlc3BlY3Rpbmcgc3RyaW5ncyBpbnNpZGUgZG91YmxlLXF1b3Rlc1xuICAgICAgICBmb3IgKGNvbnN0IGNhcCBvZiBjYXBzLnNwbGl0KC8sKD89KD86W15cXFwiXSpcXFwiW15cXFwiXSpcXFwiKSpbXlxcXCJdKiQpL2cpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IGNhcC5tYXRjaCgvXlxccyooW149XSspKD86ID89ID9cIj8oLio/KVwiP1xccyopPyQvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICByZXN1bHRbbWF0Y2hbMV1dID0gKF9hID0gbWF0Y2hbMl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikgeyB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlDYXBzKGNhcHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoY2FwcylcbiAgICAgICAgLmZpbHRlcigoWywgdl0pID0+IHR5cGVvZiB2ICE9PSAnYm9vbGVhbicgfHwgdilcbiAgICAgICAgLm1hcCgoW2ssIHZdKSA9PiAodHlwZW9mIHYgPT09ICdib29sZWFuJyA/IGsgOiBgJHtrfT1cIiR7dn1cImApKVxuICAgICAgICAuam9pbignLCcpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIG9ic2VydmFibGUgd2hpY2gga2VlcHMgaW52aXRpbmcgdXNlcklkIHRvIHJvb21JZCB3aGlsZSB1c2VyIGRvZXNuJ3Qgam9pblxuICpcbiAqIElmIHVzZXIgYWxyZWFkeSBqb2luZWQsIGNvbXBsZXRlcyBpbW1lZGlhdGVsbHkuXG4gKlxuICogQHBhcmFtIG1hdHJpeCAtIGNsaWVudCBpbnN0YW5jZVxuICogQHBhcmFtIHJvb21JZCAtIHJvb20gdG8gaW52aXRlIHVzZXIgdG9cbiAqIEBwYXJhbSB1c2VySWQgLSB1c2VyIHRvIGJlIGludml0ZWRcbiAqIEBwYXJhbSBjb25maWckIC0gT2JzZXJ2YWJsZSBvZiBjb25maWcgb2JqZWN0IGNvbnRhaW5pbmcgaHR0cFRpbWVvdXQgdXNlZCBhcyBpdGVyYXRpb24gZGVsYXlcbiAqIEByZXR1cm5zIENvbGQgb2JzZXJ2YWJsZSB3aGljaCBrZWVwIGludml0aW5nIHVzZXIgaWYgbmVlZGVkIGFuZCB0aGVuIGNvbXBsZXRlcy5cbiAqL1xuZnVuY3Rpb24gaW52aXRlTG9vcCQobWF0cml4LCByb29tSWQsIHVzZXJJZCwgY29uZmlnJCwgeyBsb2cgfSkge1xuICAgIHJldHVybiBkZWZlcigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvb20gPSBtYXRyaXguZ2V0Um9vbShyb29tSWQpO1xuICAgICAgICByZXR1cm4gcm9vbVxuICAgICAgICAgICAgPyAvLyB1c2Ugcm9vbSBhbHJlYWR5IHByZXNlbnQgaW4gbWF0cml4IGluc3RhbmNlXG4gICAgICAgICAgICAgICAgb2Yocm9vbSlcbiAgICAgICAgICAgIDogLy8gd2FpdCBmb3Igcm9vbVxuICAgICAgICAgICAgICAgIGZyb21FdmVudChtYXRyaXgsICdSb29tJykucGlwZShmaWx0ZXIoKHJvb20pID0+IHJvb20ucm9vbUlkID09PSByb29tSWQpLCB0YWtlKDEpKTtcbiAgICB9KS5waXBlKFxuICAgIC8vIHN0b3AgaWYgdXNlciBhbHJlYWR5IGEgcm9vbSBtZW1iZXJcbiAgICBmaWx0ZXIoKHJvb20pID0+IHtcbiAgICAgICAgY29uc3QgbWVtYmVyID0gcm9vbS5nZXRNZW1iZXIodXNlcklkKTtcbiAgICAgICAgcmV0dXJuICFtZW1iZXIgfHwgbWVtYmVyLm1lbWJlcnNoaXAgIT09ICdqb2luJztcbiAgICB9KSwgd2l0aExhdGVzdEZyb20oY29uZmlnJCksIG1lcmdlTWFwKChbLCB7IGh0dHBUaW1lb3V0IH1dKSA9PiBcbiAgICAvLyBkZWZlciBoZXJlIGVuc3VyZXMgaW52aXRlIGlzIHJlLWRvbmUgb24gcmVwZWF0IChyZS1zdWJzY3JpcHRpb24pXG4gICAgZGVmZXIoKCkgPT4gbWF0cml4Lmludml0ZShyb29tSWQsIHVzZXJJZCkuY2F0Y2gobG9nLndhcm4uYmluZChsb2csICdFcnJvciBpbnZpdGluZycpKSkucGlwZShcbiAgICAvLyB3aGlsZSBzaG91bGRuJ3Qgc3RvcCAoYnkgdW5zdWJzY3JpYmUgb3IgdGFrZVVudGlsKVxuICAgIHJlcGVhdFdoZW4oKGNvbXBsZXRlZCQpID0+IGNvbXBsZXRlZCQucGlwZShkZWxheShodHRwVGltZW91dCkpKSwgdGFrZVVudGlsKFxuICAgIC8vIHN0b3AgcmVwZWF0K2RlZmVyIGxvb3AgYWJvdmUgd2hlbiB1c2VyIGpvaW5zXG4gICAgZnJvbUV2ZW50KG1hdHJpeCwgJ1Jvb21NZW1iZXIubWVtYmVyc2hpcCcsICh7fSwgbWVtYmVyKSA9PiBtZW1iZXIpLnBpcGUoZmlsdGVyKChtZW1iZXIpID0+IG1lbWJlci5yb29tSWQgPT09IHJvb21JZCAmJlxuICAgICAgICBtZW1iZXIudXNlcklkID09PSB1c2VySWQgJiZcbiAgICAgICAgbWVtYmVyLm1lbWJlcnNoaXAgPT09ICdqb2luJykpKSkpKTtcbn1cbi8qKlxuICogRnJvbSBhIHlhbWwgbGlzdCBzdHJpbmcsIHJldHVybiBhcyBBcnJheVxuICogRS5nLiB5YW1sTGlzdFRvQXJyYXkoYFxuICogIyBjb21tZW50XG4gKiAgIC0gdGVzdDFcbiAqICAgLSB0ZXN0MlxuICogICAtIHRlc3QzXG4gKiBgKSA9PT0gWyd0ZXN0MScsICd0ZXN0MicsICd0ZXN0MyddXG4gKlxuICogQHBhcmFtIHltbCAtIFN0cmluZyBjb250YWluaW5nIG9ubHkgWUFNTCBsaXN0XG4gKiBAcmV0dXJucyBMaXN0IG9mIHN0cmluZ3MgaW5zaWRlIHltbC1lbmNvZGVkIHRleHRcbiAqL1xuZnVuY3Rpb24geWFtbExpc3RUb0FycmF5KHltbCkge1xuICAgIC8vIG1hdGNoIGFsbCBzdHJpbmdzIHN0YXJ0aW5nIHdpdGggb3B0aW9uYWwgc3BhY2VzIGZvbGxvd2VkIGJ5IGEgZGFzaCArIHNwYWNlXG4gICAgLy8gY2FwdHVyaW5nIG9ubHkgdGhlIGNvbnRlbnQgb2YgdGhlIGxpc3QgaXRlbSwgdHJpbW1pbmcgc3BhY2VzXG4gICAgY29uc3QgcmVnID0gL15cXHMqLVxccyooLis/KVxccyokL2dtO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgd2hpbGUgKChtYXRjaCA9IHJlZy5leGVjKHltbCkpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChtYXRjaFsxXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuLyoqXG4gKiBHaXZlbiBhIHNlcnZlciBuYW1lIChzY2hlbWEgZGVmYXVsdHMgdG8gaHR0cHM6Ly8gYW5kIGlzIHByZXBlbmRlZCBpZiBtaXNzaW5nKSwgcmV0dXJucyBIVFRQIEdFVFxuICogcm91bmQgdHJpcCB0aW1lICh0aW1lIHRvIHJlc3BvbnNlKVxuICpcbiAqIEBwYXJhbSBzZXJ2ZXIgLSBTZXJ2ZXIgbmFtZSB3aXRoIG9yIHdpdGhvdXQgc2NoZW1hXG4gKiBAcGFyYW0gaHR0cFRpbWVvdXQgLSBPcHRpb25hbCB0aW1lb3V0IGZvciB0aGUgSFRUUCByZXF1ZXN0XG4gKiBAcmV0dXJucyBQcm9taXNlIHRvIGEgeyBzZXJ2ZXIsIHJ0dCB9IG9iamVjdCwgd2hlcmUgYHJ0dGAgbWF5IGJlIE5hTlxuICovXG5mdW5jdGlvbiBtYXRyaXhSVFQkKHNlcnZlciwgaHR0cFRpbWVvdXQpIHtcbiAgICBpZiAoIXNlcnZlci5pbmNsdWRlcygnOi8vJykpXG4gICAgICAgIHNlcnZlciA9ICdodHRwczovLycgKyBzZXJ2ZXI7XG4gICAgcmV0dXJuIGRlZmVyKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gZnJvbUZldGNoKHNlcnZlciArICcvX21hdHJpeC9jbGllbnQvdmVyc2lvbnMnKS5waXBlKHRpbWVvdXQoaHR0cFRpbWVvdXQpLCBtYXAoKHsgb2sgfSkgPT4gKG9rID8gRGF0ZS5ub3coKSA6IE5hTikpLCBjYXRjaEVycm9yKCgpID0+IG9mKE5hTikpLCBtYXAoKGVuZCkgPT4gKHsgc2VydmVyLCBydHQ6IGVuZCAtIHN0YXJ0IH0pKSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSBvZiBzZXJ2ZXJzLCBzb3J0ZWQgYnkgcmVzcG9uc2UgdGltZVxuICpcbiAqIEBwYXJhbSBtYXRyaXhTZXJ2ZXJMb29rdXAgLSBVUkwgY29udGFpbmluZyBhbiBZQU1MIGxpc3Qgb2Ygc2VydmVycyB1cmxcbiAqIEBwYXJhbSBodHRwVGltZW91dCAtIGh0dHBUaW1lb3V0IHRvIGxpbWl0IHF1ZXJpZXNcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgeyBzZXJ2ZXIsIHJ0dCB9IG9iamVjdHMsIGVtaXR0ZWQgaW4gaW5jcmVhc2luZyBydHQgb3JkZXJcbiAqL1xuZnVuY3Rpb24gZmV0Y2hTb3J0ZWRNYXRyaXhTZXJ2ZXJzJChtYXRyaXhTZXJ2ZXJMb29rdXAsIGh0dHBUaW1lb3V0KSB7XG4gICAgcmV0dXJuIGZyb21GZXRjaChtYXRyaXhTZXJ2ZXJMb29rdXApLnBpcGUobWVyZ2VNYXAoKHJlc3BvbnNlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGFzc2VydChyZXNwb25zZS5vaywgYENvdWxkIG5vdCBmZXRjaCBzZXJ2ZXIgbGlzdCBmcm9tIFwiJHttYXRyaXhTZXJ2ZXJMb29rdXB9XCIgPT4gJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgfSkpLCB0aW1lb3V0KGh0dHBUaW1lb3V0KSwgbWVyZ2VNYXAoKHRleHQpID0+IHlhbWxMaXN0VG9BcnJheSh0ZXh0KSksIG1lcmdlTWFwKChzZXJ2ZXIpID0+IG1hdHJpeFJUVCQoc2VydmVyLCBodHRwVGltZW91dCkpLCB0b0FycmF5KCksIG1lcmdlTWFwKChydHRzKSA9PiBzb3J0QnkocnR0cywgWydydHQnXSkpLCBmaWx0ZXIoKHsgcnR0IH0pID0+ICFpc05hTihydHQpKSwgdGhyb3dJZkVtcHR5KCgpID0+IG5ldyBSYWlkZW5FcnJvcihFcnJvckNvZGVzLlRSTlNfTk9fTUFUUklYX1NFUlZFUlMpKSk7XG59XG4vKipcbiAqIFZhbGlkYXRlIGFuZCBzZXR1cCBhIE1hdHJpeENsaWVudCBjb25uZWN0ZWQgdG8gc2VydmVyLCBwb3NzaWJseSB1c2luZyBwcmV2aW91cyAnc2V0dXAnIGRhdGFcbiAqIE1heSBlcnJvciBpZiBhbnl0aGluZyBnb2VzIHdyb25nLlxuICpcbiAqIEBwYXJhbSBzZXJ2ZXIgLSBzZXJ2ZXIgVVJMLCB3aXRoIHNjaGVtYVxuICogQHBhcmFtIHNldHVwIC0gb3B0aW9uYWwgcHJldmlvdXMgc2V0dXAvY3JlZGVudGlhbHMgZGF0YVxuICogQHBhcmFtIGRlcHMgLSBSYWlkZW5FcGljRGVwcy1saWtlL3BhcnRpYWwgb2JqZWN0XG4gKiBAcGFyYW0gZGVwcy5hZGRyZXNzIC0gT3VyIGFkZHJlc3MgKHRvIGNvbXBvc2UgbWF0cml4IHVzZXIpXG4gKiBAcGFyYW0gZGVwcy5zaWduZXIgLSBTaWduZXIgdG8gYmUgdXNlZCB0byBzaWduIHBhc3N3b3JkIGFuZCBkaXNwbGF5TmFtZVxuICogQHBhcmFtIGNhcHMgLSBUcmFuc3BvcnQgY2FwYWJpbGl0aWVzIHRvIHNldCBpbiB1c2VyJ3MgYXZhdGFyX3VybFxuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBvbmUgeyBtYXRyaXgsIHNlcnZlciwgc2V0dXAgfSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gc2V0dXBNYXRyaXhDbGllbnQkKHNlcnZlciwgc2V0dXAsIHsgYWRkcmVzcywgc2lnbmVyIH0sIGNhcHMpIHtcbiAgICBjb25zdCBzZXJ2ZXJOYW1lID0gZ2V0U2VydmVyTmFtZShzZXJ2ZXIpO1xuICAgIGlmICghc2VydmVyTmFtZSlcbiAgICAgICAgdGhyb3cgbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuVFJOU19OT19TRVJWRVJOQU1FLCB7IHNlcnZlciB9KTtcbiAgICByZXR1cm4gZGVmZXIoKCkgPT4ge1xuICAgICAgICBpZiAoc2V0dXApIHtcbiAgICAgICAgICAgIC8vIGlmIG1hdHJpeFNldHVwIHdhcyBhbHJlYWR5IGlzc3VlZCBiZWZvcmUsIGFuZCBjcmVkZW50aWFscyBhcmUgYWxyZWFkeSBpbiBzdGF0ZVxuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gY3JlYXRlQ2xpZW50KHtcbiAgICAgICAgICAgICAgICBiYXNlVXJsOiBzZXJ2ZXIsXG4gICAgICAgICAgICAgICAgdXNlcklkOiBzZXR1cC51c2VySWQsXG4gICAgICAgICAgICAgICAgYWNjZXNzVG9rZW46IHNldHVwLmFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgICAgIGRldmljZUlkOiBzZXR1cC5kZXZpY2VJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9mKHsgbWF0cml4LCBzZXJ2ZXIsIHNldHVwIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF0cml4ID0gY3JlYXRlQ2xpZW50KHsgYmFzZVVybDogc2VydmVyIH0pO1xuICAgICAgICAgICAgY29uc3QgdXNlck5hbWUgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCksIHVzZXJJZCA9IGBAJHt1c2VyTmFtZX06JHtzZXJ2ZXJOYW1lfWA7XG4gICAgICAgICAgICAvLyBjcmVhdGUgcGFzc3dvcmQgYXMgc2lnbmF0dXJlIG9mIHNlcnZlck5hbWUsIHRoZW4gdHJ5IGxvZ2luIG9yIHJlZ2lzdGVyXG4gICAgICAgICAgICByZXR1cm4gZnJvbShzaWduZXIuc2lnbk1lc3NhZ2Uoc2VydmVyTmFtZSkpLnBpcGUobWVyZ2VNYXAoKHBhc3N3b3JkKSA9PiBmcm9tKG1hdHJpeC5sb2dpbignbS5sb2dpbi5wYXNzd29yZCcsIHsgdXNlcjogdXNlck5hbWUsIHBhc3N3b3JkLCBkZXZpY2VfaWQ6IERFVklDRV9JRCB9KSkucGlwZShjYXRjaEVycm9yKCgpID0+IG1hdHJpeC5yZWdpc3Rlcih1c2VyTmFtZSwgcGFzc3dvcmQpKSkpLCBtZXJnZU1hcCgoeyBhY2Nlc3NfdG9rZW4sIGRldmljZV9pZCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gbWF0cml4LnJlZ2lzdGVyIGltcGxlbWVudGF0aW9uIGRvZXNuJ3Qgc2V0IHJldHVybmVkIGNyZWRlbnRpYWxzXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd291bGQgcmVxdWlyZSBhbiB1bm5lY2Vzc2FyeSBhZGRpdGlvbmFsIGxvZ2luIHJlcXVlc3QgaWYgd2UgZGlkbid0XG4gICAgICAgICAgICAgICAgLy8gc2V0IGl0IGhlcmUsIGFuZCBsb2dpbiBkb2Vzbid0IHNldCBkZXZpY2VJZCwgc28gd2Ugc2V0IGFsbCBjcmVkZW50aWFsXG4gICAgICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBhZ2FpbiBoZXJlIGFmdGVyIHN1Y2Nlc3NmdWwgbG9naW4gb3IgcmVnaXN0ZXJcbiAgICAgICAgICAgICAgICBtYXRyaXguZGV2aWNlSWQgPSBkZXZpY2VfaWQ7XG4gICAgICAgICAgICAgICAgbWF0cml4Ll9odHRwLm9wdHMuYWNjZXNzVG9rZW4gPSBhY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICAgICAgbWF0cml4LmNyZWRlbnRpYWxzID0geyB1c2VySWQgfTtcbiAgICAgICAgICAgICAgICAvLyBkaXNwbGF5TmFtZSBtdXN0IGJlIHNpZ25hdHVyZSBvZiBmdWxsIHVzZXJJZCBmb3Igb3VyIG1lc3NhZ2VzIHRvIGJlIGFjY2VwdGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb20oc2lnbmVyLnNpZ25NZXNzYWdlKHVzZXJJZCkpLnBpcGUobWFwKChzaWduZWRVc2VySWQpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLFxuICAgICAgICAgICAgICAgICAgICBzZXR1cDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW46IGFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZUlkOiBkZXZpY2VfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogc2lnbmVkVXNlcklkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9KS5waXBlKFxuICAgIC8vIHRoZSBBUElzIGJlbG93IGFyZSBhdXRoZW50aWNhdGVkLCBhbmQgdGhlcmVmb3JlIGFsc28gYWN0IGFzIHZhbGlkYXRvclxuICAgIG1lcmdlTWFwKCh7IG1hdHJpeCwgc2VydmVyLCBzZXR1cCB9KSA9PiBcbiAgICAvLyBlbnN1cmUgZGlzcGxheU5hbWUgaXMgc2V0IGV2ZW4gb24gcmVzdGFydHNcbiAgICBtZXJnZShmcm9tKG1hdHJpeC5zZXREaXNwbGF5TmFtZShzZXR1cC5kaXNwbGF5TmFtZSkpLCBmcm9tKG1hdHJpeC5zZXRQcmVzZW5jZSh7IHByZXNlbmNlOiAnb25saW5lJywgc3RhdHVzX21zZzogJycgfSkpLCBjYXBzID8gZnJvbShtYXRyaXguc2V0QXZhdGFyVXJsKHN0cmluZ2lmeUNhcHMoY2FwcykpKSA6IEVNUFRZKS5waXBlKG1hcFRvKHsgbWF0cml4LCBzZXJ2ZXIsIHNldHVwIH0pKSkpO1xufVxuLyoqXG4gKiBJbml0aWFsaXplIG1hdHJpeCB0cmFuc3BvcnRcbiAqIFRoZSBtYXRyaXggY2xpZW50IGluc3RhbmNlIHdpbGwgYmUgb3V0cHV0ZWQgdG8gUmFpZGVuRXBpY0RlcHMubWF0cml4JCBBc3luY1N1YmplY3RcbiAqIFRoZSBzZXR1cCBpbmZvIChpbmNsdWRpbmcgY3JlZGVudGlhbHMsIGZvciBwZXJzaXN0ZW5jZSkgd2lsbCBiZSB0aGUgbWF0cml4U2V0dXAgb3V0cHV0IGFjdGlvblxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5BY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEBwYXJhbSBhZGRyZXNzLG5ldHdvcmssc2lnbmVyLG1hdHJpeCQgLSBSYWlkZW5FcGljRGVwcyBtZW1iZXJzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIG1hdHJpeFNldHVwIGdlbmVyYXRlZCBieSBpbml0aWFsaXppbmcgbWF0cml4IGNsaWVudFxuICovXG5leHBvcnQgY29uc3QgaW5pdE1hdHJpeEVwaWMgPSAoYWN0aW9uJCwge30sIHsgYWRkcmVzcywgc2lnbmVyLCBtYXRyaXgkLCBsYXRlc3QkLCBjb25maWckIH0pID0+IGNvbWJpbmVMYXRlc3QoW2xhdGVzdCQucGlwZShwbHVjaygnc3RhdGUnKSksIGNvbmZpZyRdKS5waXBlKGZpcnN0KCksIC8vIGF0IHN0YXJ0dXBcbm1lcmdlTWFwKChbc3RhdGUsIHsgbWF0cml4U2VydmVyLCBtYXRyaXhTZXJ2ZXJMb29rdXAsIGh0dHBUaW1lb3V0LCBjYXBzIH1dKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBzZXJ2ZXIgPSAoX2EgPSBzdGF0ZS50cmFuc3BvcnQubWF0cml4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VydmVyLCBzZXR1cCA9IChfYiA9IHN0YXRlLnRyYW5zcG9ydC5tYXRyaXgpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXR1cDtcbiAgICBjb25zdCBzZXJ2ZXJzJEFycmF5ID0gW107XG4gICAgaWYgKG1hdHJpeFNlcnZlcikge1xuICAgICAgICAvLyBpZiBjb25maWcubWF0cml4U2VydmVyIGlzIHNldCwgd2UgbXVzdCB1c2UgaXQgKHBvc3NpYmx5IHJlLXVzaW5nIHN0b3JlZCBjcmVkZW50aWFscyxcbiAgICAgICAgLy8gaWYgbWF0Y2hpbmcpLCBub3QgZmV0Y2ggZnJvbSBsb29rdXAgYWRkcmVzc1xuICAgICAgICBpZiAobWF0cml4U2VydmVyID09PSBzZXJ2ZXIpXG4gICAgICAgICAgICBzZXJ2ZXJzJEFycmF5LnB1c2gob2YoeyBzZXJ2ZXIsIHNldHVwIH0pKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc2VydmVycyRBcnJheS5wdXNoKG9mKHsgc2VydmVyOiBtYXRyaXhTZXJ2ZXIgfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gcHJldmlvdXNseSB1c2VkIHNlcnZlclxuICAgICAgICBpZiAoc2VydmVyKVxuICAgICAgICAgICAgc2VydmVycyRBcnJheS5wdXNoKG9mKHsgc2VydmVyLCBzZXR1cCB9KSk7XG4gICAgICAgIC8vIGZldGNoZWQgc2VydmVycyBsaXN0XG4gICAgICAgIC8vIG5vdGljZSBpdCBtYXkgaW5jbHVkZSBzdG9yZWQgc2VydmVyIGFnYWluLCBidXQgbm8gc3RvcmVkIHNldHVwLCB3aGljaCBjb3VsZCBiZSB0aGVcbiAgICAgICAgLy8gY2F1c2Ugb2YgdGhlICBmaXJzdCBmYWlsdXJlLCBzbyB3ZSBhbGxvdyBpdCB0byB0cnkgYWdhaW4gKG5vdCBuZWNlc3NhcmlseSBmaXJzdClcbiAgICAgICAgc2VydmVycyRBcnJheS5wdXNoKGZldGNoU29ydGVkTWF0cml4U2VydmVycyQobWF0cml4U2VydmVyTG9va3VwLCBodHRwVGltZW91dCkpO1xuICAgIH1cbiAgICBsZXQgbGFzdEVycm9yO1xuICAgIGNvbnN0IGFuZFN1cHByZXNzID0gKGVycikgPT4gKChsYXN0RXJyb3IgPSBlcnIpLCBFTVBUWSk7XG4gICAgLy8gb24gW3JlLV1zdWJzY3JpcHRpb24gKGRlZmVyKSwgcG9wcyBuZXh0IG9ic2VydmFibGUgYW5kIHN1YnNjcmliZSB0byBpdFxuICAgIHJldHVybiBkZWZlcigoKSA9PiBzZXJ2ZXJzJEFycmF5LnNoaWZ0KCkgfHwgRU1QVFkpLnBpcGUoY2F0Y2hFcnJvcihhbmRTdXBwcmVzcyksIC8vIHNlcnZlcnMkIG1heSBlcnJvciwgc28gc3RvcmUgbGFzdEVycm9yXG4gICAgY29uY2F0TWFwKCh7IHNlcnZlciwgc2V0dXAgfSkgPT4gXG4gICAgLy8gc2VyaWFsbHksIHRyeSBzZXR0aW5nIHVwIGNsaWVudCBhbmQgdmFsaWRhdGUgaXRzIGNyZWRlbnRpYWxcbiAgICBzZXR1cE1hdHJpeENsaWVudCQoc2VydmVyLCBzZXR1cCwgeyBhZGRyZXNzLCBzaWduZXIgfSwgY2FwcykucGlwZShcbiAgICAvLyBzdG9yZSBhbmQgc3VwcHJlc3MgYW55ICdzZXR1cE1hdHJpeENsaWVudCQnIGVycm9yXG4gICAgY2F0Y2hFcnJvcihhbmRTdXBwcmVzcykpKSwgXG4gICAgLy8gb24gZmlyc3Qgc2V0dXBNYXRyaXhDbGllbnQkJ3Mgc3VjY2VzcywgZW1pdCwgY29tcGxldGUgYW5kIHVuc3Vic2NyaWJlXG4gICAgZmlyc3QoKSwgdGFwKCh7IG1hdHJpeCB9KSA9PiBtYXRyaXguc2V0TWF4TGlzdGVuZXJzKDMwKSksIFxuICAgIC8vIHdpdGggZXJyb3JzIHN1cHByZXNzZWQsIG9ubHkgcG9zc2libGUgZXJyb3IgaGVyZSBpcyAnbm8gZWxlbWVudCBpbiBzZXF1ZW5jZSdcbiAgICByZXRyeVdoZW4oKGVyciQpID0+IFxuICAgIC8vIGlmIHRoZXJlJ3JlIG1vcmUgc2VydmVycyQgb2JzZXJ2YWJsZXMgaW4gcXVldWUsIGVtaXQgb25jZSB0byByZXRyeSBmcm9tIGRlZmVyO1xuICAgIC8vIGVsc2UsIGVycm9ycyBvdXRwdXQgd2l0aCBsYXN0RXJyb3IgdG8gdW5zdWJzY3JpYmVcbiAgICBlcnIkLnBpcGUobWVyZ2VNYXAoKCkgPT4gKHNlcnZlcnMkQXJyYXkubGVuZ3RoID8gb2YobnVsbCkgOiB0aHJvd0Vycm9yKGxhc3RFcnJvcikpKSkpKTtcbn0pLCBcbi8vIG9uIHN1Y2Nlc3Ncbm1lcmdlTWFwKCh7IG1hdHJpeCwgc2VydmVyLCBzZXR1cCB9KSA9PiBtZXJnZShcbi8vIHdhaXQgZm9yIG1hdHJpeFNldHVwIHRocm91Z2ggcmVkdWNlciwgdGhlbiByZXNvbHZlcyBtYXRyaXgkIHdpdGggY2xpZW50IGFuZCBzdGFydHMgaXRcbnN0YXJ0TWF0cml4U3luYyhhY3Rpb24kLCBtYXRyaXgsIG1hdHJpeCQsIGNvbmZpZyQpLCBcbi8vIGVtaXQgbWF0cml4U2V0dXAgaW4gcGFyYWxsZWwgdG8gYmUgcGVyc2lzdGVkIGluIHN0YXRlXG5vZihtYXRyaXhTZXR1cCh7IHNlcnZlciwgc2V0dXAgfSkpLCBcbi8vIG1vbml0b3IgY29uZmlnLmxvZ2dlciAmIGRpc2FibGUgb3IgcmUtZW5hYmxlIG1hdHJpeCdzIGxvZ2dlciBhY2NvcmRpbmdseVxuY29uZmlnJC5waXBlKHBsdWNrRGlzdGluY3QoJ2xvZ2dlcicpLCB0YXAoKGxvZ2dlcikgPT4gbWF0cml4TG9nZ2VyLnNldExldmVsKGxvZ2dlciB8fCAnc2lsZW50JywgZmFsc2UpKSwgaWdub3JlRWxlbWVudHMoKSkpKSk7XG4vKipcbiAqIENhbGxzIG1hdHJpeC5zdG9wQ2xpZW50IHdoZW4gcmFpZGVuIGlzIHNodXR0aW5nIGRvd24sIGkuZS4gYWN0aW9uJCBjb21wbGV0ZXNcbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgbWF0cml4U2V0dXAgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gbWF0cml4JCAtIFJhaWRlbkVwaWNEZXBzIG1lbWJlcnNcbiAqIEByZXR1cm5zIEVtcHR5IG9ic2VydmFibGUgKHdob2xlIHNpZGUtZWZmZWN0IG9uIG1hdHJpeCBpbnN0YW5jZSlcbiAqL1xuZXhwb3J0IGNvbnN0IG1hdHJpeFNodXRkb3duRXBpYyA9IChhY3Rpb24kLCB7fSwgeyBtYXRyaXgkIH0pID0+IG1hdHJpeCQucGlwZShtZXJnZU1hcCgobWF0cml4KSA9PiBhY3Rpb24kLnBpcGUoZmluYWxpemUoKCkgPT4ge1xuICAgIG1hdHJpeC5zZXRQcmVzZW5jZSh7IHByZXNlbmNlOiAnb2ZmbGluZScsIHN0YXR1c19tc2c6ICcnIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgLyogc3RvcHBpbmcsIGlnbm9yZSBleGNlcHRpb25zICovXG4gICAgfSk7XG4gICAgbWF0cml4LnN0b3BDbGllbnQoKTtcbn0pKSksIGlnbm9yZUVsZW1lbnRzKCkpO1xuLyoqXG4gKiBIYW5kbGVzIE1hdHJpeFJlcXVlc3RNb25pdG9yUHJlc2VuY2VBY3Rpb24gYW5kIGVtaXRzIGEgTWF0cml4UHJlc2VuY2VVcGRhdGVBY3Rpb25cbiAqIElmIHByZXNlbmNlIGlzIGFscmVhZHkga25vd24sIGVtaXRzIGl0LCBlbHNlIGZldGNoIGZyb20gdXNlciBwcm9maWxlXG4gKiBFdmVuIGlmIHRoZSBwcmVzZW5jZSBzdGF5cyB0aGUgc2FtZSwgd2UgZW1pdCBhIE1hdHJpeFByZXNlbmNlVXBkYXRlQWN0aW9uLCBhcyB0aGlzIG1heSBiZSBhXG4gKiByZXF1ZXN0IGJlaW5nIHdhaXRlZCBieSBhIHByb21pc2Ugb3Igc29tZXRoaW5nIGxpa2UgdGhhdFxuICogSU9XOiBldmVyeSByZXF1ZXN0IHNob3VsZCBiZSBmb2xsb3dlZCBieSBhIHByZXNlbmNlIHVwZGF0ZSBvciBhIGZhaWxlZCBhY3Rpb24sIGJ1dCBwcmVzZW5jZVxuICogdXBkYXRlcyBtYXkgaGFwcGVuIGxhdGVyIHdpdGhvdXQgbmV3IHJlcXVlc3RzIChlLmcuIHdoZW4gdGhlIHVzZXIgZ29lcyBvZmZsaW5lKVxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBtYXRyaXhQcmVzZW5jZS5yZXF1ZXN0IGFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHBhcmFtIG1hdHJpeCQgLSBSYWlkZW5FcGljRGVwcyBtZW1iZXJzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIHByZXNlbmNlIHVwZGF0ZXMgb3IgZmFpbCBhY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG1hdHJpeE1vbml0b3JQcmVzZW5jZUVwaWMgPSAoYWN0aW9uJCwge30sIHsgbWF0cml4JCwgbGF0ZXN0JCwgbG9nIH0pID0+IGFjdGlvbiQucGlwZShmaWx0ZXIoaXNBY3Rpb25PZihtYXRyaXhQcmVzZW5jZS5yZXF1ZXN0KSksIFxuLy8gdGhpcyBtZXJnZU1hcCBpcyBsaWtlIHdpdGhMYXRlc3RGcm9tLCBidXQgd2FpdHMgdW50aWwgbWF0cml4JCBlbWl0cyBpdHMgb25seSB2YWx1ZVxubWVyZ2VNYXAoKGFjdGlvbikgPT4gbWF0cml4JC5waXBlKG1hcCgobWF0cml4KSA9PiAoeyBhY3Rpb24sIG1hdHJpeCB9KSkpKSwgZ3JvdXBCeSgoeyBhY3Rpb24gfSkgPT4gYWN0aW9uLm1ldGEuYWRkcmVzcyksIG1lcmdlTWFwKChncm91cGVkJCkgPT4gZ3JvdXBlZCQucGlwZSh3aXRoTGF0ZXN0RnJvbShsYXRlc3QkLnBpcGUocGx1Y2tEaXN0aW5jdCgncHJlc2VuY2VzJykpKSwgXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IGZldGNoaW5nIHByZXNlbmNlIGZvciB0aGlzIGFkZHJlc3MsIG5vIG5lZWQgdG8gZmV0Y2ggYWdhaW5cbmV4aGF1c3RNYXAoKFt7IGFjdGlvbiwgbWF0cml4IH0sIHByZXNlbmNlc10pID0+IGFjdGlvbi5tZXRhLmFkZHJlc3MgaW4gcHJlc2VuY2VzXG4gICAgPyAvLyB3ZSBhbHJlYWR5IG1vbml0b3JlZC9zYXcgdGhpcyB1c2VyJ3MgcHJlc2VuY2VcbiAgICAgICAgb2YocHJlc2VuY2VzW2FjdGlvbi5tZXRhLmFkZHJlc3NdKVxuICAgIDogc2VhcmNoQWRkcmVzc1ByZXNlbmNlJChtYXRyaXgsIGFjdGlvbi5tZXRhLmFkZHJlc3MsIHsgbG9nIH0pLnBpcGUobWFwKCh7IHByZXNlbmNlLCB1c2VyX2lkOiB1c2VySWQsIGF2YXRhcl91cmwgfSkgPT4gbWF0cml4UHJlc2VuY2Uuc3VjY2Vzcyh7XG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgYXZhaWxhYmxlOiBBVkFJTEFCTEUuaW5jbHVkZXMocHJlc2VuY2UpLFxuICAgICAgICB0czogRGF0ZS5ub3coKSxcbiAgICAgICAgY2FwczogcGFyc2VDYXBzKGF2YXRhcl91cmwpLFxuICAgIH0sIGFjdGlvbi5tZXRhKSksIGNhdGNoRXJyb3IoKGVycikgPT4gb2YobWF0cml4UHJlc2VuY2UuZmFpbHVyZShlcnIsIGFjdGlvbi5tZXRhKSkpKSkpKSk7XG4vKipcbiAqIE1vbml0b3IgcGVlcnMgbWF0cml4IHByZXNlbmNlIGZyb20gVXNlci5wcmVzZW5jZSBldmVudHNcbiAqIFdlIGFnZ3JlZ2F0ZSBhbGwgdXNlcnMgb2YgaW50ZXJlc3QgKGkuZS4gZm9yIHdoaWNoIGEgbW9uaXRvciByZXF1ZXN0IHdhcyBlbWl0dGVkIGF0IHNvbWUgcG9pbnQpXG4gKiBhbmQgZW1pdCBwcmVzZW5jZSB1cGRhdGVzIGZvciBhbnkgcHJlc2VuY2UgY2hhbmdlIGhhcHBlbmluZyB0byBhIHVzZXIgdmFsaWRhdGluZyB0byB0aGlzIGFkZHJlc3NcbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuQWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gbWF0cml4JCAtIFJhaWRlbkVwaWNEZXBzIG1lbWJlcnNcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgcHJlc2VuY2UgdXBkYXRlc1xuICovXG5leHBvcnQgY29uc3QgbWF0cml4UHJlc2VuY2VVcGRhdGVFcGljID0gKGFjdGlvbiQsIHt9LCB7IGxvZywgbWF0cml4JCwgbGF0ZXN0JCB9KSA9PiBtYXRyaXgkXG4gICAgLnBpcGUoXG4vLyB3aGVuIG1hdHJpeCBmaW5pc2hlcyBpbml0aWFsaXphdGlvbiwgcmVnaXN0ZXIgdG8gbWF0cml4IHByZXNlbmNlIGV2ZW50c1xuc3dpdGNoTWFwKChtYXRyaXgpID0+IFxuLy8gbWF0cml4J3MgJ1VzZXIucHJlc2VuY2UnIHNvbWV0aW1lcyBmYWlsIHRvIGZpcmUsIGJ1dCBnZW5lcmljICdldmVudCcgaXMgYWx3YXlzIGZpcmVkLFxuLy8gYW5kIFVzZXIgKHJldHJpZXZlZCB2aWEgbWF0cml4LmdldFVzZXIpIGlzIHVwLXRvLWRhdGUgYmVmb3JlICdldmVudCcgZW1pdHNcbmZyb21FdmVudChtYXRyaXgsICdldmVudCcpLnBpcGUobWFwKChldmVudCkgPT4gKHsgZXZlbnQsIG1hdHJpeCB9KSkpKSwgZmlsdGVyKCh7IGV2ZW50IH0pID0+IGV2ZW50LmdldFR5cGUoKSA9PT0gJ20ucHJlc2VuY2UnKSwgXG4vLyBwYXJzZSBwZWVyIGFkZHJlc3MgZnJvbSB1c2VySWRcbm1hcCgoeyBldmVudCwgbWF0cml4IH0pID0+IHtcbiAgICAvLyBhcyAnZXZlbnQnIGlzIGVtaXR0ZWQgYWZ0ZXIgdXNlciBpcyAoY3JlYXRlZCBhbmQpIHVwZGF0ZWQsIGdldFVzZXIgYWx3YXlzIHJldHVybnMgaXRcbiAgICBjb25zdCB1c2VyID0gbWF0cml4LmdldFVzZXIoZXZlbnQuZ2V0U2VuZGVyKCkpO1xuICAgIGlmICghdXNlciB8fCAhdXNlci5wcmVzZW5jZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG1hdGNoID0gdXNlclJlLmV4ZWModXNlci51c2VySWQpLCBwZWVyQWRkcmVzcyA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIGlmICghcGVlckFkZHJlc3MpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBnZXRBZGRyZXNzIHdpbGwgY29udmVydCBhbnkgdmFsaWQgYWRkcmVzcyBpbnRvIGNoZWNrc3VtbWVkLWZvcm1hdFxuICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKHBlZXJBZGRyZXNzKTtcbiAgICBpZiAoIWFkZHJlc3MpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4geyBtYXRyaXgsIHVzZXIsIGFkZHJlc3MgfTtcbn0pLCBcbi8vIGZpbHRlciBvdXQgZXZlbnRzIHdpdGhvdXQgdXNlcklkIGluIHRoZSByaWdodCBmb3JtYXQgKHN0YXJ0V2l0aCBoZXgtYWRkcmVzcylcbmZpbHRlcihpc250TmlsKSwgd2l0aExhdGVzdEZyb20oXG4vLyBvYnNlcnZhYmxlIG9mIGFsbCBhZGRyZXNzZXMgd2hvc2UgcHJlc2VuY2UgbW9uaXRvcmluZyB3YXMgcmVxdWVzdGVkIHNpbmNlIGluaXRcbmFjdGlvbiQucGlwZShmaWx0ZXIoaXNBY3Rpb25PZihtYXRyaXhQcmVzZW5jZS5yZXF1ZXN0KSksIHNjYW4oKHRvTW9uaXRvciwgcmVxdWVzdCkgPT4gdG9Nb25pdG9yLmFkZChyZXF1ZXN0Lm1ldGEuYWRkcmVzcyksIG5ldyBTZXQoKSksIHN0YXJ0V2l0aChuZXcgU2V0KCkpKSwgXG4vLyBrbm93biBwcmVzZW5jZXMgYXMgeyBhZGRyZXNzOiA8bGFzdCBzZWVuIE1hdHJpeFByZXNlbmNlVXBkYXRlQWN0aW9uPiB9IG1hcHBpbmdcbmxhdGVzdCQucGlwZShwbHVja0Rpc3RpbmN0KCdwcmVzZW5jZXMnKSkpLCBcbi8vIGZpbHRlciBvdXQgZXZlbnRzIGZyb20gdXNlcnMgd2UgZG9uJ3QgY2FyZSBhYm91dFxuLy8gaS5lLjogcHJlc2VuY2UgbW9uaXRvcmluZyBuZXZlciByZXF1ZXN0ZWRcbmZpbHRlcigoW3sgYWRkcmVzcyB9LCB0b01vbml0b3JdKSA9PiB0b01vbml0b3IuaGFzKGFkZHJlc3MpKSwgbWVyZ2VNYXAoKFt7IG1hdHJpeCwgdXNlciwgYWRkcmVzcyB9LCAsIHByZXNlbmNlc10pID0+IHtcbiAgICAvLyBmaXJzdCBmaWx0ZXIgY2FuJ3QgdGVsbCB0eXBlc2NyaXB0IHRoaXMgcHJvcGVydHkgd2lsbCBhbHdheXMgYmUgc2V0IVxuICAgIGNvbnN0IHVzZXJJZCA9IHVzZXIudXNlcklkLCBwcmVzZW5jZSA9IHVzZXIucHJlc2VuY2UsIGF2YWlsYWJsZSA9IEFWQUlMQUJMRS5pbmNsdWRlcyhwcmVzZW5jZSk7XG4gICAgaWYgKGFkZHJlc3MgaW4gcHJlc2VuY2VzICYmXG4gICAgICAgIHByZXNlbmNlc1thZGRyZXNzXS5wYXlsb2FkLnVzZXJJZCA9PT0gdXNlcklkICYmXG4gICAgICAgIHByZXNlbmNlc1thZGRyZXNzXS5wYXlsb2FkLmF2YWlsYWJsZSA9PT0gYXZhaWxhYmxlKVxuICAgICAgICAvLyBldmVuIGlmIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24gcGFzc2VzLCB0aGlzIHdvdWxkbid0IGNoYW5nZSBwcmVzZW5jZSwgc28gcmV0dXJuIGVhcmx5XG4gICAgICAgIHJldHVybiBFTVBUWTtcbiAgICAvLyBmZXRjaCBwcm9maWxlIGluZm8gaWYgdXNlciBoYXZlIG5vIHZhbGlkIGRpc3BsYXlOYW1lIHNldFxuICAgIGNvbnN0IHByb2ZpbGUkID0gU2lnbmF0dXJlLmlzKHVzZXIuZGlzcGxheU5hbWUpXG4gICAgICAgID8gb2YoeyBkaXNwbGF5bmFtZTogdXNlci5kaXNwbGF5TmFtZSwgYXZhdGFyX3VybDogdXNlci5hdmF0YXJVcmwgfSlcbiAgICAgICAgOiBkZWZlcigoKSA9PiBtYXRyaXguZ2V0UHJvZmlsZUluZm8odXNlcklkKSk7XG4gICAgcmV0dXJuIHByb2ZpbGUkLnBpcGUobWFwKChwcm9maWxlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gZXJyb3JzIHJhaXNlZCBoZXJlIHdpbGwgYmUgbG9nZ2VkIGFuZCBpZ25vcmVkIG9uIGNhdGNoRXJyb3IgYmVsb3dcbiAgICAgICAgYXNzZXJ0KHByb2ZpbGUgPT09IG51bGwgfHwgcHJvZmlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvZmlsZS5kaXNwbGF5bmFtZSwgJ25vIGRpc3BsYXluYW1lJyk7XG4gICAgICAgIC8vIGVjcmVjb3ZlciBhZGRyZXNzLCB2YWxpZGF0aW5nIGRpc3BsYXlOYW1lIGlzIHRoZSBzaWduYXR1cmUgb2YgdGhlIHVzZXJJZFxuICAgICAgICBjb25zdCByZWNvdmVyZWQgPSB2ZXJpZnlNZXNzYWdlKHVzZXJJZCwgcHJvZmlsZS5kaXNwbGF5bmFtZSk7XG4gICAgICAgIGFzc2VydChyZWNvdmVyZWQgPT09IGFkZHJlc3MsIGBpbnZhbGlkIGRpc3BsYXluYW1lIHNpZ25hdHVyZTogJHtyZWNvdmVyZWR9ICE9PSAke2FkZHJlc3N9YCk7XG4gICAgICAgIHJldHVybiBtYXRyaXhQcmVzZW5jZS5zdWNjZXNzKHtcbiAgICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICAgIGF2YWlsYWJsZSxcbiAgICAgICAgICAgIHRzOiAoX2EgPSB1c2VyLmxhc3RQcmVzZW5jZVRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgY2FwczogcGFyc2VDYXBzKHByb2ZpbGUuYXZhdGFyX3VybCksXG4gICAgICAgIH0sIHsgYWRkcmVzczogcmVjb3ZlcmVkIH0pO1xuICAgIH0pLCBjYXRjaEVycm9yKChlcnIpID0+IChsb2cuZGVidWcoJ0Vycm9yIHZhbGlkYXRpbmcgcHJlc2VuY2UgZXZlbnQsIGlnbm9yaW5nJywgZXJyKSwgRU1QVFkpKSk7XG59KSlcbiAgICAucGlwZSh3aXRoTGF0ZXN0RnJvbShsYXRlc3QkKSwgXG4vLyBmaWx0ZXIgb3V0IGlmIHByZXNlbmNlIHVwZGF0ZSBpcyB0byBvZmZsaW5lLCBhbmQgYWRkcmVzcyBiZWNhbWUgb25saW5lIGluIGFub3RoZXIgdXNlclxuZmlsdGVyKChbYWN0aW9uLCB7IHByZXNlbmNlcyB9XSkgPT4gYWN0aW9uLnBheWxvYWQuYXZhaWxhYmxlIHx8XG4gICAgIShhY3Rpb24ubWV0YS5hZGRyZXNzIGluIHByZXNlbmNlcykgfHxcbiAgICAhcHJlc2VuY2VzW2FjdGlvbi5tZXRhLmFkZHJlc3NdLnBheWxvYWQuYXZhaWxhYmxlIHx8XG4gICAgYWN0aW9uLnBheWxvYWQudXNlcklkID09PSBwcmVzZW5jZXNbYWN0aW9uLm1ldGEuYWRkcmVzc10ucGF5bG9hZC51c2VySWQpLCBwbHVjaygwKSk7XG4vKipcbiAqIENyZWF0ZSByb29tIChpZiBuZWVkZWQpIGZvciBhIHRyYW5zZmVyJ3MgdGFyZ2V0LCBjaGFubmVsJ3MgcGFydG5lciBvciwgYXMgYSBmYWxsYmFjaywgZm9yIGFueVxuICogcmVjaXBpZW50IG9mIGEgbWVzc2FnZVNlbmQucmVxdWVzdCBhY3Rpb25cbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgdHJhbnNmZXJTaWduZWR8Y2hhbm5lbE1vbml0b3J8bWVzc2FnZVNlbmQucmVxdWVzdCBhY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEBwYXJhbSBtYXRyaXgkIC0gUmFpZGVuRXBpY0RlcHMgbWVtYmVyc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBtYXRyaXhSb29tIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hdHJpeENyZWF0ZVJvb21FcGljID0gKGFjdGlvbiQsIHt9LCB7IGxvZywgbWF0cml4JCwgbGF0ZXN0JCB9KSA9PiBcbi8vIGFjdHVhbCBvdXRwdXQgb2JzZXJ2YWJsZSwgc2VsZWN0cyBhZGRyZXNzZXMgb2YgaW50ZXJlc3QgZnJvbSBhY3Rpb25zXG5hY3Rpb24kLnBpcGUoXG4vLyBlbnN1cmUgdGhlcmUncyBhIHJvb20gZm9yIGFkZHJlc3Mgb2YgaW50ZXJlc3QgZm9yIGVhY2ggb2YgdGhlc2UgYWN0aW9uc1xuLy8gbWF0cml4Um9vbUxlYXZlIGVuc3VyZXMgYSBuZXcgcm9vbSBpcyBjcmVhdGVkIGlmIGFsbCB3ZSBoYWQgYXJlIGZvcmdvdHRlbi9sZWZ0XG5maWx0ZXIoaXNBY3Rpb25PZihbdHJhbnNmZXJTaWduZWQsIGNoYW5uZWxNb25pdG9yLCBtZXNzYWdlU2VuZC5yZXF1ZXN0LCBtYXRyaXhSb29tTGVhdmVdKSksIG1hcCgoYWN0aW9uKSA9PiBpc0FjdGlvbk9mKHRyYW5zZmVyU2lnbmVkLCBhY3Rpb24pXG4gICAgPyBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlLnRhcmdldFxuICAgIDogaXNBY3Rpb25PZihjaGFubmVsTW9uaXRvciwgYWN0aW9uKVxuICAgICAgICA/IGFjdGlvbi5tZXRhLnBhcnRuZXJcbiAgICAgICAgOiBhY3Rpb24ubWV0YS5hZGRyZXNzKSwgXG4vLyBncm91cGJ5K21lcmdlTWFwIGVuc3VyZXMgZGlmZmVyZW50IGFkZHJlc3NlcyBhcmUgcHJvY2Vzc2VkIGluIHBhcmFsbGVsLCBhbmQgYWxzb1xuLy8gcHJldmVudHMgb25lIHN0dWNrIGFkZHJlc3Mgb2JzZXJ2YWJsZSAoZS5nLiBwcmVzZW5jZSBkZWxheWVkKSBmcm9tIGhvbGRpbmcgd2hvbGUgcXVldWVcbmdyb3VwQnkoKGFkZHJlc3MpID0+IGFkZHJlc3MpLCBtZXJnZU1hcCgoZ3JvdXBlZCQpID0+IGdyb3VwZWQkLnBpcGUoXG4vLyB0aGlzIG1lcmdlTWFwIGlzIGxpa2Ugd2l0aExhdGVzdEZyb20sIGJ1dCB3YWl0cyB1bnRpbCBtYXRyaXgkIGVtaXRzIGl0cyBvbmx5IHZhbHVlXG5tZXJnZU1hcCgoYWRkcmVzcykgPT4gbWF0cml4JC5waXBlKG1hcCgobWF0cml4KSA9PiAoeyBhZGRyZXNzLCBtYXRyaXggfSkpKSksIFxuLy8gZXhoYXVzdE1hcCBpcyB1c2VkIHRvIHByZXZlbnQgYnVyc3RzIG9mIGFjdGlvbnMgZm9yIGEgZ2l2ZW4gYWRkcmVzcyAoZWcuIG9uIHN0YXJ0dXApXG4vLyBvZiBjcmVhdGluZyBtdWx0aXBsZSByb29tcyBmb3Igc2FtZSBhZGRyZXNzLCBzbyB3ZSBpZ25vcmUgbmV3IGFkZHJlc3MgaXRlbXMgd2hpbGVcbi8vIHByZXZpb3VzIGlzIGJlaW5nIHByb2Nlc3NlZC4gSWYgdXNlciByb2FtcywgbWF0cml4SW52aXRlRXBpYyB3aWxsIHJlLWludml0ZVxuZXhoYXVzdE1hcCgoeyBhZGRyZXNzLCBtYXRyaXggfSkgPT4gXG4vLyBwcmVzZW5jZXNTdGF0ZVJlcGxheSQrdGFrZSgxKSBhY3RzIGxpa2Ugd2l0aExhdGVzdEZyb20gd2l0aCBjYWNoZWQgcmVzdWx0XG5sYXRlc3QkLnBpcGUoXG4vLyB3YWl0IGZvciB1c2VyIHRvIGJlIG1vbml0b3JlZFxuZmlsdGVyKCh7IHByZXNlbmNlcyB9KSA9PiBhZGRyZXNzIGluIHByZXNlbmNlcyksIHRha2UoMSksIFxuLy8gaWYgdGhlcmUncyBhbHJlYWR5IGEgcm9vbSBpbiBzdGF0ZSBmb3IgYWRkcmVzcywgc2tpcFxuZmlsdGVyKCh7IHN0YXRlIH0pID0+IHsgdmFyIF9hLCBfYiwgX2M7IHJldHVybiAhKChfYyA9IChfYiA9IChfYSA9IHN0YXRlLnRyYW5zcG9ydC5tYXRyaXgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yb29tcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2FkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbMF0pOyB9KSwgXG4vLyBlbHNlLCBjcmVhdGUgYSByb29tLCBpbnZpdGUga25vd24gdXNlciBhbmQgcGVyc2lzdCByb29tSWQgaW4gc3RhdGVcbm1lcmdlTWFwKCh7IHByZXNlbmNlcyB9KSA9PiBtYXRyaXguY3JlYXRlUm9vbSh7XG4gICAgdmlzaWJpbGl0eTogJ3ByaXZhdGUnLFxuICAgIGludml0ZTogW3ByZXNlbmNlc1thZGRyZXNzXS5wYXlsb2FkLnVzZXJJZF0sXG59KSksIG1hcCgoeyByb29tX2lkOiByb29tSWQgfSkgPT4gbWF0cml4Um9vbSh7IHJvb21JZCB9LCB7IGFkZHJlc3MgfSkpLCBjYXRjaEVycm9yKChlcnIpID0+IChsb2cuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHJvb20sIGlnbm9yaW5nJywgZXJyKSwgRU1QVFkpKSkpKSkpO1xuLyoqXG4gKiBJbnZpdGVzIHVzZXJzIGNvbWluZyBvbmxpbmUgdG8gbWFpbiByb29tIHdlIG1heSBoYXZlIHdpdGggdGhlbVxuICpcbiAqIFRoaXMgYWxzbyBrZWVwcyByZXRyeWluZyBpbnZpdGluZyBldmVyeSBjb25maWcuaHR0cFRpbWVvdXQgKGRlZmF1bHQ9MzBzKSB3aGlsZSB1c2VyIGRvZXNuJ3RcbiAqIGFjY2VwdCBvdXIgaW52aXRlIG9yIGRvbid0IGludml0ZSBvciB3cml0ZSB0byB1cyB0by9pbiBhbm90aGVyIHJvb20uXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIG1hdHJpeFByZXNlbmNlLnN1Y2Nlc3MgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gZGVwcyAtIFJhaWRlbkVwaWNEZXBzXG4gKiBAcGFyYW0gZGVwcy5tYXRyaXgkIC0gTWF0cml4Q2xpZW50IEFzeW5jU3ViamVjdFxuICogQHBhcmFtIGRlcHMuY29uZmlnJCAtIFJhaWRlbkNvbmZpZyBCZWhhdmlvclN1YmplY3RcbiAqIEByZXR1cm5zIEVtcHR5IG9ic2VydmFibGUgKHdob2xlIHNpZGUtZWZmZWN0IG9uIG1hdHJpeCBpbnN0YW5jZSlcbiAqL1xuZXhwb3J0IGNvbnN0IG1hdHJpeEludml0ZUVwaWMgPSAoYWN0aW9uJCwge30sIHsgbWF0cml4JCwgY29uZmlnJCwgbGF0ZXN0JCwgbG9nIH0pID0+IGFjdGlvbiQucGlwZShmaWx0ZXIoaXNBY3Rpb25PZihtYXRyaXhQcmVzZW5jZS5zdWNjZXNzKSksIGdyb3VwQnkoKGEpID0+IGEubWV0YS5hZGRyZXNzKSwgbWVyZ2VNYXAoKGdyb3VwZWQkKSA9PiBcbi8vIGdyb3VwZWQkIGlzIG9uZSBvYnNlcnZhYmxlIG9mIHByZXNlbmNlIGFjdGlvbnMgcGVyIHBhcnRuZXJzIGFkZHJlc3Ncbmdyb3VwZWQkLnBpcGUoXG4vLyBhY3Rpb24gY29tZXMgb25seSBhZnRlciBtYXRyaXgkIGlzIHN0YXJ0ZWQsIHNvIGl0J3Mgc2FmZSB0byB1c2Ugd2l0aExhdGVzdEZyb21cbndpdGhMYXRlc3RGcm9tKG1hdHJpeCQpLCBcbi8vIHN3aXRjaE1hcCBvbiBuZXcgcHJlc2VuY2UgYWN0aW9uIGZvciBhZGRyZXNzXG5zd2l0Y2hNYXAoKFthY3Rpb24sIG1hdHJpeF0pID0+IFxuLy8gaWYgbm90IGF2YWlsYWJsZSwgZG8gbm90aGluZyAoYW5kIHVuc3Vic2NyaWJlIGZyb20gcHJldmlvdXMgb2JzZXJ2YWJsZSlcbiFhY3Rpb24ucGF5bG9hZC5hdmFpbGFibGVcbiAgICA/IEVNUFRZXG4gICAgOiBsYXRlc3QkLnBpcGUobWFwKCh7IHN0YXRlIH0pID0+IHsgdmFyIF9hLCBfYiwgX2M7IHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBzdGF0ZS50cmFuc3BvcnQubWF0cml4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eucm9vbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlthY3Rpb24ubWV0YS5hZGRyZXNzXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jWzBdOyB9KSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgc3dpdGNoTWFwKChyb29tSWQpID0+IGNvbmNhdChvZihyb29tSWQpLCAhcm9vbUlkXG4gICAgICAgID8gRU1QVFlcbiAgICAgICAgOiAvLyByZS10cmlnZ2VyIGludml0ZSBsb29wIGlmIHVzZXIgbGVhdmVzXG4gICAgICAgICAgICBmcm9tRXZlbnQobWF0cml4LCAnUm9vbU1lbWJlci5tZW1iZXJzaGlwJywgKHt9LCBtZW1iZXIpID0+IG1lbWJlcikucGlwZShmaWx0ZXIoKG1lbWJlcikgPT4gbWVtYmVyLnJvb21JZCA9PT0gcm9vbUlkICYmXG4gICAgICAgICAgICAgICAgbWVtYmVyLnVzZXJJZCA9PT0gYWN0aW9uLnBheWxvYWQudXNlcklkICYmXG4gICAgICAgICAgICAgICAgbWVtYmVyLm1lbWJlcnNoaXAgPT09ICdsZWF2ZScpLCBtYXBUbyhyb29tSWQpKSkpLCBcbiAgICAvLyBzd2l0Y2hNYXAgb24gbWFpbiByb29tSWQgY2hhbmdlXG4gICAgc3dpdGNoTWFwKChyb29tSWQpID0+ICFyb29tSWRcbiAgICAgICAgPyAvLyBpZiByb29tSWQgbm90IHNldCwgZG8gbm90aGluZyBhbmQgdW5zdWJzY3JpYmVcbiAgICAgICAgICAgIEVNUFRZXG4gICAgICAgIDogLy8gd2hpbGUgc3Vic2NyaWJlZCBhbmQgdXNlciBkaWRuJ3Qgam9pbiwgaW52aXRlIGV2ZXJ5IGh0dHBUaW1lb3V0PTMwc1xuICAgICAgICAgICAgaW52aXRlTG9vcCQobWF0cml4LCByb29tSWQsIGFjdGlvbi5wYXlsb2FkLnVzZXJJZCwgY29uZmlnJCwgeyBsb2cgfSkpKSkpKSwgaWdub3JlRWxlbWVudHMoKSk7XG4vKipcbiAqIEhhbmRsZSBpbnZpdGVzIHNlbnQgdG8gdXMgYW5kIGFjY2VwdHMgdGhlbSBpZmYgc2VudCBieSBhIG1vbml0b3JlZCB1c2VyXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlbkFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHBhcmFtIG1hdHJpeCQgLSBSYWlkZW5FcGljRGVwcyBtZW1iZXJzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIG1hdHJpeFJvb20gYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgbWF0cml4SGFuZGxlSW52aXRlc0VwaWMgPSAoe30sIHt9LCB7IGxvZywgbWF0cml4JCwgY29uZmlnJCwgbGF0ZXN0JCB9KSA9PiBtYXRyaXgkLnBpcGUoXG4vLyB3aGVuIG1hdHJpeCBmaW5pc2hlcyBpbml0aWFsaXphdGlvbiwgcmVnaXN0ZXIgdG8gbWF0cml4IGludml0ZSBldmVudHNcbnN3aXRjaE1hcCgobWF0cml4KSA9PiBmcm9tRXZlbnQobWF0cml4LCAnUm9vbU1lbWJlci5tZW1iZXJzaGlwJywgKGV2ZW50LCBtZW1iZXIpID0+ICh7IGV2ZW50LCBtZW1iZXIsIG1hdHJpeCB9KSkpLCBmaWx0ZXIoXG4vLyBmaWx0ZXIgZm9yIGludml0ZSBldmVudHMgdG8gdXNcbih7IG1lbWJlciwgbWF0cml4IH0pID0+IG1lbWJlci51c2VySWQgPT09IG1hdHJpeC5nZXRVc2VySWQoKSAmJiBtZW1iZXIubWVtYmVyc2hpcCA9PT0gJ2ludml0ZScpLCB3aXRoTGF0ZXN0RnJvbShjb25maWckKSwgbWVyZ2VNYXAoKFt7IGV2ZW50LCBtZW1iZXIsIG1hdHJpeCB9LCB7IGh0dHBUaW1lb3V0IH1dKSA9PiB7XG4gICAgY29uc3Qgc2VuZGVyID0gZXZlbnQuZ2V0U2VuZGVyKCksIHNlbmRlclByZXNlbmNlJCA9IGxhdGVzdCQucGlwZShwbHVja0Rpc3RpbmN0KCdwcmVzZW5jZXMnKSwgbWFwKChwcmVzZW5jZXMpID0+IGZpbmQocHJlc2VuY2VzLCAocCkgPT4gcC5wYXlsb2FkLnVzZXJJZCA9PT0gc2VuZGVyKSksIGZpbHRlcihpc250TmlsKSwgdGFrZSgxKSwgXG4gICAgLy8gRG9uJ3Qgd2FpdCBtb3JlIHRoYW4gc29tZSBhcmJpdHJhcnkgdGltZSBmb3IgdGhpcyBzZW5kZXIgcHJlc2VuY2UgdXBkYXRlIHRvIHNob3dcbiAgICAvLyB1cDsgY29tcGxldGVzIHdpdGhvdXQgZW1pdHRpbmcgYW55dGhpbmcgb3RoZXJ3aXNlLCBlbmRpbmcgdGhpcyBwaXBlbGluZS5cbiAgICAvLyBUaGlzIGFsc28gd29ya3MgYXMgYSBmaWx0ZXIgdG8gY29udGludWUgcHJvY2Vzc2luZyBpbnZpdGVzIG9ubHkgZm9yIG1vbml0b3JlZFxuICAgIC8vIHVzZXJzLCBhcyBpdCdsbCBjb21wbGV0ZSB3aXRob3V0IGVtaXR0aW5nIGlmIG5vIE1hdHJpeFByZXNlbmNlVXBkYXRlQWN0aW9uIGlzXG4gICAgLy8gZm91bmQgZm9yIHNlbmRlciBpbiB0aW1lXG4gICAgdGFrZVVudGlsKHRpbWVyKGh0dHBUaW1lb3V0KSkpO1xuICAgIHJldHVybiBzZW5kZXJQcmVzZW5jZSQucGlwZShtYXAoKHNlbmRlclByZXNlbmNlKSA9PiAoeyBtYXRyaXgsIG1lbWJlciwgc2VuZGVyUHJlc2VuY2UgfSkpKTtcbn0pLCBtZXJnZU1hcCgoeyBtYXRyaXgsIG1lbWJlciwgc2VuZGVyUHJlc2VuY2UgfSkgPT4gXG4vLyBqb2luIHJvb20gYW5kIGVtaXQgTWF0cml4Um9vbUFjdGlvbiB0byBtYWtlIGl0IGRlZmF1bHQvZmlyc3Qgb3B0aW9uIGZvciBzZW5kZXIgYWRkcmVzc1xuZnJvbShtYXRyaXguam9pblJvb20obWVtYmVyLnJvb21JZCwgeyBzeW5jUm9vbTogdHJ1ZSB9KSkucGlwZShtYXBUbyhtYXRyaXhSb29tKHsgcm9vbUlkOiBtZW1iZXIucm9vbUlkIH0sIHsgYWRkcmVzczogc2VuZGVyUHJlc2VuY2UubWV0YS5hZGRyZXNzIH0pKSwgY2F0Y2hFcnJvcigoZXJyKSA9PiAobG9nLmVycm9yKCdFcnJvciBqb2luaW5nIGludml0ZWQgcm9vbSwgaWdub3JpbmcnLCBlcnIpLCBFTVBUWSkpKSkpO1xuLyoqXG4gKiBMZWF2ZSBhbnkgZXhjZXNzIHJvb20gZm9yIGEgcGFydG5lciB3aGVuIGNyZWF0aW5nIG9yIGpvaW5pbmcgYSBuZXcgb25lLlxuICogRXhjZXNzIHJvb21zIGFyZSBMUlUgYmV5b25kIGEgZ2l2ZW4gdGhyZXNob2xkIChjb25maWd1cmFibGUsIGRlZmF1bHQ9MykgaW4gYWRkcmVzcydzIHJvb21zXG4gKiBxdWV1ZSBhbmQgYXJlIGNoZWNrZWQgKG9ubHkpIHdoZW4gYSBuZXcgb25lIGlzIGFkZGVkIHRvIGl0LlxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBtYXRyaXhSb29tIGFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHBhcmFtIG1hdHJpeCQgLSBSYWlkZW5FcGljRGVwcyBtZW1iZXJzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIG1hdHJpeFJvb21MZWF2ZSBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRyaXhMZWF2ZUV4Y2Vzc1Jvb21zRXBpYyA9IChhY3Rpb24kLCBzdGF0ZSQsIHsgbG9nLCBtYXRyaXgkLCBjb25maWckIH0pID0+IGFjdGlvbiQucGlwZShcbi8vIGFjdCB3aGVuZXZlciBhIG5ldyByb29tIGlzIGFkZGVkIHRvIHRoZSBhZGRyZXNzIHF1ZXVlIGluIHN0YXRlXG5maWx0ZXIoaXNBY3Rpb25PZihtYXRyaXhSb29tKSksIFxuLy8gdGhpcyBtZXJnZU1hcCBpcyBsaWtlIHdpdGhMYXRlc3RGcm9tLCBidXQgd2FpdHMgdW50aWwgbWF0cml4JCBlbWl0cyBpdHMgb25seSB2YWx1ZVxubWVyZ2VNYXAoKGFjdGlvbikgPT4gbWF0cml4JC5waXBlKG1hcCgobWF0cml4KSA9PiAoeyBhY3Rpb24sIG1hdHJpeCB9KSkpKSwgd2l0aExhdGVzdEZyb20oc3RhdGUkLCBjb25maWckKSwgbWVyZ2VNYXAoKFt7IGFjdGlvbiwgbWF0cml4IH0sIHN0YXRlLCB7IG1hdHJpeEV4Y2Vzc1Jvb21zIH1dKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3Qgcm9vbXMgPSAoX2MgPSAoX2IgPSAoX2EgPSBzdGF0ZS50cmFuc3BvcnQubWF0cml4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eucm9vbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlthY3Rpb24ubWV0YS5hZGRyZXNzXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW107XG4gICAgcmV0dXJuIGZyb20ocm9vbXMuZmlsdGVyKCh7fSwgaSkgPT4gaSA+PSBtYXRyaXhFeGNlc3NSb29tcykpLnBpcGUobWVyZ2VNYXAoKHJvb21JZCkgPT4gbWF0cml4XG4gICAgICAgIC5sZWF2ZShyb29tSWQpXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiBsb2cuZXJyb3IoJ0Vycm9yIGxlYXZpbmcgZXhjZXNzIHJvb20sIGlnbm9yaW5nJywgZXJyKSlcbiAgICAgICAgLnRoZW4oKCkgPT4gcm9vbUlkKSksIG1hcCgocm9vbUlkKSA9PiBtYXRyaXhSb29tTGVhdmUoeyByb29tSWQgfSwgYWN0aW9uLm1ldGEpKSk7XG59KSk7XG4vKipcbiAqIExlYXZlIGFueSByb29tIHdoaWNoIGlzIG5laXRoZXIgZ2xvYmFsIG5vciBrbm93biBhcyBhIHJvb20gZm9yIHNvbWUgdXNlciBvZiBpbnRlcmVzdFxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5BY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEBwYXJhbSBtYXRyaXgkIC0gUmFpZGVuRXBpY0RlcHMgbWVtYmVyc1xuICogQHJldHVybnMgRW1wdHkgb2JzZXJ2YWJsZSAod2hvbGUgc2lkZS1lZmZlY3Qgb24gbWF0cml4IGluc3RhbmNlKVxuICovXG5leHBvcnQgY29uc3QgbWF0cml4TGVhdmVVbmtub3duUm9vbXNFcGljID0gKHt9LCBzdGF0ZSQsIHsgbG9nLCBtYXRyaXgkLCBjb25maWckIH0pID0+IG1hdHJpeCQucGlwZShcbi8vIHdoZW4gbWF0cml4IGZpbmlzaGVzIGluaXRpYWxpemF0aW9uLCByZWdpc3RlciB0byBtYXRyaXggUm9vbSBldmVudHNcbnN3aXRjaE1hcCgobWF0cml4KSA9PiBmcm9tRXZlbnQobWF0cml4LCAnUm9vbScpLnBpcGUobWFwKChyb29tKSA9PiAoeyBtYXRyaXgsIHJvb21JZDogcm9vbS5yb29tSWQgfSkpKSksIFxuLy8gdGhpcyByb29tIG1heSBiZWNvbWUga25vd24gbGF0ZXIgZm9yIHNvbWUgcmVhc29uLCBzbyB3YWl0IGEgbGl0dGxlXG5kZWxheVdoZW4oKCkgPT4gY29uZmlnJC5waXBlKGZpcnN0KCksIG1lcmdlTWFwKCh7IGh0dHBUaW1lb3V0IH0pID0+IHRpbWVyKGh0dHBUaW1lb3V0KSkpKSwgd2l0aExhdGVzdEZyb20oc3RhdGUkLCBjb25maWckKSwgXG4vLyBmaWx0ZXIgZm9yIGxlYXZlIGV2ZW50cyB0byB1c1xuZmlsdGVyKChbeyBtYXRyaXgsIHJvb21JZCB9LCBzdGF0ZSwgY29uZmlnXSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3Qgcm9vbSA9IG1hdHJpeC5nZXRSb29tKHJvb21JZCk7XG4gICAgaWYgKCFyb29tKVxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJvb20gYWxyZWFkeSBnb25lIHdoaWxlIHdhaXRpbmdcbiAgICBjb25zdCBnbG9iYWxSb29tcyA9IGdsb2JhbFJvb21OYW1lcyhjb25maWcpO1xuICAgIGlmIChyb29tLm5hbWUgJiYgZ2xvYmFsUm9vbXMuc29tZSgoZykgPT4gcm9vbS5uYW1lLm1hdGNoKGAjJHtnfTpgKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCByb29tcyA9IChfYiA9IChfYSA9IHN0YXRlLnRyYW5zcG9ydC5tYXRyaXgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yb29tcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gICAgZm9yIChjb25zdCBhZGRyZXNzIGluIHJvb21zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbUlkIG9mIHJvb21zW2FkZHJlc3NdKSB7XG4gICAgICAgICAgICBpZiAocm9vbUlkID09PSByb29tLnJvb21JZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KSwgbWVyZ2VNYXAoKFt7IG1hdHJpeCwgcm9vbUlkIH1dKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBsb2cud2FybignVW5rbm93biByb29tIGluIG1hdHJpeCwgbGVhdmluZycsIHJvb21JZCk7XG4gICAgcmV0dXJuIG1hdHJpeFxuICAgICAgICAubGVhdmUocm9vbUlkKVxuICAgICAgICAuY2F0Y2goKGVycikgPT4gbG9nLmVycm9yKCdFcnJvciBsZWF2aW5nIHVua25vd24gcm9vbSwgaWdub3JpbmcnLCBlcnIpKTtcbn0pKSwgaWdub3JlRWxlbWVudHMoKSk7XG4vKipcbiAqIElmIHdlIGxlYXZlIGEgcm9vbSBmb3IgYW55IHJlYXNvbiAoZWcuIGEga2ljayBldmVudCksIHB1cmdlIGl0IGZyb20gc3RhdGVcbiAqIE5vdGljZSBleGNlc3Mgcm9vbXMgbGVmdCBieSBtYXRyaXhMZWF2ZUV4Y2Vzc1Jvb21zRXBpYyBhcmUgY2xlYW5lZCBiZWZvcmUgdGhlIG1hdHJpeCBldmVudCBpc1xuICogZGV0ZWN0ZWQsIGFuZCB0aGVuIG5vIE1hdHJpeFJvb21MZWF2ZUFjdGlvbiBpcyBlbWl0dGVkIGZvciB0aGVtIGJ5IHRoaXMgZXBpYy5cbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuQWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gbWF0cml4JCAtIFJhaWRlbkVwaWNEZXBzIG1lbWJlcnNcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgbWF0cml4Um9vbUxlYXZlIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hdHJpeENsZWFuTGVmdFJvb21zRXBpYyA9ICh7fSwgc3RhdGUkLCB7IGxvZywgbWF0cml4JCB9KSA9PiBtYXRyaXgkLnBpcGUoXG4vLyB3aGVuIG1hdHJpeCBmaW5pc2hlcyBpbml0aWFsaXphdGlvbiwgcmVnaXN0ZXIgdG8gbWF0cml4IGludml0ZSBldmVudHNcbnN3aXRjaE1hcCgobWF0cml4KSA9PiBmcm9tRXZlbnQobWF0cml4LCAnUm9vbS5teU1lbWJlcnNoaXAnLCAocm9vbSwgbWVtYmVyc2hpcCkgPT4gKHsgcm9vbSwgbWVtYmVyc2hpcCwgbWF0cml4IH0pKSksIFxuLy8gZmlsdGVyIGZvciBsZWF2ZSBldmVudHMgdG8gdXNcbmZpbHRlcigoeyBtZW1iZXJzaGlwIH0pID0+IG1lbWJlcnNoaXAgPT09ICdsZWF2ZScpLCB3aXRoTGF0ZXN0RnJvbShzdGF0ZSQpLCBtZXJnZU1hcChmdW5jdGlvbiogKFt7IHJvb20gfSwgc3RhdGVdKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCByb29tcyA9IChfYiA9IChfYSA9IHN0YXRlLnRyYW5zcG9ydC5tYXRyaXgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yb29tcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gICAgZm9yIChjb25zdCBhZGRyZXNzIGluIHJvb21zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbUlkIG9mIHJvb21zW2FkZHJlc3NdKSB7XG4gICAgICAgICAgICBpZiAocm9vbUlkID09PSByb29tLnJvb21JZCkge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKCdMZWZ0IGV2ZW50IGZvciBwZWVyIHJvb20gZGV0ZWN0ZWQsIGZvcmdldHRpbmcnLCBhZGRyZXNzLCByb29tSWQpO1xuICAgICAgICAgICAgICAgIHlpZWxkIG1hdHJpeFJvb21MZWF2ZSh7IHJvb21JZCB9LCB7IGFkZHJlc3M6IGFkZHJlc3MgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KSk7XG4vKipcbiAqIElmIHNvbWUgcm9vbSB3ZSBoYWQgd2l0aCBhIHBlZXIgZG9lc24ndCBzaG93IHVwIGluIHRyYW5zcG9ydCwgZm9yZ2V0IGl0XG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlbkFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHBhcmFtIGRlcHMgLSBSYWlkZW5FcGljRGVwcyBtZW1iZXJzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIG1hdHJpeFJvb21MZWF2ZSBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRyaXhDbGVhbk1pc3NpbmdSb29tc0VwaWMgPSAoe30sIHN0YXRlJCwgeyBsb2csIG1hdHJpeCQsIGNvbmZpZyQgfSkgPT4gc3RhdGUkLnBpcGUocGx1Y2tEaXN0aW5jdCgndHJhbnNwb3J0JywgJ21hdHJpeCcpLCBtZXJnZU1hcChmdW5jdGlvbiogKG1hdHJpeCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByb29tcyA9IChfYSA9IG1hdHJpeCA9PT0gbnVsbCB8fCBtYXRyaXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hdHJpeC5yb29tcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgZm9yIChjb25zdCBhZGRyZXNzIGluIHJvb21zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbUlkIG9mIHJvb21zW2FkZHJlc3NdKSB7XG4gICAgICAgICAgICB5aWVsZCB7IHJvb21JZCwgYWRkcmVzczogYWRkcmVzcyB9O1xuICAgICAgICB9XG4gICAgfVxufSksIGRpc3RpbmN0KCh7IHJvb21JZCB9KSA9PiByb29tSWQpLCBtZXJnZU1hcCgoeyByb29tSWQsIGFkZHJlc3MgfSkgPT4gbWF0cml4JC5waXBlKG1hcCgobWF0cml4KSA9PiAoeyBtYXRyaXgsIHJvb21JZCwgYWRkcmVzcyB9KSkpKSwgd2l0aExhdGVzdEZyb20oY29uZmlnJCksIG1lcmdlTWFwKChbeyByb29tSWQsIGFkZHJlc3MsIG1hdHJpeCB9LCB7IGh0dHBUaW1lb3V0IH1dKSA9PiBnZXRSb29tJChtYXRyaXgsIHJvb21JZCkucGlwZShcbi8vIHdhaXQgZm9yIHJvb20gdG8gc2hvdyB1cCBpbiBNYXRyaXhDbGllbnQ7IGlmIGl0IGRvZXNuJ3QsIGNsZWFuIHVwXG50aW1lb3V0KGh0dHBUaW1lb3V0KSwgaWdub3JlRWxlbWVudHMoKSwgY2F0Y2hFcnJvcigoKSA9PiB7XG4gICAgbG9nLndhcm4oJ1BlZXIgcm9vbSBpbiBzdGF0ZSBub3QgZm91bmQgaW4gbWF0cml4LCBmb3JnZXR0aW5nJywgYWRkcmVzcywgcm9vbUlkKTtcbiAgICByZXR1cm4gb2YobWF0cml4Um9vbUxlYXZlKHsgcm9vbUlkIH0sIHsgYWRkcmVzcyB9KSk7XG59KSkpKTtcbmZ1bmN0aW9uIHdhaXRNZW1iZXJBbmRTZW5kJChhZGRyZXNzLCBtYXRyaXgsIHR5cGUsIGNvbnRlbnQsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxueyBsb2csIGxhdGVzdCQsIGNvbmZpZyQgfSwgYWxsb3dSdGMgPSBmYWxzZSkge1xuICAgIGNvbnN0IFJFVFJZX0NPVU5UID0gMzsgLy8gaXMgdGhpcyByZWxldmFudCBlbm91Z2ggdG8gYmVjb21lIGEgY29uc3RhbnQvc2V0dGluZz9cbiAgICByZXR1cm4gbGF0ZXN0JC5waXBlKGZpbHRlcigoeyBwcmVzZW5jZXMgfSkgPT4gYWRkcmVzcyBpbiBwcmVzZW5jZXMpLCB0YWtlKDEpLCBtZXJnZU1hcCgoeyBydGMgfSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIGlmIGF2YWlsYWJsZSAmIG9wZW4sIHVzZSBjaGFubmVsXG4gICAgICAgIGlmIChhbGxvd1J0YyAmJiAoKF9hID0gcnRjID09PSBudWxsIHx8IHJ0YyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcnRjW2FkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZHlTdGF0ZSkgPT09ICdvcGVuJylcbiAgICAgICAgICAgIHJldHVybiBvZihydGNbYWRkcmVzc10pO1xuICAgICAgICAvLyBlbHNlLCB3YWl0IGZvciBtZW1iZXIgdG8gam9pbiBpbiB0aGUgZmlyc3Qgcm9vbSwgYW5kIHJldHVybiByb29tSWRcbiAgICAgICAgcmV0dXJuIGxhdGVzdCQucGlwZShtYXAoKHsgc3RhdGUgfSkgPT4geyB2YXIgX2EsIF9iLCBfYzsgcmV0dXJuIChfYyA9IChfYiA9IChfYSA9IHN0YXRlLnRyYW5zcG9ydC5tYXRyaXgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yb29tcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2FkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbMF07IH0pLCBcbiAgICAgICAgLy8gd2FpdCBmb3IgYSByb29tIHRvIGV4aXN0IChjcmVhdGVkIG9yIGludml0ZWQpIGZvciBhZGRyZXNzXG4gICAgICAgIGZpbHRlcihpc250TmlsKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgXG4gICAgICAgIC8vIHRoaXMgc3dpdGNoTWFwIHVuc3Vic2NyaWJlcyBmcm9tIHByZXZpb3VzIFwid2FpdFwiIGlmIGZpcnN0IHJvb20gZm9yIGFkZHJlc3MgY2hhbmdlc1xuICAgICAgICBzd2l0Y2hNYXAoKHJvb21JZCkgPT4gXG4gICAgICAgIC8vIGdldC93YWl0IHJvb20gb2JqZWN0IGZvciByb29tSWRcbiAgICAgICAgLy8gbWF5IHdhaXQgZm9yIHRoZSByb29tIHN0YXRlIHRvIGJlIHBvcHVsYXRlZCAoaGFwcGVucyBhZnRlciBjcmVhdGVSb29tIHJlc29sdmVzKVxuICAgICAgICBnZXRSb29tJChtYXRyaXgsIHJvb21JZCkucGlwZShtZXJnZU1hcCgocm9vbSkgPT4gXG4gICAgICAgIC8vIHdhaXQgZm9yIGFkZHJlc3MgdG8gYmUgbW9uaXRvcmVkICYgb25saW5lIChhZnRlciBnZXR0aW5nIFJvb20gZm9yIGFkZHJlc3MpXG4gICAgICAgIC8vIGxhdGVzdCQgZW5zdXJlcyBpdCBoYXBwZW5zIGltbWVkaWF0ZWxseSBpZiBhbGwgY29uZGl0aW9ucyBhcmUgc2F0aXNmaWVkXG4gICAgICAgIGxhdGVzdCQucGlwZShwbHVjaygncHJlc2VuY2VzJywgYWRkcmVzcyksIG1hcCgocHJlc2VuY2UpID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHByZXNlbmNlID09PSBudWxsIHx8IHByZXNlbmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmVzZW5jZS5wYXlsb2FkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXZhaWxhYmxlKSA/IHByZXNlbmNlLnBheWxvYWQudXNlcklkIDogdW5kZWZpbmVkOyB9KSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgbWFwKCh1c2VySWQpID0+ICh7IHJvb20sIHVzZXJJZCB9KSkpKSwgXG4gICAgICAgIC8vIHdoZW4gdXNlciBpcyBvbmxpbmUsIGdldCByb29tIG1lbWJlciBmb3IgcGFydG5lcidzIHVzZXJJZFxuICAgICAgICAvLyB0aGlzIHN3aXRjaE1hcCB1bnN1YnNjcmliZXMgZnJvbSBwcmV2aW91cyB3YWl0IGlmIHVzZXJJZCBjaGFuZ2VzIG9yIGdvIG9mZmxpbmVcbiAgICAgICAgc3dpdGNoTWFwKCh7IHJvb20sIHVzZXJJZCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXVzZXJJZClcbiAgICAgICAgICAgICAgICByZXR1cm4gRU1QVFk7IC8vIHVzZXIgbm90IG1vbml0b3JlZCBvciBub3QgYXZhaWxhYmxlXG4gICAgICAgICAgICBjb25zdCBtZW1iZXIgPSByb29tLmdldE1lbWJlcih1c2VySWQpO1xuICAgICAgICAgICAgLy8gaWYgaXQgYWxyZWFkeSBqb2luZWQgcm9vbSwgcmV0dXJuIGl0cyBtZW1iZXJzaGlwXG4gICAgICAgICAgICBpZiAobWVtYmVyICYmIG1lbWJlci5tZW1iZXJzaGlwID09PSAnam9pbicpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKG1lbWJlcik7XG4gICAgICAgICAgICAvLyBlbHNlLCB3YWl0IGZvciB0aGUgdXNlciB0byBqb2luL2FjY2VwdCBpbnZpdGVcbiAgICAgICAgICAgIHJldHVybiBmcm9tRXZlbnQobWF0cml4LCAnUm9vbU1lbWJlci5tZW1iZXJzaGlwJywgKHt9LCBtZW1iZXIpID0+IG1lbWJlcikucGlwZShmaWx0ZXIoKG1lbWJlcikgPT4gbWVtYmVyLnJvb21JZCA9PT0gcm9vbS5yb29tSWQgJiZcbiAgICAgICAgICAgICAgICBtZW1iZXIudXNlcklkID09PSB1c2VySWQgJiZcbiAgICAgICAgICAgICAgICBtZW1iZXIubWVtYmVyc2hpcCA9PT0gJ2pvaW4nKSk7XG4gICAgICAgIH0pLCBwbHVjaygncm9vbUlkJykpKSk7XG4gICAgfSksIHRha2UoMSksIC8vIHVzZSBmaXJzdCByb29tL3VzZXIgd2hpY2ggbWVldHMgYWxsIHJlcXVpcmVtZW50cy9maWx0ZXJzIGFib3ZlXG4gICAgbWVyZ2VNYXAoKHZpYSkgPT4gZGVmZXIoKCkgPT4gdHlwZW9mIHZpYSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBtYXRyaXguc2VuZEV2ZW50KHZpYSwgdHlwZSwgY29udGVudCwgJycpIC8vIHZpYSByb29tXG4gICAgICAgIDogdmlhLnNlbmQoY29udGVudC5ib2R5KSkucGlwZShcbiAgICAvLyB0aGlzIHJldHVybmVkIHZhbHVlIGlzIGp1c3QgZm9yIG5vdGlmaWNhdGlvbiwgYW5kIHNob3VsZG4ndCBiZSByZWxheWVkIG9uXG4gICAgLy8gYWxsIGZ1bmN0aW9uYWxpdHkgaXMgcHJvdmlkZWQgYXMgc2lkZSBlZmZlY3RzIG9mIHRoZSBzdWJzY3JpcHRpb25cbiAgICBtYXBUbyh0eXBlb2YgdmlhID09PSAnc3RyaW5nJyA/IHZpYSA6IHZpYS5sYWJlbCksIHJldHJ5V2hlbigoZXJyJCkgPT4gXG4gICAgLy8gaWYgc2VuZEV2ZW50IHRocm93cywgb21pdCAmIHJldHJ5IGFmdGVyIGh0dHBUaW1lb3V0IC8gTixcbiAgICAvLyB1cCB0byBSRVRSWV9DT1VOVCB0aW1lczsgaWYgaXQgY29udGludWVzIHRvIGVycm9yLCB0aHJvd3MgZG93blxuICAgIGVyciQucGlwZSh3aXRoTGF0ZXN0RnJvbShjb25maWckKSwgbWVyZ2VNYXAoKFtlcnIsIHsgaHR0cFRpbWVvdXQgfV0sIGkpID0+IHtcbiAgICAgICAgaWYgKGkgPCBSRVRSWV9DT1VOVCAtIDEpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKGBtZXNzYWdlU2VuZCBlcnJvciwgcmV0cnlpbmcgJHtpICsgMX0vJHtSRVRSWV9DT1VOVH1gLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVyKGh0dHBUaW1lb3V0IC8gUkVUUllfQ09VTlQpO1xuICAgICAgICAgICAgLy8gZ2l2ZSB1cFxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycik7XG4gICAgfSkpKSkpKTtcbn1cbi8qKlxuICogSGFuZGxlcyBhIFtbbWVzc2FnZVNlbmQucmVxdWVzdF1dIGFjdGlvbiBhbmQgc2VuZCBpdHMgbWVzc2FnZSB0byB0aGUgZmlyc3Qgcm9vbSBvbiBxdWV1ZSBmb3JcbiAqIGFkZHJlc3NcbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgbWVzc2FnZVNlbmQucmVxdWVzdCBhY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEBwYXJhbSBtYXRyaXgkIC0gUmFpZGVuRXBpY0RlcHMgbWVtYmVyc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBtZXNzYWdlU2VuZC5zdWNjZXNzIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IG1hdHJpeE1lc3NhZ2VTZW5kRXBpYyA9IChhY3Rpb24kLCB7fSwgeyBsb2csIG1hdHJpeCQsIGNvbmZpZyQsIGxhdGVzdCQgfSkgPT4gYWN0aW9uJC5waXBlKGZpbHRlcihpc0FjdGlvbk9mKG1lc3NhZ2VTZW5kLnJlcXVlc3QpKSwgXG4vLyB0aGlzIG1lcmdlTWFwIGlzIGxpa2Ugd2l0aExhdGVzdEZyb20sIGJ1dCB3YWl0cyB1bnRpbCBtYXRyaXgkIGVtaXRzIGl0cyBvbmx5IHZhbHVlXG5tZXJnZU1hcCgoYWN0aW9uKSA9PiBtYXRyaXgkLnBpcGUobWFwKChtYXRyaXgpID0+ICh7IGFjdGlvbiwgbWF0cml4IH0pKSkpLCBncm91cEJ5KCh7IGFjdGlvbiB9KSA9PiBhY3Rpb24ubWV0YS5hZGRyZXNzKSwgXG4vLyBtZXJnZSBhbGwgaW5uZXIvZ3JvdXBlZCBvYnNlcnZhYmxlcywgc28gZGlmZmVyZW50IHVzZXIncyBcInF1ZXVlc1wiIGNhbiBiZSBwYXJhbGxlbFxubWVyZ2VNYXAoKGdyb3VwZWQkKSA9PiBcbi8vIHBlci11c2VyIFwicXVldWVcIlxuZ3JvdXBlZCQucGlwZShcbi8vIGVhY2ggcGVyLXVzZXIgXCJxdWV1ZVwiIChvYnNlcnZhYmxlKSBhcmUgcHJvY2Vzc2VkIHNlcmlhbGx5IChiZWNhdXNlIGNvbmNhdE1hcClcbi8vIFRPRE86IGJhdGNoIGFsbCBwZW5kaW5nIG1lc3NhZ2VzIGluIGEgc2luZ2xlIHNlbmQgbWVzc2FnZSByZXF1ZXN0LCB3aXRoIHJldHJ5XG5jb25jYXRNYXAoKHsgYWN0aW9uLCBtYXRyaXggfSkgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSB0eXBlb2YgYWN0aW9uLnBheWxvYWQubWVzc2FnZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlXG4gICAgICAgIDogZW5jb2RlSnNvbk1lc3NhZ2UoYWN0aW9uLnBheWxvYWQubWVzc2FnZSk7XG4gICAgY29uc3QgY29udGVudCA9IHsgYm9keSwgbXNndHlwZTogJ20udGV4dCcgfTtcbiAgICAvLyB3YWl0IGZvciBhZGRyZXNzIHRvIGJlIG1vbml0b3JlZCwgb25saW5lICYgaGF2ZSBqb2luZWQgYSBub24tZ2xvYmFsIHJvb20gd2l0aCB1c1xuICAgIHJldHVybiB3YWl0TWVtYmVyQW5kU2VuZCQoYWN0aW9uLm1ldGEuYWRkcmVzcywgbWF0cml4LCAnbS5yb29tLm1lc3NhZ2UnLCBjb250ZW50LCB7IGxvZywgbGF0ZXN0JCwgY29uZmlnJCB9LCB0cnVlKS5waXBlKG1hcFRvKG1lc3NhZ2VTZW5kLnN1Y2Nlc3ModW5kZWZpbmVkLCBhY3Rpb24ubWV0YSkpLCBjYXRjaEVycm9yKChlcnIpID0+IHtcbiAgICAgICAgbG9nLmVycm9yKCdtZXNzYWdlU2VuZCBlcnJvcicsIGVyciwgYWN0aW9uLm1ldGEpO1xuICAgICAgICByZXR1cm4gb2YobWVzc2FnZVNlbmQuZmFpbHVyZShlcnIsIGFjdGlvbi5tZXRhKSk7XG4gICAgfSkpO1xufSkpKSk7XG4vKipcbiAqIEhhbmRsZXMgYSBbW21lc3NhZ2VHbG9iYWxTZW5kXV0gYWN0aW9uIGFuZCBzZW5kIG9uZS1zaG90IG1lc3NhZ2UgdG8gYSBnbG9iYWwgcm9vbVxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBtZXNzYWdlR2xvYmFsU2VuZCBhY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEBwYXJhbSBtYXRyaXgkIC0gUmFpZGVuRXBpY0RlcHMgbWVtYmVyc1xuICogQHJldHVybnMgRW1wdHkgb2JzZXJ2YWJsZSAod2hvbGUgc2lkZS1lZmZlY3Qgb24gbWF0cml4IGluc3RhbmNlKVxuICovXG5leHBvcnQgY29uc3QgbWF0cml4TWVzc2FnZUdsb2JhbFNlbmRFcGljID0gKGFjdGlvbiQsIHt9LCB7IGxvZywgbWF0cml4JCwgY29uZmlnJCB9KSA9PiBcbi8vIGFjdHVhbCBvdXRwdXQgb2JzZXJ2YWJsZSwgZ2V0cy93YWl0IGZvciB0aGUgdXNlciB0byBiZSBpbiBhIHJvb20sIGFuZCB0aGVuIHNlbmRNZXNzYWdlXG5hY3Rpb24kLnBpcGUoZmlsdGVyKGlzQWN0aW9uT2YobWVzc2FnZUdsb2JhbFNlbmQpKSwgXG4vLyB0aGlzIG1lcmdlTWFwIGlzIGxpa2Ugd2l0aExhdGVzdEZyb20sIGJ1dCB3YWl0cyB1bnRpbCBtYXRyaXgkIGVtaXRzIGl0cyBvbmx5IHZhbHVlXG5tZXJnZU1hcCgoYWN0aW9uKSA9PiBtYXRyaXgkLnBpcGUobWFwKChtYXRyaXgpID0+ICh7IGFjdGlvbiwgbWF0cml4IH0pKSkpLCB3aXRoTGF0ZXN0RnJvbShjb25maWckKSwgbWVyZ2VNYXAoKFt7IGFjdGlvbiwgbWF0cml4IH0sIGNvbmZpZ10pID0+IHtcbiAgICBjb25zdCBnbG9iYWxSb29tcyA9IGdsb2JhbFJvb21OYW1lcyhjb25maWcpO1xuICAgIGlmICghZ2xvYmFsUm9vbXMuaW5jbHVkZXMoYWN0aW9uLm1ldGEucm9vbU5hbWUpKSB7XG4gICAgICAgIGxvZy53YXJuKCdtZXNzYWdlR2xvYmFsU2VuZCBmb3IgdW5rbm93biBnbG9iYWwgcm9vbSwgaWdub3JpbmcnLCBhY3Rpb24ubWV0YS5yb29tTmFtZSwgZ2xvYmFsUm9vbXMpO1xuICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgfVxuICAgIGNvbnN0IHNlcnZlck5hbWUgPSBnZXRTZXJ2ZXJOYW1lKG1hdHJpeC5nZXRIb21lc2VydmVyVXJsKCkpLCByb29tQWxpYXMgPSBgIyR7YWN0aW9uLm1ldGEucm9vbU5hbWV9OiR7c2VydmVyTmFtZX1gO1xuICAgIHJldHVybiBnZXRSb29tJChtYXRyaXgsIHJvb21BbGlhcykucGlwZShcbiAgICAvLyBzZW5kIG1lc3NhZ2UhXG4gICAgbWVyZ2VNYXAoKHJvb20pID0+IHtcbiAgICAgICAgY29uc3QgYm9keSA9IHR5cGVvZiBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlXG4gICAgICAgICAgICA6IGVuY29kZUpzb25NZXNzYWdlKGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbWF0cml4LnNlbmRFdmVudChyb29tLnJvb21JZCwgJ20ucm9vbS5tZXNzYWdlJywgeyBib2R5LCBtc2d0eXBlOiAnbS50ZXh0JyB9LCAnJyk7XG4gICAgfSksIGNhdGNoRXJyb3IoKGVycikgPT4ge1xuICAgICAgICBsb2cuZXJyb3IoJ0Vycm9yIHNlbmRpbmcgbWVzc2FnZSB0byBnbG9iYWwgcm9vbScsIGFjdGlvbi5tZXRhLCBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlLCBlcnIpO1xuICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgfSkpO1xufSksIGlnbm9yZUVsZW1lbnRzKCkpO1xuZnVuY3Rpb24gcGFyc2VNZXNzYWdlKGxpbmUsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuYWRkcmVzcywgeyBsb2cgfSkge1xuICAgIGlmICh0eXBlb2YgbGluZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2RlSnNvbk1lc3NhZ2UobGluZSk7XG4gICAgICAgIC8vIGlmIFNpZ25lZCwgYWNjZXB0IG9ubHkgaWYgc2lnbmF0dXJlIG1hdGNoZXMgc2VuZGVyIGFkZHJlc3NcbiAgICAgICAgaWYgKCdzaWduYXR1cmUnIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lciA9IGdldE1lc3NhZ2VTaWduZXIobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoc2lnbmVyICE9PSBhZGRyZXNzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYWlkZW5FcnJvcihFcnJvckNvZGVzLlRSTlNfTUVTU0FHRV9TSUdOQVRVUkVfTUlTTUFUQ0gsIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBzaWduZXIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nLndhcm4oYENvdWxkIG5vdCBkZWNvZGUgbWVzc2FnZTogJHtsaW5lfTogJHtlcnJ9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gbWF0cml4IG1lc3NhZ2VzIGFuZCBlbWl0cyBNZXNzYWdlUmVjZWl2ZWRBY3Rpb24gdXBvbiByZWNlaXZpbmcgYSB2YWxpZCBtZXNzYWdlIGZyb21cbiAqIGFuIHVzZXIgb2YgaW50ZXJlc3QgKG9uZSB2YWxpZCBzaWduYXR1cmUgZnJvbSBhbiBhZGRyZXNzIHdlIG1vbml0b3IpIGluIGEgcm9vbSB3ZSBoYXZlIGZvciB0aGVtXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlbkFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHBhcmFtIG1hdHJpeCQgLSBSYWlkZW5FcGljRGVwcyBtZW1iZXJzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIG1lc3NhZ2VSZWNlaXZlZCBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRyaXhNZXNzYWdlUmVjZWl2ZWRFcGljID0gKHt9LCB7fSwgeyBsb2csIG1hdHJpeCQsIGNvbmZpZyQsIGxhdGVzdCQgfSkgPT4gXG4vLyBnZXRzL3dhaXQgZm9yIHRoZSB1c2VyIHRvIGJlIGluIGEgcm9vbSwgYW5kIHRoZW4gc2VuZE1lc3NhZ2Vcbm1hdHJpeCQucGlwZShcbi8vIHdoZW4gbWF0cml4IGZpbmlzaGVzIGluaXRpYWxpemF0aW9uLCByZWdpc3RlciB0byBtYXRyaXggdGltZWxpbmUgZXZlbnRzXG5zd2l0Y2hNYXAoKG1hdHJpeCkgPT4gZnJvbUV2ZW50KG1hdHJpeCwgJ1Jvb20udGltZWxpbmUnLCAoZXZlbnQsIHJvb20pID0+ICh7IG1hdHJpeCwgZXZlbnQsIHJvb20gfSkpKSwgd2l0aExhdGVzdEZyb20oY29uZmlnJCksIFxuLy8gZmlsdGVyIGZvciB0ZXh0IG1lc3NhZ2VzIG5vdCBmcm9tIHVzIGFuZCBub3QgZnJvbSBnbG9iYWwgcm9vbXNcbmZpbHRlcigoW3sgbWF0cml4LCBldmVudCwgcm9vbSB9LCBjb25maWddKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gZXZlbnQuZ2V0VHlwZSgpID09PSAnbS5yb29tLm1lc3NhZ2UnICYmXG4gICAgICAgICgoX2IgPSAoX2EgPSBldmVudC5ldmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tc2d0eXBlKSA9PT0gJ20udGV4dCcgJiZcbiAgICAgICAgZXZlbnQuZ2V0U2VuZGVyKCkgIT09IG1hdHJpeC5nZXRVc2VySWQoKSAmJlxuICAgICAgICAhZ2xvYmFsUm9vbU5hbWVzKGNvbmZpZykuc29tZSgoZykgPT4gXG4gICAgICAgIC8vIGdlbmVyYXRlIGFuIGFsaWFzIGZvciBnbG9iYWwgcm9vbSBvZiBnaXZlbiBuYW1lLCBhbmQgY2hlY2sgaWYgcm9vbSBtYXRjaGVzXG4gICAgICAgIHJvb21NYXRjaChgIyR7Z306JHtnZXRTZXJ2ZXJOYW1lKG1hdHJpeC5nZXRIb21lc2VydmVyVXJsKCkpfWAsIHJvb20pKTtcbn0pLCBtZXJnZU1hcCgoW3sgZXZlbnQsIHJvb20gfSwgeyBodHRwVGltZW91dCB9XSkgPT4gbGF0ZXN0JC5waXBlKGZpbHRlcigoeyBwcmVzZW5jZXMsIHN0YXRlIH0pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBwcmVzZW5jZSA9IGZpbmQocHJlc2VuY2VzLCBbJ3BheWxvYWQudXNlcklkJywgZXZlbnQuZ2V0U2VuZGVyKCldKTtcbiAgICBpZiAoIXByZXNlbmNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgcm9vbXMgPSAoX2MgPSAoX2IgPSAoX2EgPSBzdGF0ZS50cmFuc3BvcnQubWF0cml4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eucm9vbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltwcmVzZW5jZS5tZXRhLmFkZHJlc3NdKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICBpZiAoIXJvb21zLmluY2x1ZGVzKHJvb20ucm9vbUlkKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufSksIHRha2UoMSksIFxuLy8gdGFrZSB1cCB0byBhbiBhcmJpdHJhcnkgdGltZW91dCB0byBwcmVzZW5jZSBzdGF0dXMgZm9yIHRoZSBzZW5kZXJcbi8vIEFORCB0aGUgcm9vbSBpbiB3aGljaCB0aGlzIG1lc3NhZ2Ugd2FzIHNlbnQgdG8gYmUgaW4gc2VuZGVyJ3MgYWRkcmVzcyByb29tIHF1ZXVlXG50YWtlVW50aWwodGltZXIoaHR0cFRpbWVvdXQpKSwgbWVyZ2VNYXAoZnVuY3Rpb24qICh7IHByZXNlbmNlcyB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHByZXNlbmNlID0gZmluZChwcmVzZW5jZXMsIFsncGF5bG9hZC51c2VySWQnLCBldmVudC5nZXRTZW5kZXIoKV0pO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiAoZXZlbnQuZXZlbnQuY29udGVudC5ib2R5IHx8ICcnKS5zcGxpdCgnXFxuJykpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHBhcnNlTWVzc2FnZShsaW5lLCBwcmVzZW5jZS5tZXRhLmFkZHJlc3MsIHsgbG9nIH0pO1xuICAgICAgICB5aWVsZCBtZXNzYWdlUmVjZWl2ZWQoe1xuICAgICAgICAgICAgdGV4dDogbGluZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICB0czogKF9hID0gZXZlbnQuZXZlbnQub3JpZ2luX3NlcnZlcl90cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHVzZXJJZDogcHJlc2VuY2UucGF5bG9hZC51c2VySWQsXG4gICAgICAgICAgICByb29tSWQ6IHJvb20ucm9vbUlkLFxuICAgICAgICB9LCBwcmVzZW5jZS5tZXRhKTtcbiAgICB9XG59KSkpKTtcbi8qKlxuICogSWYgbWF0cml4IHJlY2VpdmVkIGEgbWVzc2FnZSBmcm9tIHVzZXIgaW4gYSByb29tIHdlIGhhdmUgd2l0aCB0aGVtLCBidXQgbm90IHRoZSBmaXJzdCBvbiBxdWV1ZSxcbiAqIHVwZGF0ZSBxdWV1ZSBzbyB0aGlzIHJvb20gZ29lcyB0byB0aGUgZnJvbnQgYW5kIHdpbGwgYmUgdXNlZCBhcyBzZW5kIG1lc3NhZ2Ugcm9vbSBmcm9tIG5vdyBvblxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBtZXNzYWdlUmVjZWl2ZWQgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIG1hdHJpeFJvb20gYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgbWF0cml4TWVzc2FnZVJlY2VpdmVkVXBkYXRlUm9vbUVwaWMgPSAoYWN0aW9uJCwgc3RhdGUkKSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKG1lc3NhZ2VSZWNlaXZlZC5pcyksIHdpdGhMYXRlc3RGcm9tKHN0YXRlJCksIGZpbHRlcigoW2FjdGlvbiwgc3RhdGVdKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3Qgcm9vbXMgPSAoX2MgPSAoX2IgPSAoX2EgPSBzdGF0ZS50cmFuc3BvcnQubWF0cml4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eucm9vbXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlthY3Rpb24ubWV0YS5hZGRyZXNzXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW107XG4gICAgcmV0dXJuICghIWFjdGlvbi5wYXlsb2FkLnJvb21JZCAmJlxuICAgICAgICByb29tcy5pbmNsdWRlcyhhY3Rpb24ucGF5bG9hZC5yb29tSWQpICYmXG4gICAgICAgIHJvb21zWzBdICE9PSBhY3Rpb24ucGF5bG9hZC5yb29tSWQpO1xufSksIG1hcCgoW2FjdGlvbl0pID0+IG1hdHJpeFJvb20oeyByb29tSWQ6IGFjdGlvbi5wYXlsb2FkLnJvb21JZCB9LCBhY3Rpb24ubWV0YSkpKTtcbi8qKlxuICogQ2hhbm5lbCBtb25pdG9yaW5nIHRyaWdnZXJzIG1hdHJpeCBwcmVzZW5jZSBtb25pdG9yaW5nIGZvciBwYXJ0bmVyXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlbkFjdGlvbnNcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgbWF0cml4UHJlc2VuY2UucmVxdWVzdCBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRyaXhNb25pdG9yQ2hhbm5lbFByZXNlbmNlRXBpYyA9IChhY3Rpb24kKSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzQWN0aW9uT2YoY2hhbm5lbE1vbml0b3IpKSwgbWFwKChhY3Rpb24pID0+IG1hdHJpeFByZXNlbmNlLnJlcXVlc3QodW5kZWZpbmVkLCB7IGFkZHJlc3M6IGFjdGlvbi5tZXRhLnBhcnRuZXIgfSkpKTtcbi8qKlxuICogU2VuZHMgRGVsaXZlcmVkIGZvciBzcGVjaWZpYyBtZXNzYWdlc1xuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBtZXNzYWdlUmVjZWl2ZWQgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gc2lnbmVyIC0gUmFpZGVuRXBpY0RlcHMgbWVtYmVyc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBtZXNzYWdlU2VuZC5yZXF1ZXN0IGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGRlbGl2ZXJlZEVwaWMgPSAoYWN0aW9uJCwge30sIHsgbG9nLCBzaWduZXIsIGxhdGVzdCQgfSkgPT4ge1xuICAgIGNvbnN0IGNhY2hlID0gbmV3IExydUNhY2hlKDMyKTtcbiAgICByZXR1cm4gYWN0aW9uJC5waXBlKGZpbHRlcihpc01lc3NhZ2VSZWNlaXZlZE9mVHlwZShbU2lnbmVkKFByb2Nlc3NlZCksIFNpZ25lZChTZWNyZXRSZXF1ZXN0KSwgU2lnbmVkKFNlY3JldFJldmVhbCldKSksIHdpdGhMYXRlc3RGcm9tKGxhdGVzdCQpLCBmaWx0ZXIoKFthY3Rpb24sIHsgcHJlc2VuY2VzIH1dKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5tZXRhLmFkZHJlc3MgaW4gcHJlc2VuY2VzICYmXG4gICAgICAgICAgICAvLyBza2lwIGlmIHBlZXIgc3VwcG9ydHMgQ2FwYWJpbGl0aWVzLk5PX0RFTElWRVJZXG4gICAgICAgICAgICAhKChfYSA9IHByZXNlbmNlc1thY3Rpb24ubWV0YS5hZGRyZXNzXS5wYXlsb2FkLmNhcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtDYXBhYmlsaXRpZXMuTk9fREVMSVZFUlldKTtcbiAgICB9KSwgY29uY2F0TWFwKChbYWN0aW9uXSkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYWN0aW9uLnBheWxvYWQubWVzc2FnZTtcbiAgICAgICAgLy8gZGVmZXIgY2F1c2VzIHRoZSBjYWNoZSBjaGVjayB0byBiZSBwZXJmb3JtZWQgYXQgc3Vic2NyaXB0aW9uIHRpbWVcbiAgICAgICAgcmV0dXJuIGRlZmVyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1zZ0lkID0gbWVzc2FnZS5tZXNzYWdlX2lkZW50aWZpZXI7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBtc2dJZC50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoY2FjaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBvZihtZXNzYWdlU2VuZC5yZXF1ZXN0KHsgbWVzc2FnZTogY2FjaGVkIH0sIHsgYWRkcmVzczogYWN0aW9uLm1ldGEuYWRkcmVzcywgbXNnSWQ6IGtleSB9KSk7XG4gICAgICAgICAgICBjb25zdCBkZWxpdmVyZWQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuREVMSVZFUkVELFxuICAgICAgICAgICAgICAgIGRlbGl2ZXJlZF9tZXNzYWdlX2lkZW50aWZpZXI6IG1zZ0lkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxvZy5pbmZvKGBTaWduaW5nIFwiJHtkZWxpdmVyZWQudHlwZX1cIiBmb3IgXCIke21lc3NhZ2UudHlwZX1cIiB3aXRoIGlkPSR7bXNnSWQudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tKHNpZ25NZXNzYWdlKHNpZ25lciwgZGVsaXZlcmVkLCB7IGxvZyB9KSkucGlwZSh0YXAoKHNpZ25lZCkgPT4gY2FjaGUucHV0KGtleSwgc2lnbmVkKSksIG1hcCgoc2lnbmVkKSA9PiBtZXNzYWdlU2VuZC5yZXF1ZXN0KHsgbWVzc2FnZTogc2lnbmVkIH0sIHsgYWRkcmVzczogYWN0aW9uLm1ldGEuYWRkcmVzcywgbXNnSWQ6IGtleSB9KSkpO1xuICAgICAgICB9KTtcbiAgICB9KSk7XG59O1xuLy8gZmV0Y2hlcyBhbmQgY2FjaGVzIG1hdHJpeCBzZXQgdHVyblNlcnZlclxuY29uc3QgX21hdHJpeEljZVNlcnZlcnNDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBnZXRNYXRyaXhJY2VTZXJ2ZXJzKG1hdHJpeCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IF9tYXRyaXhJY2VTZXJ2ZXJzQ2FjaGUuZ2V0KG1hdHJpeCk7XG4gICAgICAgIGlmIChjYWNoZWQgJiYgRGF0ZS5ub3coKSA8IGNhY2hlZFswXSlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRbMV07XG4gICAgICAgIGNvbnN0IGZldGNoZWQgPSAoeWllbGQgbWF0cml4LnR1cm5TZXJ2ZXIoKSk7XG4gICAgICAgIC8vIGlmIHJlcXVlc3QgcmV0dXJucyBub3RoaW5nLCBjYWNoZXMgZW1wdHkgbGlzdCBmb3IgMWhcbiAgICAgICAgbGV0IGV4cGlyZSA9IERhdGUubm93KCkgKyAzNmU1O1xuICAgICAgICBjb25zdCBzZXJ2ZXJzID0gW107XG4gICAgICAgIGlmIChmZXRjaGVkICYmICd1cmlzJyBpbiBmZXRjaGVkKSB7XG4gICAgICAgICAgICBzZXJ2ZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHVybHM6IGZldGNoZWQudXJpcyxcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogZmV0Y2hlZC51c2VybmFtZSxcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsVHlwZTogJ3Bhc3N3b3JkJyxcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsOiBmZXRjaGVkLnBhc3N3b3JkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBpcmUgPSBEYXRlLm5vdygpICsgZmV0Y2hlZC50dGwgKiAxZTM7XG4gICAgICAgIH1cbiAgICAgICAgX21hdHJpeEljZVNlcnZlcnNDYWNoZS5zZXQobWF0cml4LCBbZXhwaXJlLCBzZXJ2ZXJzXSk7XG4gICAgICAgIHJldHVybiBzZXJ2ZXJzO1xuICAgIH0pO1xufVxuLy8gY3JlYXRlcyBhIGZpbHRlciBmdW5jdGlvbiB3aGljaCBmaWx0ZXJzIHZhbGlkIE1hdHJpeEV2ZW50c1xuZnVuY3Rpb24gZmlsdGVyTWF0cml4Vm9pcEV2ZW50cyh0eXBlLCBzZW5kZXIsIGNhbGxJZCwgaHR0cFRpbWVvdXQpIHtcbiAgICBjb25zdCBjb250ZW50S2V5ID0gKHR5cGUgPT09ICdtLmNhbGwuaW52aXRlJ1xuICAgICAgICA/ICdvZmZlcidcbiAgICAgICAgOiB0eXBlID09PSAnbS5jYWxsLmFuc3dlcidcbiAgICAgICAgICAgID8gJ2Fuc3dlcidcbiAgICAgICAgICAgIDogdHlwZSA9PT0gJ20uY2FsbC5jYW5kaWRhdGVzJ1xuICAgICAgICAgICAgICAgID8gJ2NhbmRpZGF0ZXMnXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIHJldHVybiAoXG4gICAgLy8gRklYTUU6IHJlbW92ZSBhbnkgd2hlbiBNYXRyaXhFdmVudCB0eXBlIGV4cG9zZXMgZ2V0QWdlICYgZ2V0Q29udGVudCBtZXRob2RzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBldmVudCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHJldHVybiBldmVudC5nZXRUeXBlKCkgPT09IHR5cGUgJiZcbiAgICAgICAgICAgIGV2ZW50LmdldFNlbmRlcigpID09PSBzZW5kZXIgJiZcbiAgICAgICAgICAgICgoX2EgPSBldmVudC5nZXRDb250ZW50KCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsX2lkKSA9PT0gY2FsbElkICYmXG4gICAgICAgICAgICAoIWh0dHBUaW1lb3V0IHx8IGV2ZW50LmdldEFnZSgpIDw9ICgoX2MgPSAoX2IgPSBldmVudC5nZXRDb250ZW50KCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5saWZldGltZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogaHR0cFRpbWVvdXQpKSAmJlxuICAgICAgICAgICAgKCFjb250ZW50S2V5IHx8ICEhKChfZCA9IGV2ZW50LmdldENvbnRlbnQoKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kW2NvbnRlbnRLZXldKSk7XG4gICAgfTtcbn1cbi8vIHNldHVwIGNhbmRpZGF0ZXMkIGhhbmRsZXJzXG5mdW5jdGlvbiBoYW5kbGVDYW5kaWRhdGVzJChjb25uZWN0aW9uLCBtYXRyaXgsIHN0YXJ0JCwgeyBjYWxsSWQsIHBlZXJJZCwgcGVlckFkZHJlc3MgfSwgeyBsb2csIGxhdGVzdCQsIGNvbmZpZyQgfSkge1xuICAgIHJldHVybiBtZXJnZShcbiAgICAvLyB3aGVuIHNlZWluZyBhbiBpY2VjYW5kaWRhdGUsIHNlbmQgaXQgdG8gcGVlclxuICAgIGZyb21FdmVudChjb25uZWN0aW9uLCAnaWNlY2FuZGlkYXRlJykucGlwZShwbHVjaygnY2FuZGlkYXRlJyksIGRlbGF5V2hlbigoKSA9PiBzdGFydCQpLCB0YWtlV2hpbGUoaXNudE5pbCksIGJ1ZmZlclRpbWUoMTApLCBmaWx0ZXIoKGNhbmRpZGF0ZXMpID0+IGNhbmRpZGF0ZXMubGVuZ3RoID4gMCksIHRhcCgoZSkgPT4gbG9nLmRlYnVnKCdSVEM6IGdvdCBjYW5kaWRhdGVzJywgY2FsbElkLCBlKSksIG1lcmdlTWFwKChjYW5kaWRhdGVzKSA9PiB3YWl0TWVtYmVyQW5kU2VuZCQocGVlckFkZHJlc3MsIG1hdHJpeCwgJ20uY2FsbC5jYW5kaWRhdGVzJywgeyBjYWxsX2lkOiBjYWxsSWQsIHZlcnNpb246IDAsIGNhbmRpZGF0ZXMgfSwgeyBsb2csIGxhdGVzdCQsIGNvbmZpZyQgfSkpKSwgXG4gICAgLy8gd2hlbiByZWNlaXZpbmcgY2FuZGlkYXRlcyBmcm9tIHBlZXIsIGFkZCBpdCBsb2NhbGx5XG4gICAgZnJvbUV2ZW50KG1hdHJpeCwgJ2V2ZW50JykucGlwZShmaWx0ZXIoZmlsdGVyTWF0cml4Vm9pcEV2ZW50cygnbS5jYWxsLmNhbmRpZGF0ZXMnLCBwZWVySWQsIGNhbGxJZCkpLCB0YXAoKGUpID0+IGxvZy5kZWJ1ZygnUlRDOiByZWNlaXZlZCBjYW5kaWRhdGVzJywgY2FsbElkLCBlLmdldENvbnRlbnQoKS5jYW5kaWRhdGVzKSksIG1lcmdlTWFwKChldmVudCkgPT4geyB2YXIgX2E7IHJldHVybiBmcm9tKChfYSA9IGV2ZW50LmdldENvbnRlbnQoKS5jYW5kaWRhdGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7IH0pLCBtZXJnZU1hcCgoY2FuZGlkYXRlKSA9PiBkZWZlcigoKSA9PiBjb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpKS5waXBlKGNhdGNoRXJyb3IoKGVycikgPT4ge1xuICAgICAgICBsb2cuZXJyb3IoJ1JUQzogZXJyb3Igc2V0dGluZyBjYW5kaWRhdGUsIGlnbm9yaW5nJywgZXJyKTtcbiAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIH0pKSkpKS5waXBlKGlnbm9yZUVsZW1lbnRzKCkpO1xufVxuLy8gc2V0dXAgUlRDIGRhdGEgY2hhbm5lbCBmb3IgY2FsbGVyXG5mdW5jdGlvbiBzZXR1cENhbGxlckRhdGFDaGFubmVsJChtYXRyaXgsIHN0YXJ0JCwgaW5mbywgeyBodHRwVGltZW91dCwgZmFsbGJhY2tJY2VTZXJ2ZXJzIH0sIGRlcHMpIHtcbiAgICBjb25zdCB7IGNhbGxJZCwgcGVlcklkLCBwZWVyQWRkcmVzcyB9ID0gaW5mbztcbiAgICBjb25zdCB7IGxvZywgbGF0ZXN0JCwgY29uZmlnJCB9ID0gZGVwcztcbiAgICByZXR1cm4gZnJvbShnZXRNYXRyaXhJY2VTZXJ2ZXJzKG1hdHJpeCkpLnBpcGUobWVyZ2VNYXAoKG1hdHJpeFR1cm5TZXJ2ZXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogWy4uLm1hdHJpeFR1cm5TZXJ2ZXJzLCAuLi5mYWxsYmFja0ljZVNlcnZlcnNdLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gd2UgcmVsYXkgb24gcmV0cmllcywgbm8gbmVlZCB0byBlbmZvcmNlIG9yZGVyZWRcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSBjb25uZWN0aW9uLmNyZWF0ZURhdGFDaGFubmVsKGNhbGxJZCwgeyBvcmRlcmVkOiBmYWxzZSB9KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlKFxuICAgICAgICAvLyBkZXNwaXRlICduZXZlcicgZW1pdHRpbmcsIGNhbmRpZGF0ZXMkIGhhdmUgc2lkZS1lZmZlY3RzIHdoaWxlL3doZW4gc3Vic2NyaWJlZFxuICAgICAgICBoYW5kbGVDYW5kaWRhdGVzJChjb25uZWN0aW9uLCBtYXRyaXgsIHN0YXJ0JCwgaW5mbywgZGVwcyksIGRlZmVyKCgpID0+IGNvbm5lY3Rpb24uY3JlYXRlT2ZmZXIoKSkucGlwZShtZXJnZU1hcCgob2ZmZXIpID0+IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0ge1xuICAgICAgICAgICAgICAgIGNhbGxfaWQ6IGNhbGxJZCxcbiAgICAgICAgICAgICAgICBsaWZldGltZTogaHR0cFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogMCxcbiAgICAgICAgICAgICAgICBvZmZlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2UoXG4gICAgICAgICAgICAvLyB3YWl0IGZvciBhbnN3ZXJcbiAgICAgICAgICAgIGZyb21FdmVudChtYXRyaXgsICdldmVudCcpLnBpcGUoZmlsdGVyKGZpbHRlck1hdHJpeFZvaXBFdmVudHMoJ20uY2FsbC5hbnN3ZXInLCBwZWVySWQsIGNhbGxJZCwgaHR0cFRpbWVvdXQpKSksIFxuICAgICAgICAgICAgLy8gc2VuZCBpbnZpdGUgd2l0aCBvZmZlclxuICAgICAgICAgICAgd2FpdE1lbWJlckFuZFNlbmQkKHBlZXJBZGRyZXNzLCBtYXRyaXgsICdtLmNhbGwuaW52aXRlJywgY29udGVudCwge1xuICAgICAgICAgICAgICAgIGxvZyxcbiAgICAgICAgICAgICAgICBsYXRlc3QkLFxuICAgICAgICAgICAgICAgIGNvbmZpZyQsXG4gICAgICAgICAgICB9KS5waXBlKHRhcCgoZSkgPT4gbG9nLmRlYnVnKCdSVEM6IHNlbnQgaW52aXRlJywgY2FsbElkLCBlKSksIGlnbm9yZUVsZW1lbnRzKCkpKTtcbiAgICAgICAgfSksIHRha2UoMSksIHRhcCgoKSA9PiBsb2cuaW5mbygnUlRDOiBnb3QgYW5zd2VyJywgY2FsbElkKSksIG1hcCgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24obmV3IFJUQ1Nlc3Npb25EZXNjcmlwdGlvbihldmVudC5nZXRDb250ZW50KCkuYW5zd2VyKSk7XG4gICAgICAgICAgICBzdGFydCQubmV4dChudWxsKTtcbiAgICAgICAgICAgIHN0YXJ0JC5jb21wbGV0ZSgpO1xuICAgICAgICB9KSwgaWdub3JlRWxlbWVudHMoKSksIG9mKGRhdGFDaGFubmVsKSk7XG4gICAgfSkpO1xufVxuLy8gc2V0dXAgUlRDIGRhdGEgY2hhbm5lbCBmb3IgY2FsbGVlXG5mdW5jdGlvbiBzZXR1cENhbGxlZURhdGFDaGFubmVsJChtYXRyaXgsIHN0YXJ0JCwgaW5mbywgeyBodHRwVGltZW91dCB9LCBkZXBzKSB7XG4gICAgY29uc3QgeyBjYWxsSWQsIHBlZXJJZCwgcGVlckFkZHJlc3MgfSA9IGluZm87XG4gICAgY29uc3QgeyBsb2csIGxhdGVzdCQsIGNvbmZpZyQgfSA9IGRlcHM7XG4gICAgcmV0dXJuIGZyb21FdmVudChtYXRyaXgsICdldmVudCcpLnBpcGUoZmlsdGVyKGZpbHRlck1hdHJpeFZvaXBFdmVudHMoJ20uY2FsbC5pbnZpdGUnLCBwZWVySWQsIGNhbGxJZCwgaHR0cFRpbWVvdXQpKSwgdGFwKCgpID0+IGxvZy5pbmZvKCdSVEM6IGdvdCBpbnZpdGUnLCBjYWxsSWQpKSwgbWVyZ2VNYXAoKGV2ZW50KSA9PiBmcm9tKGdldE1hdHJpeEljZVNlcnZlcnMobWF0cml4KSkucGlwZShtYXAoKHNlcnYpID0+IFtldmVudCwgc2Vydl0pKSksIHdpdGhMYXRlc3RGcm9tKGNvbmZpZyQpLCBtZXJnZU1hcCgoW1tldmVudCwgbWF0cml4VHVyblNlcnZlcnNdLCB7IGZhbGxiYWNrSWNlU2VydmVycyB9XSkgPT4ge1xuICAgICAgICAvLyBjcmVhdGUgY29ubmVjdGlvbiBvbmx5IHVwb24gaW52aXRlL29mZmVyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogWy4uLm1hdHJpeFR1cm5TZXJ2ZXJzLCAuLi5mYWxsYmFja0ljZVNlcnZlcnNdLFxuICAgICAgICB9KTtcbiAgICAgICAgY29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKGV2ZW50LmdldENvbnRlbnQoKS5vZmZlcikpO1xuICAgICAgICByZXR1cm4gbWVyZ2UoXG4gICAgICAgIC8vIGRlc3BpdGUgJ25ldmVyJyBlbWl0dGluZywgY2FuZGlkYXRlcyQgaGF2ZSBzaWRlLWVmZmVjdHMgd2hpbGUvd2hlbiBzdWJzY3JpYmVkXG4gICAgICAgIGhhbmRsZUNhbmRpZGF0ZXMkKGNvbm5lY3Rpb24sIG1hdHJpeCwgc3RhcnQkLCBpbmZvLCBkZXBzKSwgZGVmZXIoKCkgPT4gY29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKSkucGlwZShtZXJnZU1hcCgoYW5zd2VyKSA9PiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB7XG4gICAgICAgICAgICAgICAgY2FsbF9pZDogY2FsbElkLFxuICAgICAgICAgICAgICAgIGxpZmV0aW1lOiBodHRwVGltZW91dCxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICAgICAgICAgIGFuc3dlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBzZW5kIGFuc3dlclxuICAgICAgICAgICAgcmV0dXJuIHdhaXRNZW1iZXJBbmRTZW5kJChwZWVyQWRkcmVzcywgbWF0cml4LCAnbS5jYWxsLmFuc3dlcicsIGNvbnRlbnQsIHtcbiAgICAgICAgICAgICAgICBsb2csXG4gICAgICAgICAgICAgICAgbGF0ZXN0JCxcbiAgICAgICAgICAgICAgICBjb25maWckLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLCB0YXAoKGUpID0+IHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZygnUlRDOiBzZW50IGFuc3dlcicsIGNhbGxJZCwgZSk7XG4gICAgICAgICAgICBzdGFydCQubmV4dChudWxsKTtcbiAgICAgICAgICAgIHN0YXJ0JC5jb21wbGV0ZSgpO1xuICAgICAgICB9KSwgaWdub3JlRWxlbWVudHMoKSksIGZyb21FdmVudChjb25uZWN0aW9uLCAnZGF0YWNoYW5uZWwnKS5waXBlKHBsdWNrKCdjaGFubmVsJykpKTtcbiAgICB9KSwgdGFrZSgxKSk7XG59XG4vLyBzZXR1cCBsaXN0ZW5lcnMgJiBldmVudHMgZm9yIGEgZGF0YSBjaGFubmVsLCB3aGVuIGl0IGdldHMgb3BlbmVkLCBhbmQgdGVhcmRvd24gd2hlbiBjbG9zZWRcbmZ1bmN0aW9uIGxpc3RlbkRhdGFDaGFubmVsJChzdG9wJCwgeyBjYWxsSWQsIHBlZXJJZCwgcGVlckFkZHJlc3MgfSwgeyBodHRwVGltZW91dCB9LCB7IGxvZyB9KSB7XG4gICAgcmV0dXJuIChkYXRhQ2hhbm5lbCQpID0+IGRhdGFDaGFubmVsJC5waXBlKG1lcmdlTWFwKChkYXRhQ2hhbm5lbCkgPT4gbWVyZ2UoZnJvbUV2ZW50KGRhdGFDaGFubmVsLCAnY2xvc2UnKS5waXBlKHRhcCgoKSA9PiB7XG4gICAgICAgIGxvZy5pbmZvKCdSVEM6IGRhdGFDaGFubmVsIGNsb3NlJywgY2FsbElkKTtcbiAgICAgICAgc3RvcCQubmV4dChudWxsKTtcbiAgICAgICAgc3RvcCQuY29tcGxldGUoKTtcbiAgICB9KSwgaWdub3JlRWxlbWVudHMoKSksIGZyb21FdmVudChkYXRhQ2hhbm5lbCwgJ2Vycm9yJykucGlwZShtZXJnZU1hcCgoZXYpID0+IHRocm93RXJyb3IoZXYuZXJyb3IpKSksIGZyb21FdmVudChkYXRhQ2hhbm5lbCwgJ29wZW4nKS5waXBlKHRha2UoMSksIFxuICAgIC8vIHRoaXMgdGltZW91dCBlbnN1cmVzIHRoZSB3aG9sZSBkYXRhQ2hhbm5lbCQgb2JzZXJ2YWJsZSB0aHJvd3MgaWYgaXQgY2FuJ3QgYmUgc2V0IHVwLFxuICAgIC8vIHNvIGl0IGNhbiBiZSByZXRyaWVkL3JlcGVhdGVkL3Jlc3RhcnRlZC5cbiAgICAvLyBub3RpY2UgaXQgb25seSBzdGFydHMgYWZ0ZXIgZGF0YUNoYW5uZWwkIGVtaXRzLCBpLmUuIG9uIHN1YnNjcmlwdGlvbiBmb3IgY2FsbGVyIChhc1xuICAgIC8vIGl0IGNyZWF0ZURhdGFDaGFubmVsIG9iamVjdCwgdGhlbiByZXNwb25zaWJsZSBmb3IgaGFuZ2luZyB1cCBjYWxsIGFuZCByZXRyeWluZyksXG4gICAgLy8gYW5kIGFmdGVyICdkYXRhY2hhbm5lbCcgZXZlbnQgZm9yIGNhbGxlZSAocGFzc2l2ZSBsaXN0ZW5lcilcbiAgICB0aW1lb3V0KGh0dHBUaW1lb3V0IC8gMyksIHRhcCgoKSA9PiBsb2cuaW5mbygnUlRDOiBkYXRhQ2hhbm5lbCBvcGVuJywgY2FsbElkKSksIFxuICAgIC8vIG91dHB1dCBydGNDaGFubmVsIGFjdGlvbiB3aXRoIGRlZmluZWQgY2hhbm5lbCBpbnN0YW5jZSB0byBoYXZlIGl0IHNldCBpbiBsYXRlc3QkXG4gICAgbWFwVG8ocnRjQ2hhbm5lbChkYXRhQ2hhbm5lbCwgeyBhZGRyZXNzOiBwZWVyQWRkcmVzcyB9KSkpLCBmcm9tRXZlbnQoZGF0YUNoYW5uZWwsICdtZXNzYWdlJykucGlwZSh0YXAoKGUpID0+IGxvZy5kZWJ1ZygnUlRDOiBkYXRhQ2hhbm5lbCBtZXNzYWdlJywgY2FsbElkLCBlKSksIHBsdWNrKCdkYXRhJyksIGZpbHRlcigoZCkgPT4gdHlwZW9mIGQgPT09ICdzdHJpbmcnKSwgbWFwKChsaW5lKSA9PiBtZXNzYWdlUmVjZWl2ZWQoe1xuICAgICAgICB0ZXh0OiBsaW5lLFxuICAgICAgICBtZXNzYWdlOiBwYXJzZU1lc3NhZ2UobGluZSwgcGVlckFkZHJlc3MsIHsgbG9nIH0pLFxuICAgICAgICB0czogRGF0ZS5ub3coKSxcbiAgICAgICAgdXNlcklkOiBwZWVySWQsXG4gICAgfSwgeyBhZGRyZXNzOiBwZWVyQWRkcmVzcyB9KSkpKS5waXBlKGZpbmFsaXplKCgpID0+IGRhdGFDaGFubmVsLmNsb3NlKCkpKSksIHRha2VVbnRpbChzdG9wJCksIGNhdGNoRXJyb3IoKGVycikgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN0b3AkLm5leHQobnVsbCk7XG4gICAgICAgIHN0b3AkLmNvbXBsZXRlKCk7XG4gICAgICAgIGxvZy5pbmZvKFwiQ291bGRuJ3Qgc2V0IHVwIFdlYlJUQyBkYXRhQ2hhbm5lbCwgcmV0cnlpbmdcIiwgY2FsbElkLCAoX2EgPSBlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIubWVzc2FnZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXJyKTtcbiAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIH0pLCBcbiAgICAvLyBpZiBpdCBlbmRzIGJ5IHRha2VVbnRpbCBvciBjYXRjaEVycm9yLCBvdXRwdXQgcnRjQ2hhbm5lbCB0byByZXNldCBsYXRlc3QkIG1hcHBpbmdcbiAgICBlbmRXaXRoKHJ0Y0NoYW5uZWwodW5kZWZpbmVkLCB7IGFkZHJlc3M6IHBlZXJBZGRyZXNzIH0pKSk7XG59XG4vLyBoYW5kbGVzIHByZXNlbmNlIGNoYW5nZXMgZm9yIGEgc2luZ2xlIHBlZXIgYWRkcmVzcyAoZ3JvdXBlZClcbmZ1bmN0aW9uIGhhbmRsZVByZXNlbmNlQ2hhbmdlJChhY3Rpb24kLCBwcmVzZW5jZSQsIHsgbG9nLCBhZGRyZXNzLCBsYXRlc3QkLCBtYXRyaXgkLCBjb25maWckIH0pIHtcbiAgICByZXR1cm4gcHJlc2VuY2UkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKGEsIGIpID0+IGEucGF5bG9hZC51c2VySWQgPT09IGIucGF5bG9hZC51c2VySWQgJiYgYS5wYXlsb2FkLmF2YWlsYWJsZSA9PT0gYi5wYXlsb2FkLmF2YWlsYWJsZSksIHdpdGhMYXRlc3RGcm9tKG1hdHJpeCQsIGNvbmZpZyQpLCBmaWx0ZXIoKFthY3Rpb24sICwgeyBjYXBzIH1dKSA9PiB7IHZhciBfYTsgcmV0dXJuICEhKChfYSA9IGFjdGlvbi5wYXlsb2FkLmNhcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtDYXBhYmlsaXRpZXMuV0VCUlRDXSkgJiYgISEoY2FwcyA9PT0gbnVsbCB8fCBjYXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXBzW0NhcGFiaWxpdGllcy5XRUJSVENdKTsgfSksIHN3aXRjaE1hcCgoW2FjdGlvbiwgbWF0cml4LCBjb25maWddKSA9PiB7XG4gICAgICAgIC8vIGlmIHBlZXIgZ29lcyBvZmZsaW5lIGluIE1hdHJpeCwgcmVzZXQgZGF0YUNoYW5uZWwgJiB1bnN1YnNjcmliZSBkZWZlciB0byBjbG9zZSBkYXRhQ2hhbm5lbFxuICAgICAgICBpZiAoIWFjdGlvbi5wYXlsb2FkLmF2YWlsYWJsZSlcbiAgICAgICAgICAgIHJldHVybiBvZihydGNDaGFubmVsKHVuZGVmaW5lZCwgYWN0aW9uLm1ldGEpKTtcbiAgICAgICAgY29uc3QgZGVwcyA9IHsgbG9nLCBsYXRlc3QkLCBjb25maWckIH07XG4gICAgICAgIGNvbnN0IGNhbGxJZCA9IFthZGRyZXNzLCBhY3Rpb24ubWV0YS5hZGRyZXNzXVxuICAgICAgICAgICAgLm1hcCgoYSkgPT4gYS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSlcbiAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gICAgICAgIGNvbnN0IGlzQ2FsbGVyID0gY2FsbElkLnN0YXJ0c1dpdGgoYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgcmV0dXJuIGRlZmVyKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgICAgICAgICAgY2FsbElkLFxuICAgICAgICAgICAgICAgIHBlZXJJZDogYWN0aW9uLnBheWxvYWQudXNlcklkLFxuICAgICAgICAgICAgICAgIHBlZXJBZGRyZXNzOiBhY3Rpb24ubWV0YS5hZGRyZXNzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIHN0YXJ0JCBpbmRpY2F0ZXMgaW52aXRlL29mZmVyL2Fuc3dlciBjeWNsZSBjb21wbGV0ZWQsIGFuZCBjYW5kaWRhdGVzIGNhbiBiZSBleGNoYW5nZWRcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0JCA9IG5ldyBBc3luY1N1YmplY3QoKTtcbiAgICAgICAgICAgIC8vIHN0b3AkIGluZGljYXRlcyBkYXRhQ2hhbm5lbCBjbG9zZWQgKG1heWJlIGJ5IHBlZXIpLCBhbmQgdGVhcmRvd24gc2hvdWxkIHRha2UgcGxhY2VcbiAgICAgICAgICAgIGNvbnN0IHN0b3AkID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuICAgICAgICAgICAgbGV0IGRhdGFDaGFubmVsJDtcbiAgICAgICAgICAgIGlmIChpc0NhbGxlcikge1xuICAgICAgICAgICAgICAgIC8vIGNhbGxlclxuICAgICAgICAgICAgICAgIGRhdGFDaGFubmVsJCA9IHNldHVwQ2FsbGVyRGF0YUNoYW5uZWwkKG1hdHJpeCwgc3RhcnQkLCBpbmZvLCBjb25maWcsIGRlcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbGVlXG4gICAgICAgICAgICAgICAgZGF0YUNoYW5uZWwkID0gc2V0dXBDYWxsZWVEYXRhQ2hhbm5lbCQobWF0cml4LCBzdGFydCQsIGluZm8sIGNvbmZpZywgZGVwcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9wJFxuICAgICAgICAgICAgICAgIC5waXBlKG1lcmdlTWFwKCgpID0+IHdhaXRNZW1iZXJBbmRTZW5kJChhY3Rpb24ubWV0YS5hZGRyZXNzLCBtYXRyaXgsICdtLmNhbGwuaGFuZ3VwJywgeyBjYWxsX2lkOiBjYWxsSWQsIHZlcnNpb246IDAgfSwgeyBsb2csIGxhdGVzdCQsIGNvbmZpZyQgfSkucGlwZSh0YWtlVW50aWwodGltZXIoY29uZmlnLmh0dHBUaW1lb3V0IC8gMTApKSkpLCB0YWtlVW50aWwoYWN0aW9uJC5waXBlKGZpbHRlcihyYWlkZW5TaHV0ZG93bi5pcykpKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCk7IC8vIHdoZW4gc3RvcHBpbmcsIGlmIG5vdCBzaHV0dGluZyBkb3duLCBzZW5kIGhhbmd1cFxuICAgICAgICAgICAgLy8gbGlzdGVuRGF0YUNoYW5uZWwkIG5lZWRzIGNoYW5uZWwkOk9ic2VydmFibGU8UlRDRGF0YUNoYW5uZWw+LCBidXQgd2UgbXVzdCBpbmNsdWRlL21lcmdlXG4gICAgICAgICAgICAvLyBzZXR1cCBhbmQgbW9uaXRvcmluZyBPYnNlcnZhYmxlPG5ldmVyPidzIHRvIGdldCB0aGluZ3MgbW92aW5nIG9uIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlKGRhdGFDaGFubmVsJCwgXG4gICAgICAgICAgICAvLyB0aHJvd3MgbmFkIHJlc3RhcnQgaWYgcGVlciBoYW5ncyB1cFxuICAgICAgICAgICAgZnJvbUV2ZW50KG1hdHJpeCwgJ2V2ZW50JykucGlwZShmaWx0ZXIoZmlsdGVyTWF0cml4Vm9pcEV2ZW50cygnbS5jYWxsLmhhbmd1cCcsIGluZm8ucGVlcklkLCBjYWxsSWQpKSwgXG4gICAgICAgICAgICAvLyBubyBuZWVkIGZvciBzcGVjaWZpYyBlcnJvciBzaW5jZSB0aGlzIGlzIGp1c3QgbG9nZ2VkIGFuZCBpZ25vcmVkIGluIGxpc3RlbkRhdGFDaGFubmVsJFxuICAgICAgICAgICAgbWVyZ2VNYXBUbyh0aHJvd0Vycm9yKG5ldyBFcnJvcignUlRDOiBwZWVyIGh1bmcgdXAnKSkpKSkucGlwZShsaXN0ZW5EYXRhQ2hhbm5lbCQoc3RvcCQsIGluZm8sIGNvbmZpZywgZGVwcykpO1xuICAgICAgICB9KS5waXBlKFxuICAgICAgICAvLyBpZiBpdCBkaXNjb25uZWN0cyBmb3IgYW55IHJlYXNvbiwgYnV0IHBhcnRuZXIgaXMgc3RpbGwgb25saW5lLFxuICAgICAgICAvLyB0cnkgdG8gcmVjb25uZWN0IGJ5IHJlcGVhdGluZyBmcm9tICdkZWZlcidcbiAgICAgICAgcmVwZWF0V2hlbigoY29tcGxldGVkJCkgPT4gY29tcGxldGVkJC5waXBlKHdpdGhMYXRlc3RGcm9tKGxhdGVzdCQsIGNvbmZpZyQpLCBtZXJnZU1hcCgoWywgeyBwcmVzZW5jZXMgfSwgeyBodHRwVGltZW91dCB9XSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiAhKChfYiA9IChfYSA9IHByZXNlbmNlc1thY3Rpb24ubWV0YS5hZGRyZXNzXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBheWxvYWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hdmFpbGFibGUpXG4gICAgICAgICAgICAgICAgPyBFTVBUWVxuICAgICAgICAgICAgICAgIDogaXNDYWxsZXJcbiAgICAgICAgICAgICAgICAgICAgPyB0aW1lcihodHRwVGltZW91dCAvIDEwKSAvLyBjYWxsZXIgd2FpdHMgc29tZSB0aW1lIHRvIHJldHJ5XG4gICAgICAgICAgICAgICAgICAgIDogb2YobnVsbCk7XG4gICAgICAgIH0pKSkpO1xuICAgIH0pKTtcbn1cbmV4cG9ydCBjb25zdCBydGNDb25uZWN0RXBpYyA9IChhY3Rpb24kLCB7fSwgZGVwcykgPT4gYWN0aW9uJC5waXBlKGZpbHRlcihtYXRyaXhQcmVzZW5jZS5zdWNjZXNzLmlzKSwgZ3JvdXBCeSgoYWN0aW9uKSA9PiBhY3Rpb24ubWV0YS5hZGRyZXNzKSwgbWVyZ2VNYXAoKGdyb3VwZWQkKSA9PiBoYW5kbGVQcmVzZW5jZUNoYW5nZSQoYWN0aW9uJCwgZ3JvdXBlZCQsIGRlcHMpKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcGljcy5qcy5tYXAiLCJpbXBvcnQgeyBmcm9tIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1lcmdlTWFwLCB3aXRoTGF0ZXN0RnJvbSwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgY2hhbm5lbENsb3NlIH0gZnJvbSAnLi4vLi4vY2hhbm5lbHMvYWN0aW9ucyc7XG5pbXBvcnQgeyBnZXRCYWxhbmNlUHJvb2ZGcm9tRW52ZWxvcGVNZXNzYWdlIH0gZnJvbSAnLi4vLi4vbWVzc2FnZXMvdXRpbHMnO1xuaW1wb3J0IHsgaXNBY3Rpb25PZiB9IGZyb20gJy4uLy4uL3V0aWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgUmFpZGVuRXJyb3IsIEVycm9yQ29kZXMgfSBmcm9tICcuLi8uLi91dGlscy9lcnJvcic7XG5pbXBvcnQgeyBpc250TmlsIH0gZnJvbSAnLi4vLi4vdXRpbHMvdHlwZXMnO1xuaW1wb3J0IHsgdHJhbnNmZXIgfSBmcm9tICcuLi9hY3Rpb25zJztcbmltcG9ydCB7IERpcmVjdGlvbiB9IGZyb20gJy4uL3N0YXRlJztcbi8qKlxuICogQ29tcGxldGUgb3IgZmFpbCBhbnkgcGVuZGluZyB0cmFuc2ZlciBmb3IgYW55IGNsb3Npbmcgb3IgY2xvc2VkIGNoYW5uZWxzXG4gKiBUcmFuc2ZlciBpcyBjb25zaWRlcmVkIHN1Y2Nlc3NmdWwgaWYgc2VjcmV0IHdhcyByZXZlYWxlZCAoYXMgaXQgY291bGQgYmUgY2xhaW1lZCBvbi1jaGFpbiksXG4gKiBlbHNlIGl0J3MgY29uc2lkZXJlZCBhcyBmYWlsZWQgYXMgY291bGRuJ3Qgc3VjY2VlZCBpbnNpZGUgZXhwaXJhdGlvbiB0aW1lb3V0XG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIGNoYW5uZWxDbG9zZS57cmVxdWV0LHN1Y2Nlc3N9IGFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB0cmFuc2Zlci57c3VjY2Vzc3xmYWlsdXJlfSBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2ZlckNoYW5uZWxDbG9zZWRFcGljID0gKGFjdGlvbiQsIHN0YXRlJCwgeyBhZGRyZXNzIH0pID0+IGFjdGlvbiQucGlwZShmaWx0ZXIoaXNBY3Rpb25PZihbY2hhbm5lbENsb3NlLnJlcXVlc3QsIGNoYW5uZWxDbG9zZS5zdWNjZXNzXSkpLCB3aXRoTGF0ZXN0RnJvbShzdGF0ZSQpLCBtZXJnZU1hcCgoW2FjdGlvbiwgc3RhdGVdKSA9PiBmcm9tKE9iamVjdC5lbnRyaWVzKHN0YXRlLnNlbnQpKS5waXBlKGZpbHRlcigoWywgeyB0cmFuc2ZlcjogWywgdHJhbnNmXSwgfSxdKSA9PiB0cmFuc2YudG9rZW5fbmV0d29ya19hZGRyZXNzID09PSBhY3Rpb24ubWV0YS50b2tlbk5ldHdvcmsgJiZcbiAgICB0cmFuc2YucmVjaXBpZW50ID09PSBhY3Rpb24ubWV0YS5wYXJ0bmVyICYmXG4gICAgdHJhbnNmLmluaXRpYXRvciA9PT0gYWRkcmVzcyksIG1hcCgoW3NlY3JldGhhc2gsIHNlbnRdKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIC8vIGFzIHdlIGNhbid0IGtub3cgZm9yIHN1cmUgaWYgcmVjaXBpZW50L3BhcnRuZXIgcmVjZWl2ZWQgdGhlIHNlY3JldCBvciB1bmxvY2ssXG4gICAgLy9jb25zaWRlciB0cmFuc2ZlciBmYWlsZWQgaWZmIG5laXRoZXIgdGhlIHNlY3JldCB3YXMgcmV2ZWFsZWQgbm9yIHRoZSB1bmxvY2sgaGFwcGVuZWRcbiAgICBjb25zdCBtZXRhID0geyBzZWNyZXRoYXNoLCBkaXJlY3Rpb246IERpcmVjdGlvbi5TRU5UIH07XG4gICAgaWYgKHNlbnQubG9ja0V4cGlyZWQgfHxcbiAgICAgICAgc2VudC51bmxvY2tQcm9jZXNzZWQgfHwgKChfYiA9IChfYSA9IHNlbnQuc2VjcmV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWdpc3RlckJsb2NrKSB8fFxuICAgICAgICAoc2VudC5zZWNyZXRSZXF1ZXN0ICYmICFzZW50LnNlY3JldFJldmVhbCkpXG4gICAgICAgIC8vIHN1Y2Nlc3MvZmFpbHVyZSBhbHJlYWR5IGVtaXR0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgIGVsc2UgaWYgKCEoKF9kID0gKF9jID0gc2VudC5zZWNyZXQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1sxXSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnJlZ2lzdGVyQmxvY2spICYmICFzZW50LnNlY3JldFJldmVhbCAmJiAhc2VudC51bmxvY2spXG4gICAgICAgIHJldHVybiB0cmFuc2Zlci5mYWlsdXJlKG5ldyBSYWlkZW5FcnJvcihFcnJvckNvZGVzLlhGRVJfQ0hBTk5FTF9DTE9TRURfUFJFTUFUVVJFTFkpLCBtZXRhKTtcbiAgICBlbHNlIGlmIChzZW50LnVubG9jaylcbiAgICAgICAgcmV0dXJuIHRyYW5zZmVyLnN1Y2Nlc3MoeyBiYWxhbmNlUHJvb2Y6IGdldEJhbGFuY2VQcm9vZkZyb21FbnZlbG9wZU1lc3NhZ2Uoc2VudC51bmxvY2tbMV0pIH0sIG1ldGEpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHRyYW5zZmVyLnN1Y2Nlc3Moe30sIG1ldGEpO1xufSksIGZpbHRlcihpc250TmlsKSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb3NlLmpzLm1hcCIsImltcG9ydCB7IG1lcmdlLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBpZ25vcmVFbGVtZW50cywgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBhY3Rpb25zIGFuZCB3YWl0cyB1bnRpbCBhIGNvbmRpdGlvbiBpcyBzYXRpc2ZpZWQuXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIGFjdGlvbnMgdGhhdCB3aWxsIGJlIG1vbml0b3JlZFxuICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgcmVxdWVzdC9hY3Rpb24gdGhhdCB3aWxsIGJlIGRpc3BhdGNoZWRcbiAqIEBwYXJhbSBwcmVkaWNhdGUgLSBUaGUgY29uZGl0aW9uIHRoYXQgd2lsbCB0aGF0IHdhcyB0byBiZSBzYXRpc2ZpZWQgZm9yIHRoZSBvYnNlcnZhYmxlIHRvXG4gKiBjb21wbGV0ZVxuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB0aGUgcmVxdWVzdCB0eXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzcGF0Y2hBbmRXYWl0JChhY3Rpb24kLCByZXF1ZXN0LCBwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gbWVyZ2UoXG4gICAgLy8gd2FpdCB1bnRpbCByZXNwZWN0aXZlIHN1Y2Nlc3MvZmFpbHVyZSBhY3Rpb24gaXMgc2VlbiBiZWZvcmUgY29tcGxldGluZ1xuICAgIGFjdGlvbiQucGlwZShmaWx0ZXIocHJlZGljYXRlKSwgdGFrZSgxKSwgXG4gICAgLy8gZG9uJ3Qgb3V0cHV0IHN1Y2Nlc3MvZmFpbHVyZSBhY3Rpb24sIGp1c3Qgd2FpdCBmb3IgZmlyc3QgbWF0Y2ggdG8gY29tcGxldGVcbiAgICBpZ25vcmVFbGVtZW50cygpKSwgXG4gICAgLy8gb3V0cHV0IG9uY2VcbiAgICBvZihyZXF1ZXN0KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBmcm9tLCBtZXJnZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGV4aGF1c3RNYXAsIGZpbHRlciwgd2l0aExhdGVzdEZyb20sIG1lcmdlTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgbmV3QmxvY2sgfSBmcm9tICcuLi8uLi9jaGFubmVscy9hY3Rpb25zJztcbmltcG9ydCB7IGlzQWN0aW9uT2YsIGlzUmVzcG9uc2VPZiB9IGZyb20gJy4uLy4uL3V0aWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgUmFpZGVuRXJyb3IsIEVycm9yQ29kZXMgfSBmcm9tICcuLi8uLi91dGlscy9lcnJvcic7XG5pbXBvcnQgeyB0cmFuc2ZlciwgdHJhbnNmZXJFeHBpcmUgfSBmcm9tICcuLi9hY3Rpb25zJztcbmltcG9ydCB7IERpcmVjdGlvbiB9IGZyb20gJy4uL3N0YXRlJztcbmltcG9ydCB7IGRpc3BhdGNoQW5kV2FpdCQgfSBmcm9tICcuL3V0aWxzJztcbi8qKlxuICogQ29udGFpbnMgdGhlIGNvcmUgbG9naWMgb2Yge0BsaW5rIHRyYW5zZmVyQXV0b0V4cGlyZUVwaWN9LlxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiB7QGxpbmsgUmFpZGVuQWN0aW9ufSBhY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUgLSBDb250YWlucyBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgYXBwXG4gKiBAcGFyYW0gY29uZmlnIC0gQ29udGFpbnMgdGhlIGN1cnJlbnQgYXBwIGNvbmZpZ1xuICogQHBhcmFtIGJsb2NrTnVtYmVyIC0gVGhlIGN1cnJlbnQgYmxvY2sgbnVtYmVyXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIHtAbGluayB0cmFuc2ZlckV4cGlyZS5yZXF1ZXN0fSBvciB7QGxpbmsgdHJhbnNmZXIuZmFpbHVyZX0gYWN0aW9uc1xuICovXG5mdW5jdGlvbiBhdXRvRXhwaXJlJChhY3Rpb24kLCBzdGF0ZSwgeyBjb25maXJtYXRpb25CbG9ja3MgfSwgYmxvY2tOdW1iZXIpIHtcbiAgICAvLyB3ZSBjYW4gc2VuZCBMb2NrRXhwaXJlZCBvbmx5IGZvciBTRU5UIHRyYW5zZmVyc1xuICAgIHJldHVybiBmcm9tKE9iamVjdC5lbnRyaWVzKHN0YXRlLnNlbnQpKS5waXBlKGZpbHRlcigoWywgc2VudF0pID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuICFzZW50LnVubG9jayAmJlxuICAgICAgICAgICAgIXNlbnQubG9ja0V4cGlyZWQgJiZcbiAgICAgICAgICAgICFzZW50LmNoYW5uZWxDbG9zZWQgJiZcbiAgICAgICAgICAgIHNlbnQudHJhbnNmZXJbMV0ubG9jay5leHBpcmF0aW9uLmFkZChjb25maXJtYXRpb25CbG9ja3MpLmx0ZShibG9ja051bWJlcikgJiZcbiAgICAgICAgICAgIC8vIGRvbid0IGV4cGlyZSBpZiBzZWNyZXQgZ290IHJlZ2lzdGVyZWQgYmVmb3JlIGxvY2sgZXhwaXJlZFxuICAgICAgICAgICAgISgoX2IgPSAoX2EgPSBzZW50LnNlY3JldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzFdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVnaXN0ZXJCbG9jayk7XG4gICAgfSksIG1lcmdlTWFwKChbc2VjcmV0aGFzaCwgc2VudF0pID0+IHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHsgc2VjcmV0aGFzaCwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uU0VOVCB9O1xuICAgICAgICAvLyB0aGlzIG9ic2VydmFibGUgYWN0cyBsaWtlIGEgUHJvbWlzZTogZW1pdHMgcmVxdWVzdCBvbmNlLCBjb21wbGV0ZXMgb24gc3VjY2Vzcy9mYWlsdXJlXG4gICAgICAgIHJldHVybiBtZXJnZShkaXNwYXRjaEFuZFdhaXQkKGFjdGlvbiQsIHRyYW5zZmVyRXhwaXJlLnJlcXVlc3QodW5kZWZpbmVkLCBtZXRhKSwgaXNSZXNwb25zZU9mKHRyYW5zZmVyRXhwaXJlLCBtZXRhKSksIFxuICAgICAgICAvLyBub3RpZnkgdXNlcnMgdGhhdCB0aGlzIHRyYW5zZmVyIGZhaWxlZCBkZWZpbml0ZWx5XG4gICAgICAgIG9mKHRyYW5zZmVyLmZhaWx1cmUobmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuWEZFUl9FWFBJUkVELCB7XG4gICAgICAgICAgICBibG9jazogc2VudC50cmFuc2ZlclsxXS5sb2NrLmV4cGlyYXRpb24udG9TdHJpbmcoKSxcbiAgICAgICAgfSksIG1ldGEpKSk7XG4gICAgfSkpO1xufVxuLyoqXG4gKiBQcm9jZXNzIG5ld0Jsb2NrcywgZW1pdHMgdHJhbnNmZXJFeHBpcmUucmVxdWVzdCAocmVxdWVzdCB0byBjb21wb3NlJnNpZ24gTG9ja0V4cGlyZWQgZm9yIGEgdHJhbnNmZXIpXG4gKiBpZiBwZW5kaW5nIHRyYW5zZmVyJ3MgbG9jayBleHBpcmVkIGFuZCB0cmFuc2ZlciBkaWRuJ3QgdW5sb2NrIChzdWNjZWVkKSBpbiB0aW1lXG4gKiBBbHNvLCBlbWl0cyB0cmFuc2Zlci5mYWlsdXJlLCB0byBub3RpZnkgdXNlcnMgdGhhdCBhIHRyYW5zZmVyIGhhcyBmYWlsZWQgKGFsdGhvdWdoIGl0J2xsIG9ubHkgYmVcbiAqIGNvbnNpZGVyZWQgYXMgY29tcGxldGVkIHdpdGggZmFpbCBvbmNlIHRoZSB0cmFuc2ZlckV4cGlyZVByb2Nlc3NlZCBhcnJpdmVzKS5cbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgbmV3QmxvY2t8dHJhbnNmZXJFeHBpcmUuc3VjY2Vzc3x0cmFuc2ZlckV4cGlyZS5mYWlsdXJlIGFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB0cmFuc2ZlckV4cGlyZS5yZXF1ZXN0fHRyYW5zZmVyLmZhaWx1cmUgYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXJBdXRvRXhwaXJlRXBpYyA9IChhY3Rpb24kLCBzdGF0ZSQsIHsgY29uZmlnJCB9KSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzQWN0aW9uT2YobmV3QmxvY2spKSwgd2l0aExhdGVzdEZyb20oc3RhdGUkLCBjb25maWckKSwgXG4vLyBleGhhdXN0TWFwIGlnbm9yZXMgbmV3IGJsb2NrcyB3aGlsZSBwcmV2aW91cyByZXF1ZXN0IGJhdGNoIGlzIHN0aWxsIHBlbmRpbmdcbmV4aGF1c3RNYXAoKFt7IHBheWxvYWQ6IHsgYmxvY2tOdW1iZXIgfSB9LCBzdGF0ZSwgY29uZmlnXSkgPT4gYXV0b0V4cGlyZSQoYWN0aW9uJCwgc3RhdGUsIGNvbmZpZywgYmxvY2tOdW1iZXIpKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHBpcmUuanMubWFwIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2NhbWVsY2FzZSAqL1xuaW1wb3J0IHsgWmVybyB9IGZyb20gJ2V0aGVycy9jb25zdGFudHMnO1xuaW1wb3J0IHsgYmlnTnVtYmVyaWZ5IH0gZnJvbSAnZXRoZXJzL3V0aWxzJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QsIEVNUFRZLCBmcm9tLCBvZiwgbWVyZ2UsIGRlZmVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBjb25jYXRNYXAsIGZpbHRlciwgZmlyc3QsIG1hcCwgbWVyZ2VNYXAsIHRhcCwgd2l0aExhdGVzdEZyb20sIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IGZpbmRLZXkgZnJvbSAnbG9kYXNoL2ZpbmRLZXknO1xuaW1wb3J0IGdldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBpc01hdGNoV2l0aCBmcm9tICdsb2Rhc2gvaXNNYXRjaFdpdGgnO1xuaW1wb3J0IHBpY2sgZnJvbSAnbG9kYXNoL3BpY2snO1xuaW1wb3J0IHsgQ2hhbm5lbFN0YXRlIH0gZnJvbSAnLi4vLi4vY2hhbm5lbHMvc3RhdGUnO1xuaW1wb3J0IHsgY2hhbm5lbEFtb3VudHMgfSBmcm9tICcuLi8uLi9jaGFubmVscy91dGlscyc7XG5pbXBvcnQgeyBMb2NrZWRUcmFuc2ZlciwgTG9ja0V4cGlyZWQsIE1lc3NhZ2VUeXBlLCBVbmxvY2ssIH0gZnJvbSAnLi4vLi4vbWVzc2FnZXMvdHlwZXMnO1xuaW1wb3J0IHsgc2lnbk1lc3NhZ2UsIGlzTWVzc2FnZVJlY2VpdmVkT2ZUeXBlLCBnZXRCYWxhbmNlUHJvb2ZGcm9tRW52ZWxvcGVNZXNzYWdlLCB9IGZyb20gJy4uLy4uL21lc3NhZ2VzL3V0aWxzJztcbmltcG9ydCB7IG1hdHJpeFByZXNlbmNlIH0gZnJvbSAnLi4vLi4vdHJhbnNwb3J0L2FjdGlvbnMnO1xuaW1wb3J0IHsgaXNBY3Rpb25PZiB9IGZyb20gJy4uLy4uL3V0aWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgTHJ1Q2FjaGUgfSBmcm9tICcuLi8uLi91dGlscy9scnUnO1xuaW1wb3J0IHsgcGx1Y2tEaXN0aW5jdCB9IGZyb20gJy4uLy4uL3V0aWxzL3J4JztcbmltcG9ydCB7IGFzc2VydCwgQmlnTnVtYmVyQywgU2lnbmVkIH0gZnJvbSAnLi4vLi4vdXRpbHMvdHlwZXMnO1xuaW1wb3J0IHsgUmFpZGVuRXJyb3IsIEVycm9yQ29kZXMgfSBmcm9tICcuLi8uLi91dGlscy9lcnJvcic7XG5pbXBvcnQgeyBDYXBhYmlsaXRpZXMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgdHJhbnNmZXIsIHRyYW5zZmVyRXhwaXJlLCB0cmFuc2ZlclNlY3JldCwgdHJhbnNmZXJTaWduZWQsIHRyYW5zZmVyVW5sb2NrLCB3aXRoZHJhd1JlY2VpdmUsIHRyYW5zZmVyUHJvY2Vzc2VkLCB0cmFuc2ZlclNlY3JldFJlcXVlc3QsIHRyYW5zZmVyVW5sb2NrUHJvY2Vzc2VkLCB0cmFuc2ZlckV4cGlyZVByb2Nlc3NlZCwgfSBmcm9tICcuLi9hY3Rpb25zJztcbmltcG9ydCB7IGdldExvY2tzcm9vdCwgbWFrZU1lc3NhZ2VJZCwgZ2V0U2VjcmV0aGFzaCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IERpcmVjdGlvbiB9IGZyb20gJy4uL3N0YXRlJztcbi8qKlxuICogUmV0dXJuIHRoZSBuZXh0IG5vbmNlIGZvciBhIChwb3NzaWJseSBtaXNzaW5nKSBiYWxhbmNlUHJvb2YsIG9yIGVsc2UgQmlnTnVtYmVyKDEpXG4gKlxuICogQHBhcmFtIGJhbGFuY2VQcm9vZiAtIEJhbGFuY2UgcHJvb2YgdG8gaW5jcmVhc2Ugbm9uY2UgZnJvbVxuICogQHJldHVybnMgSW5jcmVhc2VkIG5vbmNlLCBvciBPbmUgaWYgbm8gYmFsYW5jZSBwcm9vZiBwcm92aWRlZFxuICovXG5mdW5jdGlvbiBuZXh0Tm9uY2UoYmFsYW5jZVByb29mKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gYmFsYW5jZVByb29mID09PSBudWxsIHx8IGJhbGFuY2VQcm9vZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFsYW5jZVByb29mLm5vbmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBaZXJvKS5hZGQoMSk7XG59XG5mdW5jdGlvbiBnZXRDaGFubmVsTG9ja3Nyb290KGNoYW5uZWwsIHNlY3JldGhhc2gpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbG9ja3MgPSAoKF9hID0gY2hhbm5lbC5vd24ubG9ja3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKS5maWx0ZXIoKGwpID0+IGwuc2VjcmV0aGFzaCAhPT0gc2VjcmV0aGFzaCk7XG4gICAgcmV0dXJuIGdldExvY2tzcm9vdChsb2Nrcyk7XG59XG4vKipcbiAqIFRIZSBjb3JlIGxvZ2ljIG9mIHtAbGluayBtYWtlQW5kU2lnblRyYW5zZmVyfS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgLSBDb250YWlucyBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgYXBwXG4gKiBAcGFyYW0gYWN0aW9uIC0gdHJhbnNmZXIgcmVxdWVzdCBhY3Rpb24gdG8gYmUgc2VudC5cbiAqIEBwYXJhbSByZXZlYWxUaW1lb3V0IC0gVGhlIHJldmVhbCB0aW1lb3V0IGZvciB0aGUgdHJhbnNmZXIuXG4gKiBAcGFyYW0gZGVwcyAtIHtAbGluayBSYWlkZW5FcGljRGVwc31cbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2Yge0BsaW5rIHRyYW5zZmVyU2VjcmV0fSBvciB7QGxpbmsgdHJhbnNmZXJTaWduZWR9IGFjdGlvbnNcbiAqL1xuZnVuY3Rpb24gbWFrZUFuZFNpZ25UcmFuc2ZlciQoc3RhdGUsIGFjdGlvbiwgeyByZXZlYWxUaW1lb3V0IH0sIHsgbG9nLCBhZGRyZXNzLCBuZXR3b3JrLCBzaWduZXIgfSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIGlmIChhY3Rpb24ubWV0YS5zZWNyZXRoYXNoIGluIHN0YXRlLnNlbnQpIHtcbiAgICAgICAgLy8gZG9uJ3QgdGhyb3cgdG8gYXZvaWQgZW1pdHRpbmcgdHJhbnNmZXIuZmFpbHVyZSwgdG8ganVzdCB3YWl0IGZvciBhbHJlYWR5IHBlbmRpbmcgdHJhbnNmZXJcbiAgICAgICAgbG9nLndhcm4oJ3RyYW5zZmVyIGFscmVhZHkgcHJlc2VudCcsIGFjdGlvbi5tZXRhKTtcbiAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIH1cbiAgICAvLyBhc3N1bWUgcGF0aHMgYXJlIHZhbGlkIGFuZCByZWNpcGllbnQgaXMgZmlyc3QgaG9wIG9mIGZpcnN0IHJvdXRlXG4gICAgLy8gY29tcG9zZSBtZXRhZGF0YSBmcm9tIGl0LCBhbmQgdXNlIGZpcnN0IHBhdGggZmVlXG4gICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgIHJvdXRlczogYWN0aW9uLnBheWxvYWQucGF0aHMubWFwKCh7IHBhdGggfSkgPT4gKHsgcm91dGU6IHBhdGggfSkpLFxuICAgIH07XG4gICAgY29uc3QgZmVlID0gYWN0aW9uLnBheWxvYWQucGF0aHNbMF0uZmVlO1xuICAgIGNvbnN0IHJlY2lwaWVudCA9IGFjdGlvbi5wYXlsb2FkLnBhdGhzWzBdLnBhdGhbMF07XG4gICAgY29uc3QgY2hhbm5lbCA9IHN0YXRlLmNoYW5uZWxzW2FjdGlvbi5wYXlsb2FkLnRva2VuTmV0d29ya11bcmVjaXBpZW50XTtcbiAgICAvLyBjaGVjayBiZWxvdyBzaG91bGRuJ3QgZmFpbCBiZWNhdXNlIG9mIHJvdXRlIHZhbGlkYXRpb24gaW4gcGF0aEZpbmRTZXJ2aWNlRXBpY1xuICAgIC8vIHVzZWQgaGVyZSBtb3N0bHkgZm9yIHR5cGUgbmFycm93aW5nIG9uIGNoYW5uZWwgdW5pb25cbiAgICBhc3NlcnQoKGNoYW5uZWwgPT09IG51bGwgfHwgY2hhbm5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbC5zdGF0ZSkgPT09IENoYW5uZWxTdGF0ZS5vcGVuLCAnbm90IG9wZW4nKTtcbiAgICBhc3NlcnQoIWFjdGlvbi5wYXlsb2FkLmV4cGlyYXRpb24gfHwgYWN0aW9uLnBheWxvYWQuZXhwaXJhdGlvbiA+PSBzdGF0ZS5ibG9ja051bWJlciArIHJldmVhbFRpbWVvdXQsICdleHBpcmF0aW9uIHRvbyBzb29uJyk7XG4gICAgY29uc3QgbG9jayA9IHtcbiAgICAgICAgYW1vdW50OiBhY3Rpb24ucGF5bG9hZC52YWx1ZS5hZGQoZmVlKSxcbiAgICAgICAgZXhwaXJhdGlvbjogYmlnTnVtYmVyaWZ5KGFjdGlvbi5wYXlsb2FkLmV4cGlyYXRpb24gfHwgc3RhdGUuYmxvY2tOdW1iZXIgKyByZXZlYWxUaW1lb3V0ICogMiksXG4gICAgICAgIHNlY3JldGhhc2g6IGFjdGlvbi5tZXRhLnNlY3JldGhhc2gsXG4gICAgfTtcbiAgICBjb25zdCBsb2NrcyA9IFsuLi4oKF9hID0gY2hhbm5lbC5vd24ubG9ja3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSwgbG9ja107XG4gICAgY29uc3QgbG9ja3Nyb290ID0gZ2V0TG9ja3Nyb290KGxvY2tzKTtcbiAgICBjb25zdCB0b2tlbiA9IGZpbmRLZXkoc3RhdGUudG9rZW5zLCAodG4pID0+IHRuID09PSBhY3Rpb24ucGF5bG9hZC50b2tlbk5ldHdvcmspO1xuICAgIGxvZy5pbmZvKCdTaWduaW5nIHRyYW5zZmVyIG9mIHZhbHVlJywgYWN0aW9uLnBheWxvYWQudmFsdWUudG9TdHJpbmcoKSwgJ29mIHRva2VuJywgdG9rZW4sICcsIHRvJywgYWN0aW9uLnBheWxvYWQudGFyZ2V0LCAnLCB0aHJvdWdoIHJvdXRlcycsIGFjdGlvbi5wYXlsb2FkLnBhdGhzLCAnLCBwYXlpbmcnLCBmZWUudG9TdHJpbmcoKSwgJ2luIGZlZXMuJyk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuTE9DS0VEX1RSQU5TRkVSLFxuICAgICAgICBtZXNzYWdlX2lkZW50aWZpZXI6IG1ha2VNZXNzYWdlSWQoKSxcbiAgICAgICAgY2hhaW5faWQ6IGJpZ051bWJlcmlmeShuZXR3b3JrLmNoYWluSWQpLFxuICAgICAgICB0b2tlbl9uZXR3b3JrX2FkZHJlc3M6IGFjdGlvbi5wYXlsb2FkLnRva2VuTmV0d29yayxcbiAgICAgICAgY2hhbm5lbF9pZGVudGlmaWVyOiBiaWdOdW1iZXJpZnkoY2hhbm5lbC5pZCksXG4gICAgICAgIG5vbmNlOiBuZXh0Tm9uY2UoY2hhbm5lbC5vd24uYmFsYW5jZVByb29mKSxcbiAgICAgICAgdHJhbnNmZXJyZWRfYW1vdW50OiAoKF9jID0gKF9iID0gY2hhbm5lbC5vd24uYmFsYW5jZVByb29mKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHJhbnNmZXJyZWRBbW91bnQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFplcm8pLFxuICAgICAgICBsb2NrZWRfYW1vdW50OiAoKF9lID0gKF9kID0gY2hhbm5lbC5vd24uYmFsYW5jZVByb29mKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubG9ja2VkQW1vdW50KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBaZXJvKS5hZGQobG9jay5hbW91bnQpLFxuICAgICAgICBsb2Nrc3Jvb3QsXG4gICAgICAgIHBheW1lbnRfaWRlbnRpZmllcjogYWN0aW9uLnBheWxvYWQucGF5bWVudElkLFxuICAgICAgICB0b2tlbixcbiAgICAgICAgcmVjaXBpZW50LFxuICAgICAgICBsb2NrLFxuICAgICAgICB0YXJnZXQ6IGFjdGlvbi5wYXlsb2FkLnRhcmdldCxcbiAgICAgICAgaW5pdGlhdG9yOiAoX2YgPSBhY3Rpb24ucGF5bG9hZC5pbml0aWF0b3IpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IGFkZHJlc3MsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgIH07XG4gICAgcmV0dXJuIGZyb20oc2lnbk1lc3NhZ2Uoc2lnbmVyLCBtZXNzYWdlLCB7IGxvZyB9KSkucGlwZShtZXJnZU1hcChmdW5jdGlvbiogKHNpZ25lZCkge1xuICAgICAgICAvLyBtZXNzYWdlU2VuZCBMb2NrZWRUcmFuc2ZlciBoYW5kbGVkIGJ5IHRyYW5zZmVyUmV0cnlNZXNzYWdlRXBpY1xuICAgICAgICB5aWVsZCB0cmFuc2ZlclNpZ25lZCh7IG1lc3NhZ2U6IHNpZ25lZCwgZmVlIH0sIGFjdGlvbi5tZXRhKTtcbiAgICAgICAgLy8gYmVzaWRlcyB0cmFuc2ZlclNpZ25lZCwgYWxzbyB5aWVsZCB0cmFuc2ZlclNlY3JldCAoZm9yIHJlZ2lzdGVyaW5nKSBpZiB3ZSBrbm93IGl0XG4gICAgICAgIGlmIChhY3Rpb24ucGF5bG9hZC5zZWNyZXQpXG4gICAgICAgICAgICB5aWVsZCB0cmFuc2ZlclNlY3JldCh7IHNlY3JldDogYWN0aW9uLnBheWxvYWQuc2VjcmV0IH0sIGFjdGlvbi5tZXRhKTtcbiAgICB9KSk7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBvYnNlcnZhYmxlIHRvIGNvbXBvc2UgYW5kIHNpZ24gYSBMb2NrZWRUcmFuc2ZlciBtZXNzYWdlL3RyYW5zZmVyU2lnbmVkIGFjdGlvblxuICogQXMgaXQncyBhbiBhc3luYyBvYnNlcnZhYmxlIHdoaWNoIGRlcGVuZHMgb24gc3RhdGUgYW5kIG1heSByZXR1cm4gYW4gYWN0aW9uIHdoaWNoIGNoYW5nZXMgaXQsXG4gKiB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZSBtdXN0IGJlIHN1YnNjcmliZWQgaW4gYSBzZXJpYWxpemVkIGNvbnRleHQgdGhhdCBlbnN1cmVzIG5vbi1jb25jdXJyZW50XG4gKiB3cml0ZSBhY2Nlc3MgdG8gdGhlIGNoYW5uZWwncyBiYWxhbmNlIHByb29mIChlLmcuIGNvbmNhdE1hcClcbiAqXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0gYWN0aW9uIC0gdHJhbnNmZXIgcmVxdWVzdCBhY3Rpb24gdG8gYmUgc2VudFxuICogQHBhcmFtIGRlcHMgLSBSYWlkZW5FcGljRGVwc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB0cmFuc2ZlclNpZ25lZHx0cmFuc2ZlclNlY3JldHx0cmFuc2Zlci5mYWlsdXJlIGFjdGlvbnNcbiAqL1xuZnVuY3Rpb24gbWFrZUFuZFNpZ25UcmFuc2ZlcihzdGF0ZSQsIGFjdGlvbiwgZGVwcykge1xuICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KFtzdGF0ZSQsIGRlcHMuY29uZmlnJF0pLnBpcGUoZmlyc3QoKSwgbWVyZ2VNYXAoKFtzdGF0ZSwgY29uZmlnXSkgPT4gbWFrZUFuZFNpZ25UcmFuc2ZlciQoc3RhdGUsIGFjdGlvbiwgY29uZmlnLCBkZXBzKSksIGNhdGNoRXJyb3IoKGVycikgPT4gb2YodHJhbnNmZXIuZmFpbHVyZShlcnIsIGFjdGlvbi5tZXRhKSkpKTtcbn1cbi8qKlxuICogQ29udGFpbnMgdGhlIGNvcmUgbG9naWMgb2Yge0BsaW5rIG1ha2VBbmRTaWduVW5sb2NrfS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiB0aGUgbGF0ZXN0IGFwcCBzdGF0ZS5cbiAqIEBwYXJhbSBzdGF0ZSAtIENvbnRhaW5zIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBhcHBcbiAqIEBwYXJhbSBhY3Rpb24gLSBUaGUgdHJhbnNmZXIgdW5sb2NrIGFjdGlvbiB0aGF0IHdpbGwgZ2VuZXJhdGUgdGhlIHRyYW5zZmVyVW5sb2NrLnN1Y2Nlc3MgYWN0aW9uLlxuICogQHBhcmFtIHNpZ25lciAtIFRoZSBzaWduZXIgdGhhdCB3aWxsIHNpZ24gdGhlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2Yge0BsaW5rIHRyYW5zZmVyVW5sb2NrLnN1Y2Nlc3N9IGFjdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFrZUFuZFNpZ25VbmxvY2skKHN0YXRlJCwgc3RhdGUsIGFjdGlvbiwgeyBsb2csIHNpZ25lciB9KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBzZWNyZXRoYXNoID0gYWN0aW9uLm1ldGEuc2VjcmV0aGFzaDtcbiAgICBhc3NlcnQoc2VjcmV0aGFzaCBpbiBzdGF0ZS5zZW50LCAndW5rbm93biB0cmFuc2ZlcicpO1xuICAgIGNvbnN0IHRyYW5zZmVyID0gc3RhdGUuc2VudFtzZWNyZXRoYXNoXS50cmFuc2ZlclsxXTtcbiAgICBjb25zdCBjaGFubmVsID0gZ2V0KHN0YXRlLmNoYW5uZWxzLCBbXG4gICAgICAgIHRyYW5zZmVyLnRva2VuX25ldHdvcmtfYWRkcmVzcyxcbiAgICAgICAgdHJhbnNmZXIucmVjaXBpZW50LFxuICAgIF0pO1xuICAgIC8vIHNob3VsZG4ndCBoYXBwZW4sIGNoYW5uZWwgY2xvc2UgY2xlYXJzIHRyYW5zZmVycywgYnV0IHVubG9jayBtYXkgYWxyZWFkeSBoYXZlIGJlZW4gcXVldWVkXG4gICAgYXNzZXJ0KChjaGFubmVsID09PSBudWxsIHx8IGNoYW5uZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWwuc3RhdGUpID09PSBDaGFubmVsU3RhdGUub3BlbiAmJiBjaGFubmVsLm93bi5iYWxhbmNlUHJvb2YsICdjaGFubmVsIGdvbmUsIG5vdCBvcGVuIG9yIG5vIGJhbGFuY2VQcm9vZicpO1xuICAgIGxldCBzaWduZWQkO1xuICAgIGlmIChzdGF0ZS5zZW50W3NlY3JldGhhc2hdLnVubG9jaykge1xuICAgICAgICAvLyB1bmxvY2sgYWxyZWFkeSBzaWduZWQsIHVzZSBjYWNoZWRcbiAgICAgICAgc2lnbmVkJCA9IG9mKHN0YXRlLnNlbnRbc2VjcmV0aGFzaF0udW5sb2NrWzFdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGRvbid0IGZvcmdldCB0byBjaGVjayBhZnRlciBzaWduYXR1cmUgdG9vLCBtYXkgaGF2ZSBleHBpcmVkIGJ5IHRoZW5cbiAgICAgICAgLy8gYWxsb3cgdW5sb2NraW5nIHBhc3QgZXhwaXJhdGlvbiBpZiBzZWNyZXQgcmVnaXN0ZXJlZFxuICAgICAgICBhc3NlcnQoKChfYiA9IChfYSA9IHN0YXRlLnNlbnRbc2VjcmV0aGFzaF0uc2VjcmV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWdpc3RlckJsb2NrKSB8fFxuICAgICAgICAgICAgdHJhbnNmZXIubG9jay5leHBpcmF0aW9uLmd0KHN0YXRlLmJsb2NrTnVtYmVyKSwgJ2xvY2sgZXhwaXJlZCcpO1xuICAgICAgICBjb25zdCBsb2Nrc3Jvb3QgPSBnZXRDaGFubmVsTG9ja3Nyb290KGNoYW5uZWwsIHNlY3JldGhhc2gpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuVU5MT0NLLFxuICAgICAgICAgICAgbWVzc2FnZV9pZGVudGlmaWVyOiBtYWtlTWVzc2FnZUlkKCksXG4gICAgICAgICAgICBjaGFpbl9pZDogdHJhbnNmZXIuY2hhaW5faWQsXG4gICAgICAgICAgICB0b2tlbl9uZXR3b3JrX2FkZHJlc3M6IHRyYW5zZmVyLnRva2VuX25ldHdvcmtfYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYW5uZWxfaWRlbnRpZmllcjogdHJhbnNmZXIuY2hhbm5lbF9pZGVudGlmaWVyLFxuICAgICAgICAgICAgbm9uY2U6IG5leHROb25jZShjaGFubmVsLm93bi5iYWxhbmNlUHJvb2YpLFxuICAgICAgICAgICAgdHJhbnNmZXJyZWRfYW1vdW50OiBjaGFubmVsLm93bi5iYWxhbmNlUHJvb2YudHJhbnNmZXJyZWRBbW91bnQuYWRkKHRyYW5zZmVyLmxvY2suYW1vdW50KSxcbiAgICAgICAgICAgIGxvY2tlZF9hbW91bnQ6IGNoYW5uZWwub3duLmJhbGFuY2VQcm9vZi5sb2NrZWRBbW91bnQuc3ViKHRyYW5zZmVyLmxvY2suYW1vdW50KSxcbiAgICAgICAgICAgIGxvY2tzcm9vdCxcbiAgICAgICAgICAgIHBheW1lbnRfaWRlbnRpZmllcjogdHJhbnNmZXIucGF5bWVudF9pZGVudGlmaWVyLFxuICAgICAgICAgICAgc2VjcmV0OiBzdGF0ZS5zZW50W2FjdGlvbi5tZXRhLnNlY3JldGhhc2hdLnNlY3JldFsxXS52YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgc2lnbmVkJCA9IGZyb20oc2lnbk1lc3NhZ2Uoc2lnbmVyLCBtZXNzYWdlLCB7IGxvZyB9KSk7XG4gICAgfVxuICAgIHJldHVybiBzaWduZWQkLnBpcGUod2l0aExhdGVzdEZyb20oc3RhdGUkKSwgbWVyZ2VNYXAoZnVuY3Rpb24qIChbc2lnbmVkLCBzdGF0ZV0pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgYXNzZXJ0KCgoX2IgPSAoX2EgPSBzdGF0ZS5zZW50W3NlY3JldGhhc2hdLnNlY3JldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzFdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVnaXN0ZXJCbG9jaykgfHxcbiAgICAgICAgICAgIHRyYW5zZmVyLmxvY2suZXhwaXJhdGlvbi5ndChzdGF0ZS5ibG9ja051bWJlciksICdsb2NrIGV4cGlyZWQnKTtcbiAgICAgICAgYXNzZXJ0KCFzdGF0ZS5zZW50W3NlY3JldGhhc2hdLmNoYW5uZWxDbG9zZWQsICdjaGFubmVsIGNsb3NlZCEnKTtcbiAgICAgICAgeWllbGQgdHJhbnNmZXJVbmxvY2suc3VjY2Vzcyh7IG1lc3NhZ2U6IHNpZ25lZCB9LCBhY3Rpb24ubWV0YSk7XG4gICAgICAgIC8vIG1lc3NhZ2VTZW5kIFVubG9jayBoYW5kbGVkIGJ5IHRyYW5zZmVyUmV0cnlNZXNzYWdlRXBpY1xuICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayBpZiB0cmFuc2ZlciB3YXMgcmVmdW5kZWQuIElmIHBhcnRuZXIgcmVmdW5kZWQgdGhlIHRyYW5zZmVyIGJ1dCBzdGlsbFxuICAgICAgICAvLyBmb3J3YXJkZWQgdGhlIHBheW1lbnQsIHdlIHN0aWxsIGFjdCBob25lc3RseSBhbmQgdW5sb2NrIGlmIHRoZXkgcmV2ZWFsZWRcbiAgICB9KSk7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBvYnNlcnZhYmxlIHRvIGNvbXBvc2UgYW5kIHNpZ24gYSBVbmxvY2sgbWVzc2FnZS90cmFuc2ZlclVubG9jay5zdWNjZXNzIGFjdGlvblxuICogQXMgaXQncyBhbiBhc3luYyBvYnNlcnZhYmxlIHdoaWNoIGRlcGVuZHMgb24gc3RhdGUgYW5kIG1heSByZXR1cm4gYW4gYWN0aW9uIHdoaWNoIGNoYW5nZXMgaXQsXG4gKiB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZSBtdXN0IGJlIHN1YnNjcmliZWQgaW4gYSBzZXJpYWxpemVkIGNvbnRleHQgdGhhdCBlbnN1cmVzIG5vbi1jb25jdXJyZW50XG4gKiB3cml0ZSBhY2Nlc3MgdG8gdGhlIGNoYW5uZWwncyBiYWxhbmNlIHByb29mIChlLmcuIGNvbmNhdE1hcClcbiAqXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0gYWN0aW9uIC0gdHJhbnNmZXJVbmxvY2sucmVxdWVzdCByZXF1ZXN0IGFjdGlvbiB0byBiZSBzZW50XG4gKiBAcGFyYW0gc2lnbmVyIC0gUmFpZGVuRXBpY0RlcHMgbWVtYmVyc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB0cmFuc2ZlclVubG9jay5zdWNjZXNzIGFjdGlvbnNcbiAqL1xuZnVuY3Rpb24gbWFrZUFuZFNpZ25VbmxvY2soc3RhdGUkLCBhY3Rpb24sIHsgc2lnbmVyLCBsb2cgfSkge1xuICAgIHJldHVybiBzdGF0ZSQucGlwZShmaXJzdCgpLCBtZXJnZU1hcCgoc3RhdGUpID0+IG1ha2VBbmRTaWduVW5sb2NrJChzdGF0ZSQsIHN0YXRlLCBhY3Rpb24sIHsgbG9nLCBzaWduZXIgfSkpLCBjYXRjaEVycm9yKChlcnIpID0+IHtcbiAgICAgICAgbG9nLndhcm4oJ0Vycm9yIHRyeWluZyB0byB1bmxvY2sgYWZ0ZXIgU2VjcmV0UmV2ZWFsJywgZXJyKTtcbiAgICAgICAgcmV0dXJuIG9mKHRyYW5zZmVyVW5sb2NrLmZhaWx1cmUoZXJyLCBhY3Rpb24ubWV0YSkpO1xuICAgIH0pKTtcbn1cbi8qKlxuICogQ29udGFpbnMgdGhlIGNvcmUgbG9naWMgb2Yge0BsaW5rIG1ha2VBbmRTaWduTG9ja0V4cGlyZWR9LlxuICpcbiAqIEBwYXJhbSBzdGF0ZSAtIENvbnRhaW5zIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBhcHBcbiAqIEBwYXJhbSBhY3Rpb24gLSBUaGUgdHJhbnNmZXIgZXhwaXJlIGFjdGlvbi5cbiAqIEBwYXJhbSBzaWduZXIgLSBSYWlkZW5FcGljRGVwcyBtZW1iZXJzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIHRyYW5zZmVyRXhwaXJlLnN1Y2Nlc3MgYWN0aW9uc1xuICovXG5mdW5jdGlvbiBtYWtlQW5kU2lnbkxvY2tFeHBpcmVkJChzdGF0ZSwgYWN0aW9uLCB7IHNpZ25lciwgbG9nIH0pIHtcbiAgICBjb25zdCBzZWNyZXRoYXNoID0gYWN0aW9uLm1ldGEuc2VjcmV0aGFzaDtcbiAgICBhc3NlcnQoc2VjcmV0aGFzaCBpbiBzdGF0ZS5zZW50LCAndW5rbm93biB0cmFuc2ZlcicpO1xuICAgIGNvbnN0IHRyYW5zZmVyID0gc3RhdGUuc2VudFtzZWNyZXRoYXNoXS50cmFuc2ZlclsxXTtcbiAgICBjb25zdCBjaGFubmVsID0gZ2V0KHN0YXRlLmNoYW5uZWxzLCBbXG4gICAgICAgIHRyYW5zZmVyLnRva2VuX25ldHdvcmtfYWRkcmVzcyxcbiAgICAgICAgdHJhbnNmZXIucmVjaXBpZW50LFxuICAgIF0pO1xuICAgIGFzc2VydCgoY2hhbm5lbCA9PT0gbnVsbCB8fCBjaGFubmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVsLnN0YXRlKSA9PT0gQ2hhbm5lbFN0YXRlLm9wZW4gJiYgY2hhbm5lbC5vd24uYmFsYW5jZVByb29mLCAnY2hhbm5lbCBnb25lLCBub3Qgb3BlbiBvciBubyBiYWxhbmNlUHJvb2YnKTtcbiAgICBsZXQgc2lnbmVkJDtcbiAgICBpZiAoc3RhdGUuc2VudFtzZWNyZXRoYXNoXS5sb2NrRXhwaXJlZCkge1xuICAgICAgICAvLyBsb2NrRXhwaXJlZCBhbHJlYWR5IHNpZ25lZCwgdXNlIGNhY2hlZFxuICAgICAgICBzaWduZWQkID0gb2Yoc3RhdGUuc2VudFtzZWNyZXRoYXNoXS5sb2NrRXhwaXJlZFsxXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnQodHJhbnNmZXIubG9jay5leHBpcmF0aW9uLmx0KHN0YXRlLmJsb2NrTnVtYmVyKSwgJ2xvY2sgbm90IHlldCBleHBpcmVkJyk7XG4gICAgICAgIGFzc2VydCghc3RhdGUuc2VudFtzZWNyZXRoYXNoXS51bmxvY2ssICd0cmFuc2ZlciBhbHJlYWR5IHVubG9ja2VkJyk7XG4gICAgICAgIGNvbnN0IGxvY2tzcm9vdCA9IGdldENoYW5uZWxMb2Nrc3Jvb3QoY2hhbm5lbCwgc2VjcmV0aGFzaCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5MT0NLX0VYUElSRUQsXG4gICAgICAgICAgICBtZXNzYWdlX2lkZW50aWZpZXI6IG1ha2VNZXNzYWdlSWQoKSxcbiAgICAgICAgICAgIGNoYWluX2lkOiB0cmFuc2Zlci5jaGFpbl9pZCxcbiAgICAgICAgICAgIHRva2VuX25ldHdvcmtfYWRkcmVzczogdHJhbnNmZXIudG9rZW5fbmV0d29ya19hZGRyZXNzLFxuICAgICAgICAgICAgY2hhbm5lbF9pZGVudGlmaWVyOiB0cmFuc2Zlci5jaGFubmVsX2lkZW50aWZpZXIsXG4gICAgICAgICAgICBub25jZTogbmV4dE5vbmNlKGNoYW5uZWwub3duLmJhbGFuY2VQcm9vZiksXG4gICAgICAgICAgICB0cmFuc2ZlcnJlZF9hbW91bnQ6IGNoYW5uZWwub3duLmJhbGFuY2VQcm9vZi50cmFuc2ZlcnJlZEFtb3VudCxcbiAgICAgICAgICAgIGxvY2tlZF9hbW91bnQ6IGNoYW5uZWwub3duLmJhbGFuY2VQcm9vZi5sb2NrZWRBbW91bnQuc3ViKHRyYW5zZmVyLmxvY2suYW1vdW50KSxcbiAgICAgICAgICAgIGxvY2tzcm9vdCxcbiAgICAgICAgICAgIHJlY2lwaWVudDogdHJhbnNmZXIucmVjaXBpZW50LFxuICAgICAgICAgICAgc2VjcmV0aGFzaCxcbiAgICAgICAgfTtcbiAgICAgICAgc2lnbmVkJCA9IGZyb20oc2lnbk1lc3NhZ2Uoc2lnbmVyLCBtZXNzYWdlLCB7IGxvZyB9KSk7XG4gICAgfVxuICAgIHJldHVybiBzaWduZWQkLnBpcGUoXG4gICAgLy8gbWVzc2FnZVNlbmQgTG9ja0V4cGlyZWQgaGFuZGxlZCBieSB0cmFuc2ZlclJldHJ5TWVzc2FnZUVwaWNcbiAgICBtYXAoKHNpZ25lZCkgPT4gdHJhbnNmZXJFeHBpcmUuc3VjY2Vzcyh7IG1lc3NhZ2U6IHNpZ25lZCB9LCBhY3Rpb24ubWV0YSkpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGFuIG9ic2VydmFibGUgdG8gY29tcG9zZSBhbmQgc2lnbiBhIExvY2tFeHBpcmVkIG1lc3NhZ2UvdHJhbnNmZXJFeHBpcmUuc3VjY2VzcyBhY3Rpb25cbiAqIEFzIGl0J3MgYW4gYXN5bmMgb2JzZXJ2YWJsZSB3aGljaCBkZXBlbmRzIG9uIHN0YXRlIGFuZCBtYXkgcmV0dXJuIGFuIGFjdGlvbiB3aGljaCBjaGFuZ2VzIGl0LFxuICogdGhlIHJldHVybmVkIG9ic2VydmFibGUgbXVzdCBiZSBzdWJzY3JpYmVkIGluIGEgc2VyaWFsaXplZCBjb250ZXh0IHRoYXQgZW5zdXJlcyBub24tY29uY3VycmVudFxuICogd3JpdGUgYWNjZXNzIHRvIHRoZSBjaGFubmVsJ3MgYmFsYW5jZSBwcm9vZiAoZS5nLiBjb25jYXRNYXApXG4gKlxuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgY3VycmVudCBzdGF0ZVxuICogQHBhcmFtIGFjdGlvbiAtIHRyYW5zZmVyIHJlcXVlc3QgYWN0aW9uIHRvIGJlIHNlbnRcbiAqIEBwYXJhbSBzaWduZXIgLSBSYWlkZW5FcGljRGVwcyBtZW1iZXJzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIHRyYW5zZmVyRXhwaXJlLnN1Y2Nlc3N8dHJhbnNmZXJFeHBpcmUuZmFpbHVyZSBhY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIG1ha2VBbmRTaWduTG9ja0V4cGlyZWQoc3RhdGUkLCBhY3Rpb24sIHsgbG9nLCBzaWduZXIgfSkge1xuICAgIHJldHVybiBzdGF0ZSQucGlwZShmaXJzdCgpLCBtZXJnZU1hcCgoc3RhdGUpID0+IG1ha2VBbmRTaWduTG9ja0V4cGlyZWQkKHN0YXRlLCBhY3Rpb24sIHsgc2lnbmVyLCBsb2cgfSkpLCBjYXRjaEVycm9yKChlcnIpID0+IG9mKHRyYW5zZmVyRXhwaXJlLmZhaWx1cmUoZXJyLCBhY3Rpb24ubWV0YSkpKSk7XG59XG5mdW5jdGlvbiBtYWtlQW5kU2lnbldpdGhkcmF3Q29uZmlybWF0aW9uJChzdGF0ZSwgYWN0aW9uLCB7IGxvZywgc2lnbmVyIH0sIGNhY2hlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCByZXF1ZXN0ID0gYWN0aW9uLnBheWxvYWQubWVzc2FnZTtcbiAgICBjb25zdCBjaGFubmVsID0gZ2V0KHN0YXRlLmNoYW5uZWxzLCBbXG4gICAgICAgIGFjdGlvbi5tZXRhLnRva2VuTmV0d29yayxcbiAgICAgICAgYWN0aW9uLm1ldGEucGFydG5lcixcbiAgICBdKTtcbiAgICAvLyBjaGVjayBjaGFubmVsIGlzIGluIHZhbGlkIHN0YXRlIGFuZCByZXF1ZXN0ZWQgdG90YWxfd2l0aGRyYXcgaXMgdmFsaWRcbiAgICAvLyB3aXRoZHJhd2FibGUgYW1vdW50IGlzOiB0b3RhbF93aXRoZHJhdyA8PSBwYXJ0bmVyLmRlcG9zaXQgKyBvd24udHJhbnNmZXJyZWRBbW91bnRcbiAgICBhc3NlcnQoY2hhbm5lbCAmJiBjaGFubmVsLnN0YXRlID09PSBDaGFubmVsU3RhdGUub3BlbiAmJiByZXF1ZXN0LmNoYW5uZWxfaWRlbnRpZmllci5lcShjaGFubmVsLmlkKSwgJ2NoYW5uZWwgZ29uZSBvciBub3Qgb3BlbicpO1xuICAgIGFzc2VydChyZXF1ZXN0LmV4cGlyYXRpb24uZ3Qoc3RhdGUuYmxvY2tOdW1iZXIpLCAnV2l0aGRyYXdSZXF1ZXN0IGV4cGlyZWQnKTtcbiAgICBhc3NlcnQocmVxdWVzdC50b3RhbF93aXRoZHJhdy5sdGUoY2hhbm5lbC5wYXJ0bmVyLmRlcG9zaXQuYWRkKChfYiA9IChfYSA9IGNoYW5uZWwub3duLmJhbGFuY2VQcm9vZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyYW5zZmVycmVkQW1vdW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBaZXJvKSksICdpbnZhbGlkIHRvdGFsX3dpdGhkcmF3LCBncmVhdGVyIHRoYW4gcGFydG5lci5kZXBvc2l0ICsgb3duLnRyYW5zZmVycmVkQW1vdW50Jyk7XG4gICAgbGV0IHNpZ25lZCQ7XG4gICAgY29uc3Qga2V5ID0gcmVxdWVzdC5tZXNzYWdlX2lkZW50aWZpZXIudG9TdHJpbmcoKTtcbiAgICAvLyBjb21wYXJlIFdpdGhkcmF3UmVxdWVzdCBhbmQgYSBwb3NzaWJsZSBzaWduZWQgV2l0aGRyYXdDb25maXJtYXRpb25cbiAgICBmdW5jdGlvbiBjb21wYXJlUmVxQ29uZihyZXEsIGNvbmYpIHtcbiAgICAgICAgaWYgKCFjb25mKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBtYXRjaFNldCA9IHBpY2soY29uZiwgW1xuICAgICAgICAgICAgJ3Rva2VuX25ldHdvcmtfYWRkcmVzcycsXG4gICAgICAgICAgICAncGFydGljaXBhbnQnLFxuICAgICAgICAgICAgJ2NoYWluX2lkJyxcbiAgICAgICAgICAgICdjaGFubmVsX2lkZW50aWZpZXInLFxuICAgICAgICAgICAgJ3RvdGFsX3dpdGhkcmF3JyxcbiAgICAgICAgICAgICdleHBpcmF0aW9uJyxcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBpc01hdGNoV2l0aChyZXEsIG1hdGNoU2V0LCAob2JqVmFsLCBvdGhWYWwpID0+IEJpZ051bWJlckMuaXMob2JqVmFsKVxuICAgICAgICAgICAgPyBvYmpWYWwuZXEob3RoVmFsKVxuICAgICAgICAgICAgOiBCaWdOdW1iZXJDLmlzKG90aFZhbClcbiAgICAgICAgICAgICAgICA/IG90aFZhbC5lcShvYmpWYWwpXG4gICAgICAgICAgICAgICAgOiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAvLyBlbnN1cmUgYWxsIHBhcmFtZXRlcnMgYXJlIGVxdWFsIHRoZSBjYWNoZWQgb25lIGJlZm9yZSByZXR1cm5pbmcgaXQsIG9yIGVsc2Ugc2lnbiBhZ2FpblxuICAgIGlmIChjb21wYXJlUmVxQ29uZihyZXF1ZXN0LCBjYWNoZWQpKSB7XG4gICAgICAgIHNpZ25lZCQgPSBvZihjYWNoZWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY29uZmlybWF0aW9uID0ge1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuV0lUSERSQVdfQ09ORklSTUFUSU9OLFxuICAgICAgICAgICAgbWVzc2FnZV9pZGVudGlmaWVyOiByZXF1ZXN0Lm1lc3NhZ2VfaWRlbnRpZmllcixcbiAgICAgICAgICAgIGNoYWluX2lkOiByZXF1ZXN0LmNoYWluX2lkLFxuICAgICAgICAgICAgdG9rZW5fbmV0d29ya19hZGRyZXNzOiByZXF1ZXN0LnRva2VuX25ldHdvcmtfYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYW5uZWxfaWRlbnRpZmllcjogcmVxdWVzdC5jaGFubmVsX2lkZW50aWZpZXIsXG4gICAgICAgICAgICBwYXJ0aWNpcGFudDogcmVxdWVzdC5wYXJ0aWNpcGFudCxcbiAgICAgICAgICAgIHRvdGFsX3dpdGhkcmF3OiByZXF1ZXN0LnRvdGFsX3dpdGhkcmF3LFxuICAgICAgICAgICAgbm9uY2U6IG5leHROb25jZShjaGFubmVsLm93bi5iYWxhbmNlUHJvb2YpLFxuICAgICAgICAgICAgZXhwaXJhdGlvbjogcmVxdWVzdC5leHBpcmF0aW9uLFxuICAgICAgICB9O1xuICAgICAgICBzaWduZWQkID0gZnJvbShzaWduTWVzc2FnZShzaWduZXIsIGNvbmZpcm1hdGlvbiwgeyBsb2cgfSkpLnBpcGUodGFwKChzaWduZWQpID0+IGNhY2hlLnB1dChrZXksIHNpZ25lZCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ25lZCQucGlwZShtYXAoKHNpZ25lZCkgPT4gd2l0aGRyYXdSZWNlaXZlLnN1Y2Nlc3MoeyBtZXNzYWdlOiBzaWduZWQgfSwgYWN0aW9uLm1ldGEpKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBvYnNlcnZhYmxlIHRvIGNvbXBvc2UgYW5kIHNpZ24gYSBbW1dpdGhkcmF3Q29uZmlybWF0aW9uXV0gbWVzc2FnZVxuICpcbiAqIFZhbGlkYXRlIHdlJ3JlIGluc2lkZSBleHBpcmF0aW9uIHRpbWVvdXQsIGNoYW5uZWwgZXhpc3RzIGFuZCBpcyBvcGVuLCBhbmQgdGhhdCB0b3RhbF93aXRoZHJhdyBpc1xuICogbGVzcyB0aGFuIG9yIGVxdWFsIHdpdGhkcmF3YWJsZSBhbW91bnQgKHdoaWxlIHdlIGRvbid0IHJlY2VpdmUsIHBhcnRuZXIuZGVwb3NpdCArXG4gKiBvd24udHJhbnNmZXJyZWRBbW91bnQpLlxuICogV2UgbmVlZCBpdCBpbnNpZGUgW1t0cmFuc2ZlckdlbmVyYXRlQW5kU2lnbkVudmVsb3BlTWVzc2FnZUVwaWNdXSBjb25jYXRNYXAvbG9jayBiZWNhdXNlIHdlIHJlYWRcbiAqIGFuZCBjaGFuZ2UgdGhlICdub25jZScsIGV2ZW4gdGhvdWdoIFdpdGhkcmF3Q29uZmlybWF0aW9uIGRvZXNuJ3QgY2FycnkgYSBmdWxsIGJhbGFuY2VQcm9vZi5cbiAqIEFsc28sIGluc3RlYWQgb2Ygc3RvcmluZyB0aGUgbWVzc2FnZXMgaW4gc3RhdGUgYW5kIHJldHJ5aW5nLCB3ZSBqdXN0IGNhY2hlIGl0IGFuZCBzZW5kIGNhY2hlZFxuICogc2lnbmVkIG1lc3NhZ2Ugb24gZWFjaCByZWNlaXZlZCByZXF1ZXN0LlxuICpcbiAqIFRPRE86IG9uY2Ugd2UncmUgYWJsZSB0byByZWNlaXZlIHRyYW5zZmVycywgaW5zdGVhZCBvZiBjb25zaWRlcmluZyBvbmx5IG93bi50cmFuc2ZlcnJlZEFtb3VudCxcbiAqIHdlIG11c3QgYWxzbyBsaXN0ZW4gdG8gQ2hhbm5lbFdpdGhkcmF3IGV2ZW50cywgc3RvcmUgaXQgYWxvbmdzaWRlIHBlbmRpbmcgd2l0aGRyYXcgcmVxdWVzdHMgYW5kXG4gKiB0YWtlIHRoYXQgaW50byBhY2NvdW50IGJlZm9yZSBhY2NlcHRpbmcgYSB0cmFuc2ZlciBhbmQgYWxzbyB0b3RhbCBiYWxhbmNlL2NhcGFjaXR5IGZvciBhY2NlcHRpbmdcbiAqIGEgdG90YWxfd2l0aGRyYXcgZnJvbSBhIFdpdGhkcmF3UmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0gYWN0aW9uIC0gV2l0aGRyYXcgcmVxdWVzdCB3aGljaCBjYXVzZWQgdGhpcyBoYW5kbGluZ1xuICogQHBhcmFtIHNpZ25lciAtIFJhaWRlbkVwaWNEZXBzIG1lbWJlcnNcbiAqIEBwYXJhbSBjYWNoZSAtIEEgTWFwIHRvIHN0b3JlIGFuZCByZXVzZSBwcmV2aW91c2x5IFNpZ25lZDxXaXRoZHJhd0NvbmZpcm1hdGlvbj5cbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgdHJhbnNmZXJFeHBpcmUuc3VjY2Vzc3x0cmFuc2ZlckV4cGlyZS5mYWlsdXJlIGFjdGlvbnNcbiAqL1xuZnVuY3Rpb24gbWFrZUFuZFNpZ25XaXRoZHJhd0NvbmZpcm1hdGlvbihzdGF0ZSQsIGFjdGlvbiwgeyBzaWduZXIsIGxvZyB9LCBjYWNoZSkge1xuICAgIHJldHVybiBzdGF0ZSQucGlwZShmaXJzdCgpLCBtZXJnZU1hcCgoc3RhdGUpID0+IG1ha2VBbmRTaWduV2l0aGRyYXdDb25maXJtYXRpb24kKHN0YXRlLCBhY3Rpb24sIHsgbG9nLCBzaWduZXIgfSwgY2FjaGUpKSwgY2F0Y2hFcnJvcigoZXJyKSA9PiB7XG4gICAgICAgIGxvZy53YXJuKCdFcnJvciB0cnlpbmcgdG8gaGFuZGxlIFdpdGhkcmF3UmVxdWVzdCwgaWdub3Jpbmc6JywgZXJyKTtcbiAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIHJlY2VpdmVUcmFuc2ZlclNpZ25lZChzdGF0ZSQsIGFjdGlvbiwgeyBhZGRyZXNzLCBsb2csIG5ldHdvcmssIHNpZ25lciwgY29uZmlnJCB9KSB7XG4gICAgY29uc3Qgc2VjcmV0aGFzaCA9IGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2UubG9jay5zZWNyZXRoYXNoO1xuICAgIGNvbnN0IG1ldGEgPSB7IHNlY3JldGhhc2gsIGRpcmVjdGlvbjogRGlyZWN0aW9uLlJFQ0VJVkVEIH07XG4gICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QoW3N0YXRlJCwgY29uZmlnJF0pLnBpcGUoZmlyc3QoKSwgbWVyZ2VNYXAoKFtzdGF0ZSwgeyByZXZlYWxUaW1lb3V0LCBjYXBzIH1dKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBjb25zdCB0cmFuc2ZlciA9IGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2U7XG4gICAgICAgIGlmIChzZWNyZXRoYXNoIGluIHN0YXRlLnJlY2VpdmVkKSB7XG4gICAgICAgICAgICBsb2cud2FybigndHJhbnNmZXIgYWxyZWFkeSBwcmVzZW50JywgYWN0aW9uLm1ldGEpO1xuICAgICAgICAgICAgY29uc3QgbXNnSWQgPSB0cmFuc2Zlci5tZXNzYWdlX2lkZW50aWZpZXI7XG4gICAgICAgICAgICAvLyBpZiB0cmFuc2ZlciBtYXRjaGVzIHRoZSBzdG9yZWQgb25lLCByZS1zZW5kIFByb2Nlc3NlZCBvbmNlXG4gICAgICAgICAgICBpZiAoc3RhdGUucmVjZWl2ZWRbc2VjcmV0aGFzaF0ucGFydG5lciA9PT0gYWN0aW9uLm1ldGEuYWRkcmVzcyAmJlxuICAgICAgICAgICAgICAgIHN0YXRlLnJlY2VpdmVkW3NlY3JldGhhc2hdLnRyYW5zZmVyWzFdLm1lc3NhZ2VfaWRlbnRpZmllci5lcShtc2dJZCkpIHtcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2ZlclByb2Nlc3NlZCBhZ2FpbiB3aWxsIHRyaWdnZXIgbWVzc2FnZVNlbmQucmVxdWVzdFxuICAgICAgICAgICAgICAgIHJldHVybiBvZih0cmFuc2ZlclByb2Nlc3NlZCh7IG1lc3NhZ2U6IHN0YXRlLnJlY2VpdmVkW3NlY3JldGhhc2hdLnRyYW5zZmVyUHJvY2Vzc2VkWzFdIH0sIG1ldGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZnVsbCBiYWxhbmNlIHByb29mIHZhbGlkYXRpb25cbiAgICAgICAgY29uc3QgdG9rZW5OZXR3b3JrID0gdHJhbnNmZXIudG9rZW5fbmV0d29ya19hZGRyZXNzO1xuICAgICAgICBjb25zdCBwYXJ0bmVyID0gYWN0aW9uLm1ldGEuYWRkcmVzcztcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IChfYSA9IHN0YXRlLmNoYW5uZWxzW3Rva2VuTmV0d29ya10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtwYXJ0bmVyXTtcbiAgICAgICAgYXNzZXJ0KChjaGFubmVsID09PSBudWxsIHx8IGNoYW5uZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWwuc3RhdGUpID09PSBDaGFubmVsU3RhdGUub3BlbiwgJ2NoYW5uZWwgbm90IGZvdW5kIG9yIG5vdCBvcGVuJyk7XG4gICAgICAgIGFzc2VydCh0cmFuc2Zlci5jaGFpbl9pZC5lcShuZXR3b3JrLmNoYWluSWQpLCAnY2hhaW5JZCBtaXNtYXRjaCcpO1xuICAgICAgICBhc3NlcnQodHJhbnNmZXIuY2hhbm5lbF9pZGVudGlmaWVyLmVxKGNoYW5uZWwuaWQpLCAnY2hhbm5lbElkIG1pc21hdGNoJyk7XG4gICAgICAgIGFzc2VydCh0cmFuc2Zlci5ub25jZS5lcShuZXh0Tm9uY2UoY2hhbm5lbC5wYXJ0bmVyLmJhbGFuY2VQcm9vZikpLCAnbm9uY2UgbWlzbWF0Y2gnKTtcbiAgICAgICAgYXNzZXJ0KHRyYW5zZmVyLnRyYW5zZmVycmVkX2Ftb3VudC5lcSgoX2MgPSAoX2IgPSBjaGFubmVsLnBhcnRuZXIuYmFsYW5jZVByb29mKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHJhbnNmZXJyZWRBbW91bnQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFplcm8pLCAndHJhbnNmZXJyZWRBbW91bnQgbWlzbWF0Y2gnKTtcbiAgICAgICAgYXNzZXJ0KHRyYW5zZmVyLmxvY2tlZF9hbW91bnQuZXEoKChfZSA9IChfZCA9IGNoYW5uZWwucGFydG5lci5iYWxhbmNlUHJvb2YpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sb2NrZWRBbW91bnQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFplcm8pLmFkZCh0cmFuc2Zlci5sb2NrLmFtb3VudCkpLCAnbG9ja2VkQW1vdW50IG1pc21hdGNoJyk7XG4gICAgICAgIGNvbnN0IHBhcnRuZXJDYXBhY2l0eSA9IGNoYW5uZWxBbW91bnRzKGNoYW5uZWwpLnBhcnRuZXJDYXBhY2l0eTtcbiAgICAgICAgYXNzZXJ0KHRyYW5zZmVyLmxvY2suYW1vdW50Lmx0ZShwYXJ0bmVyQ2FwYWNpdHkpLCAnYmFsYW5jZVByb29mIHRvdGFsIGFtb3VudCBiaWdnZXIgdGhhbiBjYXBhY2l0eScpO1xuICAgICAgICBhc3NlcnQodHJhbnNmZXIucmVjaXBpZW50ID09PSBhZGRyZXNzLCBcIlJlY2VpdmVkIHRyYW5zZmVyIGlzbid0IGZvciB1c1wiKTtcbiAgICAgICAgYXNzZXJ0KHRyYW5zZmVyLmxvY2suZXhwaXJhdGlvbi5zdWIoc3RhdGUuYmxvY2tOdW1iZXIpLmd0KHJldmVhbFRpbWVvdXQpLCAnbG9jayBleHBpcmVzIHRvbyBzb29uJyk7XG4gICAgICAgIGNvbnN0IGxvY2tzID0gWy4uLigoX2YgPSBjaGFubmVsLnBhcnRuZXIubG9ja3MpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IFtdKSwgdHJhbnNmZXIubG9ja107XG4gICAgICAgIGNvbnN0IGxvY2tzcm9vdCA9IGdldExvY2tzcm9vdChsb2Nrcyk7XG4gICAgICAgIGFzc2VydCh0cmFuc2Zlci5sb2Nrc3Jvb3QgPT09IGxvY2tzcm9vdCwgJ2xvY2tzcm9vdCBtaXNtYXRjaCcpO1xuICAgICAgICBjb25zdCB0b2tlbiA9IGZpbmRLZXkoc3RhdGUudG9rZW5zLCAodG4pID0+IHRuID09PSB0b2tlbk5ldHdvcmspO1xuICAgICAgICBsb2cuaW5mbygnUmVjZWl2aW5nIHRyYW5zZmVyIG9mIHZhbHVlJywgdHJhbnNmZXIubG9jay5hbW91bnQudG9TdHJpbmcoKSwgJ29mIHRva2VuJywgdG9rZW4sICcsIGZyb20nLCB0cmFuc2Zlci5pbml0aWF0b3IsICcsIHRocm91Z2ggcGFydG5lcicsIHBhcnRuZXIpO1xuICAgICAgICBsZXQgcmVxdWVzdCQgPSBvZih1bmRlZmluZWQpO1xuICAgICAgICBpZiAoIShjYXBzID09PSBudWxsIHx8IGNhcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhcHNbQ2FwYWJpbGl0aWVzLk5PX1JFQ0VJVkVdKSAmJiB0cmFuc2Zlci50YXJnZXQgPT09IGFkZHJlc3MpXG4gICAgICAgICAgICByZXF1ZXN0JCA9IGRlZmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TRUNSRVRfUkVRVUVTVCxcbiAgICAgICAgICAgICAgICAgICAgcGF5bWVudF9pZGVudGlmaWVyOiB0cmFuc2Zlci5wYXltZW50X2lkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgIHNlY3JldGhhc2gsXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogdHJhbnNmZXIubG9jay5hbW91bnQsXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyYXRpb246IHRyYW5zZmVyLmxvY2suZXhwaXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZV9pZGVudGlmaWVyOiBtYWtlTWVzc2FnZUlkKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbk1lc3NhZ2Uoc2lnbmVyLCByZXF1ZXN0LCB7IGxvZyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQkID0gZGVmZXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlBST0NFU1NFRCxcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NhbWVsY2FzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2VfaWRlbnRpZmllcjogdHJhbnNmZXIubWVzc2FnZV9pZGVudGlmaWVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzaWduTWVzc2FnZShzaWduZXIsIHByb2Nlc3NlZCwgeyBsb2cgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpZiBhbnkgb2YgdGhlc2Ugc2lnbmF0dXJlIHByb21wdHMgZmFpbCwgbm9uZSBvZiB0aGVzZSBhY3Rpb25zIHdpbGwgYmUgZW1pdHRlZFxuICAgICAgICByZXR1cm4gY29tYmluZUxhdGVzdChbcHJvY2Vzc2VkJCwgcmVxdWVzdCRdKS5waXBlKG1lcmdlTWFwKGZ1bmN0aW9uKiAoW3Byb2Nlc3NlZCwgcmVxdWVzdF0pIHtcbiAgICAgICAgICAgIHlpZWxkIHRyYW5zZmVyU2lnbmVkKHsgbWVzc2FnZTogdHJhbnNmZXIsIGZlZTogWmVybyB9LCBtZXRhKTtcbiAgICAgICAgICAgIC8vIHNldHMgVHJhbnNmZXJTdGF0ZS50cmFuc2ZlclByb2Nlc3NlZFxuICAgICAgICAgICAgeWllbGQgdHJhbnNmZXJQcm9jZXNzZWQoeyBtZXNzYWdlOiBwcm9jZXNzZWQgfSwgbWV0YSk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgaW5pdGlhdG9yJ3MgcHJlc2VuY2UsIHRvIGJlIGFibGUgdG8gcmVxdWVzdCBzZWNyZXRcbiAgICAgICAgICAgICAgICB5aWVsZCBtYXRyaXhQcmVzZW5jZS5yZXF1ZXN0KHVuZGVmaW5lZCwgeyBhZGRyZXNzOiB0cmFuc2Zlci5pbml0aWF0b3IgfSk7XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBzZWNyZXQgaWZmIHdlJ3JlIHRoZSB0YXJnZXQgYW5kIHJlY2VpdmluZyBpcyBlbmFibGVkXG4gICAgICAgICAgICAgICAgeWllbGQgdHJhbnNmZXJTZWNyZXRSZXF1ZXN0KHsgbWVzc2FnZTogcmVxdWVzdCB9LCBtZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH0pLCBjYXRjaEVycm9yKChlcnIpID0+IG9mKHRyYW5zZmVyLmZhaWx1cmUoZXJyLCBtZXRhKSkpKTtcbn1cbmZ1bmN0aW9uIHJlY2VpdmVUcmFuc2ZlclVubG9ja2VkKHN0YXRlJCwgYWN0aW9uLCB7IGxvZywgbmV0d29yaywgc2lnbmVyIH0pIHtcbiAgICBjb25zdCBzZWNyZXRoYXNoID0gZ2V0U2VjcmV0aGFzaChhY3Rpb24ucGF5bG9hZC5tZXNzYWdlLnNlY3JldCk7XG4gICAgY29uc3QgbWV0YSA9IHsgc2VjcmV0aGFzaCwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uUkVDRUlWRUQgfTtcbiAgICByZXR1cm4gc3RhdGUkLnBpcGUoZmlyc3QoKSwgbWVyZ2VNYXAoKHN0YXRlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCEoc2VjcmV0aGFzaCBpbiBzdGF0ZS5yZWNlaXZlZCkpXG4gICAgICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVkID0gc3RhdGUucmVjZWl2ZWRbc2VjcmV0aGFzaF07XG4gICAgICAgIGNvbnN0IHVubG9jayA9IGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IHBhcnRuZXIgPSBhY3Rpb24ubWV0YS5hZGRyZXNzO1xuICAgICAgICBhc3NlcnQocGFydG5lciA9PT0gcmVjZWl2ZWQucGFydG5lciwgJ3dyb25nIHBhcnRuZXInKTtcbiAgICAgICAgaWYgKHJlY2VpdmVkLnVubG9jaykge1xuICAgICAgICAgICAgbG9nLndhcm4oJ3RyYW5zZmVyIGFscmVhZHkgdW5sb2NrZWQnLCBhY3Rpb24ubWV0YSk7XG4gICAgICAgICAgICAvLyBpZiBtZXNzYWdlIG1hdGNoZXMgdGhlIHN0b3JlZCBvbmUsIHJlLXNlbmQgUHJvY2Vzc2VkIG9uY2VcbiAgICAgICAgICAgIGlmIChyZWNlaXZlZC51bmxvY2tQcm9jZXNzZWQgJiZcbiAgICAgICAgICAgICAgICByZWNlaXZlZC51bmxvY2tQcm9jZXNzZWRbMV0ubWVzc2FnZV9pZGVudGlmaWVyLmVxKHVubG9jay5tZXNzYWdlX2lkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmZXJQcm9jZXNzZWQgYWdhaW4gd2lsbCB0cmlnZ2VyIG1lc3NhZ2VTZW5kLnJlcXVlc3RcbiAgICAgICAgICAgICAgICByZXR1cm4gb2YodHJhbnNmZXJVbmxvY2tQcm9jZXNzZWQoeyBtZXNzYWdlOiByZWNlaXZlZC51bmxvY2tQcm9jZXNzZWRbMV0gfSwgbWV0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBFTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2YgPSByZWNlaXZlZC50cmFuc2ZlclsxXTtcbiAgICAgICAgLy8gdW5sb2NrIHZhbGlkYXRpb25cbiAgICAgICAgY29uc3QgdG9rZW5OZXR3b3JrID0gdW5sb2NrLnRva2VuX25ldHdvcmtfYWRkcmVzcztcbiAgICAgICAgYXNzZXJ0KHRva2VuTmV0d29yayA9PT0gdHJhbnNmLnRva2VuX25ldHdvcmtfYWRkcmVzcywgJ3dyb25nIHRva2VuTmV0d29yaycpO1xuICAgICAgICBjb25zdCBjaGFubmVsID0gKF9hID0gc3RhdGUuY2hhbm5lbHNbdG9rZW5OZXR3b3JrXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3BhcnRuZXJdO1xuICAgICAgICBhc3NlcnQoKGNoYW5uZWwgPT09IG51bGwgfHwgY2hhbm5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbC5zdGF0ZSkgPT09IENoYW5uZWxTdGF0ZS5vcGVuICYmXG4gICAgICAgICAgICBjaGFubmVsLnBhcnRuZXIuYmFsYW5jZVByb29mICYmXG4gICAgICAgICAgICBjaGFubmVsLnBhcnRuZXIubG9ja3MsICdjaGFubmVsIG5vdCBmb3VuZCBvciBub3Qgb3BlbicpO1xuICAgICAgICBhc3NlcnQodW5sb2NrLmNoYWluX2lkLmVxKG5ldHdvcmsuY2hhaW5JZCksICdjaGFpbklkIG1pc21hdGNoJyk7XG4gICAgICAgIGFzc2VydCh1bmxvY2suY2hhbm5lbF9pZGVudGlmaWVyLmVxKGNoYW5uZWwuaWQpLCAnY2hhbm5lbElkIG1pc21hdGNoJyk7XG4gICAgICAgIGFzc2VydCh1bmxvY2subm9uY2UuZXEobmV4dE5vbmNlKGNoYW5uZWwucGFydG5lci5iYWxhbmNlUHJvb2YpKSwgJ25vbmNlIG1pc21hdGNoJyk7XG4gICAgICAgIGNvbnN0IGxvY2sgPSB0cmFuc2YubG9jaztcbiAgICAgICAgY29uc3QgYW1vdW50ID0gbG9jay5hbW91bnQ7XG4gICAgICAgIGFzc2VydCh1bmxvY2sudHJhbnNmZXJyZWRfYW1vdW50LmVxKGNoYW5uZWwucGFydG5lci5iYWxhbmNlUHJvb2YudHJhbnNmZXJyZWRBbW91bnQuYWRkKGFtb3VudCkpLCAndHJhbnNmZXJyZWRBbW91bnQgbWlzbWF0Y2gnKTtcbiAgICAgICAgYXNzZXJ0KHVubG9jay5sb2NrZWRfYW1vdW50LmVxKGNoYW5uZWwucGFydG5lci5iYWxhbmNlUHJvb2YubG9ja2VkQW1vdW50LnN1YihhbW91bnQpKSwgJ2xvY2tlZEFtb3VudCBtaXNtYXRjaCcpO1xuICAgICAgICBjb25zdCBsb2NrcyA9IGNoYW5uZWwucGFydG5lci5sb2Nrcy5maWx0ZXIoKGxvY2spID0+IGxvY2suc2VjcmV0aGFzaCAhPT0gc2VjcmV0aGFzaCk7XG4gICAgICAgIGNvbnN0IGxvY2tzcm9vdCA9IGdldExvY2tzcm9vdChsb2Nrcyk7XG4gICAgICAgIGFzc2VydCh1bmxvY2subG9ja3Nyb290ID09PSBsb2Nrc3Jvb3QsICdsb2Nrc3Jvb3QgbWlzbWF0Y2gnKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0ge1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuUFJPQ0VTU0VELFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jYW1lbGNhc2VcbiAgICAgICAgICAgIG1lc3NhZ2VfaWRlbnRpZmllcjogdW5sb2NrLm1lc3NhZ2VfaWRlbnRpZmllcixcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaWYgYW55IG9mIHRoZXNlIHNpZ25hdHVyZSBwcm9tcHRzIGZhaWwsIG5vbmUgb2YgdGhlc2UgYWN0aW9ucyB3aWxsIGJlIGVtaXR0ZWRcbiAgICAgICAgcmV0dXJuIGZyb20oc2lnbk1lc3NhZ2Uoc2lnbmVyLCBwcm9jZXNzZWQsIHsgbG9nIH0pKS5waXBlKG1lcmdlTWFwKGZ1bmN0aW9uKiAocHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICB5aWVsZCB0cmFuc2ZlclVubG9jay5zdWNjZXNzKHsgbWVzc2FnZTogdW5sb2NrIH0sIG1ldGEpO1xuICAgICAgICAgICAgLy8gc2V0cyBUcmFuc2ZlclN0YXRlLnRyYW5zZmVyUHJvY2Vzc2VkXG4gICAgICAgICAgICB5aWVsZCB0cmFuc2ZlclVubG9ja1Byb2Nlc3NlZCh7IG1lc3NhZ2U6IHByb2Nlc3NlZCB9LCBtZXRhKTtcbiAgICAgICAgICAgIHlpZWxkIHRyYW5zZmVyLnN1Y2Nlc3MoeyBiYWxhbmNlUHJvb2Y6IGdldEJhbGFuY2VQcm9vZkZyb21FbnZlbG9wZU1lc3NhZ2UodW5sb2NrKSB9LCBtZXRhKTtcbiAgICAgICAgfSkpO1xuICAgIH0pLCBjYXRjaEVycm9yKChlcnIpID0+IHtcbiAgICAgICAgbG9nLndhcm4oJ0Vycm9yIHRyeWluZyB0byBwcm9jZXNzIHJlY2VpdmVkIFVubG9jaycsIGVycik7XG4gICAgICAgIHJldHVybiBvZih0cmFuc2ZlclVubG9jay5mYWlsdXJlKGVyciwgbWV0YSkpO1xuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIHJlY2VpdmVUcmFuc2ZlckV4cGlyZWQoc3RhdGUkLCBhY3Rpb24sIHsgbG9nLCBuZXR3b3JrLCBzaWduZXIsIGNvbmZpZyQgfSkge1xuICAgIGNvbnN0IHNlY3JldGhhc2ggPSBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlLnNlY3JldGhhc2g7XG4gICAgY29uc3QgbWV0YSA9IHsgc2VjcmV0aGFzaCwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uUkVDRUlWRUQgfTtcbiAgICByZXR1cm4gY29tYmluZUxhdGVzdChbc3RhdGUkLCBjb25maWckXSkucGlwZShmaXJzdCgpLCBtZXJnZU1hcCgoW3N0YXRlLCB7IGNvbmZpcm1hdGlvbkJsb2NrcyB9XSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKCEoc2VjcmV0aGFzaCBpbiBzdGF0ZS5yZWNlaXZlZCkpXG4gICAgICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVkID0gc3RhdGUucmVjZWl2ZWRbc2VjcmV0aGFzaF07XG4gICAgICAgIGNvbnN0IGV4cGlyZWQgPSBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlO1xuICAgICAgICBjb25zdCBwYXJ0bmVyID0gYWN0aW9uLm1ldGEuYWRkcmVzcztcbiAgICAgICAgYXNzZXJ0KHBhcnRuZXIgPT09IHJlY2VpdmVkLnBhcnRuZXIsICd3cm9uZyBwYXJ0bmVyJyk7XG4gICAgICAgIGlmIChyZWNlaXZlZC5sb2NrRXhwaXJlZCkge1xuICAgICAgICAgICAgbG9nLndhcm4oJ3RyYW5zZmVyIGFscmVhZHkgZXhwaXJlZCcsIGFjdGlvbi5tZXRhKTtcbiAgICAgICAgICAgIC8vIGlmIG1lc3NhZ2UgbWF0Y2hlcyB0aGUgc3RvcmVkIG9uZSwgcmUtc2VuZCBQcm9jZXNzZWQgb25jZVxuICAgICAgICAgICAgaWYgKHJlY2VpdmVkLmxvY2tFeHBpcmVkUHJvY2Vzc2VkICYmXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQubG9ja0V4cGlyZWRQcm9jZXNzZWRbMV0ubWVzc2FnZV9pZGVudGlmaWVyLmVxKGV4cGlyZWQubWVzc2FnZV9pZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgICAgIC8vIHRyYW5zZmVyUHJvY2Vzc2VkIGFnYWluIHdpbGwgdHJpZ2dlciBtZXNzYWdlU2VuZC5yZXF1ZXN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKHRyYW5zZmVyRXhwaXJlUHJvY2Vzc2VkKHsgbWVzc2FnZTogcmVjZWl2ZWQubG9ja0V4cGlyZWRQcm9jZXNzZWRbMV0gfSwgbWV0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBFTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2YgPSByZWNlaXZlZC50cmFuc2ZlclsxXTtcbiAgICAgICAgLy8gbG9ja0V4cGlyZWQgdmFsaWRhdGlvblxuICAgICAgICBhc3NlcnQodHJhbnNmLmxvY2suZXhwaXJhdGlvbi5hZGQoY29uZmlybWF0aW9uQmxvY2tzKS5sdGUoc3RhdGUuYmxvY2tOdW1iZXIpLCAnZXhwaXJhdGlvbiBibG9jayBub3QgY29uZmlybWVkIHlldCcpO1xuICAgICAgICBhc3NlcnQoIXJlY2VpdmVkLnVubG9jaywgJ3RyYW5zZmVyIHVubG9ja2VkJyk7XG4gICAgICAgIGFzc2VydCghKChfYiA9IChfYSA9IHJlY2VpdmVkLnNlY3JldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzFdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVnaXN0ZXJCbG9jayksICdzZWNyZXQgcmVnaXN0ZXJlZCcpO1xuICAgICAgICBjb25zdCB0b2tlbk5ldHdvcmsgPSBleHBpcmVkLnRva2VuX25ldHdvcmtfYWRkcmVzcztcbiAgICAgICAgYXNzZXJ0KHRva2VuTmV0d29yayA9PT0gdHJhbnNmLnRva2VuX25ldHdvcmtfYWRkcmVzcywgJ3dyb25nIHRva2VuTmV0d29yaycpO1xuICAgICAgICBjb25zdCBjaGFubmVsID0gKF9jID0gc3RhdGUuY2hhbm5lbHNbdG9rZW5OZXR3b3JrXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jW3BhcnRuZXJdO1xuICAgICAgICBhc3NlcnQoKGNoYW5uZWwgPT09IG51bGwgfHwgY2hhbm5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbC5zdGF0ZSkgPT09IENoYW5uZWxTdGF0ZS5vcGVuICYmXG4gICAgICAgICAgICBjaGFubmVsLnBhcnRuZXIuYmFsYW5jZVByb29mICYmXG4gICAgICAgICAgICBjaGFubmVsLnBhcnRuZXIubG9ja3MsICdjaGFubmVsIG5vdCBmb3VuZCBvciBub3Qgb3BlbicpO1xuICAgICAgICBhc3NlcnQoZXhwaXJlZC5jaGFpbl9pZC5lcShuZXR3b3JrLmNoYWluSWQpLCAnY2hhaW5JZCBtaXNtYXRjaCcpO1xuICAgICAgICBhc3NlcnQoZXhwaXJlZC5jaGFubmVsX2lkZW50aWZpZXIuZXEoY2hhbm5lbC5pZCksICdjaGFubmVsSWQgbWlzbWF0Y2gnKTtcbiAgICAgICAgYXNzZXJ0KGV4cGlyZWQubm9uY2UuZXEobmV4dE5vbmNlKGNoYW5uZWwucGFydG5lci5iYWxhbmNlUHJvb2YpKSwgJ25vbmNlIG1pc21hdGNoJyk7XG4gICAgICAgIGNvbnN0IGxvY2sgPSB0cmFuc2YubG9jaztcbiAgICAgICAgY29uc3QgYW1vdW50ID0gbG9jay5hbW91bnQ7XG4gICAgICAgIGFzc2VydChleHBpcmVkLnRyYW5zZmVycmVkX2Ftb3VudC5lcShjaGFubmVsLnBhcnRuZXIuYmFsYW5jZVByb29mLnRyYW5zZmVycmVkQW1vdW50KSwgJ3RyYW5zZmVycmVkQW1vdW50IG1pc21hdGNoJyk7XG4gICAgICAgIGFzc2VydChleHBpcmVkLmxvY2tlZF9hbW91bnQuZXEoY2hhbm5lbC5wYXJ0bmVyLmJhbGFuY2VQcm9vZi5sb2NrZWRBbW91bnQuc3ViKGFtb3VudCkpLCAnbG9ja2VkQW1vdW50IG1pc21hdGNoJyk7XG4gICAgICAgIGNvbnN0IGxvY2tzID0gY2hhbm5lbC5wYXJ0bmVyLmxvY2tzLmZpbHRlcigobG9jaykgPT4gbG9jay5zZWNyZXRoYXNoICE9PSBzZWNyZXRoYXNoKTtcbiAgICAgICAgY29uc3QgbG9ja3Nyb290ID0gZ2V0TG9ja3Nyb290KGxvY2tzKTtcbiAgICAgICAgYXNzZXJ0KGV4cGlyZWQubG9ja3Nyb290ID09PSBsb2Nrc3Jvb3QsICdsb2Nrc3Jvb3QgbWlzbWF0Y2gnKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0ge1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuUFJPQ0VTU0VELFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jYW1lbGNhc2VcbiAgICAgICAgICAgIG1lc3NhZ2VfaWRlbnRpZmllcjogZXhwaXJlZC5tZXNzYWdlX2lkZW50aWZpZXIsXG4gICAgICAgIH07XG4gICAgICAgIC8vIGlmIGFueSBvZiB0aGVzZSBzaWduYXR1cmUgcHJvbXB0cyBmYWlsLCBub25lIG9mIHRoZXNlIGFjdGlvbnMgd2lsbCBiZSBlbWl0dGVkXG4gICAgICAgIHJldHVybiBmcm9tKHNpZ25NZXNzYWdlKHNpZ25lciwgcHJvY2Vzc2VkLCB7IGxvZyB9KSkucGlwZShtZXJnZU1hcChmdW5jdGlvbiogKHByb2Nlc3NlZCkge1xuICAgICAgICAgICAgeWllbGQgdHJhbnNmZXJFeHBpcmUuc3VjY2Vzcyh7IG1lc3NhZ2U6IGV4cGlyZWQgfSwgbWV0YSk7XG4gICAgICAgICAgICAvLyBzZXRzIFRyYW5zZmVyU3RhdGUudHJhbnNmZXJQcm9jZXNzZWRcbiAgICAgICAgICAgIHlpZWxkIHRyYW5zZmVyRXhwaXJlUHJvY2Vzc2VkKHsgbWVzc2FnZTogcHJvY2Vzc2VkIH0sIG1ldGEpO1xuICAgICAgICAgICAgeWllbGQgdHJhbnNmZXIuZmFpbHVyZShuZXcgUmFpZGVuRXJyb3IoRXJyb3JDb2Rlcy5YRkVSX0VYUElSRUQsIHtcbiAgICAgICAgICAgICAgICBibG9jazogdHJhbnNmLmxvY2suZXhwaXJhdGlvbi50b1N0cmluZygpLFxuICAgICAgICAgICAgfSksIG1ldGEpO1xuICAgICAgICB9KSk7XG4gICAgfSksIGNhdGNoRXJyb3IoKGVycikgPT4ge1xuICAgICAgICBsb2cud2FybignRXJyb3IgdHJ5aW5nIHRvIHByb2Nlc3MgcmVjZWl2ZWQgTG9ja0V4cGlyZWQnLCBlcnIpO1xuICAgICAgICByZXR1cm4gb2YodHJhbnNmZXJFeHBpcmUuZmFpbHVyZShlcnIsIG1ldGEpKTtcbiAgICB9KSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZSBjcmVhdGlvbiBhbmQgc2lnbmluZyBvZiBCYWxhbmNlUHJvb2YtY2hhbmdpbmcgbWVzc2FnZXMgb3IgYWN0aW9uc1xuICogQWN0aW9ucyB3aGljaCBjaGFuZ2UgYW55IGRhdGEgaW4gYW55IGNoYW5uZWwgYmFsYW5jZSBwcm9vZiBtdXN0IG9ubHkgZXZlciBiZSBjcmVhdGVkIHJlYWRpbmdcbiAqIHN0YXRlIGluc2lkZSB0aGUgc2VyaWFsaXphdGlvbiBmbG93IHByb3ZpZGVkIGJ5IHRoZSBjb25jYXRNYXAsIGFuZCBhbHNvIGJlIGNvbXBvc2VkIGFuZCBwcm9kdWNlZFxuICogaW5zaWRlIGl0IChpbm5lciwgc3Vic2NyaWJlZCBvYnNlcnZhYmxlKVxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5BY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEBwYXJhbSBkZXBzIC0gUmFpZGVuRXBpY0RlcHNcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2Ygb3V0cHV0IGFjdGlvbnMgZm9yIHRoaXMgZXBpY1xuICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXJHZW5lcmF0ZUFuZFNpZ25FbnZlbG9wZU1lc3NhZ2VFcGljID0gKGFjdGlvbiQsIHt9LCBkZXBzKSA9PiB7XG4gICAgY29uc3Qgd2l0aGRyYXdDYWNoZSA9IG5ldyBMcnVDYWNoZSgzMik7XG4gICAgY29uc3Qgc3RhdGUkID0gZGVwcy5sYXRlc3QkLnBpcGUocGx1Y2tEaXN0aW5jdCgnc3RhdGUnKSk7IC8vIHJlcGxheWVkKDEpJyBzdGF0ZSRcbiAgICByZXR1cm4gbWVyZ2UoYWN0aW9uJC5waXBlKGZpbHRlcihpc0FjdGlvbk9mKFtcbiAgICAgICAgdHJhbnNmZXIucmVxdWVzdCxcbiAgICAgICAgdHJhbnNmZXJVbmxvY2sucmVxdWVzdCxcbiAgICAgICAgdHJhbnNmZXJFeHBpcmUucmVxdWVzdCxcbiAgICAgICAgd2l0aGRyYXdSZWNlaXZlLnJlcXVlc3QsXG4gICAgXSkpKSwgXG4gICAgLy8gbWVyZ2Ugc2VwYXJhdGVkbHksIHRvIGZpbHRlciBwZXIgbWVzc2FnZSB0eXBlIGJlZm9yZSBjb25jYXRcbiAgICBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzTWVzc2FnZVJlY2VpdmVkT2ZUeXBlKFtTaWduZWQoTG9ja2VkVHJhbnNmZXIpLCBTaWduZWQoVW5sb2NrKSwgU2lnbmVkKExvY2tFeHBpcmVkKV0pKSkpLnBpcGUoY29uY2F0TWFwKChhY3Rpb24pID0+IHRyYW5zZmVyLnJlcXVlc3QuaXMoYWN0aW9uKVxuICAgICAgICA/IG1ha2VBbmRTaWduVHJhbnNmZXIoc3RhdGUkLCBhY3Rpb24sIGRlcHMpXG4gICAgICAgIDogdHJhbnNmZXJVbmxvY2sucmVxdWVzdC5pcyhhY3Rpb24pXG4gICAgICAgICAgICA/IG1ha2VBbmRTaWduVW5sb2NrKHN0YXRlJCwgYWN0aW9uLCBkZXBzKVxuICAgICAgICAgICAgOiB0cmFuc2ZlckV4cGlyZS5yZXF1ZXN0LmlzKGFjdGlvbilcbiAgICAgICAgICAgICAgICA/IG1ha2VBbmRTaWduTG9ja0V4cGlyZWQoc3RhdGUkLCBhY3Rpb24sIGRlcHMpXG4gICAgICAgICAgICAgICAgOiB3aXRoZHJhd1JlY2VpdmUucmVxdWVzdC5pcyhhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgID8gbWFrZUFuZFNpZ25XaXRoZHJhd0NvbmZpcm1hdGlvbihzdGF0ZSQsIGFjdGlvbiwgZGVwcywgd2l0aGRyYXdDYWNoZSlcbiAgICAgICAgICAgICAgICAgICAgOiBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlLnR5cGUgPT09IE1lc3NhZ2VUeXBlLkxPQ0tFRF9UUkFOU0ZFUlxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWNlaXZlVHJhbnNmZXJTaWduZWQoc3RhdGUkLCBhY3Rpb24sIGRlcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2UudHlwZSA9PT0gTWVzc2FnZVR5cGUuVU5MT0NLXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByZWNlaXZlVHJhbnNmZXJVbmxvY2tlZChzdGF0ZSQsIGFjdGlvbiwgZGVwcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlY2VpdmVUcmFuc2ZlckV4cGlyZWQoc3RhdGUkLCBhY3Rpb24sIGRlcHMpKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9ja2VkLmpzLm1hcCIsImltcG9ydCB7IGZyb20gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgZmlyc3QsIG1lcmdlTWFwLCB3aXRoTGF0ZXN0RnJvbSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENhcGFiaWxpdGllcyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBtYXRyaXhQcmVzZW5jZSB9IGZyb20gJy4uLy4uL3RyYW5zcG9ydC9hY3Rpb25zJztcbmltcG9ydCB7IHRyYW5zZmVyRXhwaXJlLCB0cmFuc2ZlclNpZ25lZCwgdHJhbnNmZXJVbmxvY2ssIHRyYW5zZmVyU2VjcmV0UmVxdWVzdCwgdHJhbnNmZXJTZWNyZXRSZXZlYWwsIHRyYW5zZmVyU2VjcmV0LCB9IGZyb20gJy4uL2FjdGlvbnMnO1xuaW1wb3J0IHsgRGlyZWN0aW9uIH0gZnJvbSAnLi4vc3RhdGUnO1xuLyoqXG4gKiBSZS1xdWV1ZSBwZW5kaW5nIHRyYW5zZmVyJ3MgQmFsYW5jZVByb29mL0VudmVsb3BlIG1lc3NhZ2VzIGZvciByZXRyeSBvbiBpbml0XG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlbkFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB0cmFuc2ZlclNpZ25lZHx0cmFuc2ZlclVubG9jay5zdWNjZXNzIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRRdWV1ZVBlbmRpbmdFbnZlbG9wZU1lc3NhZ2VzRXBpYyA9ICh7fSwgc3RhdGUkKSA9PiBzdGF0ZSQucGlwZShmaXJzdCgpLCBtZXJnZU1hcChmdW5jdGlvbiogKHN0YXRlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAvLyBsb29wIG92ZXIgYWxsIHBlbmRpbmcgdHJhbnNmZXJzXG4gICAgZm9yIChjb25zdCBba2V5LCBzZW50XSBvZiBPYmplY3QuZW50cmllcyhzdGF0ZS5zZW50KSkge1xuICAgICAgICBjb25zdCBzZWNyZXRoYXNoID0ga2V5O1xuICAgICAgICAvLyB0cmFuc2ZlciBhbHJlYWR5IGNvbXBsZXRlZCBvciBjaGFubmVsQ2xvc2VkXG4gICAgICAgIGlmIChzZW50LnVubG9ja1Byb2Nlc3NlZCB8fFxuICAgICAgICAgICAgc2VudC5sb2NrRXhwaXJlZFByb2Nlc3NlZCB8fCAoKF9iID0gKF9hID0gc2VudC5zZWNyZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsxXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlZ2lzdGVyQmxvY2spIHx8XG4gICAgICAgICAgICBzZW50LmNoYW5uZWxDbG9zZWQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbWV0YSA9IHsgc2VjcmV0aGFzaCwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uU0VOVCB9O1xuICAgICAgICAvLyBvbiBpbml0LCByZXF1ZXN0IG1vbml0b3IgcHJlc2VuY2Ugb2YgYW55IHBlbmRpbmcgdHJhbnNmZXIgdGFyZ2V0XG4gICAgICAgIHlpZWxkIG1hdHJpeFByZXNlbmNlLnJlcXVlc3QodW5kZWZpbmVkLCB7IGFkZHJlc3M6IHNlbnQudHJhbnNmZXJbMV0udGFyZ2V0IH0pO1xuICAgICAgICAvLyBQcm9jZXNzZWQgbm90IHJlY2VpdmVkIHlldCBmb3IgTG9ja2VkVHJhbnNmZXJcbiAgICAgICAgaWYgKCFzZW50LnRyYW5zZmVyUHJvY2Vzc2VkKVxuICAgICAgICAgICAgeWllbGQgdHJhbnNmZXJTaWduZWQoeyBtZXNzYWdlOiBzZW50LnRyYW5zZmVyWzFdLCBmZWU6IHNlbnQuZmVlIH0sIG1ldGEpO1xuICAgICAgICAvLyBhbHJlYWR5IHVubG9ja2VkLCBidXQgUHJvY2Vzc2VkIG5vdCByZWNlaXZlZCB5ZXQgZm9yIFVubG9ja1xuICAgICAgICBpZiAoc2VudC51bmxvY2spXG4gICAgICAgICAgICB5aWVsZCB0cmFuc2ZlclVubG9jay5zdWNjZXNzKHsgbWVzc2FnZTogc2VudC51bmxvY2tbMV0gfSwgbWV0YSk7XG4gICAgICAgIC8vIGxvY2sgZXhwaXJlZCwgYnV0IFByb2Nlc3NlZCBub3QgcmVjZWl2ZWQgeWV0IGZvciBMb2NrRXhwaXJlZFxuICAgICAgICBpZiAoc2VudC5sb2NrRXhwaXJlZClcbiAgICAgICAgICAgIHlpZWxkIHRyYW5zZmVyRXhwaXJlLnN1Y2Nlc3MoeyBtZXNzYWdlOiBzZW50LmxvY2tFeHBpcmVkWzFdIH0sIG1ldGEpO1xuICAgIH1cbn0pKTtcbi8qKlxuICogUmUtcXVldWUgcGVuZGluZyBSZWNlaXZlZCB0cmFuc2ZlcidzXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlbkFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB0cmFuc2ZlclNpZ25lZHx0cmFuc2ZlclVubG9jay5zdWNjZXNzIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRRdWV1ZVBlbmRpbmdSZWNlaXZlZEVwaWMgPSAoe30sIHN0YXRlJCwgeyBjb25maWckIH0pID0+IHN0YXRlJC5waXBlKGZpcnN0KCksIG1lcmdlTWFwKChzdGF0ZSkgPT4gZnJvbShPYmplY3QuZW50cmllcyhzdGF0ZS5yZWNlaXZlZCkpKSwgZmlsdGVyKChbLCByZWNlaXZlZF0pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAhcmVjZWl2ZWQudW5sb2NrICYmXG4gICAgICAgICFyZWNlaXZlZC5sb2NrRXhwaXJlZCAmJlxuICAgICAgICAhKChfYiA9IChfYSA9IHJlY2VpdmVkLnNlY3JldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzFdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVnaXN0ZXJCbG9jaykgJiZcbiAgICAgICAgIXJlY2VpdmVkLmNoYW5uZWxDbG9zZWQ7XG59KSwgd2l0aExhdGVzdEZyb20oY29uZmlnJCksIG1lcmdlTWFwKGZ1bmN0aW9uKiAoW1tzZWNyZXRoYXNoLCByZWNlaXZlZF0sIHsgY2FwcyB9XSkge1xuICAgIC8vIGxvb3Agb3ZlciBhbGwgcGVuZGluZyB0cmFuc2ZlcnNcbiAgICBjb25zdCBtZXRhID0geyBzZWNyZXRoYXNoLCBkaXJlY3Rpb246IERpcmVjdGlvbi5SRUNFSVZFRCB9O1xuICAgIC8vIG9uIGluaXQsIHJlcXVlc3QgbW9uaXRvciBwcmVzZW5jZSBvZiBhbnkgcGVuZGluZyB0cmFuc2ZlciBpbml0aWF0b3JcbiAgICB5aWVsZCB0cmFuc2ZlclNpZ25lZCh7IG1lc3NhZ2U6IHJlY2VpdmVkLnRyYW5zZmVyWzFdLCBmZWU6IHJlY2VpdmVkLmZlZSB9LCBtZXRhKTtcbiAgICAvLyBhbHJlYWR5IHJldmVhbGVkIHRvIHVzLCBidXQgdXNlciBkaWRuJ3Qgc2lnbiBTZWNyZXRSZXZlYWwgeWV0XG4gICAgaWYgKHJlY2VpdmVkLnNlY3JldCAmJiAhcmVjZWl2ZWQuc2VjcmV0UmV2ZWFsKVxuICAgICAgICB5aWVsZCB0cmFuc2ZlclNlY3JldCh7IHNlY3JldDogcmVjZWl2ZWQuc2VjcmV0WzFdLnZhbHVlIH0sIG1ldGEpO1xuICAgIC8vIGFscmVhZHkgcmV2ZWFsZWQgdG8gc2VuZGVyLCBidXQgdGhleSBkaWRuJ3QgVW5sb2NrIHlldFxuICAgIGlmIChyZWNlaXZlZC5zZWNyZXRSZXZlYWwpXG4gICAgICAgIHlpZWxkIHRyYW5zZmVyU2VjcmV0UmV2ZWFsKHsgbWVzc2FnZTogcmVjZWl2ZWQuc2VjcmV0UmV2ZWFsWzFdIH0sIG1ldGEpO1xuICAgIC8vIHNlY3JldCBub3QgeWV0IGtub3duOyByZXF1ZXN0IGlmZiByZWNlaXZpbmcgaXMgZW5hYmxlZFxuICAgIC8vIHNlY3JldFJlcXVlc3Qgc2hvdWxkIGFsd2F5cyBiZSBkZWZpbmVkIGFzIHdlIHNpZ24gaXQgd2hlbiByZWNlaXZpbmcgdHJhbnNmZXJcbiAgICBpZiAoIShjYXBzID09PSBudWxsIHx8IGNhcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhcHNbQ2FwYWJpbGl0aWVzLk5PX1JFQ0VJVkVdKSAmJiAhcmVjZWl2ZWQuc2VjcmV0ICYmIHJlY2VpdmVkLnNlY3JldFJlcXVlc3QpIHtcbiAgICAgICAgeWllbGQgbWF0cml4UHJlc2VuY2UucmVxdWVzdCh1bmRlZmluZWQsIHsgYWRkcmVzczogcmVjZWl2ZWQudHJhbnNmZXJbMV0uaW5pdGlhdG9yIH0pO1xuICAgICAgICB5aWVsZCB0cmFuc2ZlclNlY3JldFJlcXVlc3QoeyBtZXNzYWdlOiByZWNlaXZlZC5zZWNyZXRSZXF1ZXN0WzFdIH0sIG1ldGEpO1xuICAgIH1cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQuanMubWFwIiwiaW1wb3J0IHsgWmVybyB9IGZyb20gJ2V0aGVycy9jb25zdGFudHMnO1xuaW1wb3J0IHsgZmlsdGVyLCBtYXAsIHdpdGhMYXRlc3RGcm9tIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ2FwYWJpbGl0aWVzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IHRyYW5zZmVyLCB0cmFuc2ZlclNpZ25lZCB9IGZyb20gJy4uL2FjdGlvbnMnO1xuaW1wb3J0IHsgRGlyZWN0aW9uIH0gZnJvbSAnLi4vc3RhdGUnO1xuLyoqXG4gKiBXaGVuIHJlY2VpdmluZyBhIHRyYW5zZmVyIG5vdCB0YXJnZXRpbmcgdXMsIGNyZWF0ZSBhbiBvdXRnb2luZyB0cmFuc2ZlciB0byB0YXJnZXRcbiAqIE1lZGlhdGVkIHRyYW5zZmVycyBhcmUgaGFuZGxlZCB0aGUgc2FtZSB3YXkgYXMgdW5yZWxhdGVkIHJlY2VpdmVkICYgc2VudCBwYWlycy4gVGhlIGRpZmZlcmVuY2VcbiAqIGlzIHRoYXQgd2UgZG9uJ3QgcmVxdWVzdCB0aGUgc2VjcmV0IChhcyBpbml0aWF0b3Igd291bGQgb25seSByZXZlYWwgdG8gdGFyZ2V0KSwgYW5kIGluc3RlYWQsXG4gKiB3YWl0IGZvciBTZWNyZXRSZXZlYWwgdG8gY2FzY2FkZSBiYWNrIGZyb20gb3V0Ym91bmQgcGFydG5lciwgdGhlbiB3ZSB1bmxvY2sgaXQgYW5kIHJldmVhbCBiYWNrXG4gKiB0byBpbmJvdW5kIHBhcnRuZXIsIHRvIGdldCBpdHMgVW5sb2NrLlxuICogSWYgaXQgZG9lc24ndCBzdWNjZWVkLCBpZiB3ZSBkaWRuJ3QgZ2V0IHJldmVhbCwgd2UnbGwgYWNjZXB0IExvY2tFeHBpcmVkLCBpZiB3ZSBkaWQgYW5kIGtub3dcbiAqIHRoZSBzZWNyZXQgYnV0IHBhcnRuZXIgZGlkbid0IHVubG9jaywgd2UgcmVnaXN0ZXIgb24tY2hhaW4gYXMgdXN1YWwuXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIGluY29taW5nIHRyYW5zZmVyU2lnbmVkIHRyYW5zZmVyc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gZGVwcyAtIFJhaWRlbiBlcGljIGRlcHNcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2Ygb3V0Ym91bmQgdHJhbnNmZXIucmVxdWVzdCBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2Zlck1lZGlhdGVFcGljID0gKGFjdGlvbiQsIHN0YXRlJCwgeyBhZGRyZXNzLCBjb25maWckIH0pID0+IGFjdGlvbiQucGlwZShmaWx0ZXIodHJhbnNmZXJTaWduZWQuaXMpLCBcbi8vIGZpbHRlciBmb3IgcmVjZWl2ZWQgdHJhbnNmZXJzIG5vdCB0byB1c1xuZmlsdGVyKChhY3Rpb24pID0+IGFjdGlvbi5tZXRhLmRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlJFQ0VJVkVEICYmIGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2UudGFyZ2V0ICE9PSBhZGRyZXNzKSwgd2l0aExhdGVzdEZyb20oc3RhdGUkLCBjb25maWckKSwgXG4vLyBmaWx0ZXIgd2hlbiBtZWRpYXRpbmcgaXMgZW5hYmxlZCBhbmQgb3V0Z29pbmcgdHJhbnNmZXIgaXNuJ3Qgc2V0XG5maWx0ZXIoKFthY3Rpb24sIHsgc2VudCB9LCB7IGNhcHMgfV0pID0+ICEoY2FwcyA9PT0gbnVsbCB8fCBjYXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXBzW0NhcGFiaWxpdGllcy5OT19NRURJQVRFXSkgJiYgIShhY3Rpb24ubWV0YS5zZWNyZXRoYXNoIGluIHNlbnQpKSwgbWFwKChbeyBwYXlsb2FkOiB7IG1lc3NhZ2U6IHRyYW5zZiB9LCBtZXRhOiB7IHNlY3JldGhhc2ggfSB9XSkgPT4gXG4vLyByZXF1ZXN0IGFuIG91dGJvdW5kIHRyYW5zZmVyIHRvIHRhcmdldFxudHJhbnNmZXIucmVxdWVzdCh7XG4gICAgdG9rZW5OZXR3b3JrOiB0cmFuc2YudG9rZW5fbmV0d29ya19hZGRyZXNzLFxuICAgIHRhcmdldDogdHJhbnNmLnRhcmdldCxcbiAgICB2YWx1ZTogdHJhbnNmLmxvY2suYW1vdW50LFxuICAgIHBheW1lbnRJZDogdHJhbnNmLnBheW1lbnRfaWRlbnRpZmllcixcbiAgICBwYXRoczogdHJhbnNmLm1ldGFkYXRhLnJvdXRlcy5tYXAoKHsgcm91dGUgfSkgPT4gKHtcbiAgICAgICAgcGF0aDogcm91dGUuc2xpY2UoMSksXG4gICAgICAgIGZlZTogWmVybyxcbiAgICB9KSksXG4gICAgZXhwaXJhdGlvbjogdHJhbnNmLmxvY2suZXhwaXJhdGlvbi50b051bWJlcigpLFxuICAgIGluaXRpYXRvcjogdHJhbnNmLmluaXRpYXRvcixcbn0sIHsgc2VjcmV0aGFzaCwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uU0VOVCB9KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWF0ZS5qcy5tYXAiLCJpbXBvcnQgeyBkZWZlciwgZnJvbSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNvbmNhdE1hcCwgZmlsdGVyLCBtYXAsIG1lcmdlTWFwLCB0YXAsIHdpdGhMYXRlc3RGcm9tIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IGZpbmRLZXkgZnJvbSAnbG9kYXNoL2ZpbmRLZXknO1xuaW1wb3J0IHsgbWVzc2FnZVNlbmQgfSBmcm9tICcuLi8uLi9tZXNzYWdlcy9hY3Rpb25zJztcbmltcG9ydCB7IE1lc3NhZ2VUeXBlLCBQcm9jZXNzZWQsIFJlZnVuZFRyYW5zZmVyLCBXaXRoZHJhd0V4cGlyZWQgfSBmcm9tICcuLi8uLi9tZXNzYWdlcy90eXBlcyc7XG5pbXBvcnQgeyBnZXRCYWxhbmNlUHJvb2ZGcm9tRW52ZWxvcGVNZXNzYWdlLCBzaWduTWVzc2FnZSwgaXNNZXNzYWdlUmVjZWl2ZWRPZlR5cGUsIH0gZnJvbSAnLi4vLi4vbWVzc2FnZXMvdXRpbHMnO1xuaW1wb3J0IHsgTHJ1Q2FjaGUgfSBmcm9tICcuLi8uLi91dGlscy9scnUnO1xuaW1wb3J0IHsgU2lnbmVkIH0gZnJvbSAnLi4vLi4vdXRpbHMvdHlwZXMnO1xuaW1wb3J0IHsgaXNBY3Rpb25PZiB9IGZyb20gJy4uLy4uL3V0aWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgdHJhbnNmZXIsIHRyYW5zZmVyRXhwaXJlUHJvY2Vzc2VkLCB0cmFuc2ZlclByb2Nlc3NlZCwgdHJhbnNmZXJVbmxvY2tQcm9jZXNzZWQsIH0gZnJvbSAnLi4vYWN0aW9ucyc7XG5pbXBvcnQgeyBEaXJlY3Rpb24gfSBmcm9tICcuLi9zdGF0ZSc7XG4vKipcbiAqIEhhbmRsZXMgcmVjZWl2aW5nIGEgc2lnbmVkIFByb2Nlc3NlZCBmb3Igc29tZSBzZW50IExvY2tlZFRyYW5zZmVyXG4gKiBUaGlzIHdpbGwgcGVyc2lzdCB0aGUgUHJvY2Vzc2VkIHJlcGx5IGluIHRyYW5zZmVyIHN0YXRlIGFuZCBzdG9wIG1lc3NhZ2UgcmV0cnlcbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgbWVzc2FnZVJlY2VpdmVkIGFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB0cmFuc2ZlclByb2Nlc3NlZCBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2ZlclByb2Nlc3NlZFJlY2VpdmVkRXBpYyA9IChhY3Rpb24kLCBzdGF0ZSQpID0+IGFjdGlvbiQucGlwZShmaWx0ZXIoaXNNZXNzYWdlUmVjZWl2ZWRPZlR5cGUoU2lnbmVkKFByb2Nlc3NlZCkpKSwgd2l0aExhdGVzdEZyb20oc3RhdGUkKSwgbWVyZ2VNYXAoZnVuY3Rpb24qIChbYWN0aW9uLCBzdGF0ZV0pIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYWN0aW9uLnBheWxvYWQubWVzc2FnZTtcbiAgICBsZXQgc2VjcmV0aGFzaCA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHNlbnRdIG9mIE9iamVjdC5lbnRyaWVzKHN0YXRlLnNlbnQpKSB7XG4gICAgICAgIGlmIChzZW50LnRyYW5zZmVyWzFdLm1lc3NhZ2VfaWRlbnRpZmllci5lcShtZXNzYWdlLm1lc3NhZ2VfaWRlbnRpZmllcikgJiZcbiAgICAgICAgICAgIHNlbnQudHJhbnNmZXJbMV0ucmVjaXBpZW50ID09PSBhY3Rpb24ubWV0YS5hZGRyZXNzKSB7XG4gICAgICAgICAgICBzZWNyZXRoYXNoID0ga2V5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzZWNyZXRoYXNoKVxuICAgICAgICByZXR1cm47XG4gICAgeWllbGQgdHJhbnNmZXJQcm9jZXNzZWQoeyBtZXNzYWdlIH0sIHsgc2VjcmV0aGFzaCwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uU0VOVCB9KTtcbn0pKTtcbi8qKlxuICogSGFuZGxlcyBzZW5kaW5nIFByb2Nlc3NlZCBmb3IgYSByZWNlaXZlZCBFbnZlbG9wZU1lc3NhZ2VzXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIHRyYW5zZmVyUHJvY2Vzc2VkIGFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBtZXNzYWdlU2VuZC5yZXF1ZXN0IGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zZmVyUHJvY2Vzc2VkU2VuZEVwaWMgPSAoYWN0aW9uJCwgc3RhdGUkKSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzQWN0aW9uT2YoW3RyYW5zZmVyUHJvY2Vzc2VkLCB0cmFuc2ZlclVubG9ja1Byb2Nlc3NlZCwgdHJhbnNmZXJFeHBpcmVQcm9jZXNzZWRdKSksIFxuLy8gdHJhbnNmZXIgZGlyZWN0aW9uIGlzIFJFQ0VJVkVELCBub3QgbWVzc2FnZSBkaXJlY3Rpb24gKHdoaWNoIGlzIG91dGJvdW5kKVxuZmlsdGVyKChhY3Rpb24pID0+IGFjdGlvbi5tZXRhLmRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlJFQ0VJVkVEKSwgd2l0aExhdGVzdEZyb20oc3RhdGUkKSwgbWFwKChbYWN0aW9uLCB7IHJlY2VpdmVkIH1dKSA9PiBtZXNzYWdlU2VuZC5yZXF1ZXN0KHsgbWVzc2FnZTogYWN0aW9uLnBheWxvYWQubWVzc2FnZSB9LCB7XG4gICAgYWRkcmVzczogcmVjZWl2ZWRbYWN0aW9uLm1ldGEuc2VjcmV0aGFzaF0ucGFydG5lcixcbiAgICBtc2dJZDogYWN0aW9uLnBheWxvYWQubWVzc2FnZS5tZXNzYWdlX2lkZW50aWZpZXIudG9TdHJpbmcoKSxcbn0pKSk7XG4vKipcbiAqIEhhbmRsZXMgcmVjZWl2aW5nIGEgc2lnbmVkIFByb2Nlc3NlZCBmb3Igc29tZSBzZW50IFVubG9ja1xuICogSXQgc2VuZHMgdGhlIHN1Y2Nlc3MgYWN0aW9uIGZvciB0cmFuc2ZlciAod2hpY2ggcmVzb2x2ZXMgYW55IHBlbmRpbmcgUHJvbWlzZSksIG1hcmtpbmcgaXQgYXNcbiAqIGNvbXBsZXRlZCBzdWNjZXNzZnVseSBieSBzZXR0aW5nIHNlbnQudW5sb2NrUHJvY2Vzc2VkXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIG1lc3NhZ2VSZWNlaXZlZCBhY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2YgdHJhbnNmZXIuc3VjY2Vzc3x0cmFuc2ZlclVubG9ja1Byb2Nlc3NlZCBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2ZlclVubG9ja1Byb2Nlc3NlZFJlY2VpdmVkRXBpYyA9IChhY3Rpb24kLCBzdGF0ZSQpID0+IGFjdGlvbiQucGlwZShmaWx0ZXIoaXNNZXNzYWdlUmVjZWl2ZWRPZlR5cGUoU2lnbmVkKFByb2Nlc3NlZCkpKSwgd2l0aExhdGVzdEZyb20oc3RhdGUkKSwgbWVyZ2VNYXAoZnVuY3Rpb24qIChbYWN0aW9uLCBzdGF0ZV0pIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYWN0aW9uLnBheWxvYWQubWVzc2FnZTtcbiAgICBjb25zdCBzZWNyZXRoYXNoID0gZmluZEtleShzdGF0ZS5zZW50LCAoc2VudCkgPT4gc2VudC51bmxvY2sgJiZcbiAgICAgICAgc2VudC51bmxvY2tbMV0ubWVzc2FnZV9pZGVudGlmaWVyLmVxKG1lc3NhZ2UubWVzc2FnZV9pZGVudGlmaWVyKSAmJlxuICAgICAgICBzZW50LnBhcnRuZXIgPT09IGFjdGlvbi5tZXRhLmFkZHJlc3MpO1xuICAgIGlmICghc2VjcmV0aGFzaClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG1ldGEgPSB7IHNlY3JldGhhc2gsIGRpcmVjdGlvbjogRGlyZWN0aW9uLlNFTlQgfTtcbiAgICB5aWVsZCB0cmFuc2Zlci5zdWNjZXNzKHtcbiAgICAgICAgYmFsYW5jZVByb29mOiBnZXRCYWxhbmNlUHJvb2ZGcm9tRW52ZWxvcGVNZXNzYWdlKHN0YXRlLnNlbnRbc2VjcmV0aGFzaF0udW5sb2NrWzFdKSxcbiAgICB9LCBtZXRhKTtcbiAgICB5aWVsZCB0cmFuc2ZlclVubG9ja1Byb2Nlc3NlZCh7IG1lc3NhZ2UgfSwgbWV0YSk7XG59KSk7XG4vKipcbiAqIEhhbmRsZXMgcmVjZWl2aW5nIGEgc2lnbmVkIFByb2Nlc3NlZCBmb3Igc29tZSBzZW50IExvY2tFeHBpcmVkXG4gKiBJdCBtYXJrcyB0aGUgZW5kIG9mIHRoZSB1bmhhcHB5IGNhc2UsIGJ5IHNldHRpbmcgc2VudC5sb2NrRXhwaXJlZFByb2Nlc3NlZFxuICogdHJhbnNmZXIuZmFpbHVyZSB3YXMgYWxyZWFkeSBzZW50IGF0IG5ld0Jsb2NrIGhhbmRsaW5nL3RyYW5zZmVyRXhwaXJlLnJlcXVlc3QgdGltZVxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5BY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2Ygb3V0cHV0IGFjdGlvbnMgZm9yIHRoaXMgZXBpY1xuICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXJFeHBpcmVQcm9jZXNzZWRFcGljID0gKGFjdGlvbiQsIHN0YXRlJCkgPT4gYWN0aW9uJC5waXBlKGZpbHRlcihpc01lc3NhZ2VSZWNlaXZlZE9mVHlwZShTaWduZWQoUHJvY2Vzc2VkKSkpLCB3aXRoTGF0ZXN0RnJvbShzdGF0ZSQpLCBtZXJnZU1hcChmdW5jdGlvbiogKFthY3Rpb24sIHN0YXRlXSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlO1xuICAgIGNvbnN0IHNlY3JldGhhc2ggPSBmaW5kS2V5KHN0YXRlLnNlbnQsIChzZW50KSA9PiBzZW50LmxvY2tFeHBpcmVkICYmXG4gICAgICAgIHNlbnQubG9ja0V4cGlyZWRbMV0ubWVzc2FnZV9pZGVudGlmaWVyLmVxKG1lc3NhZ2UubWVzc2FnZV9pZGVudGlmaWVyKSAmJlxuICAgICAgICBzZW50LnBhcnRuZXIgPT09IGFjdGlvbi5tZXRhLmFkZHJlc3MpO1xuICAgIGlmICghc2VjcmV0aGFzaClcbiAgICAgICAgcmV0dXJuO1xuICAgIHlpZWxkIHRyYW5zZmVyRXhwaXJlUHJvY2Vzc2VkKHsgbWVzc2FnZSB9LCB7IHNlY3JldGhhc2gsIGRpcmVjdGlvbjogRGlyZWN0aW9uLlNFTlQgfSk7XG59KSk7XG4vKipcbiAqIFNlbmRzIFByb2Nlc3NlZCBmb3IgdW5oYW5kbGVkIG5vbmNlJ2QgbWVzc2FnZXNcbiAqXG4gKiBXZSBkb24ndCB5ZXQgc3VwcG9ydCByZWNlaXZpbmcgbm9yIG1lZGlhdGluZyB0cmFuc2ZlcnMgKExvY2tlZFRyYW5zZmVyLCBSZWZ1bmRUcmFuc2ZlciksIGJ1dFxuICogYWxzbyBkb24ndCB3YW50IHRoZSBwYXJ0bmVyIHRvIGtlZXAgcmV0cnlpbmcgYW55IG1lc3NhZ2VzIGludGVuZGVkIGZvciB1cyBpbmRlZmluaXRlbHkuXG4gKiBUaGF0J3Mgd2h5IHdlIGRlY2lkZWQgdG8ganVzdCBhbnN3ZXIgdGhlbSB3aXRoIFByb2Nlc3NlZCwgdG8gY2xlYXIgdGhlaXIgcXVldWUuIE9mIGNvdXJzZSwgd2VcbiAqIHN0aWxsIGRvbid0IHZhbGlkYXRlLCBzdG9yZSBzdGF0ZSBmb3IgdGhlc2UgbWVzc2FnZXMgbm9yIGhhbmRsZSB0aGVtIGluIGFueSB3YXkgKGUuZy4gcmVxdWVzdGluZ1xuICogc2VjcmV0IGZyb20gaW5pdGlhdG9yKSwgc28gYW55IHRyYW5zZmVyIGlzIGdvaW5nIHRvIGV4cGlyZSwgYW5kIHRoZW4gd2UgYWxzbyByZXBseSBQcm9jZXNzZWQgZm9yXG4gKiB0aGUgcmVzcGVjdGl2ZSBMb2NrRXhwaXJlZC5cbiAqIEFkZGl0aW9uYWxseSwgd2UgaG9vayBpbiBzZW5kaW5nIFByb2Nlc3NlZCBmb3Igb3RoZXIgbWVzc2FnZXMgd2hpY2ggY29udGFpbiBub25jZXMgKGFuZCByZXF1aXJlXG4gKiBQcm9jZXNzZWQgcmVwbHkgdG8gc3RvcCBiZWluZyByZXRyaWVkKSBidXQgYXJlIHNhZmUgdG8gYmUgaWdub3JlZCwgbGlrZSBXaXRoZHJhd0V4cGlyZWQuXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIG1lc3NhZ2VSZWNlaXZlZCBhY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEBwYXJhbSBzaWduZXIgLSBSYWlkZW5FcGljRGVwcyBtZW1iZXJzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIG1lc3NhZ2VTZW5kLnJlcXVlc3QgYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXJSZWNlaXZlZFJlcGx5UHJvY2Vzc2VkRXBpYyA9IChhY3Rpb24kLCB7fSwgeyBsb2csIHNpZ25lciB9KSA9PiB7XG4gICAgY29uc3QgY2FjaGUgPSBuZXcgTHJ1Q2FjaGUoMzIpO1xuICAgIHJldHVybiBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzTWVzc2FnZVJlY2VpdmVkT2ZUeXBlKFtTaWduZWQoUmVmdW5kVHJhbnNmZXIpLCBTaWduZWQoV2l0aGRyYXdFeHBpcmVkKV0pKSwgY29uY2F0TWFwKChhY3Rpb24pID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2U7XG4gICAgICAgIC8vIGRlZmVyIGNhdXNlcyB0aGUgY2FjaGUgY2hlY2sgdG8gYmUgcGVyZm9ybWVkIGF0IHN1YnNjcmlwdGlvbiB0aW1lXG4gICAgICAgIHJldHVybiBkZWZlcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtc2dJZCA9IG1lc3NhZ2UubWVzc2FnZV9pZGVudGlmaWVyO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gbXNnSWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gb2YobWVzc2FnZVNlbmQucmVxdWVzdCh7IG1lc3NhZ2U6IGNhY2hlZCB9LCB7IGFkZHJlc3M6IGFjdGlvbi5tZXRhLmFkZHJlc3MsIG1zZ0lkOiBrZXkgfSkpO1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlBST0NFU1NFRCxcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2NhbWVsY2FzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2VfaWRlbnRpZmllcjogbXNnSWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZyb20oc2lnbk1lc3NhZ2Uoc2lnbmVyLCBwcm9jZXNzZWQsIHsgbG9nIH0pKS5waXBlKHRhcCgoc2lnbmVkKSA9PiBjYWNoZS5wdXQoa2V5LCBzaWduZWQpKSwgbWFwKChzaWduZWQpID0+IG1lc3NhZ2VTZW5kLnJlcXVlc3QoeyBtZXNzYWdlOiBzaWduZWQgfSwgeyBhZGRyZXNzOiBhY3Rpb24ubWV0YS5hZGRyZXNzLCBtc2dJZDoga2V5IH0pKSk7XG4gICAgICAgIH0pO1xuICAgIH0pKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzZWQuanMubWFwIiwiaW1wb3J0IHsgZmlsdGVyLCBtZXJnZU1hcCwgd2l0aExhdGVzdEZyb20gfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgaXNFcXVhbFdpdGggZnJvbSAnbG9kYXNoL2lzRXF1YWxXaXRoJztcbmltcG9ydCB7IFJlZnVuZFRyYW5zZmVyIH0gZnJvbSAnLi4vLi4vbWVzc2FnZXMvdHlwZXMnO1xuaW1wb3J0IHsgaXNNZXNzYWdlUmVjZWl2ZWRPZlR5cGUgfSBmcm9tICcuLi8uLi9tZXNzYWdlcy91dGlscyc7XG5pbXBvcnQgeyBSYWlkZW5FcnJvciwgRXJyb3JDb2RlcyB9IGZyb20gJy4uLy4uL3V0aWxzL2Vycm9yJztcbmltcG9ydCB7IFNpZ25lZCwgQmlnTnVtYmVyQyB9IGZyb20gJy4uLy4uL3V0aWxzL3R5cGVzJztcbmltcG9ydCB7IHRyYW5zZmVyLCB0cmFuc2ZlclJlZnVuZGVkIH0gZnJvbSAnLi4vYWN0aW9ucyc7XG5pbXBvcnQgeyBEaXJlY3Rpb24gfSBmcm9tICcuLi9zdGF0ZSc7XG4vLyBDb21wYXJlIHR3byBvYmplY3RzLCB1c2luZyAuZXEgZm9yIEJpZ051bWJlciBwcm9wZXJ0aWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gYm5Jc0VxdWFsKG9iaiwgb3RoZXIpIHtcbiAgICByZXR1cm4gaXNFcXVhbFdpdGgob2JqLCBvdGhlciwgKG9ialZhbCwgb3RoVmFsKSA9PiBCaWdOdW1iZXJDLmlzKG9ialZhbClcbiAgICAgICAgPyBvYmpWYWwuZXEob3RoVmFsKVxuICAgICAgICA6IEJpZ051bWJlckMuaXMob3RoVmFsKVxuICAgICAgICAgICAgPyBvdGhWYWwuZXEob2JqVmFsKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xufVxuLyoqXG4gKiBSZWNlaXZpbmcgUmVmdW5kVHJhbnNmZXIgZm9yIHBlbmRpbmcgdHJhbnNmZXIgZmFpbHMgaXRcbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgbWVzc2FnZVJlY2VpdmVkIGFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB0cmFuc2Zlci5mYWlsdXJlfHRyYW5zZmVyUmVmdW5kZWQgYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXJSZWZ1bmRlZEVwaWMgPSAoYWN0aW9uJCwgc3RhdGUkKSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzTWVzc2FnZVJlY2VpdmVkT2ZUeXBlKFNpZ25lZChSZWZ1bmRUcmFuc2ZlcikpKSwgd2l0aExhdGVzdEZyb20oc3RhdGUkKSwgbWVyZ2VNYXAoZnVuY3Rpb24qIChbYWN0aW9uLCBzdGF0ZV0pIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYWN0aW9uLnBheWxvYWQubWVzc2FnZTtcbiAgICBjb25zdCBzZWNyZXRoYXNoID0gbWVzc2FnZS5sb2NrLnNlY3JldGhhc2g7XG4gICAgaWYgKCEoc2VjcmV0aGFzaCBpbiBzdGF0ZS5zZW50KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHNlbnQgPSBzdGF0ZS5zZW50W3NlY3JldGhhc2hdLCB0cmFuc2YgPSBzZW50LnRyYW5zZmVyWzFdO1xuICAgIGlmIChtZXNzYWdlLmluaXRpYXRvciAhPT0gdHJhbnNmLnJlY2lwaWVudCB8fFxuICAgICAgICAhbWVzc2FnZS5wYXltZW50X2lkZW50aWZpZXIuZXEodHJhbnNmLnBheW1lbnRfaWRlbnRpZmllcikgfHxcbiAgICAgICAgIWJuSXNFcXVhbChtZXNzYWdlLmxvY2ssIHRyYW5zZi5sb2NrKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChzZW50LnVubG9jayB8fCAvLyBhbHJlYWR5IHVubG9ja2VkXG4gICAgICAgIHNlbnQubG9ja0V4cGlyZWQgfHwgLy8gYWxyZWFkeSBleHBpcmVkXG4gICAgICAgIHNlbnQuY2hhbm5lbENsb3NlZCB8fCAvLyBjaGFubmVsIGNsb3NlZFxuICAgICAgICB0cmFuc2YubG9jay5leHBpcmF0aW9uLmx0ZShzdGF0ZS5ibG9ja051bWJlcikgLy8gbG9jayBleHBpcmVkIGJ1dCB0cmFuc2ZlciBkaWRuJ3QgeWV0XG4gICAgKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgbWV0YSA9IHsgc2VjcmV0aGFzaCwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uU0VOVCB9O1xuICAgIHlpZWxkIHRyYW5zZmVyUmVmdW5kZWQoeyBtZXNzYWdlIH0sIG1ldGEpO1xuICAgIHlpZWxkIHRyYW5zZmVyLmZhaWx1cmUobmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuWEZFUl9SRUZVTkRFRCksIG1ldGEpO1xufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmdW5kLmpzLm1hcCIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmltcG9ydCB7IEVNUFRZIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWxheSwgZmlsdGVyLCBtZXJnZU1hcCwgcmVwZWF0V2hlbiwgdGFrZVVudGlsLCB3aXRoTGF0ZXN0RnJvbSwgc3dpdGNoTWFwLCBmaXJzdCwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBtZXNzYWdlU2VuZCB9IGZyb20gJy4uLy4uL21lc3NhZ2VzL2FjdGlvbnMnO1xuaW1wb3J0IHsgaXNBY3Rpb25PZiwgaXNSZXNwb25zZU9mIH0gZnJvbSAnLi4vLi4vdXRpbHMvYWN0aW9ucyc7XG5pbXBvcnQgeyBwbHVja0Rpc3RpbmN0IH0gZnJvbSAnLi4vLi4vdXRpbHMvcngnO1xuaW1wb3J0IHsgdHJhbnNmZXJFeHBpcmUsIHRyYW5zZmVyU2lnbmVkLCB0cmFuc2ZlclVubG9jaywgdHJhbnNmZXJTZWNyZXRSZXF1ZXN0LCB0cmFuc2ZlclNlY3JldFJldmVhbCwgfSBmcm9tICcuLi9hY3Rpb25zJztcbmltcG9ydCB7IERpcmVjdGlvbiB9IGZyb20gJy4uL3N0YXRlJztcbmltcG9ydCB7IGRpc3BhdGNoQW5kV2FpdCQgfSBmcm9tICcuL3V0aWxzJztcbmZ1bmN0aW9uIHJlcGVhdFVudGlsKG5vdGlmaWVyLCBkZWxheU1zID0gMzBlMykge1xuICAgIC8vIFJlc3Vic2NyaWJlL3JldHJ5IGV2ZXJ5IDMwcyBhZnRlciBtZXNzYWdlU2VuZCBzdWNjZWVkc1xuICAgIC8vIE5vdGljZSBmaXJzdCAob3IgYW55KSBtZXNzYWdlU2VuZC5yZXF1ZXN0IGNhbiB3YWl0IGZvciBhIGxvbmcgdGltZSBiZWZvcmUgc3VjY2VlZGluZywgYXMgaXRcbiAgICAvLyB3YWl0cyBmb3IgYWRkcmVzcydzIHVzZXIgaW4gdHJhbnNwb3J0IHRvIGJlIG9ubGluZSBhbmQgam9pbmVkIHJvb20gYmVmb3JlIGFjdHVhbGx5XG4gICAgLy8gc2VuZGluZyB0aGUgbWVzc2FnZS4gVGhhdCdzIHdoeSByZXBlYXRXaGVuIGVtaXRzL3Jlc3Vic2NyaWJlIG9ubHkgc29tZSB0aW1lIGFmdGVyXG4gICAgLy8gc2VuZE9uY2VBbmRXYWl0U2VudCQgY29tcGxldGVzLCBpbnN0ZWFkIG9mIGEgcGxhaW4gJ2ludGVydmFsJ1xuICAgIHJldHVybiAoaW5wdXQkKSA9PiBpbnB1dCQucGlwZShyZXBlYXRXaGVuKChjb21wbGV0ZWQkKSA9PiBjb21wbGV0ZWQkLnBpcGUoZGVsYXkoZGVsYXlNcykpKSwgdGFrZVVudGlsKG5vdGlmaWVyKSk7XG59XG5mdW5jdGlvbiByZXRyeVNlbmRVbnRpbCQoc2VuZCwgYWN0aW9uJCwgbm90aWZpZXIsIGRlbGF5TXMgPSAzMGUzKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoQW5kV2FpdCQoYWN0aW9uJCwgc2VuZCwgaXNSZXNwb25zZU9mKG1lc3NhZ2VTZW5kLCBzZW5kLm1ldGEpKS5waXBlKHJlcGVhdFVudGlsKG5vdGlmaWVyLCBkZWxheU1zKSk7XG59XG4vKipcbiAqIEhhbmRsZXMgYSB0cmFuc2ZlclNpZ25lZCBhY3Rpb24gYW5kIHJldHJ5IG1lc3NhZ2VTZW5kLnJlcXVlc3QgdW50aWwgdHJhbnNmZXIgaXMgZ29uZSAoY29tcGxldGVkXG4gKiB3aXRoIHN1Y2Nlc3Mgb3IgZXJyb3IpIE9SIFByb2Nlc3NlZCBtZXNzYWdlIGZvciBMb2NrZWRUcmFuc2ZlciByZWNlaXZlZC5cbiAqIHRyYW5zZmVyU2lnbmVkIGZvciBwZW5kaW5nIExvY2tlZFRyYW5zZmVyJ3MgbWF5IGJlIHJlLWVtaXR0ZWQgb24gc3RhcnR1cCBmb3IgcGVuZGluZyB0cmFuc2ZlcixcbiAqIHRvIHN0YXJ0IHJldHJ5aW5nIHNlbmRpbmcgdGhlIG1lc3NhZ2UgYWdhaW4gdW50aWwgc3RvcCBjb25kaXRpb24gaXMgbWV0LlxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiB0cmFuc2ZlclNpZ25lZCBhY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBsYXRlc3QgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gY29uZmlnJCAtIE9ic2VydmFibGUgb2YgbGF0ZXN0IFJhaWRlbkNvbmZpZ1xuICogQHBhcmFtIGFjdGlvbiAtIFRoZSB7QGxpbmsgdHJhbnNmZXJTaWduZWR9IGFjdGlvblxuICogQHJldHVybnMgLSBPYnNlcnZhYmxlIG9mIHtAbGluayBtZXNzYWdlU2VuZC5yZXF1ZXN0fSBhY3Rpb25zXG4gKi9cbmNvbnN0IHNpZ25lZFJldHJ5TWVzc2FnZSQgPSAoYWN0aW9uJCwgc3RhdGUkLCBjb25maWckLCBhY3Rpb24pID0+IHtcbiAgICBpZiAoYWN0aW9uLm1ldGEuZGlyZWN0aW9uICE9PSBEaXJlY3Rpb24uU0VOVClcbiAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIHJldHVybiBjb25maWckLnBpcGUoZmlyc3QoKSwgc3dpdGNoTWFwKCh7IGh0dHBUaW1lb3V0IH0pID0+IHtcbiAgICAgICAgY29uc3Qgc2VjcmV0aGFzaCA9IGFjdGlvbi5tZXRhLnNlY3JldGhhc2g7XG4gICAgICAgIGNvbnN0IHNpZ25lZCA9IGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IHNlbmQgPSBtZXNzYWdlU2VuZC5yZXF1ZXN0KHsgbWVzc2FnZTogc2lnbmVkIH0sIHsgYWRkcmVzczogc2lnbmVkLnJlY2lwaWVudCwgbXNnSWQ6IHNpZ25lZC5tZXNzYWdlX2lkZW50aWZpZXIudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgY29uc3Qgbm90aWZpZXIgPSBzdGF0ZSQucGlwZShwbHVja0Rpc3RpbmN0KCdzZW50Jywgc2VjcmV0aGFzaCksIGZpbHRlcigoc2VudCkgPT4gISEoc2VudC50cmFuc2ZlclByb2Nlc3NlZCB8fFxuICAgICAgICAgICAgc2VudC51bmxvY2tQcm9jZXNzZWQgfHxcbiAgICAgICAgICAgIHNlbnQubG9ja0V4cGlyZWRQcm9jZXNzZWQgfHxcbiAgICAgICAgICAgIHNlbnQuY2hhbm5lbENsb3NlZCkpKTtcbiAgICAgICAgLy8gZW1pdCByZXF1ZXN0IG9uY2UgaW1tZWRpYXRlbGx5LCB0aGVuIHdhaXQgdW50aWwgc3VjY2VzcywgdGhlbiByZXRyeSBldmVyeSAzMHNcbiAgICAgICAgcmV0dXJuIHJldHJ5U2VuZFVudGlsJChzZW5kLCBhY3Rpb24kLCBub3RpZmllciwgaHR0cFRpbWVvdXQpO1xuICAgIH0pKTtcbn07XG4vKipcbiAqIEhhbmRsZXMgYSB0cmFuc2ZlclVubG9jay5zdWNjZXNzIGFjdGlvbiBhbmQgcmV0cnkgbWVzc2FnZVNlbmQgdW50aWwgY29uZmlybWVkLlxuICogdHJhbnNmZXJVbmxvY2suc3VjY2VzcyBmb3IgcGVuZGluZyBVbmxvY2sncyBtYXkgYmUgcmUtZW1pdHRlZCBvbiBzdGFydHVwIGZvciBwZW5kaW5nIHRyYW5zZmVyLCB0b1xuICogc3RhcnQgcmV0cnlpbmcgc2VuZGluZyB0aGUgbWVzc2FnZSBhZ2FpbiB1bnRpbCBzdG9wIGNvbmRpdGlvbiBpcyBtZXQuXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIHRyYW5zZmVyVW5sb2NrLnN1Y2Nlc3MgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgdGhlIGxhdGVzdCBSYWlkZW5TdGF0ZXNcbiAqIEBwYXJhbSBjb25maWckIC0gT2JzZXJ2YWJsZSBvZiBsYXRlc3QgUmFpZGVuQ29uZmlnXG4gKiBAcGFyYW0gYWN0aW9uIC0gdGhlIHRyYW5zZmVyVW5sb2NrLnN1Y2Nlc3MgYWN0aW9uXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIHtAbGluayBtZXNzYWdlU2VuZC5yZXF1ZXN0fSBhY3Rpb25zXG4gKi9cbmNvbnN0IHVubG9ja2VkUmV0cnlNZXNzYWdlJCA9IChhY3Rpb24kLCBzdGF0ZSQsIGNvbmZpZyQsIGFjdGlvbikgPT4ge1xuICAgIGlmIChhY3Rpb24ubWV0YS5kaXJlY3Rpb24gIT09IERpcmVjdGlvbi5TRU5UKVxuICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgcmV0dXJuIHN0YXRlJC5waXBlKGZpcnN0KCksIHdpdGhMYXRlc3RGcm9tKGNvbmZpZyQpLCBzd2l0Y2hNYXAoKFtzdGF0ZSwgeyBodHRwVGltZW91dCB9XSkgPT4ge1xuICAgICAgICBjb25zdCBzZWNyZXRoYXNoID0gYWN0aW9uLm1ldGEuc2VjcmV0aGFzaDtcbiAgICAgICAgY29uc3QgdW5sb2NrID0gYWN0aW9uLnBheWxvYWQubWVzc2FnZTtcbiAgICAgICAgY29uc3QgdHJhbnNmZXIgPSBzdGF0ZS5zZW50W3NlY3JldGhhc2hdLnRyYW5zZmVyWzFdO1xuICAgICAgICBjb25zdCBzZW5kID0gbWVzc2FnZVNlbmQucmVxdWVzdCh7IG1lc3NhZ2U6IHVubG9jayB9LCB7IGFkZHJlc3M6IHRyYW5zZmVyLnJlY2lwaWVudCwgbXNnSWQ6IHVubG9jay5tZXNzYWdlX2lkZW50aWZpZXIudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgY29uc3Qgbm90aWZpZXIgPSBzdGF0ZSQucGlwZShwbHVja0Rpc3RpbmN0KCdzZW50Jywgc2VjcmV0aGFzaCksIGZpbHRlcigoc2VudCkgPT4gISEoc2VudC51bmxvY2tQcm9jZXNzZWQgfHwgc2VudC5jaGFubmVsQ2xvc2VkKSkpO1xuICAgICAgICAvLyBlbWl0IHJlcXVlc3Qgb25jZSBpbW1lZGlhdGVsbHksIHRoZW4gd2FpdCB1bnRpbCByZXNwZWN0aXZlIHN1Y2Nlc3MsXG4gICAgICAgIC8vIHRoZW4gcmVwZWF0cyB1bnRpbCBjb25maXJtZWRcbiAgICAgICAgcmV0dXJuIHJldHJ5U2VuZFVudGlsJChzZW5kLCBhY3Rpb24kLCBub3RpZmllciwgaHR0cFRpbWVvdXQpO1xuICAgIH0pKTtcbn07XG4vKipcbiAqIEhhbmRsZXMgYSB0cmFuc2ZlckV4cGlyZS5zdWNjZXNzIGFjdGlvbiBhbmQgcmV0cnkgbWVzc2FnZVNlbmQucmVxdWVzdCB1bnRpbCB0cmFuc2ZlciBpcyBnb25lIChjb21wbGV0ZWRcbiAqIHdpdGggc3VjY2VzcyBvciBlcnJvcikuXG4gKiB0cmFuc2ZlckV4cGlyZS5zdWNjZXNzIGZvciBwZW5kaW5nIExvY2tFeHBpcmVkJ3MgbWF5IGJlIHJlLWVtaXR0ZWQgb24gc3RhcnR1cCBmb3IgcGVuZGluZyB0cmFuc2ZlciwgdG9cbiAqIHN0YXJ0IHJldHJ5aW5nIHNlbmRpbmcgdGhlIG1lc3NhZ2UgYWdhaW4gdW50aWwgc3RvcCBjb25kaXRpb24gaXMgbWV0LlxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiB0cmFuc2ZlclVubG9jay5zdWNjZXNzIGFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIGxhdGVzdCBSYWlkZW5TdGF0ZVxuICogQHBhcmFtIGNvbmZpZyQgLSBPYnNlcnZhYmxlIG9mIGxhdGVzdCBSYWlkZW5Db25maWdcbiAqIEBwYXJhbSBhY3Rpb24gLSB0cmFuc2ZlckV4cGlyZS5zdWNjZXNzIGFjdGlvblxuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB7QGxpbmsgbWVzc2FnZVNlbmQucmVxdWVzdH0gYWN0aW9uc1xuICovXG5jb25zdCBleHBpcmVkUmV0cnlNZXNzYWdlcyQgPSAoYWN0aW9uJCwgc3RhdGUkLCBjb25maWckLCBhY3Rpb24pID0+IHtcbiAgICBpZiAoYWN0aW9uLm1ldGEuZGlyZWN0aW9uICE9PSBEaXJlY3Rpb24uU0VOVClcbiAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIHJldHVybiBzdGF0ZSQucGlwZShmaXJzdCgpLCB3aXRoTGF0ZXN0RnJvbShjb25maWckKSwgc3dpdGNoTWFwKChbc3RhdGUsIHsgaHR0cFRpbWVvdXQgfV0pID0+IHtcbiAgICAgICAgY29uc3Qgc2VjcmV0aGFzaCA9IGFjdGlvbi5tZXRhLnNlY3JldGhhc2g7XG4gICAgICAgIGNvbnN0IGxvY2tFeHBpcmVkID0gYWN0aW9uLnBheWxvYWQubWVzc2FnZTtcbiAgICAgICAgY29uc3Qgc2VuZCA9IG1lc3NhZ2VTZW5kLnJlcXVlc3QoeyBtZXNzYWdlOiBsb2NrRXhwaXJlZCB9LCB7XG4gICAgICAgICAgICBhZGRyZXNzOiBzdGF0ZS5zZW50W3NlY3JldGhhc2hdLnRyYW5zZmVyWzFdLnJlY2lwaWVudCxcbiAgICAgICAgICAgIG1zZ0lkOiBsb2NrRXhwaXJlZC5tZXNzYWdlX2lkZW50aWZpZXIudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5vdGlmaWVyID0gc3RhdGUkLnBpcGUocGx1Y2tEaXN0aW5jdCgnc2VudCcsIHNlY3JldGhhc2gpLCBmaWx0ZXIoKHNlbnQpID0+ICEhKHNlbnQubG9ja0V4cGlyZWRQcm9jZXNzZWQgfHwgc2VudC5jaGFubmVsQ2xvc2VkKSkpO1xuICAgICAgICAvLyBlbWl0IHJlcXVlc3Qgb25jZSBpbW1lZGlhdGVsbHksIHRoZW4gd2FpdCB1bnRpbCByZXNwZWN0aXZlIHN1Y2Nlc3MsXG4gICAgICAgIC8vIHRoZW4gcmV0cmllcyB1bnRpbCBjb25maXJtZWRcbiAgICAgICAgcmV0dXJuIHJldHJ5U2VuZFVudGlsJChzZW5kLCBhY3Rpb24kLCBub3RpZmllciwgaHR0cFRpbWVvdXQpO1xuICAgIH0pKTtcbn07XG5jb25zdCBzZWNyZXRSZXF1ZXN0UmV0cnlNZXNzYWdlJCA9IChhY3Rpb24kLCBzdGF0ZSQsIGNvbmZpZyQsIGFjdGlvbikgPT4ge1xuICAgIGlmIChhY3Rpb24ubWV0YS5kaXJlY3Rpb24gIT09IERpcmVjdGlvbi5SRUNFSVZFRClcbiAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIHJldHVybiBzdGF0ZSQucGlwZShmaXJzdCgpLCB3aXRoTGF0ZXN0RnJvbShjb25maWckKSwgc3dpdGNoTWFwKChbc3RhdGUsIHsgaHR0cFRpbWVvdXQgfV0pID0+IHtcbiAgICAgICAgY29uc3Qgc2VjcmV0aGFzaCA9IGFjdGlvbi5tZXRhLnNlY3JldGhhc2g7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlO1xuICAgICAgICBjb25zdCBzZW5kID0gbWVzc2FnZVNlbmQucmVxdWVzdCh7IG1lc3NhZ2U6IHJlcXVlc3QgfSwge1xuICAgICAgICAgICAgYWRkcmVzczogc3RhdGUucmVjZWl2ZWRbc2VjcmV0aGFzaF0udHJhbnNmZXJbMV0uaW5pdGlhdG9yLFxuICAgICAgICAgICAgbXNnSWQ6IHJlcXVlc3QubWVzc2FnZV9pZGVudGlmaWVyLnRvU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBub3RpZmllciA9IHN0YXRlJC5waXBlKHBsdWNrRGlzdGluY3QoJ3JlY2VpdmVkJywgc2VjcmV0aGFzaCksIFxuICAgICAgICAvLyBzdG9wIHJldHJ5aW5nIHdoZW4gd2UndmUgc2lnbmVkIHNlY3JldFJldmVhbCwgbG9jayBleHBpcmVkIG9yIGNoYW5uZWwgY2xvc2VkXG4gICAgICAgIC8vIHdlIGNvdWxkIHN0b3AgYXMgc29vbiBhcyB3ZSBrbm93IHJlY2VpdmVkLnNlY3JldCwgYnV0IHdlIHVzZSBpdCB0byByZXRyeSBTZWNyZXRSZXZlYWxcbiAgICAgICAgLy8gc2lnbmF0dXJlLCBpZiBpdCBmYWlsZWQgZm9yIGFueSByZWFzb25cbiAgICAgICAgZmlsdGVyKChyZWNlaXZlZCkgPT4gISEocmVjZWl2ZWQuc2VjcmV0UmV2ZWFsIHx8IHJlY2VpdmVkLmxvY2tFeHBpcmVkIHx8IHJlY2VpdmVkLmNoYW5uZWxDbG9zZWQpKSk7XG4gICAgICAgIC8vIGVtaXQgcmVxdWVzdCBvbmNlIGltbWVkaWF0ZWxseSwgdGhlbiB3YWl0IHVudGlsIHJlc3BlY3RpdmUgc3VjY2VzcyxcbiAgICAgICAgLy8gdGhlbiByZXRyaWVzIHVudGlsIGNvbmZpcm1lZFxuICAgICAgICByZXR1cm4gcmV0cnlTZW5kVW50aWwkKHNlbmQsIGFjdGlvbiQsIG5vdGlmaWVyLCBodHRwVGltZW91dCk7XG4gICAgfSkpO1xufTtcbmNvbnN0IHNlY3JldFJldmVhbFJldHJ5TWVzc2FnZSQgPSAoYWN0aW9uJCwgc3RhdGUkLCBjb25maWckLCBhY3Rpb24pID0+IHtcbiAgICBpZiAoYWN0aW9uLm1ldGEuZGlyZWN0aW9uICE9PSBEaXJlY3Rpb24uUkVDRUlWRUQpXG4gICAgICAgIHJldHVybiBFTVBUWTtcbiAgICByZXR1cm4gc3RhdGUkLnBpcGUoZmlyc3QoKSwgd2l0aExhdGVzdEZyb20oY29uZmlnJCksIHN3aXRjaE1hcCgoW3N0YXRlLCB7IGh0dHBUaW1lb3V0IH1dKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlY3JldGhhc2ggPSBhY3Rpb24ubWV0YS5zZWNyZXRoYXNoO1xuICAgICAgICBjb25zdCByZXZlYWwgPSBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlO1xuICAgICAgICBjb25zdCBzZW5kID0gbWVzc2FnZVNlbmQucmVxdWVzdCh7IG1lc3NhZ2U6IHJldmVhbCB9LCB7XG4gICAgICAgICAgICBhZGRyZXNzOiBzdGF0ZS5yZWNlaXZlZFtzZWNyZXRoYXNoXS5wYXJ0bmVyLFxuICAgICAgICAgICAgbXNnSWQ6IHJldmVhbC5tZXNzYWdlX2lkZW50aWZpZXIudG9TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5vdGlmaWVyID0gc3RhdGUkLnBpcGUocGx1Y2tEaXN0aW5jdCgncmVjZWl2ZWQnLCBzZWNyZXRoYXNoKSwgXG4gICAgICAgIC8vIHN0b3AgcmV0cnlpbmcgd2hlbiB3ZSB3ZXJlIHVubG9ja2VkLCBzZWNyZXQgcmVnaXN0ZXJlZCBvciBjaGFubmVsIGNsb3NlZFxuICAgICAgICAvLyB3ZSBkb24ndCB0ZXN0IGZvciBsb2NrRXhwaXJlZCwgYXMgd2Uga25vdyB0aGUgc2VjcmV0IGFuZCBtdXN0IG5vdCBhY2NlcHQgTG9ja0V4cGlyZWRcbiAgICAgICAgZmlsdGVyKChyZWNlaXZlZCkgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gISEocmVjZWl2ZWQudW5sb2NrIHx8ICgoX2IgPSAoX2EgPSByZWNlaXZlZC5zZWNyZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsxXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlZ2lzdGVyQmxvY2spIHx8IHJlY2VpdmVkLmNoYW5uZWxDbG9zZWQpOyB9KSk7XG4gICAgICAgIC8vIGVtaXQgcmVxdWVzdCBvbmNlIGltbWVkaWF0ZWxseSwgdGhlbiB3YWl0IHVudGlsIHJlc3BlY3RpdmUgc3VjY2VzcyxcbiAgICAgICAgLy8gdGhlbiByZXRyaWVzIHVudGlsIGNvbmZpcm1lZFxuICAgICAgICByZXR1cm4gcmV0cnlTZW5kVW50aWwkKHNlbmQsIGFjdGlvbiQsIG5vdGlmaWVyLCBodHRwVGltZW91dCk7XG4gICAgfSkpO1xufTtcbi8qKlxuICogUmV0cnkgc2VuZGluZyBiYWxhbmNlIHByb29mIG1lc3NhZ2VzIHVudGlsIHRoZWlyIHJlc3BlY3RpdmUgUHJvY2Vzc2VkXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIHRyYW5zZmVyRXhwaXJlLnN1Y2Nlc3MgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gbGF0ZXN0JCAtIFJhaWRlbkVwaWNEZXBzIGxhdGVzdFxuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBtZXNzYWdlU2VuZC5yZXF1ZXN0IGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zZmVyUmV0cnlNZXNzYWdlRXBpYyA9IChhY3Rpb24kLCB7fSwgeyBsYXRlc3QkLCBjb25maWckIH0pID0+IHtcbiAgICBjb25zdCBzdGF0ZSQgPSBsYXRlc3QkLnBpcGUocGx1Y2tEaXN0aW5jdCgnc3RhdGUnKSk7XG4gICAgcmV0dXJuIGFjdGlvbiQucGlwZShmaWx0ZXIoaXNBY3Rpb25PZihbXG4gICAgICAgIHRyYW5zZmVyU2lnbmVkLFxuICAgICAgICB0cmFuc2ZlclVubG9jay5zdWNjZXNzLFxuICAgICAgICB0cmFuc2ZlckV4cGlyZS5zdWNjZXNzLFxuICAgICAgICB0cmFuc2ZlclNlY3JldFJlcXVlc3QsXG4gICAgICAgIHRyYW5zZmVyU2VjcmV0UmV2ZWFsLFxuICAgIF0pKSwgbWVyZ2VNYXAoKGFjdGlvbikgPT4gdHJhbnNmZXJTaWduZWQuaXMoYWN0aW9uKVxuICAgICAgICA/IHNpZ25lZFJldHJ5TWVzc2FnZSQoYWN0aW9uJCwgc3RhdGUkLCBjb25maWckLCBhY3Rpb24pXG4gICAgICAgIDogdHJhbnNmZXJVbmxvY2suc3VjY2Vzcy5pcyhhY3Rpb24pXG4gICAgICAgICAgICA/IHVubG9ja2VkUmV0cnlNZXNzYWdlJChhY3Rpb24kLCBzdGF0ZSQsIGNvbmZpZyQsIGFjdGlvbilcbiAgICAgICAgICAgIDogdHJhbnNmZXJFeHBpcmUuc3VjY2Vzcy5pcyhhY3Rpb24pXG4gICAgICAgICAgICAgICAgPyBleHBpcmVkUmV0cnlNZXNzYWdlcyQoYWN0aW9uJCwgc3RhdGUkLCBjb25maWckLCBhY3Rpb24pXG4gICAgICAgICAgICAgICAgOiB0cmFuc2ZlclNlY3JldFJlcXVlc3QuaXMoYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IHNlY3JldFJlcXVlc3RSZXRyeU1lc3NhZ2UkKGFjdGlvbiQsIHN0YXRlJCwgY29uZmlnJCwgYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICA6IHNlY3JldFJldmVhbFJldHJ5TWVzc2FnZSQoYWN0aW9uJCwgc3RhdGUkLCBjb25maWckLCBhY3Rpb24pKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnkuanMubWFwIiwiaW1wb3J0IHsgRU1QVFksIGZyb20sIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjb25jYXRNYXAsIGZpbHRlciwgZmlyc3QsIG1hcCwgbWVyZ2VNYXAsIHdpdGhMYXRlc3RGcm9tLCBjYXRjaEVycm9yLCBkaXN0aW5jdCwgcGx1Y2ssIGV4aGF1c3RNYXAsIHRha2VVbnRpbCwgaWdub3JlRWxlbWVudHMsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgbmV3QmxvY2sgfSBmcm9tICcuLi8uLi9jaGFubmVscy9hY3Rpb25zJztcbmltcG9ydCB7IGFzc2VydFR4IH0gZnJvbSAnLi4vLi4vY2hhbm5lbHMvdXRpbHMnO1xuaW1wb3J0IHsgbWVzc2FnZVNlbmQgfSBmcm9tICcuLi8uLi9tZXNzYWdlcy9hY3Rpb25zJztcbmltcG9ydCB7IE1lc3NhZ2VUeXBlLCBTZWNyZXRSZXF1ZXN0LCBTZWNyZXRSZXZlYWwgfSBmcm9tICcuLi8uLi9tZXNzYWdlcy90eXBlcyc7XG5pbXBvcnQgeyBzaWduTWVzc2FnZSwgaXNNZXNzYWdlUmVjZWl2ZWRPZlR5cGUgfSBmcm9tICcuLi8uLi9tZXNzYWdlcy91dGlscyc7XG5pbXBvcnQgeyBpc0FjdGlvbk9mLCBpc0NvbmZpcm1hdGlvblJlc3BvbnNlT2YgfSBmcm9tICcuLi8uLi91dGlscy9hY3Rpb25zJztcbmltcG9ydCB7IFJhaWRlbkVycm9yLCBFcnJvckNvZGVzIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXJyb3InO1xuaW1wb3J0IHsgZ2V0RXZlbnRzU3RyZWFtIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXRoZXJzJztcbmltcG9ydCB7IHBsdWNrRGlzdGluY3QgfSBmcm9tICcuLi8uLi91dGlscy9yeCc7XG5pbXBvcnQgeyBTaWduZWQgfSBmcm9tICcuLi8uLi91dGlscy90eXBlcyc7XG5pbXBvcnQgeyB0cmFuc2ZlciwgdHJhbnNmZXJTZWNyZXQsIHRyYW5zZmVyU2VjcmV0UmVnaXN0ZXIsIHRyYW5zZmVyU2VjcmV0UmVxdWVzdCwgdHJhbnNmZXJTZWNyZXRSZXZlYWwsIHRyYW5zZmVyVW5sb2NrLCB9IGZyb20gJy4uL2FjdGlvbnMnO1xuaW1wb3J0IHsgZ2V0U2VjcmV0aGFzaCwgbWFrZU1lc3NhZ2VJZCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IERpcmVjdGlvbiB9IGZyb20gJy4uL3N0YXRlJztcbmltcG9ydCB7IGNob29zZU9uY2hhaW5BY2NvdW50LCBnZXRDb250cmFjdFdpdGhTaWduZXIgfSBmcm9tICcuLi8uLi9oZWxwZXJzJztcbmltcG9ydCB7IENhcGFiaWxpdGllcyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBkaXNwYXRjaEFuZFdhaXQkIH0gZnJvbSAnLi91dGlscyc7XG4vKipcbiAqIEhhbmRsZXMgcmVjZWl2aW5nIGEgc2lnbmVkIFNlY3JldFJlcXVlc3QgZnJvbSB0YXJnZXQgZm9yIHNvbWUgc2VudCBMb2NrZWRUcmFuc2ZlclxuICogRW1pdHMgYSB0cmFuc2ZlclNlY3JldFJlcXVlc3QgYWN0aW9uIG9ubHkgaWYgYWxsIGNvbmRpdGlvbnMgYXJlIG1ldFxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBtZXNzYWdlUmVjZWl2ZWQgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIHRyYW5zZmVyU2VjcmV0UmVxdWVzdCBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2ZlclNlY3JldFJlcXVlc3RlZEVwaWMgPSAoYWN0aW9uJCwgc3RhdGUkLCB7IGFkZHJlc3MsIGxvZyB9KSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKGlzTWVzc2FnZVJlY2VpdmVkT2ZUeXBlKFNpZ25lZChTZWNyZXRSZXF1ZXN0KSkpLCB3aXRoTGF0ZXN0RnJvbShzdGF0ZSQpLCBtZXJnZU1hcChmdW5jdGlvbiogKFthY3Rpb24sIHN0YXRlXSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlO1xuICAgIC8vIHByb2NlZWQgb25seSBpZiB3ZSBrbm93IHRoZSBzZWNyZXQgYW5kIHRoZSBTRU5UIHRyYW5zZmVyXG4gICAgaWYgKCEobWVzc2FnZS5zZWNyZXRoYXNoIGluIHN0YXRlLnNlbnQpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgdHJhbnNmZXIgPSBzdGF0ZS5zZW50W21lc3NhZ2Uuc2VjcmV0aGFzaF0udHJhbnNmZXJbMV07XG4gICAgLy8gd2UgZG8gb25seSBzb21lIGJhc2ljIHZlcmlmaWNhdGlvbiBoZXJlLCBhcyBtb3N0IG9mIGl0IGlzIGRvbmUgdXBvbiBTZWNyZXRSZXZlYWwsXG4gICAgLy8gdG8gcGVyc2lzdCB0aGUgcmVxdWVzdCBpbiBtb3N0IGNhc2VzIGluIFRyYW5zZmVyU3RhdGUuc2VjcmV0UmVxdWVzdFxuICAgIGlmICh0cmFuc2Zlci5pbml0aWF0b3IgIT09IGFkZHJlc3MgfHwgLy8gb25seSB0aGUgaW5pdGlhdG9yIG1heSByZXBseSBhIFNlY3JldFJlcXVlc3RcbiAgICAgICAgdHJhbnNmZXIudGFyZ2V0ICE9PSBhY3Rpb24ubWV0YS5hZGRyZXNzIHx8IC8vIHJldmVhbCBvbmx5IHRvIHRhcmdldFxuICAgICAgICAhdHJhbnNmZXIucGF5bWVudF9pZGVudGlmaWVyLmVxKG1lc3NhZ2UucGF5bWVudF9pZGVudGlmaWVyKSkge1xuICAgICAgICBsb2cud2FybignSW52YWxpZCBTZWNyZXRSZXF1ZXN0IGZvciB0cmFuc2ZlcicsIG1lc3NhZ2UsIHRyYW5zZmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB5aWVsZCB0cmFuc2ZlclNlY3JldFJlcXVlc3QoeyBtZXNzYWdlIH0sIHsgc2VjcmV0aGFzaDogbWVzc2FnZS5zZWNyZXRoYXNoLCBkaXJlY3Rpb246IERpcmVjdGlvbi5TRU5UIH0pO1xuICAgIC8vIHdlIGRvbid0IGNoZWNrIGlmIHRyYW5zZmVyIHdhcyByZWZ1bmRlZC4gSWYgcGFydG5lciByZWZ1bmRlZCB0aGUgdHJhbnNmZXIgYnV0IHN0aWxsXG4gICAgLy8gZm9yd2FyZGVkIHRoZSBwYXltZW50LCB0aGV5IHdvdWxkIGJlIGluIHJpc2sgb2YgbG9zaW5nIHRoZWlyIG1vbmV5LCBub3QgdXNcbn0pKTtcbi8qKlxuICogQ29udGFpbnMgdGhlIGNvcmUgbG9naWMgb2Yge0BsaW5rIHRyYW5zZmVyU2VjcmV0UmV2ZWFsRXBpY30uXG4gKlxuICogQHBhcmFtIHN0YXRlIC0gQ29udGFpbnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGFwcFxuICogQHBhcmFtIGFjdGlvbiAtIFRoZSB7QGxpbmsgdHJhbnNmZXJTZWNyZXRSZXF1ZXN0fSBhY3Rpb24gdGhhdFxuICogQHBhcmFtIHNpZ25lciAtIFRoZSBzaW5nZXIgdGhhdCB3aWxsIHNpZ24gdGhlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2Yge0BsaW5rIHRyYW5zZmVyLmZhaWx1cmV9LCB7QGxpbmsgdHJhbnNmZXJTZWNyZXRSZXZlYWx9IG9yXG4gKiAgICAgIHtAbGluayBtZXNzYWdlU2VuZC5yZXF1ZXN0fSBhY3Rpb25zXG4gKi9cbmNvbnN0IHNlY3JldFJldmVhbCQgPSAoc3RhdGUsIGFjdGlvbiwgeyBzaWduZXIsIGxvZyB9KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlcXVlc3QgPSBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlO1xuICAgIGNvbnN0IHNlY3JldGhhc2ggPSBhY3Rpb24ubWV0YS5zZWNyZXRoYXNoO1xuICAgIGlmICghKChfYSA9IHN0YXRlLnNlbnRbc2VjcmV0aGFzaF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZWNyZXQpKSB7XG4gICAgICAgIC8vIHNob3VsZG4ndCBoYXBwZW4sIGFzIHdlJ3JlIHRoZSBpbml0aWF0b3IgKGZvciBub3cpLCBhbmQgYWx3YXlzIGtub3cgdGhlIHNlY3JldFxuICAgICAgICBsb2cud2FybignU2VjcmV0UmVxdWVzdCBmb3IgdW5rbm93biBzZWNyZXQnLCByZXF1ZXN0LCBzZWNyZXRoYXNoKTtcbiAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2YgPSBzdGF0ZS5zZW50W3NlY3JldGhhc2hdLnRyYW5zZmVyWzFdO1xuICAgIGNvbnN0IHRhcmdldCA9IHRyYW5zZi50YXJnZXQ7XG4gICAgY29uc3QgZmVlID0gc3RhdGUuc2VudFtzZWNyZXRoYXNoXS5mZWU7XG4gICAgY29uc3QgdmFsdWUgPSB0cmFuc2YubG9jay5hbW91bnQuc3ViKGZlZSk7XG4gICAgaWYgKCFyZXF1ZXN0LmV4cGlyYXRpb24ubHRlKHRyYW5zZi5sb2NrLmV4cGlyYXRpb24pIHx8XG4gICAgICAgICFyZXF1ZXN0LmV4cGlyYXRpb24uZ3Qoc3RhdGUuYmxvY2tOdW1iZXIpKSB7XG4gICAgICAgIGxvZy5lcnJvcignU2VjcmV0UmVxdWVzdCBmb3IgZXhwaXJlZCB0cmFuc2ZlcicsIHJlcXVlc3QsIHRyYW5zZik7XG4gICAgICAgIHJldHVybiBFTVBUWTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVxdWVzdC5hbW91bnQubHQodmFsdWUpKSB7XG4gICAgICAgIGxvZy5lcnJvcignU2VjcmV0UmVxdWVzdCBmb3IgYW1vdW50IHRvbyBzbWFsbCEnLCByZXF1ZXN0LCB0cmFuc2YpO1xuICAgICAgICByZXR1cm4gb2YodHJhbnNmZXIuZmFpbHVyZShuZXcgUmFpZGVuRXJyb3IoRXJyb3JDb2Rlcy5YRkVSX0lOVkFMSURfU0VDUkVUUkVRVUVTVCksIGFjdGlvbi5tZXRhKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFyZXF1ZXN0LmFtb3VudC5lcSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gYWNjZXB0IHJlcXVlc3RcbiAgICAgICAgbG9nLmluZm8oJ0FjY2VwdGVkIFNlY3JldFJlcXVlc3QgZm9yIGFtb3VudCBkaWZmZXJlbnQgdGhhbiBzZW50JywgcmVxdWVzdCwgdHJhbnNmKTtcbiAgICB9XG4gICAgbGV0IHJldmVhbCQ7XG4gICAgaWYgKHN0YXRlLnNlbnRbYWN0aW9uLm1ldGEuc2VjcmV0aGFzaF0uc2VjcmV0UmV2ZWFsKVxuICAgICAgICByZXZlYWwkID0gb2Yoc3RhdGUuc2VudFthY3Rpb24ubWV0YS5zZWNyZXRoYXNoXS5zZWNyZXRSZXZlYWxbMV0pO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuU0VDUkVUX1JFVkVBTCxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2FtZWxjYXNlXG4gICAgICAgICAgICBtZXNzYWdlX2lkZW50aWZpZXI6IG1ha2VNZXNzYWdlSWQoKSxcbiAgICAgICAgICAgIHNlY3JldDogc3RhdGUuc2VudFthY3Rpb24ubWV0YS5zZWNyZXRoYXNoXS5zZWNyZXRbMV0udmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIHJldmVhbCQgPSBmcm9tKHNpZ25NZXNzYWdlKHNpZ25lciwgbWVzc2FnZSwgeyBsb2cgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV2ZWFsJC5waXBlKG1lcmdlTWFwKGZ1bmN0aW9uKiAobWVzc2FnZSkge1xuICAgICAgICB5aWVsZCB0cmFuc2ZlclNlY3JldFJldmVhbCh7IG1lc3NhZ2UgfSwgYWN0aW9uLm1ldGEpO1xuICAgICAgICB5aWVsZCBtZXNzYWdlU2VuZC5yZXF1ZXN0KHsgbWVzc2FnZSB9LCB7IGFkZHJlc3M6IHRhcmdldCwgbXNnSWQ6IG1lc3NhZ2UubWVzc2FnZV9pZGVudGlmaWVyLnRvU3RyaW5nKCkgfSk7XG4gICAgfSkpO1xufTtcbi8qKlxuICogSGFuZGxlcyBhIHRyYW5zZmVyU2VjcmV0UmVxdWVzdCBhY3Rpb24gdG8gc2VuZCB0aGUgcmVzcGVjdGl2ZSBzZWNyZXQgdG8gdGFyZ2V0XG4gKiBJdCBib3RoIGVtaXRzIHRyYW5zZmVyU2VjcmV0UmV2ZWFsICh0byBwZXJzaXN0IHNlbnQgU2VjcmV0UmV2ZWFsIGluIHN0YXRlIGFuZCBpbmRpY2F0ZSB0aGF0XG4gKiB0aGUgc2VjcmV0IHdhcyByZXZlYWxlZCBhbmQgdGh1cyB0aGUgdHJhbnNmZXIgc2hvdWxkIGJlIGFzc3VtZWQgYXMgc3VjY2VlZGVkKSBhcyB3ZWxsIGFzXG4gKiB0cmlnZ2VycyBzZW5kaW5nIHRoZSBtZXNzYWdlIG9uY2UuIE5ldyBTZWNyZXRSZXF1ZXN0cyB3aWxsIGNhdXNlIGEgbmV3IHRyYW5zZmVyU2VjcmV0UmVxdWVzdCxcbiAqIHdoaWNoIHdpbGwgcmUtc2VuZCB0aGUgY2FjaGVkIFNlY3JldFJldmVhbC5cbiAqIHRyYW5zZmVyLmZhaWx1cmUgaXMgZW1pdHRlZCBpbiBjYXNlIGludmFsaWQgc2VjcmV0UmVxdWVzdCBjb21lcywgYXMgbm8gdmFsaWQgb25lIHdpbGwgY29tZSBhc1xuICogcGVyIGN1cnJlbnQgaW1wbGVtZW50YXRpb24sIHNvIHdlIGZhaWwgZWFybHkgdG8gbm90aWZ5IHVzZXJzIGFib3V0IGl0LlxuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiB0cmFuc2ZlclNlY3JldFJlcXVlc3QgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gZGVwcyAtIFJhaWRlbkVwaWNEZXBzXG4gKiBAcGFyYW0gZGVwcy5zaWduZXIgLSBSYWlkZW5FcGljRGVwcyBzaWduZXJcbiAqIEBwYXJhbSBkZXBzLmxhdGVzdCQgLSBSYWlkZW5FcGljRGVwcyBsYXRlc3QkXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIHRyYW5zZmVyLmZhaWx1cmV8dHJhbnNmZXJTZWNyZXRSZXZlYWx8bWVzc2FnZVNlbmQucmVxdWVzdCBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2ZlclNlY3JldFJldmVhbEVwaWMgPSAoYWN0aW9uJCwge30sIHsgbG9nLCBzaWduZXIsIGxhdGVzdCQgfSkgPT4gYWN0aW9uJC5waXBlKGZpbHRlcihpc0FjdGlvbk9mKHRyYW5zZmVyU2VjcmV0UmVxdWVzdCkpLCBmaWx0ZXIoKGFjdGlvbikgPT4gYWN0aW9uLm1ldGEuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uU0VOVCksIGNvbmNhdE1hcCgoYWN0aW9uKSA9PiBsYXRlc3QkLnBpcGUocGx1Y2tEaXN0aW5jdCgnc3RhdGUnKSkucGlwZShmaXJzdCgpLCBtZXJnZU1hcCgoc3RhdGUpID0+IHNlY3JldFJldmVhbCQoc3RhdGUsIGFjdGlvbiwgeyBsb2csIHNpZ25lciB9KSkpKSk7XG4vKipcbiAqIEhhbmRsZXMgcmVjZWl2aW5nIGEgdmFsaWQgU2VjcmV0UmV2ZWFsIGZyb20gcmVjaXBpZW50IChuZWlnaGJvci9wYXJ0bmVyKVxuICogVGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGUgcGFydG5lciBrbm93d3MgdGhlIHNlY3JldCwgYW5kIHdlIHNob3VsZCBVbmxvY2sgdG8gYXZvaWQgZ29pbmcgb24tY2hhaW4uXG4gKiBUaGUgdHJhbnNmZXJVbmxvY2sucmVxdWVzdCBhY3Rpb24gaXMgYSByZXF1ZXN0IGZvciB0aGUgdW5sb2NraW5nIHRvIGJlIGdlbmVyYXRlZCBhbmQgc2VudC5cbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuQWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIG91dHB1dCBhY3Rpb25zIGZvciB0aGlzIGVwaWNcbiAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zZmVyU2VjcmV0UmV2ZWFsZWRFcGljID0gKGFjdGlvbiQsIHN0YXRlJCkgPT4gYWN0aW9uJC5waXBlKFxuLy8gd2UgZG9uJ3QgcmVxdWlyZSBTaWduZWQgU2VjcmV0UmV2ZWFsLCBub3IgZXZlbiBjaGVjayBzZW5kZXIgZm9yIHBlcnNpc3RpbmcgdGhlIHNlY3JldFxuZmlsdGVyKGlzTWVzc2FnZVJlY2VpdmVkT2ZUeXBlKFNlY3JldFJldmVhbCkpLCB3aXRoTGF0ZXN0RnJvbShzdGF0ZSQpLCBtZXJnZU1hcChmdW5jdGlvbiogKFthY3Rpb24sIHN0YXRlXSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlO1xuICAgIGNvbnN0IHNlY3JldGhhc2ggPSBnZXRTZWNyZXRoYXNoKG1lc3NhZ2Uuc2VjcmV0KTtcbiAgICBpZiAoc2VjcmV0aGFzaCBpbiBzdGF0ZS5zZW50KSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7IHNlY3JldGhhc2gsIGRpcmVjdGlvbjogRGlyZWN0aW9uLlNFTlQgfTtcbiAgICAgICAgLy8gaWYgc2VjcmV0aGFzaCBtYXRjaGVzLCB3ZSdyZSBnb29kIGZvciBwZXJzaXN0aW5nXG4gICAgICAgIHlpZWxkIHRyYW5zZmVyU2VjcmV0KHsgc2VjcmV0OiBtZXNzYWdlLnNlY3JldCB9LCBtZXRhKTtcbiAgICAgICAgLy8gYnV0IGFyZSBzdHJpY3RlciBmb3IgdW5sb2NraW5nIHRvIG5leHQgaG9wXG4gICAgICAgIGlmIChhY3Rpb24ubWV0YS5hZGRyZXNzID09PSBzdGF0ZS5zZW50W3NlY3JldGhhc2hdLnBhcnRuZXIgJiZcbiAgICAgICAgICAgIC8vIGRvbid0IHVubG9jayBpZiBjaGFubmVsIGNsb3NlZFxuICAgICAgICAgICAgIXN0YXRlLnNlbnRbc2VjcmV0aGFzaF0uY2hhbm5lbENsb3NlZCAmJlxuICAgICAgICAgICAgLy8gZG9uJ3QgdW5sb2NrIGFnYWluIGlmIGFscmVhZHkgdW5sb2NrZWQsIHJldHJ5IGhhbmRsZWQgYnkgdHJhbnNmZXJSZXRyeU1lc3NhZ2VFcGljXG4gICAgICAgICAgICAvLyBpbiB0aGUgZnV0dXJlLCB3ZSBtYXkgYXZvaWQgcmV0cnkgdW50aWwgUHJvY2Vzc2VkLCBhbmQgW3JlXXNlbmQgb25jZSBwZXIgU2VjcmV0UmV2ZWFsXG4gICAgICAgICAgICAhc3RhdGUuc2VudFtzZWNyZXRoYXNoXS51bmxvY2tcbiAgICAgICAgLy8gYWNjZXB0cyBzZWNyZXRSZXZlYWwvdW5sb2NrIHJlcXVlc3QgZXZlbiBpZiByZWdpc3RlcmVkIG9uLWNoYWluXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gcmVxdWVzdCB1bmxvY2sgdG8gYmUgY29tcG9zZWQsIHNpZ25lZCAmIHNlbnQgdG8gcGFydG5lclxuICAgICAgICAgICAgeWllbGQgdHJhbnNmZXJVbmxvY2sucmVxdWVzdCh1bmRlZmluZWQsIG1ldGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdlJ3JlIG1lZGlhdG9yIG9yIHRhcmdldCwgYW5kIHJlY2VpdmVkIHJldmVhbCBmcm9tIG5leHQgaG9wIG9yIGluaXRpYXRvciwgcmVzcGVjdGl2ZWx5XG4gICAgaWYgKHNlY3JldGhhc2ggaW4gc3RhdGUucmVjZWl2ZWQpIHtcbiAgICAgICAgLy8gaWYgc2VjcmV0aGFzaCBtYXRjaGVzLCB3ZSdyZSBnb29kIGZvciBwZXJzaXN0aW5nLCB3aGljaCBhbHNvIHRyaWdnZXJzIFJldmVhbCBiYWNrXG4gICAgICAgIHlpZWxkIHRyYW5zZmVyU2VjcmV0KHsgc2VjcmV0OiBtZXNzYWdlLnNlY3JldCB9LCB7IHNlY3JldGhhc2gsIGRpcmVjdGlvbjogRGlyZWN0aW9uLlJFQ0VJVkVEIH0pO1xuICAgIH1cbn0pKTtcbi8qKlxuICogRm9yIGEgcmVjZWl2ZWQgdHJhbnNmZXIsIHdoZW4gd2Uga25vdyB0aGUgc2VjcmV0LCBzaWduICYgc2VuZCBhIFNlY3JldFJldmVhbCB0byBwcmV2aW91cyBob3BcbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgdHJhbnNmZXJTZWNyZXR8dHJhbnNmZXJTZWNyZXRSZXZlYWwgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gZGVwcyAtIFJhaWRlbkVwaWNEZXBzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIHRyYW5zZmVyU2VjcmV0UmV2ZWFsIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zZmVyUmVxdWVzdFVubG9ja0VwaWMgPSAoYWN0aW9uJCwge30sIHsgbG9nLCBzaWduZXIsIGxhdGVzdCQgfSkgPT4gYWN0aW9uJC5waXBlKGZpbHRlcihpc0FjdGlvbk9mKFt0cmFuc2ZlclNlY3JldCwgdHJhbnNmZXJTZWNyZXRSZWdpc3Rlci5zdWNjZXNzXSkpLCBmaWx0ZXIoKGFjdGlvbikgPT4gYWN0aW9uLm1ldGEuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uUkVDRUlWRUQpLCBjb25jYXRNYXAoKGFjdGlvbikgPT4gbGF0ZXN0JC5waXBlKHBsdWNrRGlzdGluY3QoJ3N0YXRlJyksIGZpcnN0KCksIGZpbHRlcigoeyByZWNlaXZlZCB9KSA9PiB7IHZhciBfYTsgcmV0dXJuICEoKF9hID0gcmVjZWl2ZWRbYWN0aW9uLm1ldGEuc2VjcmV0aGFzaF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZWNyZXRSZXZlYWwpOyB9KSwgbWVyZ2VNYXAoKCkgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLlNFQ1JFVF9SRVZFQUwsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2FtZWxjYXNlXG4gICAgICAgIG1lc3NhZ2VfaWRlbnRpZmllcjogbWFrZU1lc3NhZ2VJZCgpLFxuICAgICAgICBzZWNyZXQ6IGFjdGlvbi5wYXlsb2FkLnNlY3JldCxcbiAgICB9O1xuICAgIHJldHVybiBzaWduTWVzc2FnZShzaWduZXIsIG1lc3NhZ2UsIHsgbG9nIH0pO1xufSksIG1hcCgobWVzc2FnZSkgPT4gdHJhbnNmZXJTZWNyZXRSZXZlYWwoeyBtZXNzYWdlIH0sIGFjdGlvbi5tZXRhKSksIGNhdGNoRXJyb3IoKGVycikgPT4ge1xuICAgIGxvZy53YXJuKCdFcnJvciB0cnlpbmcgdG8gc2lnbiBTZWNyZXRSZXZlYWwgLSBpZ25vcmluZycsIGVyciwgYWN0aW9uLm1ldGEpO1xuICAgIHJldHVybiBFTVBUWTtcbn0pKSkpO1xuLyoqXG4gKiBNb25pdG9ycyBTZWNyZXRSZWdpc3RyeSBhbmQgZW1pdHMgd2hlbiBhIHJlbGV2YW50IHNlY3JldCBnZXRzIHJlZ2lzdGVyZWRcbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuQWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIHRyYW5zZmVyU2VjcmV0UmVnaXN0ZXIuc3VjY2VzcyBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBtb25pdG9yU2VjcmV0UmVnaXN0cnlFcGljID0gKHt9LCBzdGF0ZSQsIHsgc2VjcmV0UmVnaXN0cnlDb250cmFjdCB9KSA9PiBnZXRFdmVudHNTdHJlYW0oc2VjcmV0UmVnaXN0cnlDb250cmFjdCwgW1xuICAgIHNlY3JldFJlZ2lzdHJ5Q29udHJhY3QuZmlsdGVycy5TZWNyZXRSZXZlYWxlZChudWxsLCBudWxsKSxcbl0pLnBpcGUod2l0aExhdGVzdEZyb20oc3RhdGUkKSwgZmlsdGVyKChbW3NlY3JldGhhc2gsICwgeyBibG9ja051bWJlciB9XSwgeyBzZW50LCByZWNlaXZlZCB9XSkgPT4gXG4vLyBlbWl0cyBvbmx5IGlmIGxvY2sgZGlkbid0IGV4cGlyZSB5ZXRcbihzZWNyZXRoYXNoIGluIHNlbnQgJiYgc2VudFtzZWNyZXRoYXNoXS50cmFuc2ZlclsxXS5sb2NrLmV4cGlyYXRpb24uZ3RlKGJsb2NrTnVtYmVyKSkgfHxcbiAgICAoc2VjcmV0aGFzaCBpbiByZWNlaXZlZCAmJlxuICAgICAgICByZWNlaXZlZFtzZWNyZXRoYXNoXS50cmFuc2ZlclsxXS5sb2NrLmV4cGlyYXRpb24uZ3RlKGJsb2NrTnVtYmVyKSkpLCBtZXJnZU1hcChmdW5jdGlvbiogKFtbc2VjcmV0aGFzaCwgc2VjcmV0LCBldmVudF0sIHsgc2VudCwgcmVjZWl2ZWQgfV0pIHtcbiAgICBpZiAoc2VjcmV0aGFzaCBpbiBzZW50ICYmXG4gICAgICAgIHNlbnRbc2VjcmV0aGFzaF0udHJhbnNmZXJbMV0ubG9jay5leHBpcmF0aW9uLmd0ZShldmVudC5ibG9ja051bWJlcikpIHtcbiAgICAgICAgeWllbGQgdHJhbnNmZXJTZWNyZXRSZWdpc3Rlci5zdWNjZXNzKHtcbiAgICAgICAgICAgIHNlY3JldCxcbiAgICAgICAgICAgIHR4SGFzaDogZXZlbnQudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgdHhCbG9jazogZXZlbnQuYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICBjb25maXJtZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfSwgeyBzZWNyZXRoYXNoLCBkaXJlY3Rpb246IERpcmVjdGlvbi5TRU5UIH0pO1xuICAgIH1cbiAgICBpZiAoc2VjcmV0aGFzaCBpbiByZWNlaXZlZCAmJlxuICAgICAgICByZWNlaXZlZFtzZWNyZXRoYXNoXS50cmFuc2ZlclsxXS5sb2NrLmV4cGlyYXRpb24uZ3RlKGV2ZW50LmJsb2NrTnVtYmVyKSkge1xuICAgICAgICB5aWVsZCB0cmFuc2ZlclNlY3JldFJlZ2lzdGVyLnN1Y2Nlc3Moe1xuICAgICAgICAgICAgc2VjcmV0LFxuICAgICAgICAgICAgdHhIYXNoOiBldmVudC50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICB0eEJsb2NrOiBldmVudC5ibG9ja051bWJlcixcbiAgICAgICAgICAgIGNvbmZpcm1lZDogdW5kZWZpbmVkLFxuICAgICAgICB9LCB7IHNlY3JldGhhc2gsIGRpcmVjdGlvbjogRGlyZWN0aW9uLlJFQ0VJVkVEIH0pO1xuICAgIH1cbn0pKTtcbi8qKlxuICogQSBzaW1wbGUgZXBpYyB0byBlbWl0IHRyYW5zZmVyLnN1Y2Nlc3Mgd2hlbiBzZWNyZXQgcmVnaXN0ZXIgaXMgY29uZmlybWVkXG4gKlxuICogQHBhcmFtIGFjdGlvbiQgLSBPYnNlcnZhYmxlIG9mIHRyYW5zZmVyU2VjcmV0UmVnaXN0ZXIuc3VjY2VzcyBhY3Rpb25zXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIHRyYW5zZmVyLnN1Y2Nlc3MgYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXJTdWNjZXNzT25TZWNyZXRSZWdpc3RlcmVkRXBpYyA9IChhY3Rpb24kKSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKHRyYW5zZmVyU2VjcmV0UmVnaXN0ZXIuc3VjY2Vzcy5pcyksIGZpbHRlcigoYWN0aW9uKSA9PiAhIWFjdGlvbi5wYXlsb2FkLmNvbmZpcm1lZCksIG1hcCgoYWN0aW9uKSA9PiB0cmFuc2Zlci5zdWNjZXNzKHt9LCBhY3Rpb24ubWV0YSkpKTtcbi8qKlxuICogUHJvY2VzcyBuZXdCbG9ja3MgYW5kIHBlbmRpbmcgcmVjZWl2ZWQgdHJhbnNmZXJzLiBJZiB3ZSBrbm93IHRoZSBzZWNyZXQsIGFuZCB0cmFuc2ZlciBkb2Vzbid0XG4gKiBnZXQgdW5sb2NrZWQgYmVmb3JlIHJldmVhbFRpbWVvdXQgYmxvY2tzIGFyZSBsZWZ0IHRvIGxvY2sgZXhwaXJhdGlvbiwgcmVxdWVzdCB0byByZWdpc3RlciBzZWNyZXRcbiAqIFRPRE86IGNoZWNrIGVjb25vbWljIHZpYWJpbGl0eSAoYW5kIGRlZmluZSB3aGF0IHRoYXQgbWVhbnMpIG9mIHJlZ2lzdGVyaW5nIGxvY2sgb24tY2hhaW5cbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgbmV3QmxvY2sgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIHRyYW5zZmVyU2VjcmV0UmVnaXN0ZXIucmVxdWVzdCBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2ZlckF1dG9SZWdpc3RlckVwaWMgPSAoYWN0aW9uJCwgc3RhdGUkLCB7IGNvbmZpZyQsIGxhdGVzdCQgfSkgPT4gc3RhdGUkLnBpcGUocGx1Y2tEaXN0aW5jdChEaXJlY3Rpb24uUkVDRUlWRUQpLCBtZXJnZU1hcCgocmVjZWl2ZWQpID0+IGZyb20oT2JqZWN0LmtleXMocmVjZWl2ZWQpKSksIGRpc3RpbmN0KCksIG1lcmdlTWFwKChzZWNyZXRoYXNoKSA9PiBhY3Rpb24kLnBpcGUoZmlsdGVyKG5ld0Jsb2NrLmlzKSwgd2l0aExhdGVzdEZyb20obGF0ZXN0JC5waXBlKHBsdWNrKCdzdGF0ZScsIERpcmVjdGlvbi5SRUNFSVZFRCwgc2VjcmV0aGFzaCkpLCBjb25maWckKSwgZmlsdGVyKChbYWN0aW9uLCByZWNlaXZlZCwgeyBjYXBzLCByZXZlYWxUaW1lb3V0IH1dKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gIShjYXBzID09PSBudWxsIHx8IGNhcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhcHNbQ2FwYWJpbGl0aWVzLk5PX1JFQ0VJVkVdKSAmJiAvLyBpZ25vcmUgaWYgcmVjZWl2aW5nIGlzIGRpc2FibGVkXG4gICAgICAgICEhcmVjZWl2ZWQuc2VjcmV0ICYmIC8vIHJlZ2lzdGVyIG9ubHkgaWYgd2Uga25vdyB0aGUgc2VjcmV0XG4gICAgICAgIHJlY2VpdmVkLnRyYW5zZmVyWzFdLmxvY2suZXhwaXJhdGlvblxuICAgICAgICAgICAgLnN1YihyZXZlYWxUaW1lb3V0KVxuICAgICAgICAgICAgLmx0KGFjdGlvbi5wYXlsb2FkLmJsb2NrTnVtYmVyKSAmJiAvLyBhbmQgYWZ0ZXIgPHJldmVhbFRpbWVvdXQgbGVmdCB0byBleHBpcmF0aW9uXG4gICAgICAgICEoKF9iID0gKF9hID0gcmVjZWl2ZWQuc2VjcmV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWdpc3RlckJsb2NrKSAmJiAvLyBhbmQgbm90IHlldCByZWdpc3RlcmVkIG5vciB1bmxvY2tlZFxuICAgICAgICAhcmVjZWl2ZWQudW5sb2NrO1xufSksIGV4aGF1c3RNYXAoKFssIHJlY2VpdmVkXSkgPT4ge1xuICAgIGNvbnN0IG1ldGEgPSB7IHNlY3JldGhhc2gsIGRpcmVjdGlvbjogRGlyZWN0aW9uLlJFQ0VJVkVEIH07XG4gICAgcmV0dXJuIGRpc3BhdGNoQW5kV2FpdCQoYWN0aW9uJCwgdHJhbnNmZXJTZWNyZXRSZWdpc3Rlci5yZXF1ZXN0KHsgc2VjcmV0OiByZWNlaXZlZC5zZWNyZXRbMV0udmFsdWUgfSwgbWV0YSksIGlzQ29uZmlybWF0aW9uUmVzcG9uc2VPZih0cmFuc2ZlclNlY3JldFJlZ2lzdGVyLCBtZXRhKSk7XG59KSwgdGFrZVVudGlsKGxhdGVzdCQucGlwZShwbHVja0Rpc3RpbmN0KCdzdGF0ZScpLCBmaWx0ZXIoKHN0YXRlKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBibG9ja051bWJlciA9IHN0YXRlLmJsb2NrTnVtYmVyO1xuICAgIGNvbnN0IHJlY2VpdmVkID0gc3RhdGUucmVjZWl2ZWRbc2VjcmV0aGFzaF07XG4gICAgY29uc3QgZXhwaXJhdGlvbiA9IHJlY2VpdmVkLnRyYW5zZmVyWzFdLmxvY2suZXhwaXJhdGlvbjtcbiAgICByZXR1cm4gISEoZXhwaXJhdGlvbi5sdChibG9ja051bWJlcikgfHwgLy8gZ2l2ZSB1cCBpZiBsb2NrIGFscmVhZHkgZXhwaXJlZFxuICAgICAgICByZWNlaXZlZC51bmxvY2sgfHwgKChfYiA9IChfYSA9IFxuICAgIC8vIHN0b3AgaWYgc2VjcmV0IGdvdCByZWdpc3RlcmVkIG9yIHVubG9ja2VkXG4gICAgcmVjZWl2ZWQuc2VjcmV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWdpc3RlckJsb2NrKSk7XG4gICAgLy8gZXZlbiBpZiBjaGFubmVsQ2xvc2VkLCB3aGlsZSBpbnNpZGUgbG9jayBleHBpcmF0aW9uLCBjb250aW51ZSB0byB0cnkgdG8gcmVnaXN0ZXJcbn0pKSkpKSk7XG4vKipcbiAqIFJlZ2lzdGVycyBzZWNyZXQgb24tY2hhaW4uIFN1Y2Nlc3MgaXMgZGV0ZWN0ZWQgYnkgbW9uaXRvclNlY3JldFJlZ2lzdHJ5RXBpY1xuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiB0cmFuc2ZlclNlY3JldFJlZ2lzdGVyLnJlcXVlc3QgYWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gZGVwcyAtIERlcGVuZGVuY2llc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiB0cmFuc2ZlclNlY3JldFJlZ2lzdGVyLmZhaWx1cmUgYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3QgdHJhbnNmZXJTZWNyZXRSZWdpc3RlckVwaWMgPSAoYWN0aW9uJCwge30sIHsgbG9nLCBzaWduZXIsIGFkZHJlc3MsIG1haW4sIHNlY3JldFJlZ2lzdHJ5Q29udHJhY3QsIGNvbmZpZyQgfSkgPT4gYWN0aW9uJC5waXBlKGZpbHRlcih0cmFuc2ZlclNlY3JldFJlZ2lzdGVyLnJlcXVlc3QuaXMpLCB3aXRoTGF0ZXN0RnJvbShjb25maWckKSwgbWVyZ2VNYXAoKFthY3Rpb24sIHsgc3Via2V5OiBjb25maWdTdWJrZXkgfV0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBzaWduZXI6IG9uY2hhaW5TaWduZXIgfSA9IGNob29zZU9uY2hhaW5BY2NvdW50KHsgc2lnbmVyLCBhZGRyZXNzLCBtYWluIH0sIChfYSA9IGFjdGlvbi5wYXlsb2FkLnN1YmtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uZmlnU3Via2V5KTtcbiAgICBjb25zdCBjb250cmFjdCA9IGdldENvbnRyYWN0V2l0aFNpZ25lcihzZWNyZXRSZWdpc3RyeUNvbnRyYWN0LCBvbmNoYWluU2lnbmVyKTtcbiAgICByZXR1cm4gZnJvbShjb250cmFjdC5mdW5jdGlvbnMucmVnaXN0ZXJTZWNyZXQoYWN0aW9uLnBheWxvYWQuc2VjcmV0KSkucGlwZShhc3NlcnRUeCgncmVnaXN0ZXJTZWNyZXQnLCBFcnJvckNvZGVzLlhGRVJfUkVHSVNURVJTRUNSRVRfVFhfRkFJTEVELCB7IGxvZyB9KSwgXG4gICAgLy8gdHJhbnNmZXJTZWNyZXRSZWdpc3Rlci5zdWNjZXNzIGhhbmRsZWQgYnkgbW9uaXRvclNlY3JldFJlZ2lzdHJ5RXBpY1xuICAgIGlnbm9yZUVsZW1lbnRzKCksIGNhdGNoRXJyb3IoKGVycikgPT4gb2YodHJhbnNmZXJTZWNyZXRSZWdpc3Rlci5mYWlsdXJlKGVyciwgYWN0aW9uLm1ldGEpKSkpO1xufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcmV0LmpzLm1hcCIsImltcG9ydCB7IGZpbHRlciwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU2lnbmVkIH0gZnJvbSAnLi4vLi4vdXRpbHMvdHlwZXMnO1xuaW1wb3J0IHsgaXNBY3Rpb25PZiB9IGZyb20gJy4uLy4uL3V0aWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgbWVzc2FnZVNlbmQgfSBmcm9tICcuLi8uLi9tZXNzYWdlcy9hY3Rpb25zJztcbmltcG9ydCB7IFdpdGhkcmF3UmVxdWVzdCB9IGZyb20gJy4uLy4uL21lc3NhZ2VzL3R5cGVzJztcbmltcG9ydCB7IGlzTWVzc2FnZVJlY2VpdmVkT2ZUeXBlIH0gZnJvbSAnLi4vLi4vbWVzc2FnZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2l0aGRyYXdSZWNlaXZlIH0gZnJvbSAnLi4vYWN0aW9ucyc7XG4vKipcbiAqIFdoZW4gcmVjZWl2aW5nIGEgW1tXaXRoZHJhd1JlcXVlc3RdXSBtZXNzYWdlLCBjcmVhdGUgdGhlIHJlc3BlY3RpdmUgW1t3aXRoZHJhd1JlY2VpdmUucmVxdWVzdF1dXG4gKiBhY3Rpb25cbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgbWVzc2FnZVJlY2VpdmVkIGFjdGlvbnNcbiAqIEByZXR1cm5zIE9ic2VydmFibGUgb2Ygd2l0aGRyYXdSZWNlaXZlLnJlcXVlc3QgYWN0aW9uc1xuICovXG5leHBvcnQgY29uc3Qgd2l0aGRyYXdSZXF1ZXN0UmVjZWl2ZWRFcGljID0gKGFjdGlvbiQpID0+IGFjdGlvbiQucGlwZShmaWx0ZXIoaXNNZXNzYWdlUmVjZWl2ZWRPZlR5cGUoU2lnbmVkKFdpdGhkcmF3UmVxdWVzdCkpKSwgZmlsdGVyKChhY3Rpb24pID0+IGFjdGlvbi5wYXlsb2FkLm1lc3NhZ2UucGFydGljaXBhbnQgPT09IGFjdGlvbi5tZXRhLmFkZHJlc3MpLCBtYXAoKGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBhY3Rpb24ucGF5bG9hZC5tZXNzYWdlO1xuICAgIHJldHVybiB3aXRoZHJhd1JlY2VpdmUucmVxdWVzdCh7IG1lc3NhZ2UgfSwge1xuICAgICAgICB0b2tlbk5ldHdvcms6IG1lc3NhZ2UudG9rZW5fbmV0d29ya19hZGRyZXNzLFxuICAgICAgICBwYXJ0bmVyOiBtZXNzYWdlLnBhcnRpY2lwYW50LFxuICAgICAgICB0b3RhbFdpdGhkcmF3OiBtZXNzYWdlLnRvdGFsX3dpdGhkcmF3LFxuICAgICAgICBleHBpcmF0aW9uOiBtZXNzYWdlLmV4cGlyYXRpb24udG9OdW1iZXIoKSxcbiAgICB9KTtcbn0pKTtcbi8qKlxuICogc2VuZE1lc3NhZ2Ugd2hlbiBhIFtbd2l0aGRyYXdSZWNlaXZlLnN1Y2Nlc3NdXSBhY3Rpb24gaXMgZmlyZWRcbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2Ygd2l0aGRyYXdSZWNlaXZlLnN1Y2Nlc3MgYWN0aW9uc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBtZXNzYWdlU2VuZC5yZXF1ZXN0IGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IHdpdGhkcmF3U2VuZENvbmZpcm1hdGlvbkVwaWMgPSAoYWN0aW9uJCkgPT4gYWN0aW9uJC5waXBlKGZpbHRlcihpc0FjdGlvbk9mKHdpdGhkcmF3UmVjZWl2ZS5zdWNjZXNzKSksIG1hcCgoYWN0aW9uKSA9PiBtZXNzYWdlU2VuZC5yZXF1ZXN0KHsgbWVzc2FnZTogYWN0aW9uLnBheWxvYWQubWVzc2FnZSB9LCB7XG4gICAgYWRkcmVzczogYWN0aW9uLm1ldGEucGFydG5lcixcbiAgICBtc2dJZDogYWN0aW9uLnBheWxvYWQubWVzc2FnZS5tZXNzYWdlX2lkZW50aWZpZXIudG9TdHJpbmcoKSxcbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aXRoZHJhdy5qcy5tYXAiLCJleHBvcnQgKiBmcm9tICcuL2Nsb3NlJztcbmV4cG9ydCAqIGZyb20gJy4vZXhwaXJlJztcbmV4cG9ydCAqIGZyb20gJy4vbG9ja2VkJztcbmV4cG9ydCAqIGZyb20gJy4vaW5pdCc7XG5leHBvcnQgKiBmcm9tICcuL21lZGlhdGUnO1xuZXhwb3J0ICogZnJvbSAnLi9wcm9jZXNzZWQnO1xuZXhwb3J0ICogZnJvbSAnLi9yZWZ1bmQnO1xuZXhwb3J0ICogZnJvbSAnLi9yZXRyeSc7XG5leHBvcnQgKiBmcm9tICcuL3NlY3JldCc7XG5leHBvcnQgKiBmcm9tICcuL3dpdGhkcmF3Jztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2NhbWVsY2FzZSAqL1xuaW1wb3J0ICogYXMgdCBmcm9tICdpby10cyc7XG5pbXBvcnQgeyBmcm9tLCBvZiwgRU1QVFkgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1lcmdlTWFwLCBtYXAsIHRpbWVvdXQsIHdpdGhMYXRlc3RGcm9tLCBjYXRjaEVycm9yLCB0b0FycmF5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgZnJvbUZldGNoIH0gZnJvbSAncnhqcy9mZXRjaCc7XG5pbXBvcnQgbWVtb2l6ZSBmcm9tICdsb2Rhc2gvbWVtb2l6ZSc7XG5pbXBvcnQgeyBBZGRyZXNzLCBVSW50LCBkZWNvZGUgfSBmcm9tICcuLi91dGlscy90eXBlcyc7XG5pbXBvcnQgeyBsb3NzbGVzc1BhcnNlIH0gZnJvbSAnLi4vdXRpbHMvZGF0YSc7XG5pbXBvcnQgeyBDaGFubmVsU3RhdGUgfSBmcm9tICcuLi9jaGFubmVscy9zdGF0ZSc7XG5pbXBvcnQgeyBjaGFubmVsQW1vdW50cyB9IGZyb20gJy4uL2NoYW5uZWxzL3V0aWxzJztcbmltcG9ydCB7IFJhaWRlbkVycm9yLCBFcnJvckNvZGVzIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3InO1xuaW1wb3J0IHsgQ2FwYWJpbGl0aWVzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGlzVmFsaWRVcmwgfSBmcm9tICcuLi9oZWxwZXJzJztcbi8qKlxuICogRWl0aGVyIHJldHVybnMgdHJ1ZSBpZiBnaXZlbiBjaGFubmVsIGNhbiByb3V0ZSBhIHBheW1lbnQsIG9yIGEgcmVhc29uIGFzIHN0cmluZyBpZiBub3RcbiAqXG4gKiBAcGFyYW0gc3RhdGUgLSBjdXJyZW50IFJhaWRlblN0YXRlXG4gKiBAcGFyYW0gcHJlc2VuY2VzIC0gbGF0ZXN0IFByZXNlbmNlcyBtYXBwaW5nXG4gKiBAcGFyYW0gdG9rZW5OZXR3b3JrIC0gdG9rZW5OZXR3b3JrIHdoZXJlIHRoZSBjaGFubmVsIGlzXG4gKiBAcGFyYW0gcGFydG5lciAtIHBvc3NpYmx5IGEgcGFydG5lciBvbiBnaXZlbiB0b2tlbk5ldHdvcmtcbiAqIEBwYXJhbSB0YXJnZXQgLSB0cmFuc2ZlciB0YXJnZXRcbiAqIEBwYXJhbSB2YWx1ZSAtIGFtb3VudCBvZiB0b2tlbnMgdG8gY2hlY2sgaWYgY2hhbm5lbCBjYW4gcm91dGVcbiAqIEByZXR1cm5zIHRydWUgaWYgY2hhbm5lbCBjYW4gcm91dGUsIHN0cmluZyBjb250YWluaW5nIHJlYXNvbiBpZiBub3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoYW5uZWxDYW5Sb3V0ZShzdGF0ZSwgcHJlc2VuY2VzLCB0b2tlbk5ldHdvcmssIHBhcnRuZXIsIHRhcmdldCwgdmFsdWUpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCEocGFydG5lciBpbiBwcmVzZW5jZXMpIHx8ICFwcmVzZW5jZXNbcGFydG5lcl0ucGF5bG9hZC5hdmFpbGFibGUpXG4gICAgICAgIHJldHVybiBgcGF0aDogcGFydG5lciBcIiR7cGFydG5lcn1cIiBub3QgYXZhaWxhYmxlIGluIHRyYW5zcG9ydGA7XG4gICAgaWYgKHRhcmdldCAhPT0gcGFydG5lciAmJiAoKF9hID0gcHJlc2VuY2VzW3BhcnRuZXJdLnBheWxvYWQuY2FwcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW0NhcGFiaWxpdGllcy5OT19NRURJQVRFXSkpXG4gICAgICAgIHJldHVybiBgcGF0aDogcGFydG5lciBcIiR7cGFydG5lcn1cIiBkb2Vzbid0IG1lZGlhdGUgdHJhbnNmZXJzYDtcbiAgICBpZiAoIShwYXJ0bmVyIGluIHN0YXRlLmNoYW5uZWxzW3Rva2VuTmV0d29ya10pKVxuICAgICAgICByZXR1cm4gYHBhdGg6IHRoZXJlJ3Mgbm8gZGlyZWN0IGNoYW5uZWwgd2l0aCBwYXJ0bmVyIFwiJHtwYXJ0bmVyfVwiYDtcbiAgICBjb25zdCBjaGFubmVsID0gc3RhdGUuY2hhbm5lbHNbdG9rZW5OZXR3b3JrXVtwYXJ0bmVyXTtcbiAgICBpZiAoY2hhbm5lbC5zdGF0ZSAhPT0gQ2hhbm5lbFN0YXRlLm9wZW4pXG4gICAgICAgIHJldHVybiBgcGF0aDogY2hhbm5lbCB3aXRoIFwiJHtwYXJ0bmVyfVwiIGluIHN0YXRlIFwiJHtjaGFubmVsLnN0YXRlfVwiIGluc3RlYWQgb2YgXCIke0NoYW5uZWxTdGF0ZS5vcGVufVwiYDtcbiAgICBjb25zdCB7IG93bkNhcGFjaXR5OiBjYXBhY2l0eSB9ID0gY2hhbm5lbEFtb3VudHMoY2hhbm5lbCk7XG4gICAgaWYgKGNhcGFjaXR5Lmx0KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGBwYXRoOiBjaGFubmVsIHdpdGggXCIke3BhcnRuZXJ9XCIgZG9lc24ndCBoYXZlIGVub3VnaCBjYXBhY2l0eT0ke2NhcGFjaXR5LnRvU3RyaW5nKCl9YDtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IHNlcnZpY2VSZWdpc3RyeVRva2VuID0gbWVtb2l6ZSgoc2VydmljZVJlZ2lzdHJ5Q29udHJhY3QpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gc2VydmljZVJlZ2lzdHJ5Q29udHJhY3QuZnVuY3Rpb25zLnRva2VuKCk7IH0pKTtcbi8qKlxuICogUmV0dXJucyBhIGNvbGQgb2JzZXJ2YWJsZSB3aGljaCBmZXRjaCBQRlMgaW5mbyAmIHZhbGlkYXRlIGZvciBhIGdpdmVuIHNlcnZlciBhZGRyZXNzIG9yIFVSTFxuICpcbiAqIEBwYXJhbSBwZnNBZGRyT3JVcmwgLSBQRlMgYWNjb3VudC9hZGRyZXNzIG9yIFVSTFxuICogQHBhcmFtIGRlcHMgLSBSYWlkZW5FcGljRGVwcyBuZWVkZWQgZm9yIHZhcmlvdXMgcGFyYW1ldGVyc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBjb250YWluaW5nIFBGUyBzZXJ2ZXIgaW5mb1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGZzSW5mbyhwZnNBZGRyT3JVcmwsIHsgc2VydmljZVJlZ2lzdHJ5Q29udHJhY3QsIG5ldHdvcmssIGNvbnRyYWN0c0luZm8sIGNvbmZpZyQgfSkge1xuICAgIC8qKlxuICAgICAqIENvZGVjIGZvciBQRlMgL2FwaS92MS9pbmZvIHJlc3VsdCBzY2hlbWFcbiAgICAgKi9cbiAgICBjb25zdCBQYXRoSW5mbyA9IHQudHlwZSh7XG4gICAgICAgIG1lc3NhZ2U6IHQuc3RyaW5nLFxuICAgICAgICBuZXR3b3JrX2luZm86IHQudHlwZSh7XG4gICAgICAgICAgICAvLyBsaXRlcmFscyB3aWxsIGZhaWwgaWYgdHJ5aW5nIHRvIGRlY29kZSBhbnl0aGluZyBkaWZmZXJlbnQgZnJvbSB0aGVzZSBjb25zdGFudHNcbiAgICAgICAgICAgIGNoYWluX2lkOiB0LmxpdGVyYWwobmV0d29yay5jaGFpbklkKSxcbiAgICAgICAgICAgIHRva2VuX25ldHdvcmtfcmVnaXN0cnlfYWRkcmVzczogdC5saXRlcmFsKGNvbnRyYWN0c0luZm8uVG9rZW5OZXR3b3JrUmVnaXN0cnkuYWRkcmVzcyksXG4gICAgICAgIH0pLFxuICAgICAgICBvcGVyYXRvcjogdC5zdHJpbmcsXG4gICAgICAgIHBheW1lbnRfYWRkcmVzczogQWRkcmVzcyxcbiAgICAgICAgcHJpY2VfaW5mbzogVUludCgzMiksXG4gICAgICAgIHZlcnNpb246IHQuc3RyaW5nLFxuICAgIH0pO1xuICAgIC8vIGlmIGl0J3MgYW4gYWRkcmVzcywgZmV0Y2ggdXJsIGZyb20gU2VydmljZVJlZ2lzdHJ5LCBlbHNlIGl0J3MgYWxyZWFkeSB0aGUgVVJMXG4gICAgY29uc3QgdXJsJCA9IEFkZHJlc3MuaXMocGZzQWRkck9yVXJsKVxuICAgICAgICA/IGZyb20oc2VydmljZVJlZ2lzdHJ5Q29udHJhY3QuZnVuY3Rpb25zLnVybHMocGZzQWRkck9yVXJsKSlcbiAgICAgICAgOiBvZihwZnNBZGRyT3JVcmwpO1xuICAgIHJldHVybiB1cmwkLnBpcGUod2l0aExhdGVzdEZyb20oY29uZmlnJCksIG1lcmdlTWFwKChbdXJsLCB7IGh0dHBUaW1lb3V0IH1dKSA9PiB7XG4gICAgICAgIGlmICghdXJsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuUEZTX0VNUFRZX1VSTCk7XG4gICAgICAgIGVsc2UgaWYgKCFpc1ZhbGlkVXJsKHVybCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFpZGVuRXJyb3IoRXJyb3JDb2Rlcy5QRlNfSU5WQUxJRF9VUkwsIHsgdXJsIH0pO1xuICAgICAgICAvLyBkZWZhdWx0IHRvIGh0dHBzIGZvciBkb21haW4tb25seSB1cmxzXG4gICAgICAgIGVsc2UgaWYgKCF1cmwuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSAmJiAhdXJsLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSlcbiAgICAgICAgICAgIHVybCA9IGBodHRwczovLyR7dXJsfWA7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIGZyb21GZXRjaCh1cmwgKyAnL2FwaS92MS9pbmZvJykucGlwZSh0aW1lb3V0KGh0dHBUaW1lb3V0KSwgbWVyZ2VNYXAoKHJlcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBkZWNvZGUoUGF0aEluZm8sIGxvc3NsZXNzUGFyc2UoeWllbGQgcmVzLnRleHQoKSkpLFxuICAgICAgICAgICAgICAgIHlpZWxkIHNlcnZpY2VSZWdpc3RyeVRva2VuKHNlcnZpY2VSZWdpc3RyeUNvbnRyYWN0KSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pKSwgbWFwKChbaW5mbywgdG9rZW5dKSA9PiAoe1xuICAgICAgICAgICAgYWRkcmVzczogaW5mby5wYXltZW50X2FkZHJlc3MsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBydHQ6IERhdGUubm93KCkgLSBzdGFydCxcbiAgICAgICAgICAgIHByaWNlOiBpbmZvLnByaWNlX2luZm8sXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgfSkpKTtcbiAgICB9KSk7XG59XG4vKipcbiAqIFJldHJpZXZlIHBmc0luZm8gZm9yIHRoZXNlIHNlcnZlcnMgJiByZXR1cm4gc29ydGVkIFBGUyBpbmZvXG4gKlxuICogU29ydCBvcmRlciBpcyBwcmljZSB0aGVuIHJlc3BvbnNlIHRpbWUgKHJ0dCkuXG4gKiBUaHJvd3MgaWYgbm8gc2VydmVyIGNhbiBiZSB2YWxpZGF0ZWQsIG1lYW5pbmcgZWl0aGVyIHRoZXJlJ3Mgbm9uZSBpbiB0aGUgY3VycmVudCBuZXR3b3JrIG9yXG4gKiB3ZSdyZSBvdXQtb2Ytc3luYyAob3V0ZGF0ZWQgb3IgYWhlYWQgb2YgUEZTJ3MgZGVwbG95bWVudCBuZXR3b3JrIHZlcnNpb24pLlxuICpcbiAqIEBwYXJhbSBwZnNMaXN0IC0gQXJyYXkgb2YgUEZTIGFkZHJlc3NlcyBvciBVUkxzXG4gKiBAcGFyYW0gZGVwcyAtIFJhaWRlbkVwaWNEZXBzIGFycmF5XG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIG9ubGluZSwgdmFsaWRhdGVkICYgc29ydGVkIFBGUyBpbmZvIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwZnNMaXN0SW5mbyhwZnNMaXN0LCBkZXBzKSB7XG4gICAgY29uc3QgeyBsb2cgfSA9IGRlcHM7XG4gICAgcmV0dXJuIGZyb20ocGZzTGlzdCkucGlwZShtZXJnZU1hcCgoYWRkck9yVXJsKSA9PiBwZnNJbmZvKGFkZHJPclVybCwgZGVwcykucGlwZShjYXRjaEVycm9yKChlcnIpID0+IHtcbiAgICAgICAgbG9nLndhcm4oYEVycm9yIHRyeWluZyB0byBmZXRjaCBQRlMgaW5mbyBmb3IgXCIke2FkZHJPclVybH1cIiAtIGlnbm9yaW5nOmAsIGVycik7XG4gICAgICAgIHJldHVybiBFTVBUWTtcbiAgICB9KSksIDUpLCB0b0FycmF5KCksIG1hcCgobGlzdCkgPT4ge1xuICAgICAgICBpZiAoIWxpc3QubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuUEZTX0lOVkFMSURfSU5GTyk7XG4gICAgICAgIHJldHVybiBsaXN0LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpZiA9IGEucHJpY2Uuc3ViKGIucHJpY2UpO1xuICAgICAgICAgICAgLy8gZmlyc3QsIHNvcnQgYnkgcHJpY2VcbiAgICAgICAgICAgIGlmIChkaWYubHQoMCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGlmLmd0KDApKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgLy8gaWYgaXQncyBlcXVhbCwgdGllYnJlYWsgb24gcnR0XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucnR0IC0gYi5ydHQ7XG4gICAgICAgIH0pO1xuICAgIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2NhbWVsY2FzZSAqL1xuaW1wb3J0ICogYXMgdCBmcm9tICdpby10cyc7XG5pbXBvcnQgeyBkZWZlciwgRU1QVFksIGZyb20sIG1lcmdlLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciwgY29uY2F0TWFwLCBkZWJvdW5jZVRpbWUsIGRlbGF5LCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCBmaXJzdCwgZ3JvdXBCeSwgbWFwLCBtZXJnZU1hcCwgcGx1Y2ssIHNjYW4sIHN3aXRjaE1hcCwgdGFwLCB0aW1lb3V0LCB3aXRoTGF0ZXN0RnJvbSwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBmcm9tRmV0Y2ggfSBmcm9tICdyeGpzL2ZldGNoJztcbmltcG9ydCB7IGJpZ051bWJlcmlmeSwgdG9VdGY4Qnl0ZXMsIHZlcmlmeU1lc3NhZ2UsIGNvbmNhdCB9IGZyb20gJ2V0aGVycy91dGlscyc7XG5pbXBvcnQgeyBUd28sIFplcm8gfSBmcm9tICdldGhlcnMvY29uc3RhbnRzJztcbmltcG9ydCBtZW1vaXplIGZyb20gJ2xvZGFzaC9tZW1vaXplJztcbmltcG9ydCB7IG1lc3NhZ2VHbG9iYWxTZW5kIH0gZnJvbSAnLi4vbWVzc2FnZXMvYWN0aW9ucyc7XG5pbXBvcnQgeyBNZXNzYWdlVHlwZSB9IGZyb20gJy4uL21lc3NhZ2VzL3R5cGVzJztcbmltcG9ydCB7IE1lc3NhZ2VUeXBlSWQsIHNpZ25NZXNzYWdlIH0gZnJvbSAnLi4vbWVzc2FnZXMvdXRpbHMnO1xuaW1wb3J0IHsgY2hhbm5lbE1vbml0b3IgfSBmcm9tICcuLi9jaGFubmVscy9hY3Rpb25zJztcbmltcG9ydCB7IENoYW5uZWxTdGF0ZSB9IGZyb20gJy4uL2NoYW5uZWxzL3N0YXRlJztcbmltcG9ydCB7IGNoYW5uZWxBbW91bnRzIH0gZnJvbSAnLi4vY2hhbm5lbHMvdXRpbHMnO1xuaW1wb3J0IHsgZGVjb2RlLCBVSW50LCBpc250TmlsIH0gZnJvbSAnLi4vdXRpbHMvdHlwZXMnO1xuaW1wb3J0IHsgaXNBY3Rpb25PZiB9IGZyb20gJy4uL3V0aWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgZW5jb2RlLCBsb3NzbGVzc1BhcnNlLCBsb3NzbGVzc1N0cmluZ2lmeSB9IGZyb20gJy4uL3V0aWxzL2RhdGEnO1xuaW1wb3J0IHsgZ2V0RXZlbnRzU3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvZXRoZXJzJztcbmltcG9ydCB7IFJhaWRlbkVycm9yLCBFcnJvckNvZGVzIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3InO1xuaW1wb3J0IHsgcGx1Y2tEaXN0aW5jdCB9IGZyb20gJy4uL3V0aWxzL3J4JztcbmltcG9ydCB7IENhcGFiaWxpdGllcyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBpb3VDbGVhciwgcGF0aEZpbmQsIGlvdVBlcnNpc3QsIHBmc0xpc3RVcGRhdGVkIH0gZnJvbSAnLi9hY3Rpb25zJztcbmltcG9ydCB7IGNoYW5uZWxDYW5Sb3V0ZSwgcGZzSW5mbywgcGZzTGlzdEluZm8gfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IExhc3RJT1VSZXN1bHRzLCBQYXRoUmVzdWx0cyB9IGZyb20gJy4vdHlwZXMnO1xuY29uc3Qgb25lVG9OQWRkcmVzcyA9IG1lbW9pemUoKHVzZXJEZXBvc2l0Q29udHJhY3QpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gdXNlckRlcG9zaXRDb250cmFjdC5mdW5jdGlvbnMub25lX3RvX25fYWRkcmVzcygpOyB9KSk7XG4vKipcbiAqIENvZGVjIGZvciBQRlMgQVBJIHJldHVybmVkIGVycm9yXG4gKlxuICogTWF5IGNvbnRhaW4gb3RoZXIgZmllbGRzIGxpa2UgZXJyb3JfZGV0YWlscywgYnV0IHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlbSAoZm9yIG5vdylcbiAqL1xuY29uc3QgUGF0aEVycm9yID0gdC5yZWFkb25seSh0LnR5cGUoe1xuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2FtZWxjYXNlICovXG4gICAgZXJyb3JfY29kZTogdC5udW1iZXIsXG4gICAgZXJyb3JzOiB0LnN0cmluZyxcbn0pKTtcbi8vIHJldHVybnMgYSBJU08gc3RyaW5nIHRydW5jYXRlZCBhdCB0aGUgaW50ZWdlciBzZWNvbmQgcmVzb2x1dGlvblxuZnVuY3Rpb24gbWFrZVRpbWVzdGFtcCh0aW1lKSB7XG4gICAgcmV0dXJuICh0aW1lICE9PSBudWxsICYmIHRpbWUgIT09IHZvaWQgMCA/IHRpbWUgOiBuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpLnN1YnN0cigwLCAxOSk7XG59XG5jb25zdCBtYWtlSU9VID0gKHNlbmRlciwgcmVjZWl2ZXIsIGNoYWluSWQsIG9uZVRvTkFkZHJlc3MsIGJsb2NrTnVtYmVyKSA9PiAoe1xuICAgIHNlbmRlcjogc2VuZGVyLFxuICAgIHJlY2VpdmVyOiByZWNlaXZlcixcbiAgICBjaGFpbl9pZDogYmlnTnVtYmVyaWZ5KGNoYWluSWQpLFxuICAgIGFtb3VudDogWmVybyxcbiAgICBvbmVfdG9fbl9hZGRyZXNzOiBvbmVUb05BZGRyZXNzLFxuICAgIGV4cGlyYXRpb25fYmxvY2s6IGJpZ051bWJlcmlmeShibG9ja051bWJlcikuYWRkKDIgKiBNYXRoLnBvdygxMCwgNSkpLFxufSk7XG5jb25zdCB1cGRhdGVJT1UgPSAoaW91LCBwcmljZSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW91KSwgeyBhbW91bnQ6IGlvdS5hbW91bnQuYWRkKHByaWNlKSB9KSk7XG5jb25zdCBwYWNrSU9VID0gKGlvdSkgPT4gY29uY2F0KFtcbiAgICBlbmNvZGUoaW91Lm9uZV90b19uX2FkZHJlc3MsIDIwKSxcbiAgICBlbmNvZGUoaW91LmNoYWluX2lkLCAzMiksXG4gICAgZW5jb2RlKE1lc3NhZ2VUeXBlSWQuSU9VLCAzMiksXG4gICAgZW5jb2RlKGlvdS5zZW5kZXIsIDIwKSxcbiAgICBlbmNvZGUoaW91LnJlY2VpdmVyLCAyMCksXG4gICAgZW5jb2RlKGlvdS5hbW91bnQsIDMyKSxcbiAgICBlbmNvZGUoaW91LmV4cGlyYXRpb25fYmxvY2ssIDMyKSxcbl0pO1xuY29uc3Qgc2lnbklPVSQgPSAoaW91LCBzaWduZXIpID0+IGZyb20oc2lnbmVyLnNpZ25NZXNzYWdlKHBhY2tJT1UoaW91KSkpLnBpcGUobWFwKChzaWduYXR1cmUpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGlvdSksIHsgc2lnbmF0dXJlIH0pKSkpO1xuY29uc3QgbWFrZUFuZFNpZ25MYXN0SU9VUmVxdWVzdCQgPSAoc2VuZGVyLCByZWNlaXZlciwgc2lnbmVyKSA9PiBkZWZlcigoKSA9PiB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gbWFrZVRpbWVzdGFtcCgpLCBtZXNzYWdlID0gY29uY2F0KFtzZW5kZXIsIHJlY2VpdmVyLCB0b1V0ZjhCeXRlcyh0aW1lc3RhbXApXSk7XG4gICAgcmV0dXJuIGZyb20oc2lnbmVyLnNpZ25NZXNzYWdlKG1lc3NhZ2UpKS5waXBlKG1hcCgoc2lnbmF0dXJlKSA9PiAoeyBzZW5kZXIsIHJlY2VpdmVyLCB0aW1lc3RhbXAsIHNpZ25hdHVyZSB9KSkpO1xufSk7XG5jb25zdCBwcmVwYXJlTmV4dElPVSQgPSAocGZzLCB0b2tlbk5ldHdvcmssIHsgYWRkcmVzcywgc2lnbmVyLCBuZXR3b3JrLCB1c2VyRGVwb3NpdENvbnRyYWN0LCBsYXRlc3QkIH0pID0+IHtcbiAgICByZXR1cm4gbGF0ZXN0JC5waXBlKGZpcnN0KCksIHN3aXRjaE1hcCgoeyBzdGF0ZSwgY29uZmlnOiB7IGh0dHBUaW1lb3V0IH0gfSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNhY2hlZElPVSA9IChfYSA9IHN0YXRlLnBhdGguaW91W3Rva2VuTmV0d29ya10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtwZnMuYWRkcmVzc107XG4gICAgICAgIHJldHVybiAoY2FjaGVkSU9VXG4gICAgICAgICAgICA/IG9mKGNhY2hlZElPVSlcbiAgICAgICAgICAgIDogbWFrZUFuZFNpZ25MYXN0SU9VUmVxdWVzdCQoYWRkcmVzcywgcGZzLmFkZHJlc3MsIHNpZ25lcikucGlwZShtZXJnZU1hcCgocGF5bG9hZCkgPT4gZnJvbUZldGNoKGAke3Bmcy51cmx9L2FwaS92MS8ke3Rva2VuTmV0d29ya30vcGF5bWVudC9pb3U/JHtuZXcgVVJMU2VhcmNoUGFyYW1zKHBheWxvYWQpLnRvU3RyaW5nKCl9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgICB9KS5waXBlKHRpbWVvdXQoaHR0cFRpbWVvdXQpKSksIHdpdGhMYXRlc3RGcm9tKGxhdGVzdCQucGlwZShwbHVjaygnc3RhdGUnKSkpLCBtZXJnZU1hcCgoW3Jlc3BvbnNlLCB7IGJsb2NrTnVtYmVyIH1dKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VJT1UoYWRkcmVzcywgcGZzLmFkZHJlc3MsIG5ldHdvcmsuY2hhaW5JZCwgeWllbGQgb25lVG9OQWRkcmVzcyh1c2VyRGVwb3NpdENvbnRyYWN0KSwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0geWllbGQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYWlkZW5FcnJvcihFcnJvckNvZGVzLlBGU19MQVNUX0lPVV9SRVFVRVNUX0ZBSUxFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VTdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsYXN0X2lvdTogbGFzdElvdSB9ID0gZGVjb2RlKExhc3RJT1VSZXN1bHRzLCBsb3NzbGVzc1BhcnNlKHRleHQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduZXIgPSB2ZXJpZnlNZXNzYWdlKHBhY2tJT1UobGFzdElvdSksIGxhc3RJb3Uuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmVyICE9PSBhZGRyZXNzKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFpZGVuRXJyb3IoRXJyb3JDb2Rlcy5QRlNfSU9VX1NJR05BVFVSRV9NSVNNQVRDSCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhc3RJb3U7XG4gICAgICAgICAgICB9KSkpKS5waXBlKG1hcCgoaW91KSA9PiB1cGRhdGVJT1UoaW91LCBwZnMucHJpY2UpKSwgbWVyZ2VNYXAoKGlvdSkgPT4gc2lnbklPVSQoaW91LCBzaWduZXIpKSk7XG4gICAgfSkpO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgYSB0cmFuc2ZlciBjYW4gYmUgbWFkZSBhbmQgcmV0dXJuIGEgc2V0IG9mIHBhdGhzIGZvciBpdC5cbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgcGF0aEZpbmQucmVxdWVzdCBhY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEBwYXJhbSBkZXBzIC0gUmFpZGVuRXBpY0RlcHMgb2JqZWN0XG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIHBhdGhGaW5kLntzdWNjZXNzfGZhaWx1cmV9IGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IHBhdGhGaW5kU2VydmljZUVwaWMgPSAoYWN0aW9uJCwge30sIGRlcHMpID0+IHtcbiAgICBjb25zdCB7IGxvZywgbGF0ZXN0JCB9ID0gZGVwcztcbiAgICByZXR1cm4gYWN0aW9uJC5waXBlKGZpbHRlcihpc0FjdGlvbk9mKHBhdGhGaW5kLnJlcXVlc3QpKSwgY29uY2F0TWFwKChhY3Rpb24pID0+IGxhdGVzdCQucGlwZShmaXJzdCgpLCBtZXJnZU1hcCgoeyBzdGF0ZSwgcHJlc2VuY2VzLCBjb25maWc6IHsgcGZzOiBjb25maWdQZnMsIGh0dHBUaW1lb3V0LCBwZnNTYWZldHlNYXJnaW4gfSB9KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyB0b2tlbk5ldHdvcmssIHRhcmdldCB9ID0gYWN0aW9uLm1ldGE7XG4gICAgICAgIGlmICghKHRva2VuTmV0d29yayBpbiBzdGF0ZS5jaGFubmVscykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFpZGVuRXJyb3IoRXJyb3JDb2Rlcy5QRlNfVU5LTk9XTl9UT0tFTl9ORVRXT1JLLCB7IHRva2VuTmV0d29yayB9KTtcbiAgICAgICAgaWYgKCEodGFyZ2V0IGluIHByZXNlbmNlcykgfHwgIXByZXNlbmNlc1t0YXJnZXRdLnBheWxvYWQuYXZhaWxhYmxlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuUEZTX1RBUkdFVF9PRkZMSU5FLCB7IHRhcmdldCB9KTtcbiAgICAgICAgaWYgKChfYSA9IHByZXNlbmNlc1t0YXJnZXRdLnBheWxvYWQuY2FwcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW0NhcGFiaWxpdGllcy5OT19SRUNFSVZFXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYWlkZW5FcnJvcihFcnJvckNvZGVzLlBGU19UQVJHRVRfTk9fUkVDRUlWRSwgeyB0YXJnZXQgfSk7XG4gICAgICAgIC8vIGlmIHBhdGhGaW5kIHJlY2VpdmVkIGEgc2V0IG9mIHBhdGhzLCBwYXNzIGl0IHRocm91Z2ggdG8gdmFsaWRhdGlvbi9jbGVhbnVwXG4gICAgICAgIGlmIChhY3Rpb24ucGF5bG9hZC5wYXRocylcbiAgICAgICAgICAgIHJldHVybiBvZih7IHBhdGhzOiBhY3Rpb24ucGF5bG9hZC5wYXRocywgaW91OiB1bmRlZmluZWQgfSk7XG4gICAgICAgIC8vIGVsc2UsIGlmIHBvc3NpYmxlLCB1c2UgYSBkaXJlY3QgdHJhbnNmZXJcbiAgICAgICAgZWxzZSBpZiAoY2hhbm5lbENhblJvdXRlKHN0YXRlLCBwcmVzZW5jZXMsIHRva2VuTmV0d29yaywgdGFyZ2V0LCB0YXJnZXQsIGFjdGlvbi5tZXRhLnZhbHVlKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9mKHtcbiAgICAgICAgICAgICAgICBwYXRoczogW3sgcGF0aDogW2RlcHMuYWRkcmVzcywgdGFyZ2V0XSwgZmVlOiBaZXJvIH1dLFxuICAgICAgICAgICAgICAgIGlvdTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uLnBheWxvYWQucGZzID09PSBudWxsIHx8IC8vIGV4cGxpY2l0bHkgZGlzYWJsZWQgaW4gYWN0aW9uXG4gICAgICAgICAgICAoIWFjdGlvbi5wYXlsb2FkLnBmcyAmJiBjb25maWdQZnMgPT09IG51bGwpIC8vIHVuZGVmaW5lZCBpbiBhY3Rpb24gYW5kIGRpc2FibGVkIGluIGNvbmZpZ1xuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIHBmcyBub3Qgc3BlY2lmaWVkIGluIGFjdGlvbiBhbmQgZGlzYWJsZWQgKG51bGwpIGluIGNvbmZpZ1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuUEZTX0RJU0FCTEVEKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsc2UsIHJlcXVlc3QgYSByb3V0ZSBmcm9tIFBGUy5cbiAgICAgICAgICAgIC8vIHBmcyQgLSBPYnNlcnZhYmxlIHdoaWNoIGVtaXRzIG9uZSBQRlMgaW5mbyBhbmQgdGhlbiBjb21wbGV0ZXNcbiAgICAgICAgICAgIGNvbnN0IHBmcyQgPSBhY3Rpb24ucGF5bG9hZC5wZnNcbiAgICAgICAgICAgICAgICA/IC8vIGZpcnN0LCB1c2UgYWN0aW9uLnBheWxvYWQucGZzIGFzIGlzLCBpZiBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgIG9mKGFjdGlvbi5wYXlsb2FkLnBmcylcbiAgICAgICAgICAgICAgICA6IGNvbmZpZ1Bmc1xuICAgICAgICAgICAgICAgICAgICA/IC8vIG9yIGlmIGNvbmZpZy5wZnMgaXNuJ3QgZGlzYWJsZWQgKG51bGwpIG5vciBhdXRvICgnJyksIGZldGNoICYgdXNlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBwZnNJbmZvKGNvbmZpZ1BmcywgZGVwcylcbiAgICAgICAgICAgICAgICAgICAgOiAvLyBlbHNlIChhY3Rpb24gdW5zZXQsIGNvbmZpZy5wZnM9Jyc9YXV0byBtb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXN0JC5waXBlKHBsdWNrKCdwZnNMaXN0JyksIC8vIGdldCBjYWNoZWQgcGZzTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbmVlZGVkLCB3YWl0IGZvciBsaXN0IHRvIGJlIHBvcHVsYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QoKHBmc0xpc3QpID0+IHBmc0xpc3QubGVuZ3RoID4gMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmV0Y2ggcGZzSW5mbyBmcm9tIHdob2xlIGxpc3QgJiBzb3J0IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZU1hcCgocGZzTGlzdCkgPT4gcGZzTGlzdEluZm8ocGZzTGlzdCwgZGVwcykpLCB0YXAoKHBmc3MpID0+IGxvZy5pbmZvKCdBdXRvLXNlbGVjdGluZyBiZXN0IFBGUyBmcm9tOicsIHBmc3MpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3AgYmVzdCByYW5rZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWNrKDApKTtcbiAgICAgICAgICAgIHJldHVybiBwZnMkLnBpcGUobWVyZ2VNYXAoKHBmcykgPT4gcGZzLnByaWNlLmlzWmVybygpXG4gICAgICAgICAgICAgICAgPyBvZih7IHBmcywgaW91OiB1bmRlZmluZWQgfSlcbiAgICAgICAgICAgICAgICA6IHByZXBhcmVOZXh0SU9VJChwZnMsIHRva2VuTmV0d29yaywgZGVwcykucGlwZShtYXAoKGlvdSkgPT4gKHsgcGZzLCBpb3UgfSkpKSksIG1lcmdlTWFwKCh7IHBmcywgaW91IH0pID0+IGZyb21GZXRjaChgJHtwZnMudXJsfS9hcGkvdjEvJHt0b2tlbk5ldHdvcmt9L3BhdGhzYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IGxvc3NsZXNzU3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogZGVwcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICB0bzogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogVUludCgzMikuZW5jb2RlKGFjdGlvbi5tZXRhLnZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4X3BhdGhzOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgaW91OiBpb3VcbiAgICAgICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpb3UpLCB7IGFtb3VudDogVUludCgzMikuZW5jb2RlKGlvdS5hbW91bnQpLCBleHBpcmF0aW9uX2Jsb2NrOiBVSW50KDMyKS5lbmNvZGUoaW91LmV4cGlyYXRpb25fYmxvY2spLCBjaGFpbl9pZDogVUludCgzMikuZW5jb2RlKGlvdS5jaGFpbl9pZCkgfSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KS5waXBlKHRpbWVvdXQoaHR0cFRpbWVvdXQpLCBtYXAoKHJlc3BvbnNlKSA9PiAoeyByZXNwb25zZSwgaW91IH0pKSkpLCBtZXJnZU1hcCgoeyByZXNwb25zZSwgaW91IH0pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogeWllbGQgcmVzcG9uc2UudGV4dCgpLFxuICAgICAgICAgICAgICAgICAgICBpb3UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSksIG1hcCgoeyByZXNwb25zZSwgdGV4dCwgaW91IH0pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBhbnkgZGVjb2RlIGVycm9yIGhlcmUgd2lsbCB0aHJvdyBlYXJseSBhbmQgZW5kIHVwIGluIGNhdGNoRXJyb3JcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbG9zc2xlc3NQYXJzZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBkZWNvZGUoUGF0aEVycm9yLCBkYXRhKSwgaW91IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhzOiBkZWNvZGUoUGF0aFJlc3VsdHMsIGRhdGEpLnJlc3VsdC5tYXAoKHIpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiByLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgUEZTIHNhZmV0eSBtYXJnaW4gdG8gZXN0aW1hdGVkIGZlZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlZTogci5lc3RpbWF0ZWRfZmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm11bChNYXRoLnJvdW5kKHBmc1NhZmV0eU1hcmdpbiAqIDFlNikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRpdigxZTYpLFxuICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgICAgIGlvdSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSksIHdpdGhMYXRlc3RGcm9tKGxhdGVzdCQpLCBcbiAgICAvLyB2YWxpZGF0ZS9jbGVhbnVwIHJlY2VpdmVkIHJvdXRlcy9wYXRocy9yZXN1bHRzXG4gICAgbWVyZ2VNYXAoKFtkYXRhLCB7IHN0YXRlLCBwcmVzZW5jZXMgfV0pID0+IFxuICAgIC8vIGxvb2tzIGxpa2UgbWVyZ2VNYXAgd2l0aCBnZW5lcmF0b3IgZG9lc24ndCBoYW5kbGUgZXhjZXB0aW9ucyBjb3JyZWN0bHlcbiAgICAvLyB1c2UgZnJvbStpdGVyYXRvciBmcm9tIGlpZmUgZ2VuZXJhdG9yIGluc3RlYWRcbiAgICBmcm9tKChmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCB7IGlvdSB9ID0gZGF0YTtcbiAgICAgICAgaWYgKGlvdSkge1xuICAgICAgICAgICAgLy8gaWYgbm90IGVycm9yIG9yIGVycm9yX2NvZGUgb2YgXCJubyByb3V0ZSBmb3VuZFwiLCBpb3UgYWNjZXB0ZWQgPT4gcGVyc2lzdFxuICAgICAgICAgICAgaWYgKGRhdGEucGF0aHMgfHwgZGF0YS5lcnJvci5lcnJvcl9jb2RlID09PSAyMjAxKVxuICAgICAgICAgICAgICAgIHlpZWxkIGlvdVBlcnNpc3QoeyBpb3UgfSwgeyB0b2tlbk5ldHdvcms6IGFjdGlvbi5tZXRhLnRva2VuTmV0d29yaywgc2VydmljZUFkZHJlc3M6IGlvdS5yZWNlaXZlciB9KTtcbiAgICAgICAgICAgIC8vIGVsc2UgKGVycm9yIGFuZCBlcnJvcl9jb2RlIG9mIFwiaW91IHJlamVjdGVkXCIpLCBjbGVhclxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHlpZWxkIGlvdUNsZWFyKHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbk5ldHdvcms6IGFjdGlvbi5tZXRhLnRva2VuTmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgc2VydmljZUFkZHJlc3M6IGlvdS5yZWNlaXZlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBlcnJvciwgZG9uJ3QgcHJvY2VlZFxuICAgICAgICBpZiAoIWRhdGEucGF0aHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYWlkZW5FcnJvcihFcnJvckNvZGVzLlBGU19FUlJPUl9SRVNQT05TRSwge1xuICAgICAgICAgICAgICAgIGVycm9yQ29kZTogZGF0YS5lcnJvci5lcnJvcl9jb2RlLFxuICAgICAgICAgICAgICAgIGVycm9yczogZGF0YS5lcnJvci5lcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJlZFBhdGhzID0gW10sIGludmFsaWRhdGVkUmVjaXBpZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICBmb3IgKGxldCB7IHBhdGgsIGZlZSB9IG9mIGRhdGEucGF0aHMpIHtcbiAgICAgICAgICAgIC8vIGlmIHJvdXRlIGhhcyB1cyBhcyBmaXJzdCBob3AsIGNsZWFudXAvc2hpZnRcbiAgICAgICAgICAgIGlmIChwYXRoWzBdID09PSBkZXBzLmFkZHJlc3MpXG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMSk7XG4gICAgICAgICAgICBjb25zdCByZWNpcGllbnQgPSBwYXRoWzBdO1xuICAgICAgICAgICAgLy8gaWYgdGhpcyByZWNpcGllbnQgd2FzIGFscmVhZHkgaW52YWxpZGF0ZWQgaW4gYSBwcmV2aW91cyBpdGVyYXRpb24sIHNraXBcbiAgICAgICAgICAgIGlmIChpbnZhbGlkYXRlZFJlY2lwaWVudHMuaGFzKHJlY2lwaWVudCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGZvdW5kIHNvbWUgdmFsaWQgcm91dGUsIGFsbG93IG9ubHkgbmV3IHJvdXRlcyB0aHJvdWdoIHRoaXMgcGVlclxuICAgICAgICAgICAgY29uc3QgY2FuVHJhbnNmZXJPclJlYXNvbiA9ICFmaWx0ZXJlZFBhdGhzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8gY2hhbm5lbENhblJvdXRlKHN0YXRlLCBwcmVzZW5jZXMsIGFjdGlvbi5tZXRhLnRva2VuTmV0d29yaywgcmVjaXBpZW50LCBhY3Rpb24ubWV0YS50YXJnZXQsIGFjdGlvbi5tZXRhLnZhbHVlLmFkZChmZWUpKVxuICAgICAgICAgICAgICAgIDogcmVjaXBpZW50ICE9PSBmaWx0ZXJlZFBhdGhzWzBdLnBhdGhbMF1cbiAgICAgICAgICAgICAgICAgICAgPyAncGF0aDogYWxyZWFkeSBzZWxlY3RlZCBhbm90aGVyIHJlY2lwaWVudCdcbiAgICAgICAgICAgICAgICAgICAgOiBmZWUuZ3QoZmlsdGVyZWRQYXRoc1swXS5mZWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdwYXRoOiBhbHJlYWR5IHNlbGVjdGVkIGEgc21hbGxlciBmZWUnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRydWU7XG4gICAgICAgICAgICBpZiAoY2FuVHJhbnNmZXJPclJlYXNvbiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKCdJbnZhbGlkYXRlZCByZWNlaXZlZCByb3V0ZS4gUmVhc29uOicsIGNhblRyYW5zZmVyT3JSZWFzb24sICdSb3V0ZTonLCBwYXRoKTtcbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlZFJlY2lwaWVudHMuYWRkKHJlY2lwaWVudCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXJlZFBhdGhzLnB1c2goeyBwYXRoLCBmZWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaWx0ZXJlZFBhdGhzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYWlkZW5FcnJvcihFcnJvckNvZGVzLlBGU19OT19ST1VURVNfRk9VTkQpO1xuICAgICAgICB5aWVsZCBwYXRoRmluZC5zdWNjZXNzKHsgcGF0aHM6IGZpbHRlcmVkUGF0aHMgfSwgYWN0aW9uLm1ldGEpO1xuICAgIH0pKCkpKSwgY2F0Y2hFcnJvcigoZXJyKSA9PiBvZihwYXRoRmluZC5mYWlsdXJlKGVyciwgYWN0aW9uLm1ldGEpKSkpKSk7XG59O1xuZnVuY3Rpb24gY2hhbm5lbEVudHJpZXMoY2hhbm5lbHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoY2hhbm5lbHMpXG4gICAgICAgIC5tYXAoKFt0b2tlbk5ldHdvcmssIHBhcnRuZXJDaGFubmVsc10pID0+IE9iamVjdC5lbnRyaWVzKHBhcnRuZXJDaGFubmVscykubWFwKChbcGFydG5lciwgY2hhbm5lbF0pID0+IFtgJHtwYXJ0bmVyfUAke3Rva2VuTmV0d29ya31gLCBjaGFubmVsXSkpXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgdmFsKSA9PiBbLi4uYWNjLCAuLi52YWxdLCBbXSk7XG59XG5mdW5jdGlvbiBrZXlUb1ROUChrZXkpIHtcbiAgICBjb25zdCBbcGFydG5lciwgdG9rZW5OZXR3b3JrXSA9IGtleS5zcGxpdCgnQCcpO1xuICAgIHJldHVybiB7IGtleSwgdG9rZW5OZXR3b3JrOiB0b2tlbk5ldHdvcmssIHBhcnRuZXJBZGRyOiBwYXJ0bmVyIH07XG59XG4vKipcbiAqIFNlbmRzIGEgW1tQRlNDYXBhY2l0eVVwZGF0ZV1dIHRvIFBGUyBnbG9iYWwgcm9vbSBvbiBuZXcgZGVwb3NpdCBvbiBvdXIgc2lkZSBvZiBjaGFubmVsc1xuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBjaGFubmVsRGVwb3NpdC5zdWNjZXNzIGFjdGlvbnNcbiAqIEBwYXJhbSBzdGF0ZSQgLSBPYnNlcnZhYmxlIG9mIFJhaWRlblN0YXRlc1xuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBtZXNzYWdlR2xvYmFsU2VuZCBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBwZnNDYXBhY2l0eVVwZGF0ZUVwaWMgPSAoe30sIHt9LCB7IGxvZywgYWRkcmVzcywgbmV0d29yaywgc2lnbmVyLCBjb25maWckLCBsYXRlc3QkIH0pID0+IGxhdGVzdCQucGlwZShwbHVja0Rpc3RpbmN0KCdzdGF0ZScsICdjaGFubmVscycpLCBjb25jYXRNYXAoKGNoYW5uZWxzKSA9PiBmcm9tKGNoYW5uZWxFbnRyaWVzKGNoYW5uZWxzKSkpLCBcbi8qIHRoaXMgc2NhbiBzdG9yZXMgYSByZWZlcmVuY2UgdG8gZWFjaCBba2V5LHZhbHVlXSBpbiAnYWNjJywgYW5kIGVtaXQgYXMgJ2NoYW5nZWQnIGlmZiBpdFxuICogY2hhbmdlcyBmcm9tIGxhc3QgdGltZSBzZWVuLiBJdCByZWxpZXMgb24gdmFsdWUgcmVmZXJlbmNlcyBjaGFuZ2luZyBvbmx5IGlmIG5lZWRlZCAqL1xuc2NhbigoeyBhY2MgfSwgW2tleSwgY2hhbm5lbF0pID0+IFxuLy8gaWYgcmVmIGRpZG4ndCBjaGFuZ2UsIGVtaXQgcHJldmlvdXMgYWNjdW11bGF0b3IsIHdpdGhvdXQgJ2NoYW5nZWQnIHZhbHVlXG5hY2Nba2V5XSA9PT0gY2hhbm5lbFxuICAgID8geyBhY2MgfVxuICAgIDogLy8gZWxzZSwgdXBkYXRlIHJlZiBpbiAnYWNjJyBhbmQgZW1pdCB2YWx1ZSBpbiAnY2hhbmdlZCcgcHJvcFxuICAgICAgICB7XG4gICAgICAgICAgICBhY2M6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjKSwgeyBba2V5XTogY2hhbm5lbCB9KSxcbiAgICAgICAgICAgIGNoYW5nZWQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2hhbm5lbCksIGtleVRvVE5QKGtleSkpLFxuICAgICAgICB9LCB7IGFjYzoge30gfSksIHBsdWNrKCdjaGFuZ2VkJyksIGZpbHRlcihpc250TmlsKSwgLy8gZmlsdGVyIG91dCBpZiByZWZlcmVuY2UgZGlkbid0IGNoYW5nZSBmcm9tIGxhc3QgZW1pdFxuZ3JvdXBCeSgoeyBrZXkgfSkgPT4ga2V5KSwgd2l0aExhdGVzdEZyb20oY29uZmlnJCksIG1lcmdlTWFwKChbZ3JvdXBlZCQsIHsgaHR0cFRpbWVvdXQgfV0pID0+IGdyb3VwZWQkLnBpcGUod2l0aExhdGVzdEZyb20oY29uZmlnJCksIGZpbHRlcigoWywgeyBwZnNSb29tIH1dKSA9PiAhIXBmc1Jvb20pLCAvLyBpZ25vcmUgYWN0aW9ucyB3aGlsZS9pZiBjb25maWcucGZzUm9vbSBpc24ndCBzZXRcbmRlYm91bmNlVGltZShodHRwVGltZW91dCAvIDIpLCAvLyBkZWZhdWx0OiAxNXNcbmNvbmNhdE1hcCgoW2NoYW5uZWwsIHsgcmV2ZWFsVGltZW91dCwgcGZzUm9vbSB9XSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCB7IHRva2VuTmV0d29yaywgcGFydG5lckFkZHI6IHBhcnRuZXIgfSA9IGNoYW5uZWw7XG4gICAgaWYgKGNoYW5uZWwuc3RhdGUgIT09IENoYW5uZWxTdGF0ZS5vcGVuKVxuICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgY29uc3QgeyBvd25DYXBhY2l0eSwgcGFydG5lckNhcGFjaXR5IH0gPSBjaGFubmVsQW1vdW50cyhjaGFubmVsKTtcbiAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5QRlNfQ0FQQUNJVFlfVVBEQVRFLFxuICAgICAgICBjYW5vbmljYWxfaWRlbnRpZmllcjoge1xuICAgICAgICAgICAgY2hhaW5faWRlbnRpZmllcjogYmlnTnVtYmVyaWZ5KG5ldHdvcmsuY2hhaW5JZCksXG4gICAgICAgICAgICB0b2tlbl9uZXR3b3JrX2FkZHJlc3M6IHRva2VuTmV0d29yayxcbiAgICAgICAgICAgIGNoYW5uZWxfaWRlbnRpZmllcjogYmlnTnVtYmVyaWZ5KGNoYW5uZWwuaWQpLFxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGluZ19wYXJ0aWNpcGFudDogYWRkcmVzcyxcbiAgICAgICAgb3RoZXJfcGFydGljaXBhbnQ6IHBhcnRuZXIsXG4gICAgICAgIHVwZGF0aW5nX25vbmNlOiAoX2IgPSAoX2EgPSBjaGFubmVsLm93bi5iYWxhbmNlUHJvb2YpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub25jZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogWmVybyxcbiAgICAgICAgb3RoZXJfbm9uY2U6IChfZCA9IChfYyA9IGNoYW5uZWwucGFydG5lci5iYWxhbmNlUHJvb2YpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5ub25jZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogWmVybyxcbiAgICAgICAgdXBkYXRpbmdfY2FwYWNpdHk6IG93bkNhcGFjaXR5LFxuICAgICAgICBvdGhlcl9jYXBhY2l0eTogcGFydG5lckNhcGFjaXR5LFxuICAgICAgICByZXZlYWxfdGltZW91dDogYmlnTnVtYmVyaWZ5KHJldmVhbFRpbWVvdXQpLFxuICAgIH07XG4gICAgcmV0dXJuIGRlZmVyKCgpID0+IHNpZ25NZXNzYWdlKHNpZ25lciwgbWVzc2FnZSwgeyBsb2cgfSkpLnBpcGUobWFwKChzaWduZWQpID0+IG1lc3NhZ2VHbG9iYWxTZW5kKHsgbWVzc2FnZTogc2lnbmVkIH0sIHsgcm9vbU5hbWU6IHBmc1Jvb20gfSkpLCBjYXRjaEVycm9yKChlcnIpID0+IHtcbiAgICAgICAgbG9nLmVycm9yKCdFcnJvciB0cnlpbmcgdG8gZ2VuZXJhdGUgJiBzaWduIFBGU0NhcGFjaXR5VXBkYXRlJywgZXJyKTtcbiAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIH0pKTtcbn0pKSkpO1xuLyoqXG4gKiBXaGVuIG1vbml0b3JpbmcgYSBjaGFubmVsIChlaXRoZXIgYSBuZXcgY2hhbm5lbCBvciBhIHByZXZpb3VzbHkgbW9uaXRvcmVkIG9uZSksIHNlbmQgYSBtYXRjaGluZ1xuICogUEZTRmVlVXBkYXRlIHRvIHBhdGhfZmluZGluZyBnbG9iYWwgcm9vbSwgc28gUEZTcyBjYW4gcGljayB1cyBmb3IgbWVkaWF0aW9uXG4gKiBUT0RPOiBDdXJyZW50bHksIHdlIGFsd2F5cyBzZW5kIFplcm8gZmVlczsgd2Ugc2hvdWxkIHNlbmQgY29ycmVjdCBmZWUgZGF0YSBmcm9tIGNvbmZpZ1xuICpcbiAqIEBwYXJhbSBhY3Rpb24kIC0gT2JzZXJ2YWJsZSBvZiBjaGFubmVsTW9uaXRvciBhY3Rpb25zXG4gKiBAcGFyYW0gc3RhdGUkIC0gT2JzZXJ2YWJsZSBvZiBSYWlkZW5TdGF0ZXNcbiAqIEBwYXJhbSBkZXBzIC0gUmFpZGVuIGVwaWMgZGVwZW5kZW5jaWVzXG4gKiBAcmV0dXJucyBPYnNlcnZhYmxlIG9mIG1lc3NhZ2VHbG9iYWxTZW5kIGFjdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IHBmc0ZlZVVwZGF0ZUVwaWMgPSAoYWN0aW9uJCwgc3RhdGUkLCB7IGxvZywgYWRkcmVzcywgbmV0d29yaywgc2lnbmVyLCBjb25maWckIH0pID0+IGFjdGlvbiQucGlwZShmaWx0ZXIoY2hhbm5lbE1vbml0b3IuaXMpLCB3aXRoTGF0ZXN0RnJvbShzdGF0ZSQsIGNvbmZpZyQpLCBcbi8vIGlnbm9yZSBhY3Rpb25zIHdoaWxlL2lmIG1lZGlhdGluZyBub3QgZW5hYmxlZFxuZmlsdGVyKChbLCAsIHsgcGZzUm9vbSwgY2FwcyB9XSkgPT4gISFwZnNSb29tICYmICEoY2FwcyA9PT0gbnVsbCB8fCBjYXBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXBzW0NhcGFiaWxpdGllcy5OT19NRURJQVRFXSkpLCBtZXJnZU1hcCgoW2FjdGlvbiwgc3RhdGUsIHsgcGZzUm9vbSB9XSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjaGFubmVsID0gKF9hID0gc3RhdGUuY2hhbm5lbHNbYWN0aW9uLm1ldGEudG9rZW5OZXR3b3JrXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2FjdGlvbi5tZXRhLnBhcnRuZXJdO1xuICAgIGlmICgoY2hhbm5lbCA9PT0gbnVsbCB8fCBjaGFubmVsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGFubmVsLnN0YXRlKSAhPT0gQ2hhbm5lbFN0YXRlLm9wZW4pXG4gICAgICAgIHJldHVybiBFTVBUWTtcbiAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5QRlNfRkVFX1VQREFURSxcbiAgICAgICAgY2Fub25pY2FsX2lkZW50aWZpZXI6IHtcbiAgICAgICAgICAgIGNoYWluX2lkZW50aWZpZXI6IGJpZ051bWJlcmlmeShuZXR3b3JrLmNoYWluSWQpLFxuICAgICAgICAgICAgdG9rZW5fbmV0d29ya19hZGRyZXNzOiBhY3Rpb24ubWV0YS50b2tlbk5ldHdvcmssXG4gICAgICAgICAgICBjaGFubmVsX2lkZW50aWZpZXI6IGJpZ051bWJlcmlmeShjaGFubmVsLmlkKSxcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRpbmdfcGFydGljaXBhbnQ6IGFkZHJlc3MsXG4gICAgICAgIHRpbWVzdGFtcDogbWFrZVRpbWVzdGFtcCgpLFxuICAgICAgICBmZWVfc2NoZWR1bGU6IHtcbiAgICAgICAgICAgIGNhcF9mZWVzOiB0cnVlLFxuICAgICAgICAgICAgaW1iYWxhbmNlX3BlbmFsdHk6IG51bGwsXG4gICAgICAgICAgICBwcm9wb3J0aW9uYWw6IFplcm8sXG4gICAgICAgICAgICBmbGF0OiBaZXJvLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIGZyb20oc2lnbk1lc3NhZ2Uoc2lnbmVyLCBtZXNzYWdlLCB7IGxvZyB9KSkucGlwZShtYXAoKHNpZ25lZCkgPT4gbWVzc2FnZUdsb2JhbFNlbmQoeyBtZXNzYWdlOiBzaWduZWQgfSwgeyByb29tTmFtZTogcGZzUm9vbSB9KSksIGNhdGNoRXJyb3IoKGVycikgPT4ge1xuICAgICAgICBsb2cuZXJyb3IoJ0Vycm9yIHRyeWluZyB0byBnZW5lcmF0ZSAmIHNpZ24gUEZTRmVlVXBkYXRlJywgZXJyKTtcbiAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgIH0pKTtcbn0pKTtcbi8qKlxuICogRmV0Y2ggJiBtb25pdG9ycyBTZXJ2aWNlUmVnaXN0cnkncyBSZWdpc3RlcmVkU2VydmljZSBldmVudHMsIGtlZXAgdHJhY2sgb2YgdmFsaWRfdGlsbCBleHBpcmF0aW9uXG4gKiBhbmQgYWdncmVnYXRlIGxpc3Qgb2YgdmFsaWQgc2VydmljZSBhZGRyZXNzZXNcbiAqXG4gKiBOb3RpY2UgdGhpcyBlcGljIG9ubHkgZGVhbHMgd2l0aCB0aGUgZXZlbnRzICYgYWRkcmVzc2VzLCBhbmQgZG9uJ3QgZmV0Y2ggVVJMcywgd2hpY2ggbmVlZCB0byBiZVxuICogZmV0Y2hlZCBvbi1kZW1hbmQgdGhyb3VnaCBbW3Bmc0luZm9dXSAmIFtbcGZzTGlzdEluZm9dXS5cbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuQWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcGFyYW0gZGVwcyAtIFJhaWRlbkVwaWNEZXBzIG9iamVjdFxuICogQHJldHVybnMgT2JzZXJ2YWJsZSBvZiBwZnNMaXN0VXBkYXRlZCBhY3Rpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBwZnNTZXJ2aWNlUmVnaXN0cnlNb25pdG9yRXBpYyA9ICh7fSwge30sIHsgc2VydmljZVJlZ2lzdHJ5Q29udHJhY3QsIGNvbnRyYWN0c0luZm8sIGNvbmZpZyQgfSkgPT4gY29uZmlnJC5waXBlKFxuLy8gbW9uaXRvcnMgY29uZmlnLnBmcywgYW5kIG9ubHkgbW9uaXRvcnMgY29udHJhY3QgaWYgaXQncyBlbXB0eVxucGx1Y2tEaXN0aW5jdCgncGZzJyksIHN3aXRjaE1hcCgocGZzKSA9PiBwZnMgIT09ICcnXG4gICAgPyAvLyBkaXNhYmxlIFNlcnZpY2VSZWdpc3RyeSBtb25pdG9yaW5nIGlmL3doaWxlIHBmcyBpcyBudWxsPWRpc2FibGVkIG9yIHRydXR5XG4gICAgICAgIEVNUFRZXG4gICAgOiAvLyB0eXBlIG9mIGVsZW1lbnRzIGVtaXR0ZWQgYnkgZ2V0RXZlbnRzU3RyZWFtIChwYXN0IGFuZCBuZXcgZXZlbnRzIGNvbWluZyBmcm9tIGNvbnRyYWN0KTpcbiAgICAgICAgLy8gW3NlcnZpY2UsIHZhbGlkX3RpbGwsIGRlcG9zaXRfYW1vdW50LCBkZXBvc2l0X2NvbnRyYWN0LCBFdmVudF1cbiAgICAgICAgZ2V0RXZlbnRzU3RyZWFtKHNlcnZpY2VSZWdpc3RyeUNvbnRyYWN0LCBbc2VydmljZVJlZ2lzdHJ5Q29udHJhY3QuZmlsdGVycy5SZWdpc3RlcmVkU2VydmljZShudWxsLCBudWxsLCBudWxsLCBudWxsKV0sIG9mKGNvbnRyYWN0c0luZm8uU2VydmljZVJlZ2lzdHJ5LmJsb2NrX251bWJlcikpLnBpcGUoZ3JvdXBCeSgoW3NlcnZpY2VdKSA9PiBzZXJ2aWNlKSwgbWVyZ2VNYXAoKGdyb3VwZWQkKSA9PiBncm91cGVkJC5waXBlKFxuICAgICAgICAvLyBzd2l0Y2hNYXAgZW5zdXJlcyBuZXcgZXZlbnRzIGZvciBlYWNoIHNlcnZlciAoZ3JvdXBlZCQpIHBpY2tzIGxhdGVzdCBldmVudFxuICAgICAgICBzd2l0Y2hNYXAoKFtzZXJ2aWNlLCB2YWxpZF90aWxsXSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKSwgdmFsaWRUaWxsID0gdmFsaWRfdGlsbC5tdWwoMTAwMCk7IC8vIG1pbGxpc2Vjb25kcyB2YWxpZF90aWxsXG4gICAgICAgICAgICBpZiAodmFsaWRUaWxsLmx0KG5vdykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZOyAvLyB0aGlzIGV2ZW50IGFscmVhZHkgZXhwaXJlZFxuICAgICAgICAgICAgLy8gZW5kJCB3aWxsIGVtaXQgdmFsaWQ9ZmFsc2UgaWZmIDwyXjMxIG1zIGluIHRoZSBmdXR1cmUgKHNldFRpbWVvdXQgbGltaXQpXG4gICAgICAgICAgICBjb25zdCBlbmQkID0gdmFsaWRUaWxsLnN1Yihub3cpLmx0KFR3by5wb3coMzEpKVxuICAgICAgICAgICAgICAgID8gb2YoeyBzZXJ2aWNlLCB2YWxpZDogZmFsc2UgfSkucGlwZShkZWxheShuZXcgRGF0ZSh2YWxpZFRpbGwudG9OdW1iZXIoKSkpKVxuICAgICAgICAgICAgICAgIDogRU1QVFk7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2Uob2YoeyBzZXJ2aWNlLCB2YWxpZDogdHJ1ZSB9KSwgZW5kJCk7XG4gICAgICAgIH0pKSksIHNjYW4oKGFjYywgeyBzZXJ2aWNlLCB2YWxpZCB9KSA9PiAhdmFsaWQgJiYgYWNjLmluY2x1ZGVzKHNlcnZpY2UpXG4gICAgICAgICAgICA/IGFjYy5maWx0ZXIoKHMpID0+IHMgIT09IHNlcnZpY2UpXG4gICAgICAgICAgICA6IHZhbGlkICYmICFhY2MuaW5jbHVkZXMoc2VydmljZSlcbiAgICAgICAgICAgICAgICA/IFsuLi5hY2MsIHNlcnZpY2VdXG4gICAgICAgICAgICAgICAgOiBhY2MsIFtdKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgZGVib3VuY2VUaW1lKDFlMyksIC8vIGRlYm91bmNlIGJ1cnN0IG9mIHVwZGF0ZXMgb24gaW5pdGlhbCBmZXRjaFxuICAgICAgICBtYXAoKHBmc0xpc3QpID0+IHBmc0xpc3RVcGRhdGVkKHsgcGZzTGlzdCB9KSkpKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcGljcy5qcy5tYXAiLCJpbXBvcnQgeyBmcm9tLCBvZiwgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciwgZmlsdGVyLCBtZXJnZU1hcCwgdGFrZVdoaWxlLCB0YWtlVW50aWwsIHBsdWNrLCBzdGFydFdpdGgsIG1hcCwgc2NhbiwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgbmVnYXRlIGZyb20gJ2xvZGFzaC9uZWdhdGUnO1xuaW1wb3J0IHVuc2V0IGZyb20gJ2xvZGFzaC9mcC91bnNldCc7XG5pbXBvcnQgeyByYWlkZW5TaHV0ZG93biB9IGZyb20gJy4vYWN0aW9ucyc7XG5pbXBvcnQgeyBwbHVja0Rpc3RpbmN0IH0gZnJvbSAnLi91dGlscy9yeCc7XG5pbXBvcnQgeyBnZXRQcmVzZW5jZXMkIH0gZnJvbSAnLi90cmFuc3BvcnQvdXRpbHMnO1xuaW1wb3J0IHsgcnRjQ2hhbm5lbCB9IGZyb20gJy4vdHJhbnNwb3J0L2FjdGlvbnMnO1xuaW1wb3J0IHsgcGZzTGlzdFVwZGF0ZWQgfSBmcm9tICcuL3BhdGgvYWN0aW9ucyc7XG5pbXBvcnQgeyBpc0FjdGlvbk9mIH0gZnJvbSAnLi91dGlscy9hY3Rpb25zJztcbmltcG9ydCAqIGFzIENoYW5uZWxzRXBpY3MgZnJvbSAnLi9jaGFubmVscy9lcGljcyc7XG5pbXBvcnQgKiBhcyBUcmFuc3BvcnRFcGljcyBmcm9tICcuL3RyYW5zcG9ydC9lcGljcyc7XG5pbXBvcnQgKiBhcyBUcmFuc2ZlcnNFcGljcyBmcm9tICcuL3RyYW5zZmVycy9lcGljcyc7XG5pbXBvcnQgKiBhcyBQYXRoRmluZEVwaWNzIGZyb20gJy4vcGF0aC9lcGljcyc7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gbWFwcyBjYWNoZWQvbGF0ZXN0IHJlbGV2YW50IHZhbHVlcyBmcm9tIGFjdGlvbiQgJiBzdGF0ZSRcbiAqXG4gKiBAcGFyYW0gYWN0aW9uJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuQWN0aW9uc1xuICogQHBhcmFtIHN0YXRlJCAtIE9ic2VydmFibGUgb2YgUmFpZGVuU3RhdGVzXG4gKiBAcmV0dXJucyBsYXRlc3QkIG9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExhdGVzdCQoYWN0aW9uJCwgc3RhdGUkLCB7IGRlZmF1bHRDb25maWcgfSkge1xuICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KFtcbiAgICAgICAgYWN0aW9uJCxcbiAgICAgICAgc3RhdGUkLFxuICAgICAgICBzdGF0ZSQucGlwZShwbHVja0Rpc3RpbmN0KCdjb25maWcnKSwgbWFwKChjKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q29uZmlnKSwgYykpKSksXG4gICAgICAgIGdldFByZXNlbmNlcyQoYWN0aW9uJCksXG4gICAgICAgIGFjdGlvbiQucGlwZShmaWx0ZXIoaXNBY3Rpb25PZihwZnNMaXN0VXBkYXRlZCkpLCBwbHVjaygncGF5bG9hZCcsICdwZnNMaXN0JyksIHN0YXJ0V2l0aChbXSkpLFxuICAgICAgICBhY3Rpb24kLnBpcGUoZmlsdGVyKHJ0Y0NoYW5uZWwuaXMpLCBcbiAgICAgICAgLy8gc2NhbjogaWYgdi5wYXlsb2FkIGlzIGRlZmluZWQsIHNldCBpdDsgZWxzZSwgdW5zZXRcbiAgICAgICAgc2NhbigoYWNjLCB2KSA9PiB2LnBheWxvYWQgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW3YubWV0YS5hZGRyZXNzXTogdi5wYXlsb2FkIH0pIDogdW5zZXQodi5tZXRhLmFkZHJlc3MsIGFjYyksIHt9KSwgc3RhcnRXaXRoKHt9KSksXG4gICAgXSkucGlwZShtYXAoKFthY3Rpb24sIHN0YXRlLCBjb25maWcsIHByZXNlbmNlcywgcGZzTGlzdCwgcnRjXSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICBwcmVzZW5jZXMsXG4gICAgICAgICAgICBwZnNMaXN0LFxuICAgICAgICAgICAgcnRjLFxuICAgICAgICB9O1xuICAgIH0pKTtcbn1cbmNvbnN0IFJhaWRlbkVwaWNzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQ2hhbm5lbHNFcGljcyksIFRyYW5zcG9ydEVwaWNzKSwgVHJhbnNmZXJzRXBpY3MpLCBQYXRoRmluZEVwaWNzKTtcbmV4cG9ydCBjb25zdCByYWlkZW5Sb290RXBpYyA9IChhY3Rpb24kLCBzdGF0ZSQsIGRlcHMpID0+IHtcbiAgICAvLyBvYnNlcnZhYmxlIHdoaWNoIGVtaXRzIG9uY2Ugd2hlbiBhIHJhaWRlblNodXRkb3duIGFjdGlvbiBnb2VzIHRocm91Z2ggYWN0aW9ucyBwaXBlbGluZVxuICAgIGNvbnN0IHNodXRkb3duTm90aWZpY2F0aW9uID0gYWN0aW9uJC5waXBlKGZpbHRlcihpc0FjdGlvbk9mKHJhaWRlblNodXRkb3duKSkpLCBcbiAgICAvLyBhY3Rpb25zIHBpcGVsaW5lLCBidXQgZW5kcyB3aXRoIChpbmNsdWRpbmcpIGEgcmFpZGVuU2h1dGRvd24gYWN0aW9uXG4gICAgbGltaXRlZEFjdGlvbiQgPSBhY3Rpb24kLnBpcGUodGFrZVdoaWxlKG5lZ2F0ZShpc0FjdGlvbk9mKHJhaWRlblNodXRkb3duKSksIHRydWUpKSwgXG4gICAgLy8gc3RhdGVzIHBpcGVsaW5lLCBidXQgZW5kcyB3aGVuIHNodXRkb3duTm90aWZpY2F0aW9uIGVtaXRzXG4gICAgbGltaXRlZFN0YXRlJCA9IHN0YXRlJC5waXBlKHRha2VVbnRpbChzaHV0ZG93bk5vdGlmaWNhdGlvbikpO1xuICAgIC8vIHdpcmUgZGVwcy5sYXRlc3QkXG4gICAgZ2V0TGF0ZXN0JChsaW1pdGVkQWN0aW9uJCwgbGltaXRlZFN0YXRlJCwgZGVwcykuc3Vic2NyaWJlKGRlcHMubGF0ZXN0JCk7XG4gICAgLy8gbGlrZSBjb21iaW5lRXBpY3MsIGJ1dCBjb21wbGV0ZXMgYWN0aW9uJCwgc3RhdGUkICYgb3V0cHV0JCB3aGVuIGEgcmFpZGVuU2h1dGRvd24gZ29lcyB0aHJvdWdoXG4gICAgcmV0dXJuIGZyb20oT2JqZWN0LnZhbHVlcyhSYWlkZW5FcGljcykpLnBpcGUobWVyZ2VNYXAoKGVwaWMpID0+IGVwaWMobGltaXRlZEFjdGlvbiQsIGxpbWl0ZWRTdGF0ZSQsIGRlcHMpKSwgY2F0Y2hFcnJvcigoZXJyKSA9PiBvZihyYWlkZW5TaHV0ZG93bih7IHJlYXNvbjogZXJyIH0pKSksIHRha2VVbnRpbChzaHV0ZG93bk5vdGlmaWNhdGlvbikpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVwaWNzLmpzLm1hcCIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0ICcuL3BvbHlmaWxscyc7XG5pbXBvcnQgeyBXZWIzUHJvdmlkZXIsIEpzb25ScGNQcm92aWRlciB9IGZyb20gJ2V0aGVycy9wcm92aWRlcnMnO1xuaW1wb3J0IHsgYmlnTnVtYmVyaWZ5IH0gZnJvbSAnZXRoZXJzL3V0aWxzJztcbmltcG9ydCB7IFplcm8sIEFkZHJlc3NaZXJvIH0gZnJvbSAnZXRoZXJzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBhcHBseU1pZGRsZXdhcmUsIGNyZWF0ZVN0b3JlIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgY3JlYXRlRXBpY01pZGRsZXdhcmUgfSBmcm9tICdyZWR1eC1vYnNlcnZhYmxlJztcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciB9IGZyb20gJ3JlZHV4LWxvZ2dlcic7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSAnbG9kYXNoL2NvbnN0YW50JztcbmltcG9ydCBtZW1vaXplIGZyb20gJ2xvZGFzaC9tZW1vaXplJztcbmltcG9ydCB7IEFzeW5jU3ViamVjdCwgbWVyZ2UsIGRlZmVyLCBFTVBUWSwgUmVwbGF5U3ViamVjdCwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpcnN0LCBmaWx0ZXIsIG1hcCwgbWVyZ2VNYXAsIHNraXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgbG9nZ2luZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgeyBUb2tlbk5ldHdvcmtSZWdpc3RyeUZhY3RvcnkgfSBmcm9tICcuL2NvbnRyYWN0cy9Ub2tlbk5ldHdvcmtSZWdpc3RyeUZhY3RvcnknO1xuaW1wb3J0IHsgVG9rZW5OZXR3b3JrRmFjdG9yeSB9IGZyb20gJy4vY29udHJhY3RzL1Rva2VuTmV0d29ya0ZhY3RvcnknO1xuaW1wb3J0IHsgSHVtYW5TdGFuZGFyZFRva2VuRmFjdG9yeSB9IGZyb20gJy4vY29udHJhY3RzL0h1bWFuU3RhbmRhcmRUb2tlbkZhY3RvcnknO1xuaW1wb3J0IHsgU2VydmljZVJlZ2lzdHJ5RmFjdG9yeSB9IGZyb20gJy4vY29udHJhY3RzL1NlcnZpY2VSZWdpc3RyeUZhY3RvcnknO1xuaW1wb3J0IHsgQ3VzdG9tVG9rZW5GYWN0b3J5IH0gZnJvbSAnLi9jb250cmFjdHMvQ3VzdG9tVG9rZW5GYWN0b3J5JztcbmltcG9ydCB7IFVzZXJEZXBvc2l0RmFjdG9yeSB9IGZyb20gJy4vY29udHJhY3RzL1VzZXJEZXBvc2l0RmFjdG9yeSc7XG5pbXBvcnQgeyBTZWNyZXRSZWdpc3RyeUZhY3RvcnkgfSBmcm9tICcuL2NvbnRyYWN0cy9TZWNyZXRSZWdpc3RyeUZhY3RvcnknO1xuaW1wb3J0IHZlcnNpb25zIGZyb20gJy4vdmVyc2lvbnMuanNvbic7XG5pbXBvcnQgeyBFdmVudFR5cGVzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBTaHV0ZG93blJlYXNvbiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGdldFN0YXRlIH0gZnJvbSAnLi9zdGF0ZSc7XG5pbXBvcnQgeyBQYXJ0aWFsUmFpZGVuQ29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgQ2hhbm5lbFN0YXRlIH0gZnJvbSAnLi9jaGFubmVscy9zdGF0ZSc7XG5pbXBvcnQgeyBEaXJlY3Rpb24gfSBmcm9tICcuL3RyYW5zZmVycy9zdGF0ZSc7XG5pbXBvcnQgeyByYWlkZW5SZWR1Y2VyIH0gZnJvbSAnLi9yZWR1Y2VyJztcbmltcG9ydCB7IHJhaWRlblJvb3RFcGljIH0gZnJvbSAnLi9lcGljcyc7XG5pbXBvcnQgeyBSYWlkZW5FdmVudHMsIHJhaWRlblNodXRkb3duLCByYWlkZW5Db25maWdVcGRhdGUsIH0gZnJvbSAnLi9hY3Rpb25zJztcbmltcG9ydCB7IGNoYW5uZWxPcGVuLCBjaGFubmVsRGVwb3NpdCwgY2hhbm5lbENsb3NlLCBjaGFubmVsU2V0dGxlLCB0b2tlbk1vbml0b3JlZCwgfSBmcm9tICcuL2NoYW5uZWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgbWF0cml4UHJlc2VuY2UgfSBmcm9tICcuL3RyYW5zcG9ydC9hY3Rpb25zJztcbmltcG9ydCB7IHRyYW5zZmVyLCB0cmFuc2ZlclNpZ25lZCB9IGZyb20gJy4vdHJhbnNmZXJzL2FjdGlvbnMnO1xuaW1wb3J0IHsgbWFrZVNlY3JldCwgZ2V0U2VjcmV0aGFzaCwgbWFrZVBheW1lbnRJZCwgcmFpZGVuU2VudFRyYW5zZmVyIH0gZnJvbSAnLi90cmFuc2ZlcnMvdXRpbHMnO1xuaW1wb3J0IHsgcGF0aEZpbmQgfSBmcm9tICcuL3BhdGgvYWN0aW9ucyc7XG5pbXBvcnQgeyBQYXRocywgUEZTIH0gZnJvbSAnLi9wYXRoL3R5cGVzJztcbmltcG9ydCB7IHBmc0xpc3RJbmZvIH0gZnJvbSAnLi9wYXRoL3V0aWxzJztcbmltcG9ydCB7IEFkZHJlc3MsIFNlY3JldCwgSGFzaCwgVUludCwgZGVjb2RlLCBhc3NlcnQgfSBmcm9tICcuL3V0aWxzL3R5cGVzJztcbmltcG9ydCB7IGlzQWN0aW9uT2YsIGFzeW5jQWN0aW9uVG9Qcm9taXNlLCBpc1Jlc3BvbnNlT2YgfSBmcm9tICcuL3V0aWxzL2FjdGlvbnMnO1xuaW1wb3J0IHsgcGF0Y2hTaWduU2VuZCB9IGZyb20gJy4vdXRpbHMvZXRoZXJzJztcbmltcG9ydCB7IHBsdWNrRGlzdGluY3QgfSBmcm9tICcuL3V0aWxzL3J4JztcbmltcG9ydCB7IGdldENvbnRyYWN0cywgZ2V0U2lnbmVyLCBpbml0VHJhbnNmZXJzJCwgbWFwVG9rZW5Ub1BhcnRuZXIsIGNob29zZU9uY2hhaW5BY2NvdW50LCBnZXRDb250cmFjdFdpdGhTaWduZXIsIHdhaXRDb25maXJtYXRpb24sIGNhbGxBbmRXYWl0TWluZWQsIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IFJhaWRlbkVycm9yLCBFcnJvckNvZGVzIH0gZnJvbSAnLi91dGlscy9lcnJvcic7XG5leHBvcnQgY2xhc3MgUmFpZGVuIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgbmV0d29yaywgc2lnbmVyLCBjb250cmFjdHNJbmZvLCBzdGF0ZSwgZGVmYXVsdENvbmZpZywgbWFpbikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHRoaXMucmVzb2x2ZU5hbWUgPSBwcm92aWRlci5yZXNvbHZlTmFtZS5iaW5kKHByb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHN0YXRlLmFkZHJlc3M7XG4gICAgICAgIHRoaXMubG9nID0gbG9nZ2luZy5nZXRMb2dnZXIoYHJhaWRlbjoke2FkZHJlc3N9YCk7XG4gICAgICAgIC8vIHVzZSBuZXh0IGZyb20gbGF0ZXN0IGtub3duIGJsb2NrTnVtYmVyIGFzIHN0YXJ0IGJsb2NrIHdoZW4gcG9sbGluZ1xuICAgICAgICBwcm92aWRlci5yZXNldEV2ZW50c0Jsb2NrKHN0YXRlLmJsb2NrTnVtYmVyICsgMSk7XG4gICAgICAgIGNvbnN0IGxhdGVzdCQgPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcbiAgICAgICAgLy8gcGlwZSBjYWNoZWQgc3RhdGVcbiAgICAgICAgdGhpcy5zdGF0ZSQgPSBsYXRlc3QkLnBpcGUocGx1Y2tEaXN0aW5jdCgnc3RhdGUnKSk7XG4gICAgICAgIC8vIHBpcGUgYWN0aW9uLCBza2lwcGluZyBjYWNoZWRcbiAgICAgICAgdGhpcy5hY3Rpb24kID0gbGF0ZXN0JC5waXBlKHBsdWNrRGlzdGluY3QoJ2FjdGlvbicpLCBza2lwKDEpKTtcbiAgICAgICAgdGhpcy5jaGFubmVscyQgPSB0aGlzLnN0YXRlJC5waXBlKG1hcCgoc3RhdGUpID0+IG1hcFRva2VuVG9QYXJ0bmVyKHN0YXRlKSkpO1xuICAgICAgICB0aGlzLnRyYW5zZmVycyQgPSBpbml0VHJhbnNmZXJzJCh0aGlzLnN0YXRlJCk7XG4gICAgICAgIHRoaXMuZXZlbnRzJCA9IHRoaXMuYWN0aW9uJC5waXBlKGZpbHRlcihpc0FjdGlvbk9mKFJhaWRlbkV2ZW50cykpKTtcbiAgICAgICAgdGhpcy5nZXRUb2tlbkluZm8gPSBtZW1vaXplKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQoQWRkcmVzcy5pcyh0b2tlbiksICdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbkNvbnRyYWN0ID0gdGhpcy5kZXBzLmdldFRva2VuQ29udHJhY3QodG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IFt0b3RhbFN1cHBseSwgZGVjaW1hbHMsIG5hbWUsIHN5bWJvbF0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIHRva2VuQ29udHJhY3QuZnVuY3Rpb25zLnRvdGFsU3VwcGx5KCksXG4gICAgICAgICAgICAgICAgICAgIHRva2VuQ29udHJhY3QuZnVuY3Rpb25zLmRlY2ltYWxzKCksXG4gICAgICAgICAgICAgICAgICAgIHRva2VuQ29udHJhY3QuZnVuY3Rpb25zLm5hbWUoKS5jYXRjaChjb25zdGFudCh1bmRlZmluZWQpKSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5Db250cmFjdC5mdW5jdGlvbnMuc3ltYm9sKCkuY2F0Y2goY29uc3RhbnQodW5kZWZpbmVkKSksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMzc1MlxuICAgICAgICAgICAgICAgIGFzc2VydCh0b3RhbFN1cHBseSAmJiBkZWNpbWFscyAhPSBudWxsLCAnTm90IGEgdG9rZW4gY29udHJhY3QnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0b3RhbFN1cHBseSwgZGVjaW1hbHMsIG5hbWUsIHN5bWJvbCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlcHMgPSB7XG4gICAgICAgICAgICBsYXRlc3QkLFxuICAgICAgICAgICAgY29uZmlnJDogbGF0ZXN0JC5waXBlKHBsdWNrRGlzdGluY3QoJ2NvbmZpZycpKSxcbiAgICAgICAgICAgIG1hdHJpeCQ6IG5ldyBBc3luY1N1YmplY3QoKSxcbiAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgbmV0d29yayxcbiAgICAgICAgICAgIHNpZ25lcixcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBsb2c6IHRoaXMubG9nLFxuICAgICAgICAgICAgZGVmYXVsdENvbmZpZyxcbiAgICAgICAgICAgIGNvbnRyYWN0c0luZm8sXG4gICAgICAgICAgICByZWdpc3RyeUNvbnRyYWN0OiBUb2tlbk5ldHdvcmtSZWdpc3RyeUZhY3RvcnkuY29ubmVjdChjb250cmFjdHNJbmZvLlRva2VuTmV0d29ya1JlZ2lzdHJ5LmFkZHJlc3MsIChfYSA9IG1haW4gPT09IG51bGwgfHwgbWFpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFpbi5zaWduZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNpZ25lciksXG4gICAgICAgICAgICBnZXRUb2tlbk5ldHdvcmtDb250cmFjdDogbWVtb2l6ZSgoYWRkcmVzcykgPT4geyB2YXIgX2E7IHJldHVybiBUb2tlbk5ldHdvcmtGYWN0b3J5LmNvbm5lY3QoYWRkcmVzcywgKF9hID0gbWFpbiA9PT0gbnVsbCB8fCBtYWluID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYWluLnNpZ25lcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogc2lnbmVyKTsgfSksXG4gICAgICAgICAgICBnZXRUb2tlbkNvbnRyYWN0OiBtZW1vaXplKChhZGRyZXNzKSA9PiB7IHZhciBfYTsgcmV0dXJuIEh1bWFuU3RhbmRhcmRUb2tlbkZhY3RvcnkuY29ubmVjdChhZGRyZXNzLCAoX2EgPSBtYWluID09PSBudWxsIHx8IG1haW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1haW4uc2lnbmVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzaWduZXIpOyB9KSxcbiAgICAgICAgICAgIHNlcnZpY2VSZWdpc3RyeUNvbnRyYWN0OiBTZXJ2aWNlUmVnaXN0cnlGYWN0b3J5LmNvbm5lY3QoY29udHJhY3RzSW5mby5TZXJ2aWNlUmVnaXN0cnkuYWRkcmVzcywgKF9iID0gbWFpbiA9PT0gbnVsbCB8fCBtYWluID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYWluLnNpZ25lcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogc2lnbmVyKSxcbiAgICAgICAgICAgIHVzZXJEZXBvc2l0Q29udHJhY3Q6IFVzZXJEZXBvc2l0RmFjdG9yeS5jb25uZWN0KGNvbnRyYWN0c0luZm8uVXNlckRlcG9zaXQuYWRkcmVzcywgKF9jID0gbWFpbiA9PT0gbnVsbCB8fCBtYWluID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYWluLnNpZ25lcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogc2lnbmVyKSxcbiAgICAgICAgICAgIHNlY3JldFJlZ2lzdHJ5Q29udHJhY3Q6IFNlY3JldFJlZ2lzdHJ5RmFjdG9yeS5jb25uZWN0KGNvbnRyYWN0c0luZm8uU2VjcmV0UmVnaXN0cnkuYWRkcmVzcywgKF9kID0gbWFpbiA9PT0gbnVsbCB8fCBtYWluID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYWluLnNpZ25lcikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogc2lnbmVyKSxcbiAgICAgICAgICAgIG1haW4sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXNlckRlcG9zaXRUb2tlbkFkZHJlc3MgPSBtZW1vaXplKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuICh5aWVsZCB0aGlzLmRlcHMudXNlckRlcG9zaXRDb250cmFjdC5mdW5jdGlvbnMudG9rZW4oKSk7IH0pKTtcbiAgICAgICAgY29uc3QgbG9nZ2VyTWlkZGxld2FyZSA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgICAgICAgICBwcmVkaWNhdGU6ICgpID0+IHRoaXMubG9nLmdldExldmVsKCkgPD0gbG9nZ2luZy5sZXZlbHMuSU5GTyxcbiAgICAgICAgICAgIGxvZ2dlcjogdGhpcy5sb2csXG4gICAgICAgICAgICBsZXZlbDoge1xuICAgICAgICAgICAgICAgIHByZXZTdGF0ZTogJ2RlYnVnJyxcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdpbmZvJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGU6ICdkZWJ1ZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZXBzLmNvbmZpZyRcbiAgICAgICAgICAgIC5waXBlKHBsdWNrRGlzdGluY3QoJ2xvZ2dlcicpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgobG9nZ2VyKSA9PiB0aGlzLmxvZy5zZXRMZXZlbChsb2dnZXIgfHwgJ3NpbGVudCcsIGZhbHNlKSk7XG4gICAgICAgIC8vIG1pbmltdW0gYmxvY2tOdW1iZXIgb2YgY29udHJhY3RzIGRlcGxveW1lbnQgYXMgc3RhcnQgc2NhbiBibG9ja1xuICAgICAgICB0aGlzLmVwaWNNaWRkbGV3YXJlID0gY3JlYXRlRXBpY01pZGRsZXdhcmUoeyBkZXBlbmRlbmNpZXM6IHRoaXMuZGVwcyB9KTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IGNyZWF0ZVN0b3JlKHJhaWRlblJlZHVjZXIsIFxuICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciByZWR1eCdzIFByZWxvYWRlZFN0YXRlIGlzc3VlcyB3aXRoIGJyYW5kZWQgdmFsdWVzXG4gICAgICAgIHN0YXRlLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgYXBwbHlNaWRkbGV3YXJlKGxvZ2dlck1pZGRsZXdhcmUsIHRoaXMuZXBpY01pZGRsZXdhcmUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXN5bmMgaGVscGVyIGZhY3RvcnkgdG8gbWFrZSBhIFJhaWRlbiBpbnN0YW5jZSBmcm9tIG1vcmUgY29tbW9uIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBBbiBhc3luYyBmYWN0b3J5IGlzIG5lZWRlZCBzbyB3ZSBjYW4gZG8gdGhlIG5lZWRlZCBhc3luYyByZXF1ZXN0cyB0byBjb25zdHJ1Y3QgdGhlIHJlcXVpcmVkXG4gICAgICogcGFyYW1ldGVycyBhaGVhZCBvZiBjb25zdHJ1Y3Rpb24gdGltZSwgYW5kIGF2b2lkIHBhcnRpYWwgaW5pdGlhbGl6YXRpb24gdGhlblxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb24gLSBBIFVSTCBvciBwcm92aWRlciB0byBjb25uZWN0IHRvLCBvbmUgb2Y6XG4gICAgICogICAgIDx1bD5cbiAgICAgKiAgICAgICA8bGk+SnNvblJwY1Byb3ZpZGVyIGluc3RhbmNlLDwvbGk+XG4gICAgICogICAgICAgPGxpPmEgTWV0YW1hc2sncyB3ZWIzLmN1cnJlbnRQcm92aWRlciBvYmplY3Qgb3IsPC9saT5cbiAgICAgKiAgICAgICA8bGk+YSBob3N0bmFtZSBvciByZW1vdGUganNvbi1ycGMgY29ubmVjdGlvbiBzdHJpbmc8L2xpPlxuICAgICAqICAgICA8L3VsPlxuICAgICAqIEBwYXJhbSBhY2NvdW50IC0gQW4gYWNjb3VudCB0byB1c2UgYXMgbWFpbiBhY2NvdW50LCBvbmUgb2Y6XG4gICAgICogICAgIDx1bD5cbiAgICAgKiAgICAgICA8bGk+U2lnbmVyIGluc3RhbmNlIChlLmcuIFdhbGxldCkgbG9hZGRlZCB3aXRoIGFjY291bnQvcHJpdmF0ZSBrZXkgb3I8L2xpPlxuICAgICAqICAgICAgIDxsaT5oZXgtZW5jb2RlZCBzdHJpbmcgYWRkcmVzcyBvZiBhIHJlbW90ZSBhY2NvdW50IGluIHByb3ZpZGVyIG9yPC9saT5cbiAgICAgKiAgICAgICA8bGk+aGV4LWVuY29kZWQgc3RyaW5nIGxvY2FsIHByaXZhdGUga2V5IG9yPC9saT5cbiAgICAgKiAgICAgICA8bGk+bnVtYmVyIGluZGV4IG9mIGEgcmVtb3RlIGFjY291bnQgbG9hZGVkIGluIHByb3ZpZGVyXG4gICAgICogICAgICAgICAgICAoZS5nLiAwIGZvciBNZXRhbWFzaydzIGxvYWRlZCBhY2NvdW50KTwvbGk+XG4gICAgICogICAgIDwvdWw+XG4gICAgICogQHBhcmFtIHN0b3JhZ2VPclN0YXRlIC0gU3RvcmFnZS9sb2NhbFN0b3JhZ2UtbGlrZSBvYmplY3QgZnJvbSB3aGVyZSB0byBsb2FkIGFuZCBzdG9yZSBjdXJyZW50XG4gICAgICogICAgIHN0YXRlLCBpbml0aWFsIFJhaWRlblN0YXRlLWxpa2Ugb2JqZWN0LCBvciBhIHsgc3RvcmFnZTsgc3RhdGU/IH0gb2JqZWN0IGNvbnRhaW5pbmcgYm90aC5cbiAgICAgKiAgICAgSWYgYSBzdG9yYWdlIGlzbid0IHByb3ZpZGVkLCB1c2VyIG11c3QgbGlzdGVuIHN0YXRlJCBjaGFuZ2VzIG9uIGVuc3VyZSBpdCdzIHBlcnNpc3RlZC5cbiAgICAgKiBAcGFyYW0gY29udHJhY3RzIC0gQ29udHJhY3RzIGRlcGxveW1lbnQgaW5mb1xuICAgICAqIEBwYXJhbSBjb25maWcgLSBSYWlkZW4gY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSBzdWJrZXkgLSBXaGV0aGVyIHRvIHVzZSBhIGRlcml2ZWQgc3Via2V5IG9yIG5vdFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdG8gUmFpZGVuIFNESyBjbGllbnQgaW5zdGFuY2VcbiAgICAgKiovXG4gICAgc3RhdGljIGNyZWF0ZShjb25uZWN0aW9uLCBhY2NvdW50LCBzdG9yYWdlT3JTdGF0ZSwgY29udHJhY3RzLCBjb25maWcsIHN1YmtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHByb3ZpZGVyO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25uZWN0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gbmV3IEpzb25ScGNQcm92aWRlcihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbm5lY3Rpb24gaW5zdGFuY2VvZiBKc29uUnBjUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IGNvbm5lY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IG5ldyBXZWIzUHJvdmlkZXIoY29ubmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXRjaCBwcm92aWRlcidzIHNpZ24gbWV0aG9kIChodHRwczovL2dpdGh1Yi5jb20vcmFpZGVuLW5ldHdvcmsvbGlnaHQtY2xpZW50L2lzc3Vlcy8yMjMpXG4gICAgICAgICAgICBwYXRjaFNpZ25TZW5kKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSB5aWVsZCBwcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICAvLyBpZiBubyBDb250cmFjdHNJbmZvLCB0cnkgdG8gcG9wdWxhdGUgZnJvbSBkZWZhdWx0c1xuICAgICAgICAgICAgaWYgKCFjb250cmFjdHMpIHtcbiAgICAgICAgICAgICAgICBjb250cmFjdHMgPSBnZXRDb250cmFjdHMobmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHNpZ25lciwgYWRkcmVzcywgbWFpbiB9ID0geWllbGQgZ2V0U2lnbmVyKGFjY291bnQsIHByb3ZpZGVyLCBzdWJrZXkpO1xuICAgICAgICAgICAgLy8gQnVpbGQgaW5pdGlhbCBzdGF0ZSBvciBwYXJzZSBmcm9tIHN0b3JhZ2VcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUsIG9uU3RhdGUsIG9uU3RhdGVDb21wbGV0ZSwgZGVmYXVsdENvbmZpZyB9ID0geWllbGQgZ2V0U3RhdGUobmV0d29yaywgY29udHJhY3RzLCBhZGRyZXNzLCBzdG9yYWdlT3JTdGF0ZSwgY29uZmlnICYmIGRlY29kZShQYXJ0aWFsUmFpZGVuQ29uZmlnLCBjb25maWcpKTtcbiAgICAgICAgICAgIGFzc2VydChhZGRyZXNzID09PSBzdGF0ZS5hZGRyZXNzLCBgTWlzbWF0Y2ggYmV0d2VlbiBwcm92aWRlZCBhY2NvdW50IGFuZCBsb2FkZWQgc3RhdGU6IFwiJHthZGRyZXNzfVwiICE9PSBcIiR7c3RhdGUuYWRkcmVzc31cImApO1xuICAgICAgICAgICAgYXNzZXJ0KG5ldHdvcmsuY2hhaW5JZCA9PT0gc3RhdGUuY2hhaW5JZCAmJlxuICAgICAgICAgICAgICAgIGNvbnRyYWN0cy5Ub2tlbk5ldHdvcmtSZWdpc3RyeS5hZGRyZXNzID09PSBzdGF0ZS5yZWdpc3RyeSwgYE1pc21hdGNoIGJldHdlZW4gbmV0d29yayBvciByZWdpc3RyeSBhZGRyZXNzIGFuZCBsb2FkZWQgc3RhdGVgKTtcbiAgICAgICAgICAgIGNvbnN0IHJhaWRlbiA9IG5ldyBSYWlkZW4ocHJvdmlkZXIsIG5ldHdvcmssIHNpZ25lciwgY29udHJhY3RzLCBzdGF0ZSwgZGVmYXVsdENvbmZpZywgbWFpbik7XG4gICAgICAgICAgICBpZiAob25TdGF0ZSlcbiAgICAgICAgICAgICAgICByYWlkZW4uc3RhdGUkLnN1YnNjcmliZShvblN0YXRlLCBvblN0YXRlQ29tcGxldGUsIG9uU3RhdGVDb21wbGV0ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmFpZGVuO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHJlZHV4L29ic2VydmFibGVzIGJ5IHN1YnNjcmliaW5nIHRvIGFsbCBlcGljcyBhbmQgZW1pdHRpbmcgaW5pdGlhbCBzdGF0ZSBhbmQgYWN0aW9uXG4gICAgICpcbiAgICAgKiBObyBldmVudCBzaG91bGQgYmUgZW1pdHRlZCBiZWZvcmUgc3RhcnQgaXMgY2FsbGVkXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGFzc2VydCh0aGlzLmVwaWNNaWRkbGV3YXJlLCAnQWxyZWFkeSBzdGFydGVkIG9yIHN0b3BwZWQhJyk7XG4gICAgICAgIC8vIG9uIGNvbXBsZXRlLCBzZXRzIGVwaWNNaWRkbGV3YXJlIHRvIG51bGwsIHNvIHRoaXMuc3RhcnRlZCA9PT0gZmFsc2VcbiAgICAgICAgdGhpcy5kZXBzLmxhdGVzdCQuc3Vic2NyaWJlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAoKSA9PiAodGhpcy5lcGljTWlkZGxld2FyZSA9IG51bGwpKTtcbiAgICAgICAgdGhpcy5lcGljTWlkZGxld2FyZS5ydW4ocmFpZGVuUm9vdEVwaWMpO1xuICAgICAgICAvLyBwcmV2ZW50IHN0YXJ0IGZyb20gYmVpbmcgY2FsbGVkIGFnYWluLCB0dXJucyB0aGlzLnN0YXJ0ZWQgdG8gdHJ1ZVxuICAgICAgICB0aGlzLmVwaWNNaWRkbGV3YXJlID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBkaXNwYXRjaCBhIGZpcnN0LCBub29wIGFjdGlvbiwgdG8gbmV4dCBmaXJzdCBzdGF0ZSQgYXMgY3VycmVudC9pbml0aWFsIHN0YXRlXG4gICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2gocmFpZGVuQ29uZmlnVXBkYXRlKHt9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJ1bm5pbmcgc3RhdGUgb2YgdGhlIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB1bmRlZmluZWQgaWYgbm90IHlldCBzdGFydGVkLCB0cnVlIGlmIHJ1bm5pbmcsIGZhbHNlIGlmIGFscmVhZHkgc3RvcHBlZFxuICAgICAqL1xuICAgIGdldCBzdGFydGVkKCkge1xuICAgICAgICAvLyAhZXBpY01pZGRsZXdhcmUgLT4gdW5kZWZpbmVkIHwgbnVsbCAtPiB1bmRlZmluZWQgPyB0cnVlL3N0YXJ0ZWQgOiBudWxsL3N0b3BwZWQ7XG4gICAgICAgIGlmICghdGhpcy5lcGljTWlkZGxld2FyZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVwaWNNaWRkbGV3YXJlID09PSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGVsc2UgLT4gISFlcGljTWlkZGxld2FyZSAtPiBub3QgeWV0IHN0YXJ0ZWQgLT4gcmV0dXJucyB1bmRlZmluZWRcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYWxsIGVwaWNzIHRvIGJlIHVuc3Vic2NyaWJlZFxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIC8vIHN0YXJ0IHN0aWxsIGNhbid0IGJlIGNhbGxlZCBhZ2FpbiwgYnV0IHR1cm5zIHRoaXMuc3RhcnRlZCB0byBmYWxzZVxuICAgICAgICAvLyB0aGlzLmVwaWNNaWRkbGV3YXJlIGlzIHNldCB0byBudWxsIGJ5IGxhdGVzdCQncyBjb21wbGV0ZSBjYWxsYmFja1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHJhaWRlblNodXRkb3duKHsgcmVhc29uOiBTaHV0ZG93blJlYXNvbi5TVE9QIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgUmFpZGVuU3RhdGUgb2JqZWN0LiBDYW4gYmUgc2VyaWFsaXplZCBzYWZlbHkgd2l0aCBbW2VuY29kZVJhaWRlblN0YXRlXV1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEN1cnJlbnQgUmFpZGVuIHN0YXRlXG4gICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBhY2NvdW50IGFkZHJlc3MgKHN1YmtleSdzIGFkZHJlc3MsIGlmIHN1YmtleSBpcyBiZWluZyB1c2VkKVxuICAgICAqXG4gICAgICogQHJldHVybnMgSW5zdGFuY2UgYWRkcmVzc1xuICAgICAqL1xuICAgIGdldCBhZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXBzLmFkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBtYWluIGFjY291bnQgYWRkcmVzcyAoaWYgc3Via2V5IGlzIGJlaW5nIHVzZWQsIHVuZGVmaW5lZCBvdGhlcndpc2UpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBNYWluIGFjY291bnQgYWRkcmVzc1xuICAgICAqL1xuICAgIGdldCBtYWluQWRkcmVzcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5kZXBzLm1haW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBuZXR3b3JrIGZyb20gcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIE5ldHdvcmsgb2JqZWN0IGNvbnRhaW5pbmcgYmxvY2tjaGFpbidzIG5hbWUgJiBjaGFpbklkXG4gICAgICovXG4gICAgZ2V0IG5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHMubmV0d29yaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdG8gY3VycmVudCBibG9jayBudW1iZXIsIGFzIHNlZW4gaW4gcHJvdmlkZXIgYW5kIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRvIGN1cnJlbnQgYmxvY2sgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXBzLnByb3ZpZGVyLmJsb2NrTnVtYmVyIHx8ICh5aWVsZCB0aGlzLmRlcHMucHJvdmlkZXIuZ2V0QmxvY2tOdW1iZXIoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXR0ZXIgZm9yIGN1cnJlbnQgUmFpZGVuIENvbmZpZ1xuICAgICAqXG4gICAgICogQHJldHVybnMgQ3VycmVudCBSYWlkZW4gY29uZmlnXG4gICAgICovXG4gICAgZ2V0IGNvbmZpZygpIHtcbiAgICAgICAgbGV0IGNvbmZpZztcbiAgICAgICAgdGhpcy5kZXBzLmNvbmZpZyQucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoKGMpID0+IChjb25maWcgPSBjKSk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSB1c2VkIFNESyB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgU0RLIHZlcnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiB2ZXJzaW9ucy5zZGs7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZlcnNpb24gb2YgdGhlIHVzZWQgU21hcnQgQ29udHJhY3RzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgU21hcnQgQ29udHJhY3QgdmVyc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgY29udHJhY3RWZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdmVyc2lvbnMuY29udHJhY3RzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgUmFpZGVuIENvbmZpZyB3aXRoIGEgcGFydGlhbCAoc2hhbGxvdykgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gUGFydGlhbCBvYmplY3QgY29udGFpbmluZyBrZXlzIGFuZCB2YWx1ZXMgdG8gdXBkYXRlIGluIGNvbmZpZ1xuICAgICAqL1xuICAgIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChyYWlkZW5Db25maWdVcGRhdGUoZGVjb2RlKFBhcnRpYWxSYWlkZW5Db25maWcsIGNvbmZpZykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IEVUSCBiYWxhbmNlIGZvciBnaXZlbiBhZGRyZXNzIG9yIHNlbGZcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gT3B0aW9uYWwgdGFyZ2V0IGFkZHJlc3MuIElmIG9taXR0ZWQsIGdldHMgb3duIGJhbGFuY2VcbiAgICAgKiBAcmV0dXJucyBCaWdOdW1iZXIgb2YgRVRIIGJhbGFuY2VcbiAgICAgKi9cbiAgICBnZXRCYWxhbmNlKGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MgIT09IG51bGwgJiYgYWRkcmVzcyAhPT0gdm9pZCAwID8gYWRkcmVzcyA6IGNob29zZU9uY2hhaW5BY2NvdW50KHRoaXMuZGVwcywgdGhpcy5jb25maWcuc3Via2V5KS5hZGRyZXNzO1xuICAgICAgICBhc3NlcnQoQWRkcmVzcy5pcyhhZGRyZXNzKSwgJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgICAgICByZXR1cm4gdGhpcy5kZXBzLnByb3ZpZGVyLmdldEJhbGFuY2UoYWRkcmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0b2tlbiBiYWxhbmNlIGFuZCB0b2tlbiBkZWNpbWFscyBmb3IgZ2l2ZW4gYWRkcmVzcyBvciBzZWxmXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBUb2tlbiBhZGRyZXNzIHRvIGZldGNoIGJhbGFuY2UuIE11c3QgYmUgb25lIG9mIHRoZSBtb25pdG9yZWQgdG9rZW5zLlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gT3B0aW9uYWwgdGFyZ2V0IGFkZHJlc3MuIElmIG9taXR0ZWQsIGdldHMgb3duIGJhbGFuY2VcbiAgICAgKiBAcmV0dXJucyBCaWdOdW1iZXIgY29udGFpbmluZyBhZGRyZXNzJ3MgdG9rZW4gYmFsYW5jZVxuICAgICAqL1xuICAgIGdldFRva2VuQmFsYW5jZSh0b2tlbiwgYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MgIT09IG51bGwgJiYgYWRkcmVzcyAhPT0gdm9pZCAwID8gYWRkcmVzcyA6IGNob29zZU9uY2hhaW5BY2NvdW50KHRoaXMuZGVwcywgdGhpcy5jb25maWcuc3Via2V5KS5hZGRyZXNzO1xuICAgICAgICAgICAgYXNzZXJ0KEFkZHJlc3MuaXMoYWRkcmVzcykgJiYgQWRkcmVzcy5pcyh0b2tlbiksICdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuQ29udHJhY3QgPSB0aGlzLmRlcHMuZ2V0VG9rZW5Db250cmFjdCh0b2tlbik7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5Db250cmFjdC5mdW5jdGlvbnMuYmFsYW5jZU9mKGFkZHJlc3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRva2VuIGFkZHJlc3NlcyByZWdpc3RlcmVkIGFzIHRva2VuIG5ldHdvcmtzIGluIHJlZ2lzdHJ5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRvIGxpc3Qgb2YgdG9rZW4gYWRkcmVzc2VzXG4gICAgICovXG4gICAgZ2V0VG9rZW5MaXN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwcy5wcm92aWRlclxuICAgICAgICAgICAgICAgIC5nZXRMb2dzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZXBzLnJlZ2lzdHJ5Q29udHJhY3QuZmlsdGVycy5Ub2tlbk5ldHdvcmtDcmVhdGVkKG51bGwsIG51bGwpKSwgeyBmcm9tQmxvY2s6IHRoaXMuZGVwcy5jb250cmFjdHNJbmZvLlRva2VuTmV0d29ya1JlZ2lzdHJ5LmJsb2NrX251bWJlciwgdG9CbG9jazogJ2xhdGVzdCcgfSkpXG4gICAgICAgICAgICAgICAgLnRoZW4oKGxvZ3MpID0+IGxvZ3NcbiAgICAgICAgICAgICAgICAubWFwKChsb2cpID0+IHRoaXMuZGVwcy5yZWdpc3RyeUNvbnRyYWN0LmludGVyZmFjZS5wYXJzZUxvZyhsb2cpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHBhcnNlZCkgPT4geyB2YXIgX2E7IHJldHVybiAhISgoX2EgPSBwYXJzZWQudmFsdWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9rZW5fYWRkcmVzcyk7IH0pXG4gICAgICAgICAgICAgICAgLm1hcCgocGFyc2VkKSA9PiBwYXJzZWQudmFsdWVzLnRva2VuX2FkZHJlc3MpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjYW5zIGluaXRpYWxseSBhbmQgc3RhcnQgbW9uaXRvcmluZyBhIHRva2VuIGZvciBjaGFubmVscyB3aXRoIHVzLCByZXR1cm5pbmcgaXRzIFRva2VubmV0d29ya1xuICAgICAqIGFkZHJlc3NcbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBleGNlcHRpb24gaWYgdG9rZW4gaXNuJ3QgcmVnaXN0ZXJlZCBpbiBjdXJyZW50IHJlZ2lzdHJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSB0b2tlbiBhZGRyZXNzIHRvIG1vbml0b3IsIG11c3QgYmUgcmVnaXN0ZXJlZCBpbiBjdXJyZW50IHRva2VuIG5ldHdvcmsgcmVnaXN0cnlcbiAgICAgKiBAcmV0dXJucyBBZGRyZXNzIG9mIFRva2VuTmV0d29yayBjb250cmFjdFxuICAgICAqL1xuICAgIG1vbml0b3JUb2tlbih0b2tlbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYXNzZXJ0KEFkZHJlc3MuaXModG9rZW4pLCAnSW52YWxpZCBhZGRyZXNzJyk7XG4gICAgICAgICAgICBjb25zdCBhbHJlYWR5TW9uaXRvcmVkVG9rZW5zID0gdGhpcy5zdGF0ZS50b2tlbnM7XG4gICAgICAgICAgICBpZiAodG9rZW4gaW4gYWxyZWFkeU1vbml0b3JlZFRva2VucylcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxyZWFkeU1vbml0b3JlZFRva2Vuc1t0b2tlbl07XG4gICAgICAgICAgICBjb25zdCB0b2tlbk5ldHdvcmsgPSAoeWllbGQgdGhpcy5kZXBzLnJlZ2lzdHJ5Q29udHJhY3QudG9rZW5fdG9fdG9rZW5fbmV0d29ya3ModG9rZW4pKTtcbiAgICAgICAgICAgIGFzc2VydCh0b2tlbk5ldHdvcmsgJiYgdG9rZW5OZXR3b3JrICE9PSBBZGRyZXNzWmVybywgJ1Vua25vd24gdG9rZW4gbmV0d29yaycpO1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh0b2tlbk1vbml0b3JlZCh7XG4gICAgICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICAgICAgdG9rZW5OZXR3b3JrLFxuICAgICAgICAgICAgICAgIGZyb21CbG9jazogdGhpcy5kZXBzLmNvbnRyYWN0c0luZm8uVG9rZW5OZXR3b3JrUmVnaXN0cnkuYmxvY2tfbnVtYmVyLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuTmV0d29yaztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW4gYSBjaGFubmVsIG9uIHRoZSB0b2tlbk5ldHdvcmsgZm9yIGdpdmVuIHRva2VuIGFkZHJlc3Mgd2l0aCBwYXJ0bmVyXG4gICAgICpcbiAgICAgKiBJZiB0b2tlbiBpc24ndCB5ZXQgbW9uaXRvcmVkLCBzdGFydHMgbW9uaXRvcmluZyBpdFxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIC0gVG9rZW4gYWRkcmVzcyBvbiBjdXJyZW50bHkgY29uZmlndXJlZCB0b2tlbiBuZXR3b3JrIHJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIHBhcnRuZXIgLSBQYXJ0bmVyIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIChvcHRpb25hbCkgb3B0aW9uIHBhcmFtZXRlclxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNldHRsZVRpbWVvdXQgLSBDdXN0b20sIG9uZS10aW1lIHNldHRsZSB0aW1lb3V0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3Via2V5IC0gV2hldGhlciB0byB1c2UgdGhlIHN1YmtleSBmb3Igb24tY2hhaW4gdHggb3IgbWFpbiBhY2NvdW50IChkZWZhdWx0KVxuICAgICAqIEBwYXJhbSBvbkNoYW5nZSAtIE9wdGlvbmFsIGNhbGxiYWNrIGZvciBzdGF0dXMgY2hhbmdlIG5vdGlmaWNhdGlvblxuICAgICAqIEByZXR1cm5zIHR4SGFzaCBvZiBjaGFubmVsT3BlbiBjYWxsLCBpZmYgaXQgc3VjY2VlZGVkXG4gICAgICovXG4gICAgb3BlbkNoYW5uZWwodG9rZW4sIHBhcnRuZXIsIG9wdGlvbnMgPSB7fSwgb25DaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGFzc2VydChBZGRyZXNzLmlzKHRva2VuKSAmJiBBZGRyZXNzLmlzKHBhcnRuZXIpLCAnSW52YWxpZCBhZGRyZXNzJyk7XG4gICAgICAgICAgICBjb25zdCB0b2tlbk5ldHdvcmsgPSB5aWVsZCB0aGlzLm1vbml0b3JUb2tlbih0b2tlbik7XG4gICAgICAgICAgICBhc3NlcnQoIW9wdGlvbnMuc3Via2V5IHx8IHRoaXMuZGVwcy5tYWluLCBcIkNhbid0IHNlbmQgdHggZnJvbSBzdWJrZXkgaWYgbm90IHNldFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRlcG9zaXQgPSBvcHRpb25zLmRlcG9zaXQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGRlY29kZShVSW50KDMyKSwgb3B0aW9ucy5kZXBvc2l0KTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSB7IHRva2VuTmV0d29yaywgcGFydG5lciB9O1xuICAgICAgICAgICAgLy8gd2FpdCBmb3IgY29uZmlybWF0aW9uXG4gICAgICAgICAgICBjb25zdCBvcGVuUHJvbWlzZSA9IGFzeW5jQWN0aW9uVG9Qcm9taXNlKGNoYW5uZWxPcGVuLCBtZXRhLCB0aGlzLmFjdGlvbiQsIGZhbHNlKS50aGVuKCh7IHR4SGFzaCB9KSA9PiB0eEhhc2gpO1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChjaGFubmVsT3Blbi5yZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgZGVwb3NpdCB9KSwgbWV0YSkpO1xuICAgICAgICAgICAgY29uc3Qgb3BlblR4SGFzaCA9IHlpZWxkIG9wZW5Qcm9taXNlO1xuICAgICAgICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKHsgdHlwZTogRXZlbnRUeXBlcy5PUEVORUQsIHBheWxvYWQ6IHsgdHhIYXNoOiBvcGVuVHhIYXNoIH0gfSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnN0YXRlJFxuICAgICAgICAgICAgICAgIC5waXBlKHBsdWNrRGlzdGluY3QoJ2NoYW5uZWxzJywgdG9rZW5OZXR3b3JrLCBwYXJ0bmVyLCAnc3RhdGUnKSwgZmlyc3QoKHN0YXRlKSA9PiBzdGF0ZSA9PT0gQ2hhbm5lbFN0YXRlLm9wZW4pKVxuICAgICAgICAgICAgICAgIC50b1Byb21pc2UoKTtcbiAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZSh7IHR5cGU6IEV2ZW50VHlwZXMuQ09ORklSTUVELCBwYXlsb2FkOiB7IHR4SGFzaDogb3BlblR4SGFzaCB9IH0pO1xuICAgICAgICAgICAgaWYgKGRlcG9zaXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXBvc2l0VHggPSB5aWVsZCBhc3luY0FjdGlvblRvUHJvbWlzZShjaGFubmVsRGVwb3NpdCwgbWV0YSwgdGhpcy5hY3Rpb24kLCB0cnVlKS50aGVuKCh7IHR4SGFzaCB9KSA9PiB0eEhhc2gpO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZSh7IHR5cGU6IEV2ZW50VHlwZXMuREVQT1NJVEVELCBwYXlsb2FkOiB7IHR4SGFzaDogZGVwb3NpdFR4IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3BlblR4SGFzaDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcG9zaXQgdG9rZW5zIG9uIGNoYW5uZWwgYmV0d2VlbiB1cyBhbmQgcGFydG5lciBvbiB0b2tlbk5ldHdvcmsgZm9yIHRva2VuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBUb2tlbiBhZGRyZXNzIG9uIGN1cnJlbnRseSBjb25maWd1cmVkIHRva2VuIG5ldHdvcmsgcmVnaXN0cnlcbiAgICAgKiBAcGFyYW0gcGFydG5lciAtIFBhcnRuZXIgYWRkcmVzc1xuICAgICAqIEBwYXJhbSBhbW91bnQgLSBOdW1iZXIgb2YgdG9rZW5zIHRvIGRlcG9zaXQgb24gY2hhbm5lbFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gdHggb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnN1YmtleSAtIEJ5IGRlZmF1bHQsIGlmIHVzaW5nIHN1YmtleSwgbWFpbiBhY2NvdW50IGlzIHVzZWQgdG8gc2VuZCB0cmFuc2FjdGlvbnNcbiAgICAgKiAgICAoYW5kIGlzIGFsc28gdGhlIGFjY291bnQgdXNlZCBhcyBzb3VyY2Ugb2YgdGhlIGRlcG9zaXQgdG9rZW5zKS5cbiAgICAgKiAgICBTZXQgdGhpcyB0byB0cnVlIGlmIG9uZSB3YW50cyB0byBmb3JjZSBzZW5kaW5nIHRoZSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBzdWJrZXksIGFuZCB1c2luZ1xuICAgICAqICAgIHRva2VucyBoZWxkIGluIHRoZSBzdWJrZXkuXG4gICAgICogQHJldHVybnMgdHhIYXNoIG9mIHNldFRvdGFsRGVwb3NpdCBjYWxsLCBpZmYgaXQgc3VjY2VlZGVkXG4gICAgICovXG4gICAgZGVwb3NpdENoYW5uZWwodG9rZW4sIHBhcnRuZXIsIGFtb3VudCwgeyBzdWJrZXkgfSA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhc3NlcnQoQWRkcmVzcy5pcyh0b2tlbikgJiYgQWRkcmVzcy5pcyhwYXJ0bmVyKSwgJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5OZXR3b3JrID0gc3RhdGUudG9rZW5zW3Rva2VuXTtcbiAgICAgICAgICAgIGFzc2VydCh0b2tlbk5ldHdvcmssICdVbmtub3duIHRva2VuIG5ldHdvcmsnKTtcbiAgICAgICAgICAgIGFzc2VydCghc3Via2V5IHx8IHRoaXMuZGVwcy5tYWluLCBcIkNhbid0IHNlbmQgdHggZnJvbSBzdWJrZXkgaWYgbm90IHNldFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRlcG9zaXQgPSBkZWNvZGUoVUludCgzMiksIGFtb3VudCk7XG4gICAgICAgICAgICBjb25zdCBtZXRhID0geyB0b2tlbk5ldHdvcmssIHBhcnRuZXIgfTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBhc3luY0FjdGlvblRvUHJvbWlzZShjaGFubmVsRGVwb3NpdCwgbWV0YSwgdGhpcy5hY3Rpb24kLCB0cnVlKS50aGVuKCh7IHR4SGFzaCB9KSA9PiB0eEhhc2gpO1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChjaGFubmVsRGVwb3NpdC5yZXF1ZXN0KHsgZGVwb3NpdCwgc3Via2V5IH0sIG1ldGEpKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgY2hhbm5lbCBiZXR3ZWVuIHVzIGFuZCBwYXJ0bmVyIG9uIHRva2VuTmV0d29yayBmb3IgdG9rZW5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGZhaWwgaWYgY2FsbGVkIG9uIGEgY2hhbm5lbCBub3QgaW4gJ29wZW5lZCcgb3IgJ2Nsb3NpbmcnIHN0YXRlLlxuICAgICAqIFdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBvbiBhbiAnb3BlbmVkJyBjaGFubmVsLCBpdHMgc3RhdGUgYmVjb21lcyAnY2xvc2luZycsIGFuZCBmcm9tIHRoZXJlXG4gICAgICogb24sIG5vIHBheW1lbnRzIGNhbiBiZSBwZXJmb3JtZWQgb24gdGhlIGNoYW5uZWwuIElmIGZvciBhbnkgcmVhc29uIHRoZSBjbG9zZUNoYW5uZWxcbiAgICAgKiB0cmFuc2FjdGlvbiBmYWlscywgY2hhbm5lbCdzIHN0YXRlIHN0YXlzIGFzICdjbG9zaW5nJywgYW5kIHRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgYWdhaW5cbiAgICAgKiB0byByZXRyeSBzZW5kaW5nICdjbG9zZUNoYW5uZWwnIHRyYW5zYWN0aW9uLiBBZnRlciBpdCdzIHN1Y2Nlc3NmdWwsIGNoYW5uZWwgYmVjb21lcyAnY2xvc2VkJyxcbiAgICAgKiBhbmQgY2FuIGJlIHNldHRsZWQgYWZ0ZXIgJ3NldHRsZVRpbWVvdXQnIGJsb2NrcyAod2hlbiBpdCB0aGVuIGJlY29tZXMgJ3NldHRsZWFibGUnKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbiAtIFRva2VuIGFkZHJlc3Mgb24gY3VycmVudGx5IGNvbmZpZ3VyZWQgdG9rZW4gbmV0d29yayByZWdpc3RyeVxuICAgICAqIEBwYXJhbSBwYXJ0bmVyIC0gUGFydG5lciBhZGRyZXNzXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB0eCBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3Via2V5IC0gQnkgZGVmYXVsdCwgaWYgdXNpbmcgc3Via2V5LCBtYWluIGFjY291bnQgaXMgdXNlZCB0byBzZW5kIHRyYW5zYWN0aW9uc1xuICAgICAqICAgIFNldCB0aGlzIHRvIHRydWUgaWYgb25lIHdhbnRzIHRvIGZvcmNlIHNlbmRpbmcgdGhlIHRyYW5zYWN0aW9uIHdpdGggdGhlIHN1YmtleVxuICAgICAqIEByZXR1cm5zIHR4SGFzaCBvZiBjbG9zZUNoYW5uZWwgY2FsbCwgaWZmIGl0IHN1Y2NlZWRlZFxuICAgICAqL1xuICAgIGNsb3NlQ2hhbm5lbCh0b2tlbiwgcGFydG5lciwgeyBzdWJrZXkgfSA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhc3NlcnQoQWRkcmVzcy5pcyh0b2tlbikgJiYgQWRkcmVzcy5pcyhwYXJ0bmVyKSwgJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5OZXR3b3JrID0gc3RhdGUudG9rZW5zW3Rva2VuXTtcbiAgICAgICAgICAgIGFzc2VydCh0b2tlbk5ldHdvcmssICdVbmtub3duIHRva2VuIG5ldHdvcmsnKTtcbiAgICAgICAgICAgIGFzc2VydCghc3Via2V5IHx8IHRoaXMuZGVwcy5tYWluLCBcIkNhbid0IHNlbmQgdHggZnJvbSBzdWJrZXkgaWYgbm90IHNldFwiKTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSB7IHRva2VuTmV0d29yaywgcGFydG5lciB9O1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGFzeW5jQWN0aW9uVG9Qcm9taXNlKGNoYW5uZWxDbG9zZSwgbWV0YSwgdGhpcy5hY3Rpb24kLCB0cnVlKS50aGVuKCh7IHR4SGFzaCB9KSA9PiB0eEhhc2gpO1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChjaGFubmVsQ2xvc2UucmVxdWVzdChzdWJrZXkgPyB7IHN1YmtleSB9IDogdW5kZWZpbmVkLCBtZXRhKSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHRsZSBjaGFubmVsIGJldHdlZW4gdXMgYW5kIHBhcnRuZXIgb24gdG9rZW5OZXR3b3JrIGZvciB0b2tlblxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgZmFpbCBpZiBjYWxsZWQgb24gYSBjaGFubmVsIG5vdCBpbiAnc2V0dGxlYWJsZScgb3IgJ3NldHRsaW5nJyBzdGF0ZS5cbiAgICAgKiBDaGFubmVsIGJlY29tZXMgJ3NldHRsZWFibGUnIHNldHRsZVRpbWVvdXQgYmxvY2tzIGFmdGVyIGNsb3NlZCAoZGV0ZWN0ZWQgYXV0b21hdGljYWxseVxuICAgICAqIHdoaWxlIFJhaWRlbiBMaWdodCBDbGllbnQgaXMgcnVubmluZyBvciBsYXRlciBvbiByZXN0YXJ0KS4gV2hlbiBjYWxsaW5nIGl0LCBjaGFubmVsIHN0YXRlXG4gICAgICogYmVjb21lcyAnc2V0dGxpbmcnLiBJZiBmb3IgYW55IHJlYXNvbiB0cmFuc2FjdGlvbiBmYWlscywgaXQnbGwgc3RheSBvbiB0aGlzIHN0YXRlLCBhbmQgdGhpc1xuICAgICAqIG1ldGhvZCBjYW4gYmUgY2FsbGVkIGFnYWluIHRvIHJlLXNlbmQgYSBzZXR0bGVDaGFubmVsIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIC0gVG9rZW4gYWRkcmVzcyBvbiBjdXJyZW50bHkgY29uZmlndXJlZCB0b2tlbiBuZXR3b3JrIHJlZ2lzdHJ5XG4gICAgICogQHBhcmFtIHBhcnRuZXIgLSBQYXJ0bmVyIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHR4IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdWJrZXkgLSBCeSBkZWZhdWx0LCBpZiB1c2luZyBzdWJrZXksIG1haW4gYWNjb3VudCBpcyB1c2VkIHRvIHNlbmQgdHJhbnNhY3Rpb25zXG4gICAgICogICAgU2V0IHRoaXMgdG8gdHJ1ZSBpZiBvbmUgd2FudHMgdG8gZm9yY2Ugc2VuZGluZyB0aGUgdHJhbnNhY3Rpb24gd2l0aCB0aGUgc3Via2V5XG4gICAgICogQHJldHVybnMgdHhIYXNoIG9mIHNldHRsZUNoYW5uZWwgY2FsbCwgaWZmIGl0IHN1Y2NlZWRlZFxuICAgICAqL1xuICAgIHNldHRsZUNoYW5uZWwodG9rZW4sIHBhcnRuZXIsIHsgc3Via2V5IH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYXNzZXJ0KEFkZHJlc3MuaXModG9rZW4pICYmIEFkZHJlc3MuaXMocGFydG5lciksICdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuTmV0d29yayA9IHN0YXRlLnRva2Vuc1t0b2tlbl07XG4gICAgICAgICAgICBhc3NlcnQodG9rZW5OZXR3b3JrLCAnVW5rbm93biB0b2tlbiBuZXR3b3JrJyk7XG4gICAgICAgICAgICBhc3NlcnQoIXN1YmtleSB8fCB0aGlzLmRlcHMubWFpbiwgXCJDYW4ndCBzZW5kIHR4IGZyb20gc3Via2V5IGlmIG5vdCBzZXRcIik7XG4gICAgICAgICAgICAvLyB3YWl0IGZvciB0aGUgY29ycmVzcG9uZGluZyBzdWNjZXNzIG9yIGVycm9yIGFjdGlvblxuICAgICAgICAgICAgY29uc3QgbWV0YSA9IHsgdG9rZW5OZXR3b3JrLCBwYXJ0bmVyIH07XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gYXN5bmNBY3Rpb25Ub1Byb21pc2UoY2hhbm5lbFNldHRsZSwgbWV0YSwgdGhpcy5hY3Rpb24kLCB0cnVlKS50aGVuKCh7IHR4SGFzaCB9KSA9PiB0eEhhc2gpO1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChjaGFubmVsU2V0dGxlLnJlcXVlc3Qoc3Via2V5ID8geyBzdWJrZXkgfSA6IHVuZGVmaW5lZCwgbWV0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCBkZXNjcmliaW5nIGFkZHJlc3MncyB1c2VycyBhdmFpbGFiaWxpdHkgb24gdHJhbnNwb3J0XG4gICAgICogQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCwgYW55IGZ1cnRoZXIgcHJlc2VuY2UgdXBkYXRlIHRvIHZhbGlkIHRyYW5zcG9ydCBwZWVycyBvZiB0aGlzXG4gICAgICogYWRkcmVzcyB3aWxsIHRyaWdnZXIgYSBjb3JyZXNwb25kaW5nIE1hdHJpeFByZXNlbmNlVXBkYXRlQWN0aW9uIG9uIGV2ZW50cyRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gY2hlY2tzdW1tZWQgYWRkcmVzcyB0byBiZSBtb25pdG9yZWRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRvIG9iamVjdCBkZXNjcmliaW5nIGF2YWlsYWJpbGl0eSBhbmQgbGFzdCBldmVudCB0aW1lc3RhbXBcbiAgICAgKi9cbiAgICBnZXRBdmFpbGFiaWxpdHkoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYXNzZXJ0KEFkZHJlc3MuaXMoYWRkcmVzcyksICdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSB7IGFkZHJlc3MgfTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBhc3luY0FjdGlvblRvUHJvbWlzZShtYXRyaXhQcmVzZW5jZSwgbWV0YSwgdGhpcy5hY3Rpb24kKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2gobWF0cml4UHJlc2VuY2UucmVxdWVzdCh1bmRlZmluZWQsIG1ldGEpKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIExvY2tlZCBUcmFuc2ZlciFcbiAgICAgKiBUaGlzIHdpbGwgcmVqZWN0IGlmIExvY2tlZFRyYW5zZmVyIHNpZ25hdHVyZSBwcm9tcHQgaXMgY2FuY2VsZWQvc2lnbmF0dXJlIGZhaWxzLCBvciBiZVxuICAgICAqIHJlc29sdmVkIHRvIHRoZSB0cmFuc2ZlciB1bmlxdWUgaWRlbnRpZmllciAoc2VjcmV0aGFzaCkgb3RoZXJ3aXNlLCBhbmQgdHJhbnNmZXIgc3RhdHVzIGNhbiBiZVxuICAgICAqIHF1ZXJpZWQgd2l0aCB0aGlzIGlkIG9uIHRoaXMudHJhbnNmZXJzJCBvYnNlcnZhYmxlLCB3aGljaCB3aWxsIGp1c3QgaGF2ZSBlbWl0dGVkIHRoZSAncGVuZGluZydcbiAgICAgKiB0cmFuc2Zlci4gQW55IGZvbGxvd2luZyB0cmFuc2ZlciBzdGF0ZSBjaGFuZ2Ugd2lsbCBiZSBub3RpZmllZCB0aHJvdWdoIHRoaXMgb2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbiAtIFRva2VuIGFkZHJlc3Mgb24gY3VycmVudGx5IGNvbmZpZ3VyZWQgdG9rZW4gbmV0d29yayByZWdpc3RyeVxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUYXJnZXQgYWRkcmVzcyAobXVzdCBiZSBnZXRBdmFpbGFiaWxpdHkgYmVmb3JlKVxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIEFtb3VudCB0byB0cnkgdG8gdHJhbnNmZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRyYW5zZmVyOlxuICAgICAqICAgIDx1bD5cbiAgICAgKiAgICAgIDxsaT5wYXltZW50SWQgLSBwYXltZW50IGlkZW50aWZpZXIsIGEgcmFuZG9tIG9uZSB3aWxsIGJlIGdlbmVyYXRlZCBpZiBtaXNzaW5nPC9saT5cbiAgICAgKiAgICAgIDxsaT5zZWNyZXQgLSBTZWNyZXQgdG8gcmVnaXN0ZXIsIGEgcmFuZG9tIG9uZSB3aWxsIGJlIGdlbmVyYXRlZCBpZiBtaXNzaW5nPC9saT5cbiAgICAgKiAgICAgIDxsaT5zZWNyZXRoYXNoIC0gTXVzdCBtYXRjaCBzZWNyZXQsIGlmIGJvdGggcHJvdmlkZWQsIG9yIGVsc2UsIHNlY3JldCBtdXN0IGJlXG4gICAgICogICAgICAgICAgaW5mb3JtZWQgdG8gdGFyZ2V0IGJ5IG90aGVyIG1lYW5zLCBhbmQgcmV2ZWFsIGNhbid0IGJlIHBlcmZvcm1lZDwvbGk+XG4gICAgICogICAgICA8bGk+cGF0aHMgLSBVc2VkIHRvIHNwZWNpZnkgcG9zc2libGUgcm91dGVzICYgZmVlcyBpbnN0ZWFkIG9mIHF1ZXJ5aW5nIFBGUy48L2xpPlxuICAgICAqICAgICAgPGxpPnBmcyAtIFVzZSB0aGlzIFBGUyBpbnN0ZWFkIG9mIGNvbmZpZ3VyZWQgb3IgYXV0b21hdGljYWxseSBjaG9vc2VuIG9uZXMuXG4gICAgICogICAgICAgICAgSXMgaWdub3JlZCBpZiBwYXRocyB3ZXJlIGFscmVhZHkgcHJvdmlkZWQuIElmIG5laXRoZXIgYXJlIHNldCBhbmQgY29uZmlnLnBmcyBpcyBub3RcbiAgICAgKiAgICAgICAgICBkaXNhYmxlZCAobnVsbCksIHVzZSBpdCBpZiBzZXQgb3IgaWYgdW5kZWZpbmVkIChhdXRvIG1vZGUpLCBmZXRjaGVzIHRoZSBiZXN0XG4gICAgICogICAgICAgICAgUEZTIGZyb20gU2VydmljZVJlZ2lzdHJ5IGFuZCBhdXRvbWF0aWNhbGx5IGZldGNoIHJvdXRlcyBmcm9tIGl0LjwvbGk+XG4gICAgICogICAgPC91bD5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdG8gdHJhbnNmZXIncyBzZWNyZXRoYXNoICh1bmlxdWUgaWQpIHdoZW4gaXQncyBhY2NlcHRlZFxuICAgICAqL1xuICAgIHRyYW5zZmVyKHRva2VuLCB0YXJnZXQsIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGFzc2VydChBZGRyZXNzLmlzKHRva2VuKSAmJiBBZGRyZXNzLmlzKHRhcmdldCksICdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuTmV0d29yayA9IHRoaXMuc3RhdGUudG9rZW5zW3Rva2VuXTtcbiAgICAgICAgICAgIGFzc2VydCh0b2tlbk5ldHdvcmssICdVbmtub3duIHRva2VuIG5ldHdvcmsnKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWRWYWx1ZSA9IGRlY29kZShVSW50KDMyKSwgdmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgcGF5bWVudElkID0gb3B0aW9ucy5wYXltZW50SWQgPyBkZWNvZGUoVUludCg4KSwgb3B0aW9ucy5wYXltZW50SWQpIDogbWFrZVBheW1lbnRJZCgpO1xuICAgICAgICAgICAgY29uc3QgcGF0aHMgPSBvcHRpb25zLnBhdGhzID8gZGVjb2RlKFBhdGhzLCBvcHRpb25zLnBhdGhzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHBmcyA9IG9wdGlvbnMucGZzID8gZGVjb2RlKFBGUywgb3B0aW9ucy5wZnMpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgYXNzZXJ0KG9wdGlvbnMuc2VjcmV0ID09PSB1bmRlZmluZWQgfHwgU2VjcmV0LmlzKG9wdGlvbnMuc2VjcmV0KSwgJ0ludmFsaWQgb3B0aW9ucy5zZWNyZXQnKTtcbiAgICAgICAgICAgIGFzc2VydChvcHRpb25zLnNlY3JldGhhc2ggPT09IHVuZGVmaW5lZCB8fCBIYXNoLmlzKG9wdGlvbnMuc2VjcmV0aGFzaCksICdJbnZhbGlkIG9wdGlvbnMuc2VjcmV0aGFzaCcpO1xuICAgICAgICAgICAgLy8gdXNlIHByb3ZpZGVkIHNlY3JldCBvciBjcmVhdGUgb25lIGlmIG5vIHNlY3JldGhhc2ggd2FzIHByb3ZpZGVkXG4gICAgICAgICAgICBjb25zdCBzZWNyZXQgPSBvcHRpb25zLnNlY3JldFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5zZWNyZXRcbiAgICAgICAgICAgICAgICA6ICFvcHRpb25zLnNlY3JldGhhc2hcbiAgICAgICAgICAgICAgICAgICAgPyBtYWtlU2VjcmV0KClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBzZWNyZXRoYXNoID0gb3B0aW9ucy5zZWNyZXRoYXNoIHx8IGdldFNlY3JldGhhc2goc2VjcmV0KTtcbiAgICAgICAgICAgIGFzc2VydCghc2VjcmV0IHx8IGdldFNlY3JldGhhc2goc2VjcmV0KSA9PT0gc2VjcmV0aGFzaCwgJ1Byb3ZpZGVkIHNlY3JldGhhc2ggbXVzdCBtYXRjaCB0aGUgc2hhMjU2IGhhc2ggb2YgcHJvdmlkZWQgc2VjcmV0Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXRoRmluZE1ldGEgPSB7IHRva2VuTmV0d29yaywgdGFyZ2V0LCB2YWx1ZTogZGVjb2RlZFZhbHVlIH07XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2UoXG4gICAgICAgICAgICAvLyB3YWl0IGZvciBwYXRoRmluZCByZXNwb25zZVxuICAgICAgICAgICAgdGhpcy5hY3Rpb24kLnBpcGUoZmlyc3QoaXNSZXNwb25zZU9mKHBhdGhGaW5kLCBwYXRoRmluZE1ldGEpKSwgbWFwKChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aEZpbmQuZmFpbHVyZS5pcyhhY3Rpb24pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uLnBheWxvYWQucGF0aHM7XG4gICAgICAgICAgICB9KSksIFxuICAgICAgICAgICAgLy8gcmVxdWVzdCBwYXRoRmluZDsgZXZlbiBpZiBwYXRocyB3ZXJlIHByb3ZpZGVkLCBzZW5kIGl0IGFnYWluIGZvciB2YWxpZGF0aW9uXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGRvbmUgYXQgJ21lcmdlJyBzdWJzY3JpcHRpb24gdGltZSAoaS5lLiB3aGVuIGFib3ZlIGFjdGlvbiBmaWx0ZXIgaXMgc3Vic2NyaWJlZClcbiAgICAgICAgICAgIGRlZmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHBhdGhGaW5kLnJlcXVlc3QoeyBwYXRocywgcGZzIH0sIHBhdGhGaW5kTWV0YSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBFTVBUWTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC5waXBlKG1lcmdlTWFwKChwYXRocykgPT4gbWVyZ2UoXG4gICAgICAgICAgICAvLyB3YWl0IGZvciB0cmFuc2ZlciByZXNwb25zZVxuICAgICAgICAgICAgdGhpcy5hY3Rpb24kLnBpcGUoZmlsdGVyKGlzQWN0aW9uT2YoW3RyYW5zZmVyU2lnbmVkLCB0cmFuc2Zlci5mYWlsdXJlXSkpLCBmaXJzdCgoYWN0aW9uKSA9PiBhY3Rpb24ubWV0YS5zZWNyZXRoYXNoID09PSBzZWNyZXRoYXNoKSwgbWFwKChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmZXIuZmFpbHVyZS5pcyhhY3Rpb24pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VjcmV0aGFzaDtcbiAgICAgICAgICAgIH0pKSwgXG4gICAgICAgICAgICAvLyByZXF1ZXN0IHRyYW5zZmVyIHdpdGggcmV0dXJuZWQvdmFsaWRhdGVkIHBhdGhzIGF0ICdtZXJnZScgc3Vic2NyaXB0aW9uIHRpbWVcbiAgICAgICAgICAgIGRlZmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHRyYW5zZmVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICB0b2tlbk5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRlY29kZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMsXG4gICAgICAgICAgICAgICAgICAgIHBheW1lbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgc2VjcmV0LFxuICAgICAgICAgICAgICAgIH0sIHsgc2VjcmV0aGFzaCwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uU0VOVCB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZO1xuICAgICAgICAgICAgfSkpKSlcbiAgICAgICAgICAgICAgICAudG9Qcm9taXNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgdGhlIHRyYW5zZmVyIGlkZW50aWZpZWQgYnkgYSBzZWNyZXRoYXNoIHRvIGZhaWwgb3IgY29tcGxldGVcbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgcmVzb2x2ZSB3aXRoIHRoZSBmaW5hbCBhbW91bnQgcmVjZWl2ZWQgYnkgdGhlIHRhcmdldFxuICAgICAqXG4gICAgICogQHBhcmFtIHNlY3JldGhhc2ggLSBUcmFuc2ZlciBpZGVudGlmaWVyXG4gICAgICogQHJldHVybnMgQW1vdW50IHJlY2VpdmVkIGJ5IHRhcmdldCwgYXMgaW5mb3JtZWQgYnkgdGhlbSBvbiBTZWNyZXRSZXF1ZXN0XG4gICAgICovXG4gICAgd2FpdFRyYW5zZmVyKHNlY3JldGhhc2gpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYXNzZXJ0KEhhc2guaXMoc2VjcmV0aGFzaCksICdJbnZhbGlkIHNlY3JldGhhc2ggZm9yIHRyYW5zZmVyJyk7XG4gICAgICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgYXNzZXJ0KHNlY3JldGhhc2ggaW4gc3RhdGUuc2VudCwgJ1Vua25vd24gc2VjcmV0aGFzaCcpO1xuICAgICAgICAgICAgY29uc3Qgc2VudCA9IHJhaWRlblNlbnRUcmFuc2ZlcihzdGF0ZS5zZW50W3NlY3JldGhhc2hdKTtcbiAgICAgICAgICAgIC8vIGFscmVhZHkgY29tcGxldGVkL3Bhc3QgdHJhbnNmZXJcbiAgICAgICAgICAgIGlmIChzZW50LmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChzZW50LnN1Y2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLnNlbnRbc2VjcmV0aGFzaF0uc2VjcmV0UmVxdWVzdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzFdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYW1vdW50O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhaWRlbkVycm9yKEVycm9yQ29kZXMuWEZFUl9BTFJFQURZX0NPTVBMRVRFRCwgeyBzdGF0dXM6IHNlbnQuc3RhdHVzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhyb3dzL3JlamVjdHMgaWYgYSBmYWlsdXJlIG9jY3Vyc1xuICAgICAgICAgICAgeWllbGQgYXN5bmNBY3Rpb25Ub1Byb21pc2UodHJhbnNmZXIsIHsgc2VjcmV0aGFzaCwgZGlyZWN0aW9uOiBEaXJlY3Rpb24uU0VOVCB9LCB0aGlzLmFjdGlvbiQpO1xuICAgICAgICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIChfZCA9IChfYyA9IHN0YXRlLnNlbnRbc2VjcmV0aGFzaF0uc2VjcmV0UmVxdWVzdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jWzFdKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYW1vdW50O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBhIHBhdGggZnJvbSBQRlNcbiAgICAgKlxuICAgICAqIElmIGEgZGlyZWN0IHJvdXRlIGlzIHBvc3NpYmxlLCBpdCdsbCBiZSByZXR1cm5lZC4gRWxzZSBpZiBQRlMgaXMgc2V0IHVwLCBhIHJlcXVlc3Qgd2lsbCBiZVxuICAgICAqIHBlcmZvcm1lZCBhbmQgdGhlIGNsZWFuZWQvdmFsaWRhdGVkIHBhdGggcmVzdWx0cyB3aWxsIGJlIHJlc29sdmVkLlxuICAgICAqIEVsc2UsIGlmIG5vIHJvdXRlIGNhbiBiZSBmb3VuZCwgcHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIHJlc3BlY3RpdmUgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBUb2tlbiBhZGRyZXNzIG9uIGN1cnJlbnRseSBjb25maWd1cmVkIHRva2VuIG5ldHdvcmsgcmVnaXN0cnlcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGFyZ2V0IGFkZHJlc3MgKG11c3QgYmUgZ2V0QXZhaWxhYmlsaXR5IGJlZm9yZSlcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBNaW5pbXVtIGNhcGFjaXR5IHJlcXVpcmVkIG9uIHJvdXRlc1xuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnBmcyAtIFVzZSB0aGlzIFBGUyBpbnN0ZWFkIG9mIGNvbmZpZ3VyZWQgb3IgYXV0b21hdGljYWxseSBjaG9vc2VuIG9uZXNcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdG8gcmV0dXJuZWQgcm91dGVzL3BhdGhzIHJlc3VsdFxuICAgICAqL1xuICAgIGZpbmRSb3V0ZXModG9rZW4sIHRhcmdldCwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYXNzZXJ0KEFkZHJlc3MuaXModG9rZW4pICYmIEFkZHJlc3MuaXModGFyZ2V0KSwgJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5OZXR3b3JrID0gdGhpcy5zdGF0ZS50b2tlbnNbdG9rZW5dO1xuICAgICAgICAgICAgYXNzZXJ0KHRva2VuTmV0d29yaywgJ1Vua25vd24gdG9rZW4gbmV0d29yaycpO1xuICAgICAgICAgICAgY29uc3QgZGVjb2RlZFZhbHVlID0gZGVjb2RlKFVJbnQoMzIpLCB2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBwZnMgPSBvcHRpb25zLnBmcyA/IGRlY29kZShQRlMsIG9wdGlvbnMucGZzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSB7IHRva2VuTmV0d29yaywgdGFyZ2V0LCB2YWx1ZTogZGVjb2RlZFZhbHVlIH07XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gYXN5bmNBY3Rpb25Ub1Byb21pc2UocGF0aEZpbmQsIG1ldGEsIHRoaXMuYWN0aW9uJCkudGhlbigoeyBwYXRocyB9KSA9PiBwYXRocyk7XG4gICAgICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKHBhdGhGaW5kLnJlcXVlc3QoeyBwZnMgfSwgbWV0YSkpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBkaXJlY3QgdHJhbnNmZXIgb2YgdG9rZW4gdG8gdGFyZ2V0IGNvdWxkIGJlIHBlcmZvcm1lZCBhbmQgcmV0dXJucyBpdCBvbiBhXG4gICAgICogc2luZ2xlLWVsZW1lbnQgYXJyYXkgb2YgUGF0aHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbiAtIFRva2VuIGFkZHJlc3Mgb24gY3VycmVudGx5IGNvbmZpZ3VyZWQgdG9rZW4gbmV0d29yayByZWdpc3RyeVxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUYXJnZXQgYWRkcmVzcyAobXVzdCBiZSBnZXRBdmFpbGFiaWxpdHkgYmVmb3JlKVxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIE1pbmltdW0gY2FwYWNpdHkgcmVxdWlyZWQgb24gcm91dGVcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRvIGEgW1JhaWRlbl1QYXRocyBhcnJheSBjb250YWluaW5nIHRoZSBzaW5nbGUsIGRpcmVjdCByb3V0ZSwgb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgZGlyZWN0Um91dGUodG9rZW4sIHRhcmdldCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGFzc2VydChBZGRyZXNzLmlzKHRva2VuKSAmJiBBZGRyZXNzLmlzKHRhcmdldCksICdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuTmV0d29yayA9IHRoaXMuc3RhdGUudG9rZW5zW3Rva2VuXTtcbiAgICAgICAgICAgIGFzc2VydCh0b2tlbk5ldHdvcmssICdVbmtub3duIHRva2VuIG5ldHdvcmsnKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZWRWYWx1ZSA9IGRlY29kZShVSW50KDMyKSwgdmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgbWV0YSA9IHsgdG9rZW5OZXR3b3JrLCB0YXJnZXQsIHZhbHVlOiBkZWNvZGVkVmFsdWUgfTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBhc3luY0FjdGlvblRvUHJvbWlzZShwYXRoRmluZCwgbWV0YSwgdGhpcy5hY3Rpb24kKS50aGVuKCh7IHBhdGhzIH0pID0+IHBhdGhzLCAvLyBwbHVjayBwYXRoc1xuICAgICAgICAgICAgKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIC8vIGRpc3BhdGNoIGEgcGF0aEZpbmQgd2l0aCBwZnMgZGlzYWJsZWQsIHRvIGZvcmNlIGNoZWNraW5nIGZvciBhIGRpcmVjdCByb3V0ZVxuICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaChwYXRoRmluZC5yZXF1ZXN0KHsgcGZzOiBudWxsIH0sIG1ldGEpKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNvcnRlZCBhcnJheSBvZiBpbmZvIG9mIGF2YWlsYWJsZSBQRlNcbiAgICAgKlxuICAgICAqIEl0IHVzZXMgZGF0YSBwb2xsZWQgZnJvbSBTZXJ2aWNlUmVnaXN0cnksIHdoaWNoIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gY29uZmlnLnBmcyBpc1xuICAgICAqIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBzZXQgb3IgZGlzYWJsZWQgKG51bGwpLCBhbmQgd2lsbCByZWplY3QgaWYgbm90LlxuICAgICAqIEl0IGNhbiByZWplY3QgaWYgdGhlIHZhbGlkYXRlZCBsaXN0IGlzIGVtcHR5LCBtZWFuaW5nIHdlIGNhbiBiZSBvdXQtb2Ytc3luYyAod2UncmUgb3V0ZGF0ZWQgb3JcbiAgICAgKiB0aGV5IGFyZSkgd2l0aCBQRlNzIGRlcGxveW1lbnQsIG9yIG5vIFBGUyBpcyBhdmFpbGFibGUgb24gdGhpcyBUb2tlbk5ldHdvcmsvYmxvY2tjaGFpbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdG8gYXJyYXkgb2YgUEZTLCB3aGljaCBpcyB0aGUgaW50ZXJmYWNlIHdoaWNoIGRlc2NyaWJlcyBhIFBGU1xuICAgICAqL1xuICAgIGZpbmRQRlMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5jb25maWcucGZzICE9PSBudWxsLCAnUEZTIGRpc2FibGVkIGluIGNvbmZpZycpO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNvbmZpZy5wZnNcbiAgICAgICAgICAgICAgICA/IG9mKFt0aGlzLmNvbmZpZy5wZnNdKVxuICAgICAgICAgICAgICAgIDogdGhpcy5kZXBzLmxhdGVzdCQucGlwZShwbHVja0Rpc3RpbmN0KCdwZnNMaXN0JyksIGZpcnN0KCh2KSA9PiB2Lmxlbmd0aCA+IDApKSlcbiAgICAgICAgICAgICAgICAucGlwZShtZXJnZU1hcCgocGZzTGlzdCkgPT4gcGZzTGlzdEluZm8ocGZzTGlzdCwgdGhpcy5kZXBzKSkpXG4gICAgICAgICAgICAgICAgLnRvUHJvbWlzZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWludHMgdGhlIGFtb3VudCBvZiB0b2tlbnMgb2YgdGhlIHByb3ZpZGVkIHRva2VuIGFkZHJlc3MuXG4gICAgICogVGhyb3dzIGFuIGVycm9yLCBpZlxuICAgICAqIDxvbD5cbiAgICAgKiAgPGxpPkV4ZWN1dGVkIG9uIG1haW4gbmV0PC9saT5cbiAgICAgKiAgPGxpPmB0b2tlbmAgaXMgbm90IGEgdmFsaWQgYWRkcmVzczwvbGk+XG4gICAgICogIDxsaT5Ub2tlbiBjb3VsZCBub3QgYmUgbWludGVkPC9saT5cbiAgICAgKiA8L29sPlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIC0gQWRkcmVzcyBvZiB0aGUgdG9rZW4gdG8gYmUgbWludGVkXG4gICAgICogQHBhcmFtIGFtb3VudCAtIEFtb3VudCB0byBiZSBtaW50ZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIHR4IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdWJrZXkgLSBCeSBkZWZhdWx0LCBpZiB1c2luZyBzdWJrZXksIG1haW4gYWNjb3VudCBpcyB1c2VkIHRvIHNlbmQgdHJhbnNhY3Rpb25zXG4gICAgICogICAgTm90aWNlIHRoZSBiZW5lZmljaWFyeSBoZXJlIGlzIGFsd2F5cyB0aGUgYWNjb3VudCB0aGF0IHNlbmRzIHRoZSB0cmFuc2FjdGlvbiwgYXMgdGhpcyBpc1xuICAgICAqICAgIGV4cGVjdGVkbHkgYWxzbyB0aGUgYWNjb3VudCB0aGF0IHdpbGwgcGF5IGZvciBlLmcuIGZ1dHVyZSBkZXBvc2l0cy5cbiAgICAgKiAgICBTZXQgdGhpcyB0byB0cnVlIGlmIG9uZSB3YW50cyB0byBmb3JjZSBzZW5kaW5nIHRoZSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBzdWJrZXlcbiAgICAgKiBAcmV0dXJucyB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIG1pbnQodG9rZW4sIGFtb3VudCwgeyBzdWJrZXkgfSA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIGFkZHJlc3MgaXMgdmFsaWRcbiAgICAgICAgICAgIGFzc2VydChBZGRyZXNzLmlzKHRva2VuKSwgJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgICAgICAgICAgYXNzZXJ0KCFzdWJrZXkgfHwgdGhpcy5kZXBzLm1haW4sIFwiQ2FuJ3Qgc2VuZCB0eCBmcm9tIHN1YmtleSBpZiBub3Qgc2V0XCIpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB3ZSBhcmUgb24gYSB0ZXN0IG5ldHdvcmtcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLmRlcHMubmV0d29yay5uYW1lICE9PSAnaG9tZXN0ZWFkJywgJ01pbnRpbmcgaXMgb25seSBhbGxvd2VkIG9uIHRlc3QgbmV0d29ya3MuJyk7XG4gICAgICAgICAgICBjb25zdCB7IHNpZ25lciB9ID0gY2hvb3NlT25jaGFpbkFjY291bnQodGhpcy5kZXBzLCBzdWJrZXkgIT09IG51bGwgJiYgc3Via2V5ICE9PSB2b2lkIDAgPyBzdWJrZXkgOiB0aGlzLmNvbmZpZy5zdWJrZXkpO1xuICAgICAgICAgICAgLy8gTWludCB0b2tlblxuICAgICAgICAgICAgY29uc3QgY3VzdG9tVG9rZW5Db250cmFjdCA9IEN1c3RvbVRva2VuRmFjdG9yeS5jb25uZWN0KHRva2VuLCBzaWduZXIpO1xuICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IHlpZWxkIGNhbGxBbmRXYWl0TWluZWQoY3VzdG9tVG9rZW5Db250cmFjdCwgJ21pbnQnLCBbZGVjb2RlKFVJbnQoMzIpLCBhbW91bnQpXSwgRXJyb3JDb2Rlcy5SRE5fTUlOVF9GQUlMRUQsIHsgbG9nOiB0aGlzLmxvZyB9KTtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIGEgc2luZ2xlIGJsb2NrLCBzbyBmdXR1cmUgY2FsbHMgd2lsbCBjb3JyZWN0bHkgcGljayB2YWx1ZVxuICAgICAgICAgICAgeWllbGQgd2FpdENvbmZpcm1hdGlvbihyZWNlaXB0LCB0aGlzLmRlcHMsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQudHJhbnNhY3Rpb25IYXNoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBiYWxhbmNlIG9mIFVzZXJEZXBvc2l0IENvbnRyYWN0IGZvciBTREsncyBhY2NvdW50IG1pbnVzIGNhY2hlZCBzcGVudCBJT1VzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRvIFVEQyByZW1haW5pbmcgY2FwYWNpdHlcbiAgICAgKi9cbiAgICBnZXRVRENDYXBhY2l0eSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSB5aWVsZCB0aGlzLmRlcHMudXNlckRlcG9zaXRDb250cmFjdC5mdW5jdGlvbnMuYmFsYW5jZXModGhpcy5kZXBzLmFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB0aGlzLnN0YXRlLmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgY29uc3Qgb3dlZEFtb3VudCA9IE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZS5wYXRoLmlvdSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9uRXhwaXJlZElPVXMgPSBPYmplY3QudmFsdWVzKHZhbHVlKS5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZS5leHBpcmF0aW9uX2Jsb2NrLmd0ZShibG9ja051bWJlcikpO1xuICAgICAgICAgICAgICAgIGFjYy5wdXNoKC4uLm5vbkV4cGlyZWRJT1VzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwgbmV3IEFycmF5KCkpXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjLCBpb3UpID0+IGFjYy5hZGQoaW91LmFtb3VudCksIFplcm8pO1xuICAgICAgICAgICAgcmV0dXJuIGJhbGFuY2Uuc3ViKG93ZWRBbW91bnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwb3NpdHMgdGhlIGFtb3VudCB0byB0aGUgVXNlckRlcG9zaXQgY29udHJhY3Qgd2l0aCB0aGUgdGFyZ2V0L3NpZ25lciBhcyBhIGJlbmVmaWNpYXJ5LlxuICAgICAqIFRoZSBkZXBvc2l0ZWQgYW1vdW50IGNhbiBiZSB1c2VkIGFzIGEgY29sbGF0ZXJhbCBpbiBvcmRlciB0byBzaWduIHZhbGlkIElPVXMgdGhhdCB3aWxsXG4gICAgICogYmUgYWNjZXB0ZWQgYnkgdGhlIFNlcnZpY2VzLlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yLCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAqIDxvbD5cbiAgICAgKiAgPGxpPlRoZSBhbW91bnQgc3BlY2lmaWVkIGVxdWFscyB0byB6ZXJvPC9saT5cbiAgICAgKiAgPGxpPlRoZSB0YXJnZXQgaGFzIGFuIGluc3VmZmljaWVudCB0b2tlbiBiYWxhbmNlPC9saT5cbiAgICAgKiAgPGxpPlRoZSBcImFwcHJvdmVcIiB0cmFuc2FjdGlvbiBmYWlscyB3aXRoIGFuIGVycm9yPC9saT5cbiAgICAgKiAgPGxpPlRoZSBcImRlcG9zaXRcIiB0cmFuc2FjdGlvbiBmYWlscyB3aXRoIGFuIGVycm9yPC9saT5cbiAgICAgKiA8L29sPlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgdG8gZGVwb3NpdCBvbiBiZWhhbGYgb2YgdGhlIHRhcmdldC9iZW5lZmljaWFyeS5cbiAgICAgKiBAcGFyYW0gb25DaGFuZ2UgLSBjYWxsYmFjayBwcm92aWRpbmcgbm90aWZpY2F0aW9ucyBhYm91dCBzdGF0ZSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSB0eCBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3Via2V5IC0gQnkgZGVmYXVsdCwgaWYgdXNpbmcgc3Via2V5LCBtYWluIGFjY291bnQgaXMgdXNlZCB0byBzZW5kIHRyYW5zYWN0aW9uc1xuICAgICAqICAgIFNldCB0aGlzIHRvIHRydWUgaWYgb25lIHdhbnRzIHRvIGZvcmNlIHNlbmRpbmcgdGhlIHRyYW5zYWN0aW9uIHdpdGggdGhlIHN1YmtleVxuICAgICAqIEByZXR1cm5zIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgKi9cbiAgICBkZXBvc2l0VG9VREMoYW1vdW50LCBvbkNoYW5nZSwgeyBzdWJrZXkgfSA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhc3NlcnQoIXN1YmtleSB8fCB0aGlzLmRlcHMubWFpbiwgXCJDYW4ndCBzZW5kIHR4IGZyb20gc3Via2V5IGlmIG5vdCBzZXRcIiwgdGhpcy5sb2cuZGVidWcpO1xuICAgICAgICAgICAgY29uc3QgZGVwb3NpdEFtb3VudCA9IGJpZ051bWJlcmlmeShhbW91bnQpO1xuICAgICAgICAgICAgYXNzZXJ0KGRlcG9zaXRBbW91bnQuZ3QoWmVybyksICdQbGVhc2UgZGVwb3NpdCBhIHBvc2l0aXZlIGFtb3VudC4nLCB0aGlzLmxvZy5kZWJ1Zyk7XG4gICAgICAgICAgICBjb25zdCB7IHNpZ25lciwgYWRkcmVzcyB9ID0gY2hvb3NlT25jaGFpbkFjY291bnQodGhpcy5kZXBzLCBzdWJrZXkgIT09IG51bGwgJiYgc3Via2V5ICE9PSB2b2lkIDAgPyBzdWJrZXkgOiB0aGlzLmNvbmZpZy5zdWJrZXkpO1xuICAgICAgICAgICAgY29uc3QgdXNlckRlcG9zaXRDb250cmFjdCA9IGdldENvbnRyYWN0V2l0aFNpZ25lcih0aGlzLmRlcHMudXNlckRlcG9zaXRDb250cmFjdCwgc2lnbmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VUb2tlbkNvbnRyYWN0ID0gZ2V0Q29udHJhY3RXaXRoU2lnbmVyKHRoaXMuZGVwcy5nZXRUb2tlbkNvbnRyYWN0KHlpZWxkIHRoaXMudXNlckRlcG9zaXRUb2tlbkFkZHJlc3MoKSksIHNpZ25lcik7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlID0geWllbGQgc2VydmljZVRva2VuQ29udHJhY3QuZnVuY3Rpb25zLmJhbGFuY2VPZihhZGRyZXNzKTtcbiAgICAgICAgICAgIGFzc2VydChiYWxhbmNlLmd0ZShhbW91bnQpLCBgSW5zdWZmaWNpZW50IHRva2VuIGJhbGFuY2UgKCR7YmFsYW5jZX0pLmAsIHRoaXMubG9nLmRlYnVnKTtcbiAgICAgICAgICAgIGNvbnN0IGFwcHJvdmVSZWNlaXB0ID0geWllbGQgY2FsbEFuZFdhaXRNaW5lZChzZXJ2aWNlVG9rZW5Db250cmFjdCwgJ2FwcHJvdmUnLCBbdXNlckRlcG9zaXRDb250cmFjdC5hZGRyZXNzLCBkZXBvc2l0QW1vdW50XSwgRXJyb3JDb2Rlcy5SRE5fQVBQUk9WRV9UUkFOU0FDVElPTl9GQUlMRUQsIHsgbG9nOiB0aGlzLmxvZyB9KTtcbiAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlcy5BUFBST1ZFRCxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgICAgIHR4SGFzaDogYXBwcm92ZVJlY2VpcHQudHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRVRENCYWxhbmNlID0geWllbGQgdXNlckRlcG9zaXRDb250cmFjdC5mdW5jdGlvbnMuYmFsYW5jZXModGhpcy5hZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGRlcG9zaXRSZWNlaXB0ID0geWllbGQgY2FsbEFuZFdhaXRNaW5lZCh1c2VyRGVwb3NpdENvbnRyYWN0LCAnZGVwb3NpdCcsIFt0aGlzLmFkZHJlc3MsIGN1cnJlbnRVRENCYWxhbmNlLmFkZChkZXBvc2l0QW1vdW50KV0sIEVycm9yQ29kZXMuUkROX0RFUE9TSVRfVFJBTlNBQ1RJT05fRkFJTEVELCB7IGxvZzogdGhpcy5sb2cgfSk7XG4gICAgICAgICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZXMuREVQT1NJVEVELFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHhIYXNoOiBkZXBvc2l0UmVjZWlwdC50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeWllbGQgd2FpdENvbmZpcm1hdGlvbihkZXBvc2l0UmVjZWlwdCwgdGhpcy5kZXBzKTtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKGBkZXBvc2l0IHR4IFwiJHtkZXBvc2l0UmVjZWlwdC50cmFuc2FjdGlvbkhhc2h9XCIgY29uZmlybWVkYCk7XG4gICAgICAgICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZXMuQ09ORklSTUVELFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHhIYXNoOiBkZXBvc2l0UmVjZWlwdC50cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRlcG9zaXRSZWNlaXB0LnRyYW5zYWN0aW9uSGFzaDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVyIHZhbHVlIEVUSCBvbi1jaGFpbiB0byBhZGRyZXNzLlxuICAgICAqIElmIHN1YmtleSBpcyBiZWluZyB1c2VkLCB1c2UgbWFpbiBhY2NvdW50IGJ5IGRlZmF1bHQsIG9yIHN1YmtleSBhY2NvdW50IGlmICdzdWJrZXknIGlzIHRydWVcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqICAgLy8gdHJhbnNmZXIgMC4xIEVUSCBmcm9tIG1haW4gYWNjb3VudCB0byBzdWJrZXkgYWNjb3VudCwgd2hlbiBzdWJrZXkgaXMgdXNlZFxuICAgICAqICAgYXdhaXQgcmFpZGVuLnRyYW5zZmVyT25jaGFpbkJhbGFuY2UocmFpZGVuLmFkZHJlc3MsIHBhcnNlRXRoZXIoJzAuMScpKTtcbiAgICAgKiAgIC8vIHRyYW5zZmVyIDAuMSBFVEggYmFjayBmcm9tIHN1YmtleSBhY2NvdW50IHRvIG1haW4gYWNjb3VudFxuICAgICAqICAgYXdhaXQgcmFpZGVuLnRyYW5zZmVyT25jaGFpbkJhbGFuY2UocmFpZGVuLm1haW5BZGRyZXNzLCBwYXJzZUV0aGVyKCcwLjEnKSwgdHJ1ZSk7XG4gICAgICogVE9ETzogZXhwb3NlIGEgbmljZSB3YXkgdG8gdHJhbnNmZXIgQUxMLCBjb25zaWRlcmluZyBnYXMgcHJpY2UgJiBsaW1pdFxuICAgICAqXG4gICAgICogQHBhcmFtIHRvIC0gUmVjaXBpZW50IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBBbW91bnQgb2YgRVRIIChpbiBXZWkpIHRvIHRyYW5zZmVyLiBVc2UgZXRoZXJzL3V0aWxzOjpwYXJzZUV0aGVyIGlmIG5lZWRlZFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gdHggb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnN1YmtleSAtIEJ5IGRlZmF1bHQsIGlmIHVzaW5nIHN1YmtleSwgbWFpbiBhY2NvdW50IGlzIHVzZWQgdG8gc2VuZCB0cmFuc2FjdGlvbnNcbiAgICAgKiAgICBTZXQgdGhpcyB0byB0cnVlIGlmIG9uZSB3YW50cyB0byBmb3JjZSBzZW5kaW5nIHRoZSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBzdWJrZXlcbiAgICAgKiBAcmV0dXJucyB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICovXG4gICAgdHJhbnNmZXJPbmNoYWluQmFsYW5jZSh0bywgdmFsdWUsIHsgc3Via2V5IH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYXNzZXJ0KEFkZHJlc3MuaXModG8pLCAnSW52YWxpZCBhZGRyZXNzJywgdGhpcy5sb2cuZGVidWcpO1xuICAgICAgICAgICAgYXNzZXJ0KCFzdWJrZXkgfHwgdGhpcy5kZXBzLm1haW4sIFwiQ2FuJ3Qgc2VuZCB0eCBmcm9tIHN1YmtleSBpZiBub3Qgc2V0XCIsIHRoaXMubG9nLmRlYnVnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVyIH0gPSBjaG9vc2VPbmNoYWluQWNjb3VudCh0aGlzLmRlcHMsIHN1YmtleSAhPT0gbnVsbCAmJiBzdWJrZXkgIT09IHZvaWQgMCA/IHN1YmtleSA6IHRoaXMuY29uZmlnLnN1YmtleSk7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHNpZ25lci5zZW5kVHJhbnNhY3Rpb24oeyB0bywgdmFsdWU6IGJpZ051bWJlcmlmeSh2YWx1ZSkgfSk7XG4gICAgICAgICAgICBjb25zdCByZWNlaXB0ID0geWllbGQgdHgud2FpdCgpO1xuICAgICAgICAgICAgaWYgKCFyZWNlaXB0LnN0YXR1cylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFpZGVuRXJyb3IoRXJyb3JDb2Rlcy5SRE5fVFJBTlNGRVJfT05DSEFJTl9CQUxBTkNFX0ZBSUxFRCk7XG4gICAgICAgICAgICByZXR1cm4gdHguaGFzaDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVyIHZhbHVlIHRva2VucyBvbi1jaGFpbiB0byBhZGRyZXNzLlxuICAgICAqIElmIHN1YmtleSBpcyBiZWluZyB1c2VkLCB1c2UgbWFpbiBhY2NvdW50IGJ5IGRlZmF1bHQsIG9yIHN1YmtleSBhY2NvdW50IGlmICdzdWJrZXknIGlzIHRydWVcbiAgICAgKiBUT0RPOiBleHBvc2UgYSBuaWNlIHdheSB0byB0cmFuc2ZlciBBTEwgdG9rZW5zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBUb2tlbiBhZGRyZXNzXG4gICAgICogQHBhcmFtIHRvIC0gUmVjaXBpZW50IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBBbW91bnQgb2YgdG9rZW5zIChpbiBXZWkpIHRvIHRyYW5zZmVyLiBVc2UgZXRoZXJzL3V0aWxzOjpwYXJzZVVuaXRzIGlmIG5lZWRlZFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gdHggb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnN1YmtleSAtIEJ5IGRlZmF1bHQsIGlmIHVzaW5nIHN1YmtleSwgbWFpbiBhY2NvdW50IGlzIHVzZWQgdG8gc2VuZCB0cmFuc2FjdGlvbnNcbiAgICAgKiAgICBTZXQgdGhpcyB0byB0cnVlIGlmIG9uZSB3YW50cyB0byBmb3JjZSBzZW5kaW5nIHRoZSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBzdWJrZXlcbiAgICAgKiBAcmV0dXJucyB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICovXG4gICAgdHJhbnNmZXJPbmNoYWluVG9rZW5zKHRva2VuLCB0bywgdmFsdWUsIHsgc3Via2V5IH0gPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYXNzZXJ0KEFkZHJlc3MuaXModG9rZW4pICYmIEFkZHJlc3MuaXModG8pLCAnSW52YWxpZCBhZGRyZXNzJywgdGhpcy5sb2cuZGVidWcpO1xuICAgICAgICAgICAgYXNzZXJ0KCFzdWJrZXkgfHwgdGhpcy5kZXBzLm1haW4sIFwiQ2FuJ3Qgc2VuZCB0eCBmcm9tIHN1YmtleSBpZiBub3Qgc2V0XCIsIHRoaXMubG9nLmRlYnVnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVyIH0gPSBjaG9vc2VPbmNoYWluQWNjb3VudCh0aGlzLmRlcHMsIHN1YmtleSAhPT0gbnVsbCAmJiBzdWJrZXkgIT09IHZvaWQgMCA/IHN1YmtleSA6IHRoaXMuY29uZmlnLnN1YmtleSk7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkNvbnRyYWN0ID0gZ2V0Q29udHJhY3RXaXRoU2lnbmVyKHRoaXMuZGVwcy5nZXRUb2tlbkNvbnRyYWN0KHRva2VuKSwgc2lnbmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSB5aWVsZCBjYWxsQW5kV2FpdE1pbmVkKHRva2VuQ29udHJhY3QsICd0cmFuc2ZlcicsIFt0bywgYmlnTnVtYmVyaWZ5KHZhbHVlKV0sIEVycm9yQ29kZXMuUkROX1RSQU5TRkVSX09OQ0hBSU5fVE9LRU5TX0ZBSUxFRCwgeyBsb2c6IHRoaXMubG9nIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQudHJhbnNhY3Rpb25IYXNoO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZGVmYXVsdCBSYWlkZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYWlkZW4uanMubWFwIiwiLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cbmV4cG9ydCB7IFJhaWRlbiB9IGZyb20gJy4vcmFpZGVuJztcbmV4cG9ydCB7IFJhaWRlblN0YXRlLCBlbmNvZGVSYWlkZW5TdGF0ZSB9IGZyb20gJy4vc3RhdGUnO1xuZXhwb3J0IHsgU2h1dGRvd25SZWFzb24gfSBmcm9tICcuL2NvbnN0YW50cyc7XG5leHBvcnQgeyBSYWlkZW5UcmFuc2ZlclN0YXR1cyB9IGZyb20gJy4vdHJhbnNmZXJzL3N0YXRlJztcbmV4cG9ydCB7IENoYW5uZWxTdGF0ZSB9IGZyb20gJy4vY2hhbm5lbHMvc3RhdGUnO1xuZXhwb3J0IHsgUmFpZGVuQ29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMvZXJyb3InO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///f455\n')},f45e:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ob1Rva2Vucy52dWU/MDY4NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJmNDVlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///f45e\n")}});